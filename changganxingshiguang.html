<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>長干行時光拼圖</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css"/>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: {
                            50: '#f5f3ff',
                            100: '#ede9fe',
                            200: '#ddd6fe',
                            300: '#c4b5fd',
                            400: '#a78bfa',
                            500: '#8b5cf6',
                            600: '#5D5CDE', // 主色
                            700: '#4542b9',
                            800: '#393796',
                            900: '#312f79',
                            950: '#1e1c47'
                        },
                        emotion: {
                            joy: '#FFD166',
                            sorrow: '#4E8098',
                            love: '#EF767A',
                            longing: '#9381FF',
                            hope: '#78C091'
                        }
                    },
                    fontFamily: {
                        'sans': ['LXGW WenKai Screen TC', 'sans-serif'],
                        'serif': ['LXGW WenKai TC', 'serif'],
                        'cursive': ['LXGW WenKai TC', 'cursive']
                    },
                    boxShadow: {
                        'elegant': '0 4px 10px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1)',
                        'hover': '0 10px 20px rgba(93, 92, 222, 0.1), 0 6px 6px rgba(93, 92, 222, 0.06)',
                        'btn': '0 4px 6px rgba(93, 92, 222, 0.1), 0 1px 3px rgba(93, 92, 222, 0.08)'
                    }
                }
            },
            darkMode: 'class'
        }
    </script>
    <style>
        /* 使用preload防止字体文件阻塞渲染 */
        @import url('https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css');
@import url('https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-tc-webfont@1.0.0/style.css');
        
        /* 字体fallback以提高性能和可靠性 */
        :root {
            --font-poem: 'LXGW WenKai TC', serif;
            --font-sans: 'LXGW WenKai Screen TC', sans-serif;
            --font-serif: 'LXGW WenKai TC', serif;
            --font-title: 'LXGW WenKai TC', serif;
            --font-subtitle: 'LXGW WenKai TC', serif;
            --font-content: 'LXGW WenKai TC', serif;
        }
        
        /* 字体大小响应式设置 */
        html {
            font-size: 16px;
            -webkit-text-size-adjust: 100%;
            -moz-text-size-adjust: 100%;
            text-size-adjust: 100%;
        }
        
        @media (max-width: 767px) {
            html {
                font-size: 15px;
            }
        }
        
        /* 统一自定义字体类，确保一致性 */
        .font-standard {
            font-family: var(--font-serif);
        }
        
        .font-serif {
            font-family: var(--font-serif);
        }
        
        .font-poem {
            font-family: var(--font-serif);
            font-weight: 500;
            letter-spacing: 0.02em;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        
        body {
            font-family: var(--font-serif);
            background-color: #f5f2ea; /* 淡雅的米色背景 */
            min-height: 100dvh;
            overflow-x: hidden;
            overflow-y: auto;
        }
        
        /* 青梅圖標 SVG */
        .plum-icon {
            width: 28px;
            height: 28px;
            fill: #9BBF8A;
            opacity: 0.8;
            margin: 0 8px;
            vertical-align: middle;
        }
        
        .poem-card {
            transition: all 0.3s cubic-bezier(0.25, 0.8, 0.25, 1);
            cursor: grab;
            position: relative;
            box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            overflow: hidden;
            width: 100%;
            margin-bottom: 0.5rem;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 3rem; /* 減小高度以在移動設備上更緊湊 */
            /* 增加3D感和觸覺反饋 */
            transform-origin: center center;
            backface-visibility: hidden;
            will-change: transform, box-shadow;
            user-select: none; /* 防止拖拽時選中文本 */
            font-family: var(--font-poem);
            font-size: 0.95rem; /* 略微減小字體大小以更緊湊 */
            line-height: 1.4;
            letter-spacing: 0.02em; /* 減少字母間距 */
            font-weight: 500;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            white-space: nowrap; /* 防止文本換行 */
            padding: 0.65rem 1rem; /* 減小垂直內邊距 */
        }
        
        .poem-card:before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 4px;
            height: 100%;
            background-color: #5D5CDE;
            opacity: 0;
            transition: opacity 0.2s ease, transform 0.2s ease;
            transform: scaleY(0.7);
        }
        
        .poem-card:hover {
            box-shadow: 0 5px 12px rgba(0,0,0,0.16), 0 3px 6px rgba(0,0,0,0.23);
            transform: translateY(-3px) scale(1.01);
        }
        
        .poem-card:hover:before {
            opacity: 1;
            transform: scaleY(1);
        }
        
        .poem-card:active {
            cursor: grabbing;
            transform: translateY(-1px) scale(0.98);
            transition: all 0.1s cubic-bezier(0.25, 0.8, 0.25, 1);
        }
        
        .poem-card.dragging {
            opacity: 0.3; /* 實際拖拽元素半透明 */
            pointer-events: none; /* 防止干擾其他元素 */
        }
        
        /* 拖拽克隆體樣式 */
        .drag-clone {
            position: fixed;
            z-index: 9999;
            pointer-events: none;
            box-shadow: 0 14px 28px rgba(93, 92, 222, 0.25), 0 10px 10px rgba(93, 92, 222, 0.22);
            border: 2px solid rgba(93, 92, 222, 0.5);
            transform: rotate(2deg) scale(1.05);
            transition: transform 0.1s ease-out;
            will-change: transform, left, top;
        }
        
        /* 放置指示器 */
        .drop-indicator {
            border: 2px dashed #5D5CDE;
            border-radius: 0.5rem;
            background-color: rgba(93, 92, 222, 0.05);
            margin: 0.25rem 0;
            height: 2.8rem; /* 減小高度使更緊湊 */
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: pulse-border 1.5s infinite ease-in-out;
        }
        
        @keyframes pulse-border {
            0% { border-color: rgba(93, 92, 222, 0.5); }
            50% { border-color: rgba(93, 92, 222, 1); }
            100% { border-color: rgba(93, 92, 222, 0.5); }
        }
        
        @keyframes card-pulse {
            0% { box-shadow: 0 12px 24px rgba(93, 92, 222, 0.25), 0 8px 8px rgba(93, 92, 222, 0.15); }
            50% { box-shadow: 0 12px 24px rgba(93, 92, 222, 0.35), 0 8px 8px rgba(93, 92, 222, 0.25); }
            100% { box-shadow: 0 12px 24px rgba(93, 92, 222, 0.25), 0 8px 8px rgba(93, 92, 222, 0.15); }
        }
        
        .scroll-container::-webkit-scrollbar {
            height: 6px;
            width: 6px;
        }
        
        .scroll-container::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.03);
            border-radius: 10px;
        }
        
        .scroll-container::-webkit-scrollbar-thumb {
            background: rgba(93, 92, 222, 0.3);
            border-radius: 10px;
        }
        
        .scroll-container::-webkit-scrollbar-thumb:hover {
            background: rgba(93, 92, 222, 0.5);
        }
        
        .scene-illustration {
            height: 100%;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            border-radius: 0.75rem;
            transition: all 0.5s ease;
            position: relative;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 4px 10px rgba(0,0,0,0.1);
        }
        
        .text-shadow {
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .emotion-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            padding: 4px 10px;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            color: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.2);
            backdrop-filter: blur(2px);
        }
        
        .text-container {
            max-width: 90%;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 0.85rem 1.25rem;
            border-radius: 0.75rem;
            backdrop-filter: blur(4px);
            transform: translateY(0);
            animation: float 6s ease-in-out infinite;
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-6px); }
            100% { transform: translateY(0px); }
        }
        
        .fixed-height-container {
            min-height: calc(100vh - 70px); 
            display: flex;
            flex-direction: column;
            padding-bottom: 70px; /* 確保按鈕可見 */
            position: relative;
            overflow: hidden; /* 容器本身不滾動，讓內部元素滾動 */
        }
        
        @media (max-width: 767px) {
            .fixed-height-container {
                padding-bottom: 100px; /* 移動設備上增加底部間距 */
                height: auto;
                min-height: 100%;
            }
        }
        
        .tab-container {
            display: none;
        }
        
        .tab-container.active {
            display: block !important;
            height: 100%;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch; /* 改善iOS上的滾動體驗 */
        }
        
        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            gap: 12px;
            margin-bottom: 20px;
            padding-bottom: 10px;
        }
        
        @media (min-width: 768px) {
            .main-content {
                flex-direction: row;
                /* 保留可見內容，避免裁切 */
                overflow: visible;
            }
        }
        
        @media (max-width: 767px) {
            .main-content {
                flex-direction: column;
                overflow-y: auto;
                height: auto;
                min-height: 100%;
                padding-bottom: 50px; /* 減少底部間距 */
                position: relative; /* 為定位提供參考 */
            }
            
            .content-area {
                min-height: 650px;
                margin-top: 0; /* 移除間距，完全取消空白 */
                position: relative; /* 為定位提供參考 */
                z-index: 5; /* 確保在適當層級 */
                background-color: #f5f2ea; /* 與頁面背景相同，增加視覺分離 */
                border-top-left-radius: 15px;
                border-top-right-radius: 15px;
                padding-top: 15px;
                box-shadow: 0 -4px 8px rgba(0,0,0,0.04); /* 頂部陰影增加視覺層次 */
            }
            
            .dark .content-area {
                background-color: #1a1a1a; /* 深色模式下的背景色 */
            }
            
            /* 優化在移動設備上的布局 */
            #puzzleTab {
                overflow-y: visible;
                padding-bottom: 60px;
            }
            
            /* 確保標籤容器在移動設備上的位置正確 */
            .tabs-container {
                margin-top: 5px; /* 減少頂部間距 */
                position: sticky; /* 使導航欄固定 */
                top: 0; /* 固定在頂部 */
                z-index: 5; /* 降低層級，避免遮擋toast/提示 */
                background-color: #f5f2ea; /* 與頁面背景相同，防止透明背景造成視覺混亂 */
                border-radius: 0 0 10px 10px; /* 添加底部圓角 */
                box-shadow: 0 2px 8px rgba(0,0,0,0.05); /* 添加輕微陰影，增強分離感 */
                padding-bottom: 2px; /* 底部略微填充 */
            }
            
            .dark .tabs-container {
                background-color: #1a1a1a; /* 深色模式下的背景色 */
            }
        }
        
        .side-panel {
            flex: 0 0 22%;
            display: flex;
            flex-direction: column;
            height: auto;
        }
        
        @media (max-width: 767px) {
            /* 側邊面板在移動設備上的完整重新配置 */
            .side-panel {
                min-height: 330px; /* 進一步減少整體高度以消除空白 */
                margin-bottom: 0; /* 移除底部間距 */
                width: 100%;
                position: relative;
                display: flex;
                flex-direction: column;
                overflow: visible;
                padding-bottom: 0;
            }
            
            /* 場景圖示區域調整 */
            .side-panel > div:first-child {
                height: 200px !important;
                margin-bottom: 8px;
            }
            
            /* 心境變化圖卡片的全面優化 */
            .side-panel .card {
                margin-top: 5px;
                height: 130px !important; /* 進一步壓縮高度以消除空白 */
                width: 100% !important;
                display: flex;
                flex-direction: column;
                padding: 0;
                box-sizing: border-box;
                overflow: visible;
            }
            
            /* 圖表標題樣式 */
            .chart-title {
                font-size: 0.9rem;
                margin: 0 0 5px 0;
                padding: 0 10px;
                font-weight: 600;
                line-height: 1.1;
                text-align: center;
                color: #5D5CDE;
            }
            
            /* 圖表容器完整重設 */
            .emotion-chart-container {
                height: 105px !important;
                min-height: 105px !important;
                margin: 0 !important;
                padding: 0 5px !important;
                position: relative;
                width: 100% !important;
                flex-grow: 1;
                box-sizing: border-box;
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* 確保Canvas元素顯示正確 */
            #emotion-chart {
                width: 100% !important;
                max-width: 100% !important;
                height: 100% !important;
                max-height: 220px !important;
            }
            
            /* 移動端：緊貼心境變化圖，去除多餘空白 */
            .content-area {
                margin-top: 0 !important;
                padding-top: 6px !important;
            }
        }
        
        .content-area {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        @media (max-width: 767px) {
            .content-area {
                overflow-y: visible; /* 行動端不做內層滾動，避免裁切 */
            }
        }
        
        @media (max-width: 767px) {
            body {
                overflow-y: auto; /* 允許滾動整個頁面 */
                height: auto;
            }
            
            #app {
                overflow-y: visible;
                min-height: 100dvh;
                height: auto;
            }
            
            .fixed-height-container {
                height: auto;
                overflow-y: visible;
            }
        }
        
        .tab-button {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }
        
        .tab-button.active {
            border-color: #5D5CDE !important;
        }
        
        .tab-button.active:after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 3px;
            background-color: #5D5CDE;
            transform: scaleX(1);
        }
        
        .shine-effect {
            position: relative;
            overflow: hidden;
        }
        
        .shine-effect:after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(60deg, rgba(255,255,255,0) 20%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0) 80%);
            transform: rotate(30deg);
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .shine-effect:hover:after {
            opacity: 1;
            animation: shine 1.5s forwards;
        }
        
        @keyframes shine {
            0% {
                transform: translateX(-100%) rotate(30deg);
            }
            100% {
                transform: translateX(100%) rotate(30deg);
            }
        }
        
        /* 美化心境探索中的選項 */
        .quiz-option {
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            border-left: 0 solid transparent;
        }
        
        .quiz-option:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(93, 92, 222, 0.15);
        }
        
        .quiz-option.selected {
            border-color: #5D5CDE;
            border-width: 2px;
            background-color: rgba(93, 92, 222, 0.05);
            box-shadow: 0 4px 10px rgba(93, 92, 222, 0.2);
            border-left: 4px solid #5D5CDE;
            padding-left: calc(0.75rem - 2px);
        }
        
        .quiz-option.selected:after {
            content: '✓';
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #5D5CDE;
            font-weight: bold;
            font-size: 1.1rem;
        }
        
        /* 自定義按鈕 */
        .btn-primary {
            background-color: #5D5CDE;
            color: white;
            padding: 0.5rem 1.25rem;
            border-radius: 0.5rem;
            font-weight: 500;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
            box-shadow: 0 4px 6px rgba(93, 92, 222, 0.1), 0 1px 3px rgba(93, 92, 222, 0.08);
            white-space: nowrap; /* 按鈕文字單行顯示 */
        }
        
        .btn-primary:hover {
            background-color: #4542b9;
            transform: translateY(-1px);
            box-shadow: 0 7px 14px rgba(93, 92, 222, 0.15), 0 3px 6px rgba(93, 92, 222, 0.1);
        }
        
        .btn-primary:active {
            transform: translateY(1px);
            box-shadow: 0 2px 4px rgba(93, 92, 222, 0.1);
        }
        
        /* 卡片樣式 */
        .card {
            background-color: white;
            border-radius: 0.75rem;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
            overflow: hidden;
        }
        
        .card:hover {
            box-shadow: 0 10px 20px rgba(93, 92, 222, 0.1), 0 6px 6px rgba(93, 92, 222, 0.06);
        }
        
        .card-header {
            font-family: var(--font-serif);
            font-weight: 600;
            padding: 0.75rem 1rem;
            border-bottom: 1px solid rgba(0, 0, 0, 0.05);
        }
        
        .card-body {
            padding: 1rem;
            overflow-y: auto; /* 確保內容可滾動 */
        }
        
        /* 垂直排序區域樣式 */
        .vertical-sort-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            height: 280px;
            min-height: 280px;
            max-height: 280px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            border-radius: 0.75rem;
            margin-top: 0.5rem;
            margin-bottom: 0.75rem;
            transition: all 0.3s ease;
            padding-bottom: 10px;
        }
        
        @media (max-width: 767px) {
            .vertical-sort-area {
                height: 330px;
                min-height: 330px;
                max-height: 330px;
            }
        }
        
        .vertical-sort-area.highlight {
            border: 2px solid #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
        }
        
        /* 詩句排列樣式 - 兩行並自適應大小 */
        .poem-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            grid-gap: 0.75rem;
            width: 100%;
            justify-items: center;
            transition: all 0.3s ease;
        }
        
        .poem-grid.highlight {
            border: 2px solid #5D5CDE;
            background-color: rgba(93, 92, 222, 0.05);
        }
        
        /* 下一關按鈕 */
        .next-level-btn {
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(93, 92, 222, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(93, 92, 222, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(93, 92, 222, 0);
            }
        }
        
        .vertical-spacer {
            flex-grow: 1;
        }
        
        .tab-content-scroll {
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            max-height: calc(100dvh - 210px);
            padding-right: 10px;
        }

        @media (max-width: 767px) {
            .tab-content-scroll {
                max-height: none; /* 行動端不限制高度，交由 body 滾動 */
                overflow-y: visible;
            }
        }
        
        @media (prefers-color-scheme: dark) {
            body {
                background-color: #1a1a1a;
            }
            
            .card {
                background-color: #222;
                box-shadow: 0 4px 10px rgba(0, 0, 0, 0.2), 0 1px 2px rgba(0, 0, 0, 0.3);
            }
            
            .card-header {
                border-bottom: 1px solid rgba(255, 255, 255, 0.05);
            }
            
            .dark .bg-white {
                background-color: #222;
            }
            
            .dark .text-gray-800 {
                color: #e0e0e0;
            }
            
            .dark .text-gray-700 {
                color: #d0d0d0;
            }
            
            .dark .text-gray-600 {
                color: #b0b0b0;
            }
            
            .dark .border-gray-200 {
                border-color: #333;
            }
            
            .dark .bg-green-100 {
                background-color: #1b3a28;
            }
            
            .dark .text-green-800 {
                color: #7ae0a9;
            }
            
            .poem-card {
                background-color: #2a2a2a;
                box-shadow: 0 1px 3px rgba(0,0,0,0.24), 0 1px 2px rgba(0,0,0,0.36);
            }
            
            .poem-card:hover {
                box-shadow: 0 3px 6px rgba(0,0,0,0.32), 0 3px 6px rgba(0,0,0,0.46);
            }
            
            .quiz-option.selected {
                background-color: rgba(93, 92, 222, 0.15);
            }
            
            .drop-indicator {
                background-color: rgba(93, 92, 222, 0.15);
            }
            
            /* 修复深色模式下的移动端視圖問題 */
            .tabs-container {
                background-color: #1a1a1a !important;
            }
        }
        
        .music-control {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 48px;
            height: 48px;
            padding: 12px;
            background-color: #5D5CDE;
            color: white;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .music-control:hover {
            transform: scale(1.1);
            background-color: #4542b9;
        }
        
        .music-tooltip {
            position: absolute;
            bottom: 100%;
            right: 0;
            width: 300px;
            padding: 12px;
            background-color: white;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            margin-bottom: 12px;
            font-size: 14px;
            color: #333;
            display: none;
            pointer-events: none;
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s, transform 0.3s;
        }
        
        .music-control:hover .music-tooltip {
            display: block;
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .dark .music-tooltip {
            background-color: #252525;
            color: #e0e0e0;
        }
        
        /* 游標下的詩句輕輕浮動 */
        @keyframes gentle-float {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
        
        /* 心境變化圖標題樣式 */
        .chart-title {
            font-family: var(--font-poem);
            font-size: 1.25rem;
            color: #5D5CDE;
            text-align: center;
            margin-bottom: 0.5rem;
            text-shadow: 0 1px 1px rgba(0,0,0,0.1);
            letter-spacing: 0.03em;
        }
        
        /* 添加古風圖標 */
        .ancient-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-right: 0.5rem;
            width: 1.5rem;
            height: 1.5rem;
            font-size: 1.1em;
            opacity: 0.9;
            vertical-align: middle;
            color: currentColor;
            transition: transform 0.2s ease;
        }
        
        button:hover .ancient-icon {
            transform: scale(1.15);
        }
        
        /* 新增：漂亮的滾動條 */
        .custom-scrollbar::-webkit-scrollbar {
            width: 6px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(93, 92, 222, 0.05);
            border-radius: 10px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(93, 92, 222, 0.2);
            border-radius: 10px;
        }
        
        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(93, 92, 222, 0.4);
        }
        
        /* 新增: 诗句装饰 */
        .poem-decoration {
            position: relative;
        }
        
        .poem-decoration:before, .poem-decoration:after {
            content: '❖';
            color: rgba(93, 92, 222, 0.3);
            font-size: 0.8rem;
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
        }
        
        .poem-decoration:before {
            left: -20px;
        }
        
        .poem-decoration:after {
            right: -20px;
        }
        
        /* 新增：标签页的更好視覺效果 */
        .tabs-container {
            position: relative;
        }
        
        .tabs-highlight {
            position: absolute;
            height: 3px;
            bottom: 0;
            left: 0;
            background-color: #5D5CDE;
            transition: all 0.3s ease;
        }
        
        /* 新增：成就标记 */
        .achievement-badge {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background-color: #FFD166;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            font-size: 12px;
            font-weight: bold;
            color: white;
            opacity: 0;
            transform: scale(0);
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .achievement-badge.show {
            opacity: 1;
            transform: scale(1);
        }
        
        /* 新增：知识点内容更好的排版 */
        .knowledge-content p {
            margin-bottom: 1rem;
            line-height: 1.7;
        }
        
        .knowledge-content .highlight {
            background-color: rgba(93, 92, 222, 0.1);
            border-radius: 0.25rem;
            padding: 2px 4px;
            font-weight: 500;
            color: #5D5CDE;
        }
        
        /* 提升字体效果 */
        .ancient-font {
            font-family: var(--font-poem);
            letter-spacing: 0.02em;
            text-rendering: optimizeLegibility;
        }
        
        .serif-font {
            font-family: var(--font-serif);
            letter-spacing: 0.01em;
            text-rendering: optimizeLegibility;
        }
        
        /* 新增标题字体样式 */
        .font-title {
            font-family: var(--font-title);
            font-weight: 600;
            letter-spacing: 0.05em;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
            text-shadow: 1px 1px 2px rgba(93, 92, 222, 0.1);
        }
        
        .font-subtitle {
            font-family: var(--font-subtitle);
            letter-spacing: 0.03em;
            text-rendering: optimizeLegibility;
            -webkit-font-smoothing: antialiased;
        }
        
        .text-shadow-elegant {
            text-shadow: 0 2px 4px rgba(93, 92, 222, 0.15);
        }
        
        /* 修复知识点内容显示问题 */
        #knowledgeTab.active {
            display: block !important;
        }
        
        /* 错误提示样式 */
        .error-message {
            background-color: rgba(220, 38, 38, 0.1);
            color: #dc2626;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin: 1rem 0;
            font-size: 0.875rem;
        }
        
        /* 添加进度指示器 */
        .progress-indicator {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 1.5rem;
            padding: 0 1rem;
        }
        
        .progress-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 1;
        }
        
        .step-circle {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background-color: #e0e0e0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #777;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }
        
        .step-circle.completed {
            background-color: #5D5CDE;
            color: white;
        }
        
        .step-circle.active {
            background-color: #5D5CDE;
            color: white;
            box-shadow: 0 0 0 3px rgba(93, 92, 222, 0.2);
        }
        
        .step-label {
            font-size: 0.8rem;
            color: #777;
            transition: all 0.3s ease;
        }
        
        .step-label.active, .step-label.completed {
            color: #5D5CDE;
            font-weight: 500;
        }
        
        .progress-line {
            position: absolute;
            top: 15px;
            left: 20%;
            right: 20%;
            height: 2px;
            background-color: #e0e0e0;
            z-index: 0;
        }
        
        .progress-line-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background-color: #5D5CDE;
            transition: width 0.5s ease;
        }
        
        .dark .step-circle {
            background-color: #444;
            color: #bbb;
        }
        
        .dark .step-label {
            color: #bbb;
        }
        
        .dark .progress-line {
            background-color: #444;
        }
        
        /* 禁用按钮样式 */
        .btn-disabled {
            opacity: 0.5;
            cursor: not-allowed;
            pointer-events: none;
        }
        
        /* 动画效果 */
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% {transform: translateY(0);}
            40% {transform: translateY(-10px);}
            60% {transform: translateY(-5px);}
        }
        
        .bounce-animation {
            animation: bounce 2s infinite;
        }
        
        /* 拖拽動畫 */
        @keyframes ripple {
            0% { transform: scale(0.5); opacity: 0.4; }
            100% { transform: scale(1.5); opacity: 0; }
        }
        
        @keyframes dropBounce {
            0% { transform: scale(1.02); }
            50% { transform: scale(0.98); }
            100% { transform: scale(1); }
        }
        
        @keyframes pop {
            0% { transform: scale(0.95); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
</style>

<!-- Font Awesome 图标库 -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<!-- 太虛幻境應用切換器組件 -->
<script src="/assets/js/taixu-app-switcher.js"></script>
</head>
<body>
    <div id="app" class="container mx-auto px-4 py-4 max-w-6xl flex flex-col">
        <!-- 背景音樂播放器 -->
        <audio id="background-music" loop preload="auto" style="display:none;">
            <source src="https://dl.dropboxusercontent.com/scl/fi/p0docwf6s28hm08k3qjmc/music.mp3?rlkey=5vwue7zhitw4mx3yvon9c2wwo&st=16rjoefj&dl=1" type="audio/mpeg">
        </audio>
        <!-- 音樂控制按鈕 -->
        <div class="music-control" id="music-button">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="M9 18V5l12-2v13"></path>
                <circle cx="6" cy="18" r="3"></circle>
                <circle cx="18" cy="16" r="3"></circle>
            </svg>
            <div class="music-tooltip">
                <p class="font-medium mb-2">背景音樂控制</p>
                <p class="mb-2">點擊可關閉背景音樂</p>
            </div>
        </div>
        
        <!-- 游戏视图容器 -->
        <div id="game-view" class="hidden fixed-height-container animate__animated animate__fadeIn">
            <header class="mb-4 text-center">
                <h1 class="relative mb-3 tracking-wide animate__animated animate__fadeInDown">
                        <div class="w-full text-center flex flex-col items-center justify-center">
                            <!-- 使用flex-row讓標題佔用整行，且強制單行顯示 -->
                            <div class="inline-flex items-center justify-center flex-nowrap whitespace-nowrap">
                                <svg class="plum-icon h-5 w-5 sm:h-6 sm:w-6 md:h-7 md:w-7 shrink-0" viewBox="0 0 24 24">
                                    <defs>
                                        <linearGradient id="plumGradient1" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" stop-color="#b0d68c"/>
                                            <stop offset="100%" stop-color="#9BBF8A"/>
                                        </linearGradient>
                                        <radialGradient id="plumHighlight1" cx="40%" cy="40%" r="60%" fx="40%" fy="40%">
                                            <stop offset="0%" stop-color="#c2e09e" stop-opacity="0.6"/>
                                            <stop offset="100%" stop-color="#9BBF8A" stop-opacity="0"/>
                                        </radialGradient>
                                    </defs>
                                    <ellipse cx="8" cy="12" rx="4" ry="4.5" fill="url(#plumGradient1)" />
                                    <ellipse cx="8" cy="12" rx="3" ry="3.3" fill="url(#plumHighlight1)" />
                                    <ellipse cx="15" cy="13" rx="3.5" ry="4" fill="url(#plumGradient1)" />
                                    <ellipse cx="15" cy="13" rx="2.5" ry="2.8" fill="url(#plumHighlight1)" />
                                    <path d="M8,8C7.5,6,8,4.5,9,3.5C10,2.5,12,3,12,3" stroke="#8aae7a" stroke-width="0.5" fill="none" />
                                    <path d="M15,9.5C15.2,7,14,5,13,4C12,3,10,2.5,9,3" stroke="#8aae7a" stroke-width="0.5" fill="none" />
                                    <path d="M6.2,7.3C4.5,5.5,6,4,9,5.5" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.3" />
                                    <path d="M14,4C14.8,2.2,12,1.8,11,4" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.3" />
                                </svg>
                                <span class="font-title text-primary-600 block text-shadow-elegant relative z-10 text-2xl sm:text-3xl md:text-4xl tracking-wide mx-1 sm:mx-2">長干行</span>
                                <svg class="plum-icon h-5 w-5 sm:h-6 sm:w-6 md:h-7 md:w-7 shrink-0" viewBox="0 0 24 24">
                                    <defs>
                                        <linearGradient id="plumGradient2" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" stop-color="#b0d68c"/>
                                            <stop offset="100%" stop-color="#9BBF8A"/>
                                        </linearGradient>
                                        <radialGradient id="plumHighlight2" cx="40%" cy="40%" r="60%" fx="40%" fy="40%">
                                            <stop offset="0%" stop-color="#c2e09e" stop-opacity="0.6"/>
                                            <stop offset="100%" stop-color="#9BBF8A" stop-opacity="0"/>
                                        </radialGradient>
                                    </defs>
                                    <ellipse cx="8" cy="12" rx="4" ry="4.5" fill="url(#plumGradient2)" />
                                    <ellipse cx="8" cy="12" rx="3" ry="3.3" fill="url(#plumHighlight2)" />
                                    <ellipse cx="15" cy="13" rx="3.5" ry="4" fill="url(#plumGradient2)" />
                                    <ellipse cx="15" cy="13" rx="2.5" ry="2.8" fill="url(#plumHighlight2)" />
                                    <path d="M8,8C7.5,6,8,4.5,9,3.5C10,2.5,12,3,12,3" stroke="#8aae7a" stroke-width="0.5" fill="none" />
                                    <path d="M15,9.5C15.2,7,14,5,13,4C12,3,10,2.5,9,3" stroke="#8aae7a" stroke-width="0.5" fill="none" />
                                    <path d="M6.2,7.3C4.5,5.5,6,4,9,5.5" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.3" />
                                    <path d="M14,4C14.8,2.2,12,1.8,11,4" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.3" />
                                </svg>
                            </div>
                            <span class="font-subtitle text-primary-700 block mt-1 text-lg sm:text-xl md:text-2xl relative z-0">時光拼圖</span>
                        </div>
                        <div class="absolute -bottom-1 left-0 right-0 h-1 bg-gradient-to-r from-transparent via-primary-500 to-transparent"></div>
                    </h1>
                <div class="flex justify-between items-center">
                    <div>
                        <span class="text-sm text-gray-600 dark:text-gray-400">關卡：</span>
                        <span id="level-display" class="font-semibold text-primary-600"></span>
                    </div>
                    <div class="flex space-x-3">
                        <!-- 完整诗文按钮在游戏中隐藏 -->
                        <button id="show-full-poem" class="bg-white dark:bg-gray-800 text-primary-600 rounded-lg border border-primary-600 hover:bg-primary-50 dark:hover:bg-primary-900 transition-all text-sm px-3 py-1.5 shadow-btn hidden">
                            <span class="ancient-icon">📜</span>完整詩文
                        </button>
                    </div>
                </div>
                

            </header>
            
            <div class="main-content">
                <!-- 左侧面板: 场景和情感图表 -->
                <div class="side-panel mr-2">
                    <div style="height: 300px;" class="mb-3">
                        <div id="scene-illustration" class="scene-illustration animate__animated animate__fadeIn">
                            <div class="emotion-badge" id="emotion-badge"></div>
                            <div class="text-container">
                                <p id="character-monologue" class="text-white italic text-center text-shadow" style="font-family: var(--font-serif);"></p>
                            </div>
                        </div>
                    </div>
                    <div style="height: 250px;" class="card animate__animated animate__fadeIn animate__delay-1s flex flex-col justify-center">
                        <div class="chart-title">心境變化圖</div>
                        <div class="emotion-chart-container px-2 pb-2 flex-grow flex items-center justify-center">
                            <canvas id="emotion-chart"></canvas>
                        </div>
                    </div>
                </div>
                
                <!-- 右侧主要内容区：标签式导航 -->
                <div class="content-area">
                    <div class="tabs-container flex mb-3 relative">
                        <button class="tab-button flex-1 py-2 text-center border-b-2 border-gray-200 dark:border-gray-700 text-gray-600 dark:text-gray-400" data-tab="puzzleTab">
                            <span class="ancient-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                <rect x="2" y="2" width="9" height="9" rx="1"></rect>
                <rect x="13" y="2" width="9" height="9" rx="1"></rect>
                <rect x="2" y="13" width="9" height="9" rx="1"></rect>
                <rect x="13" y="13" width="9" height="9" rx="1"></rect>
              </svg>
            </span>詩句排序
                        </button>
                        <button class="tab-button flex-1 py-2 text-center border-b-2 border-gray-200 dark:border-gray-700 text-gray-600 dark:text-gray-400" data-tab="knowledgeTab">
                            <span class="ancient-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                <path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path>
                <path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path>
              </svg>
            </span>知識點
                        </button>
                        <button class="tab-button flex-1 py-2 text-center border-b-2 border-gray-200 dark:border-gray-700 text-gray-600 dark:text-gray-400" data-tab="quizTab">
                            <span class="ancient-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                <circle cx="12" cy="12" r="10"></circle>
                <path d="M12 16v.01"></path>
                <path d="M8 10a4 4 0 0 1 8 0c0 1.5-.5 2.5-2 3-1.4.4-2 1-2 3"></path>
              </svg>
            </span>心境探索
                        </button>
                    </div>
                    
                    <div class="tab-containers h-full">
                        <!-- 拼图标签 -->
                        <div id="puzzleTab" class="tab-container min-h-fit sm:h-full flex flex-col">
                            
                            <div class="flex flex-col flex-1 overflow-visible mb-12">
                                <!-- 两行诗句布局 -->
                                <div>
                                    <h3 class="text-lg font-medium mb-2 text-gray-800 dark:text-gray-200 pl-2 border-l-4 border-primary-600" style="font-family: var(--font-serif);">
                                        待排序詩句
                                    </h3>
                                    <div id="poem-pieces" class="poem-grid bg-white dark:bg-gray-800 rounded-lg shadow-elegant p-3 border border-gray-100 dark:border-gray-700 animate__animated animate__fadeIn">
                                        <!-- 诗句卡片将动态加载到这里，两行排列 -->
                                    </div>
                                </div>
                                
                                <!-- 垂直排序区域 -->
                                <div class="flex-1 overflow-hidden mt-4">
                                    <h3 class="text-lg font-medium mb-2 text-gray-800 dark:text-gray-200 pl-2 border-l-4 border-primary-600" style="font-family: var(--font-serif);">
                                        詩句排序 <span class="text-sm text-gray-500 dark:text-gray-400" style="font-family: var(--font-serif);">(從上至下)</span>
                                    </h3>
                                    <div id="poem-sequence" class="vertical-sort-area bg-white dark:bg-gray-800 rounded-lg shadow-elegant border border-gray-100 dark:border-gray-700 p-3 custom-scrollbar animate__animated animate__fadeIn">
                                        <!-- 排序后的诗句将从上至下显示在这里 -->
                                    </div>
                                </div>
                                
                                <div class="text-center mt-3 mb-4">
                                    <button id="check-button" class="btn-primary px-8 py-2.5 shine-effect animate__animated animate__fadeIn animate__delay-1s">
                                        <span class="ancient-icon">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                                <polyline points="20 6 9 17 4 12"></polyline>
                                            </svg>
                                        </span>檢查排序
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 知识点标签 -->
                        <div id="knowledgeTab" class="tab-container h-full flex flex-col">
                            <div class="card flex-1 flex flex-col overflow-hidden animate__animated animate__fadeIn">
                                <div class="card-header bg-primary-50 dark:bg-primary-900 text-primary-700 dark:text-primary-300">
                                    <span class="ancient-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                <path d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"></path>
              </svg>
            </span>詩詞知識點
                                </div>
                                <div class="card-body flex-1 overflow-y-auto custom-scrollbar">
                                    <div id="knowledge-content" class="knowledge-content text-gray-700 dark:text-gray-300 leading-relaxed"></div>
                                </div>
                                <div class="p-4 border-t border-gray-100 dark:border-gray-800 text-center">
                                    <button id="to-explore-button" class="btn-primary px-6 py-2 animate__animated animate__fadeIn" style="display: none;">
                                        <span class="ancient-icon">
                                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                                <path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path>
                                                <circle cx="12" cy="10" r="2"></circle>
                                                <path d="M12 10v.01"></path>
                                            </svg>
                                        </span>進入心境探索
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- 互动问答标签 -->
                        <div id="quizTab" class="tab-container h-full flex flex-col">
                            <div class="card flex-1 flex flex-col overflow-visible animate__animated animate__fadeIn">
                                <div class="card-header bg-primary-50 dark:bg-primary-900 text-primary-700 dark:text-primary-300">
                                    <span class="ancient-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                <path d="M11 5a7 7 0 0 1 7 7m-7 7a7 7 0 1 1 0-14"></path>
                <path d="M11 5v14"></path>
                <path d="M11 12H4"></path>
                <path d="M15 8a1 1 0 1 0 2 0 1 1 0 0 0-2 0z"></path>
                <path d="M17 16a1 1 0 1 0 2 0 1 1 0 0 0-2 0z"></path>
              </svg>
            </span>心境探索
                                </div>
                                <div class="card-body flex-1 overflow-y-auto overflow-x-hidden custom-scrollbar pb-4">
                                    <!-- 內容區域分為兩部分，使用更彈性的佈局 -->
                                    <div class="quiz-content">
                                        <p id="quiz-question" class="text-gray-700 dark:text-gray-300 mb-3 font-medium poem-decoration break-words w-full text-base"></p>
                                        <div id="quiz-options" class="grid grid-cols-1 gap-2 mb-3 w-full">
                                            <!-- 选项将在这里动态添加 -->
                                        </div>
                                        <div class="mb-3 flex items-center gap-4 flex-wrap">
                                            <button id="submit-quiz" class="btn-primary shine-effect">
                                                <span class="ancient-icon">
                                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                                    <circle cx="11" cy="11" r="8"></circle>
                                                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                                                </svg>
                                            </span>確認答案
                                            </button>
                                            
                                            <!-- 使用display:none确保初始隐藏 -->
                                            <button id="next-level-button" class="btn-primary next-level-btn px-6 py-2" 
                                                   style="display: none;">
                                                <span class="ancient-icon">
                                                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                                        <path d="M5 12h14"></path>
                                                        <path d="m12 5 7 7-7 7"></path>
                                                    </svg>
                                                </span>進入下一關
                                            </button>
                                        </div>
                                    </div>
                                    <!-- 反饋區域優化，確保在各種屏幕尺寸上都能完整顯示 -->
                                    <div id="quiz-feedback" class="hidden mb-4 w-full break-words feedback-container overflow-y-auto max-h-64 md:max-h-96"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 主菜单 -->
        <div id="main-menu" class="flex flex-col items-center justify-center min-h-[80vh]">
            <div class="text-center mb-12 animate__animated animate__fadeIn">
                <h1 class="relative mb-6 tracking-wide">
                    <div class="flex items-center justify-center">
                        <svg class="plum-icon h-12 w-12 md:h-14 md:w-14" viewBox="0 0 24 24">
                            <defs>
                                <linearGradient id="plumGradientMain1" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" stop-color="#c0e693"/>
                                    <stop offset="100%" stop-color="#9BBF8A"/>
                                </linearGradient>
                                <radialGradient id="plumShineMain1" cx="35%" cy="35%" r="60%" fx="35%" fy="35%">
                                    <stop offset="0%" stop-color="#deffb5" stop-opacity="0.7"/>
                                    <stop offset="100%" stop-color="#9BBF8A" stop-opacity="0"/>
                                </radialGradient>
                            </defs>
                            <!-- Left plum -->
                            <ellipse cx="9" cy="12" rx="4.5" ry="5" fill="url(#plumGradientMain1)" />
                            <ellipse cx="9" cy="12" rx="3" ry="3.5" fill="url(#plumShineMain1)" />
                            
                            <!-- Right plum -->
                            <ellipse cx="16" cy="11" rx="4" ry="4.5" fill="url(#plumGradientMain1)" />
                            <ellipse cx="16" cy="11" rx="2.5" ry="3" fill="url(#plumShineMain1)" />
                            
                            <!-- Stems and leaves -->
                            <path d="M9,7.5C9,5,10,3,12,2C14,1,16,2,16,2" stroke="#8aae7a" stroke-width="0.6" fill="none" />
                            <path d="M16,7C16,5,15,3,14,2" stroke="#8aae7a" stroke-width="0.5" fill="none" />
                            
                            <!-- Leaf 1 - larger and more detailed -->
                            <path d="M7,4C3,4,3,7,5,9" stroke="#8aae7a" stroke-width="0.4" fill="none" />
                            <path d="M5,9C3,7,3.5,4,7,4C9,4,11,5,10,9" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.4" />
                            <path d="M6,6.5C7,7,8,7,7,8" stroke="#8aae7a" stroke-width="0.3" fill="none" />
                            
                            <!-- Leaf 2 -->
                            <path d="M13,3C10,1,14,1,15,4" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.4" />
                            <path d="M13.5,2.5C14,2,15,2,14.5,3" stroke="#8aae7a" stroke-width="0.3" fill="none" />
                            
                            <!-- Plum textures -->
                            <path d="M8,10C9,10.5,10,10.5,11,10" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            <path d="M15,9C16,9.5,17,9.5,18,9" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            <path d="M7,14C8,13.5,10,13.5,11,14" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            <path d="M14,13C15,12.5,17,12.5,18,13" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            
                            <!-- Highlight details -->
                            <path d="M9,9C9.5,8.5,10,9,9.5,9.5" stroke="#8aae7a" stroke-width="0.2" fill="none" opacity="0.7" />
                            <path d="M16,8C16.5,7.5,17,8,16.5,8.5" stroke="#8aae7a" stroke-width="0.2" fill="none" opacity="0.7" />
                        </svg>
                        <span class="font-title text-primary-600 block text-shadow-elegant relative z-10 text-5xl md:text-6xl tracking-wide">長干行</span>
                        <svg class="plum-icon h-12 w-12 md:h-14 md:w-14" viewBox="0 0 24 24">
                            <defs>
                                <linearGradient id="plumGradientMain2" x1="0%" y1="0%" x2="100%" y2="100%">
                                    <stop offset="0%" stop-color="#c0e693"/>
                                    <stop offset="100%" stop-color="#9BBF8A"/>
                                </linearGradient>
                                <radialGradient id="plumShineMain2" cx="35%" cy="35%" r="60%" fx="35%" fy="35%">
                                    <stop offset="0%" stop-color="#deffb5" stop-opacity="0.7"/>
                                    <stop offset="100%" stop-color="#9BBF8A" stop-opacity="0"/>
                                </radialGradient>
                            </defs>
                            <!-- Left plum -->
                            <ellipse cx="9" cy="12" rx="4.5" ry="5" fill="url(#plumGradientMain2)" />
                            <ellipse cx="9" cy="12" rx="3" ry="3.5" fill="url(#plumShineMain2)" />
                            
                            <!-- Right plum -->
                            <ellipse cx="16" cy="11" rx="4" ry="4.5" fill="url(#plumGradientMain2)" />
                            <ellipse cx="16" cy="11" rx="2.5" ry="3" fill="url(#plumShineMain2)" />
                            
                            <!-- Stems and leaves -->
                            <path d="M9,7.5C9,5,10,3,12,2C14,1,16,2,16,2" stroke="#8aae7a" stroke-width="0.6" fill="none" />
                            <path d="M16,7C16,5,15,3,14,2" stroke="#8aae7a" stroke-width="0.5" fill="none" />
                            
                            <!-- Leaf 1 - larger and more detailed -->
                            <path d="M7,4C3,4,3,7,5,9" stroke="#8aae7a" stroke-width="0.4" fill="none" />
                            <path d="M5,9C3,7,3.5,4,7,4C9,4,11,5,10,9" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.4" />
                            <path d="M6,6.5C7,7,8,7,7,8" stroke="#8aae7a" stroke-width="0.3" fill="none" />
                            
                            <!-- Leaf 2 -->
                            <path d="M13,3C10,1,14,1,15,4" fill="#9BBF8A" stroke="#8aae7a" stroke-width="0.4" />
                            <path d="M13.5,2.5C14,2,15,2,14.5,3" stroke="#8aae7a" stroke-width="0.3" fill="none" />
                            
                            <!-- Plum textures -->
                            <path d="M8,10C9,10.5,10,10.5,11,10" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            <path d="M15,9C16,9.5,17,9.5,18,9" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            <path d="M7,14C8,13.5,10,13.5,11,14" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            <path d="M14,13C15,12.5,17,12.5,18,13" stroke="#8aae7a" stroke-width="0.3" fill="none" opacity="0.5" />
                            
                            <!-- Highlight details -->
                            <path d="M9,9C9.5,8.5,10,9,9.5,9.5" stroke="#8aae7a" stroke-width="0.2" fill="none" opacity="0.7" />
                            <path d="M16,8C16.5,7.5,17,8,16.5,8.5" stroke="#8aae7a" stroke-width="0.2" fill="none" opacity="0.7" />
                        </svg>
                    </div>
                    <span class="font-subtitle text-primary-700 block mt-3 text-4xl md:text-5xl relative z-0">時光拼圖</span>
                    <div class="absolute -bottom-3 left-1/4 right-1/4 h-1.5 bg-gradient-to-r from-transparent via-primary-500 to-transparent"></div>
                </h1>
                <p class="text-gray-600 dark:text-gray-400 text-xl font-serif">探索李白《長干行》的時間與情感之旅</p>
            </div>
            
            <div class="flex flex-col gap-5 w-full max-w-md animate__animated animate__fadeIn animate__delay-1s">
                <button id="start-game" class="btn-primary py-5 text-xl font-medium shine-effect">
                    <span class="ancient-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                <path d="M12 2v8"></path>
                <path d="M5 10v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V10"></path>
                <path d="M22 10H2"></path>
                <path d="M12 14v6"></path>
                <path d="M9 14v2"></path>
                <path d="M15 14v2"></path>
                <path d="M12 10v1"></path>
              </svg>
            </span>開始遊戲
                </button>
                <button id="show-poem" class="bg-white dark:bg-gray-800 text-gray-700 dark:text-gray-300 rounded-lg border border-gray-300 hover:bg-gray-50 dark:hover:bg-gray-700 transition-all font-medium text-xl py-5 shadow-btn">
                    <span class="ancient-icon">
                      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="w-5 h-5">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="16" y1="13" x2="8" y2="13"></line>
                        <line x1="16" y1="17" x2="8" y2="17"></line>
                        <line x1="10" y1="9" x2="8" y2="9"></line>
                      </svg>
                    </span>完整詩文
                </button>
            </div>
            
            <div class="mt-12 p-5 card max-w-md text-center animate__animated animate__fadeIn animate__delay-2s">
                <p class="text-gray-700 dark:text-gray-300">遊戲已自動播放背景音樂，可通過右下角<span class="text-primary-600">音樂按鈕</span>關閉</p>
            </div>
        </div>
        
        <!-- 游戏说明模态框 -->
        <div id="instructions-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden animate__animated animate__fadeIn">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 max-h-[90vh] overflow-y-auto animate__animated animate__zoomIn">
                <div class="p-6 border-b border-gray-200 dark:border-gray-700">
                    <h2 class="text-2xl font-serif font-bold text-gray-800 dark:text-gray-200">
                        <span class="ancient-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                                <path d="M14 2v6h6"></path>
                                <path d="M16 13H8"></path>
                                <path d="M16 17H8"></path>
                                <path d="M10 9H8"></path>
                            </svg>
                        </span>遊戲說明
                    </h2>
                </div>
                <div class="p-6">
                    <div class="text-gray-700 dark:text-gray-300 space-y-4">
                        <p class="leading-relaxed">《長干行時光拼圖》是一款基於李白經典詩作《長干行》的解謎游戲。</p>
                        <p class="leading-relaxed">遊戲目標：根據詩中描述的人生階段和時間線索，將打散的詩句重新排列成正確的順序。</p>
                        <h3 class="text-xl font-serif font-semibold mt-5 mb-3 text-gray-800 dark:text-gray-200 text-primary-700">
                            <span class="ancient-icon">
                                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                    <path d="M6 11h4M8 9v4M15 12h.01M18 10h.01"></path>
                                    <rect width="20" height="12" x="2" y="6" rx="2"></rect>
                                </svg>
                            </span>遊戲玩法：
                        </h3>
                        <ol class="list-decimal pl-5 space-y-3">
                            <li>每個關卡會提供《長干行》中的詩句片段</li>
                            <li>拖動詩句卡片，將它們按照由上至下的時間順序排列</li>
                            <li>點擊「檢查排序」按鈕驗證您的答案</li>
                            <li>正確排序後，您將解鎖相關的知識點和心境探索題目</li>
                            <li>回答心境探索問題，深入了解詩中女子的情感變化</li>
                            <li>完成當前關卡後，點擊「進入下一關」繼續遊戲</li>
                            <li>如果遇到困難，可以使用「提示」按鈕獲取幫助</li>
                        </ol>
                        <p class="mt-5 leading-relaxed font-medium">推薦搭配《長干行·雲兒謠》背景音樂，增強游戲體驗。</p>
                    </div>
                </div>
                <div class="p-4 bg-gray-50 dark:bg-gray-900 rounded-b-lg flex justify-end">
                    <button id="close-instructions" class="btn-primary">
                        關閉
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 完整诗文模态框 -->
        <div id="poem-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden animate__animated animate__fadeIn">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl w-full max-w-3xl mx-4 relative animate__animated animate__zoomIn">
                <div class="p-5 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <h2 class="text-2xl font-serif font-bold text-gray-800 dark:text-gray-200">
                        <span class="ancient-icon">📜</span>李白《長干行》
                    </h2>
                    <button id="close-poem" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="px-5 py-4 flex flex-col items-center justify-center space-y-3">
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">妾髮初覆額，折花門前劇。</p>
                        <p class="font-serif leading-relaxed text-center">郎騎竹馬來，繞床弄青梅。</p>
                        <p class="font-serif leading-relaxed text-center">同居長干里，兩小無嫌猜。</p>
                    </div>
                    
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">十四為君婦，羞顏未嘗開。</p>
                        <p class="font-serif leading-relaxed text-center">低頭向暗壁，千喚不一回。</p>
                        <p class="font-serif leading-relaxed text-center">十五始展眉，願同塵與灰。</p>
                        <p class="font-serif leading-relaxed text-center">常存抱柱信，豈上望夫台。</p>
                    </div>
                    
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">十六君遠行，瞿塘灩澦堆。</p>
                        <p class="font-serif leading-relaxed text-center">五月不可觸，猿聲天上哀。</p>
                        <p class="font-serif leading-relaxed text-center">門前遲行跡，一一生綠苔。</p>
                        <p class="font-serif leading-relaxed text-center">苔深不能掃，落葉秋風早。</p>
                    </div>
                    
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">八月蝴蝶來，雙飛西園草。</p>
                        <p class="font-serif leading-relaxed text-center">感此傷妾心，坐愁紅顏老。</p>
                        <p class="font-serif leading-relaxed text-center">早晚下三巴，預將書報家。</p>
                        <p class="font-serif leading-relaxed text-center">相迎不道遠，直至長風沙。</p>
                    </div>
                </div>
                <div class="p-4 bg-gray-50 dark:bg-gray-900 rounded-b-lg text-center">
                    <button id="close-poem-btn" class="btn-primary px-6 py-2">
                        關閉
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 成功完成关卡提示 -->
        <div id="success-toast" class="fixed bottom-24 right-5 bg-green-100 dark:bg-green-900 text-green-800 dark:text-green-100 px-5 py-3 rounded-lg shadow-md hidden animate__animated" style="z-index: 101;">
            <div class="flex items-center">
                <svg class="w-5 h-5 mr-3" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                </svg>
                <span id="success-message" class="font-medium">成功完成排序！</span>
            </div>
        </div>
        
        <!-- 游戏完成模态框 -->
        <div id="game-complete-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden animate__animated animate__fadeIn">
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-2xl w-full mx-4 animate__animated animate__zoomIn">
                <div class="p-6 border-b border-gray-200 dark:border-gray-700">
                    <h2 class="text-2xl font-serif font-bold text-primary-600">
                        <span class="ancient-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon>
                            </svg>
                        </span>恭喜！
                    </h2>
                </div>
                <div class="p-8 text-center">
                    <p class="text-gray-700 dark:text-gray-300 mb-6 text-lg font-medium">您已完成《長干行時光拼圖》的所有關卡！</p>
                    <p class="text-gray-700 dark:text-gray-300 mb-6 leading-relaxed">通過這個遊戲，您不僅記住了李白的《長干行》，還了解了這首詩的結構和時間序列，以及詩中女子從童年至成年的心境變化。</p>
                    <div class="mt-8 flex justify-center space-x-4">
                        <button id="view-complete-poem" class="bg-white dark:bg-gray-900 text-primary-600 rounded-lg border-2 border-primary-600 hover:bg-primary-50 dark:hover:bg-primary-900/30 transition-all px-6 py-3 shadow-btn">
                            <span class="ancient-icon">📜</span>查看完整詩文
                        </button>
                        <button id="restart-game" class="btn-primary px-6 py-3 shine-effect">
                            <span class="ancient-icon">🔄</span>重新開始
                        </button>
                        <button id="back-to-menu" class="bg-white dark:bg-gray-900 text-primary-600 rounded-lg border-2 border-primary-600 hover:bg-primary-50 dark:hover:bg-primary-900/30 transition-all px-6 py-3 shadow-btn">
                            <span class="ancient-icon">🏠</span>返回主菜單
                        </button>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- 恭喜畫面上的完整詩文彈窗 -->
        <div id="congrats-poem-modal" class="fixed inset-0 flex items-center justify-center z-[60] hidden animate__animated animate__fadeIn">
            <div class="absolute inset-0 bg-black bg-opacity-40" id="congrats-poem-backdrop"></div>
            <div class="bg-white dark:bg-gray-800 rounded-lg shadow-2xl w-full max-w-3xl mx-4 relative animate__animated animate__zoomIn">
                <div class="p-5 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center">
                    <h2 class="text-2xl font-serif font-bold text-gray-800 dark:text-gray-200">
                        <span class="ancient-icon">📜</span>李白《長干行》
                    </h2>
                    <button id="close-congrats-poem" class="text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200 transition-colors">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
                        </svg>
                    </button>
                </div>
                <div class="px-5 py-4 flex flex-col items-center justify-center space-y-3">
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">妾髮初覆額，折花門前劇。</p>
                        <p class="font-serif leading-relaxed text-center">郎騎竹馬來，繞床弄青梅。</p>
                        <p class="font-serif leading-relaxed text-center">同居長干里，兩小無嫌猜。</p>
                    </div>
                    
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">十四為君婦，羞顏未嘗開。</p>
                        <p class="font-serif leading-relaxed text-center">低頭向暗壁，千喚不一回。</p>
                        <p class="font-serif leading-relaxed text-center">十五始展眉，願同塵與灰。</p>
                        <p class="font-serif leading-relaxed text-center">常存抱柱信，豈上望夫台。</p>
                    </div>
                    
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">十六君遠行，瞿塘灩澦堆。</p>
                        <p class="font-serif leading-relaxed text-center">五月不可觸，猿聲天上哀。</p>
                        <p class="font-serif leading-relaxed text-center">門前遲行跡，一一生綠苔。</p>
                        <p class="font-serif leading-relaxed text-center">苔深不能掃，落葉秋風早。</p>
                    </div>
                    
                    <div class="border-l-4 border-primary-600 pl-4 py-2 bg-primary-50 dark:bg-primary-900/30 rounded-r-lg w-full max-w-lg">
                        <p class="font-serif leading-relaxed text-center">八月蝴蝶來，雙飛西園草。</p>
                        <p class="font-serif leading-relaxed text-center">感此傷妾心，坐愁紅顏老。</p>
                        <p class="font-serif leading-relaxed text-center">早晚下三巴，預將書報家。</p>
                        <p class="font-serif leading-relaxed text-center">相迎不道遠，直至長風沙。</p>
                    </div>
                </div>
                <div class="p-4 bg-gray-50 dark:bg-gray-900 rounded-b-lg text-center">
                    <button id="close-congrats-poem-btn" class="btn-primary px-6 py-2">
                        返回恭喜畫面
                    </button>
                </div>
            </div>
        </div>
        
        <!-- 错误消息显示 -->
        <div id="error-message" class="error-message hidden"></div>
    </div>

    <script>
        // 打字機效果的全局变量和函数
        let typewriterTimeout = null;
        const typeWriterSpeed = 70; // 調整為適中的打字速度
        let isTypingComplete = false; // 跟踪打字是否完成
        
        // 增強的打字機效果，更好地處理HTML和換行
        function typeWriter(element, htmlContent, onComplete) {
            // 重置打字狀態
            isTypingComplete = false;
            
            if (!element || !htmlContent) {
                console.error("打字機效果參數無效:", element, htmlContent);
                if (element) element.innerHTML = htmlContent || '';
                isTypingComplete = true;
                if (typeof onComplete === 'function') onComplete();
                return;
            }
            
            try {
                // 創建一個臨時容器來解析HTML
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = htmlContent;
                
                // 清空目標元素
                element.innerHTML = '';
                
                // 創建一個文本節點數組
                const nodes = [];
                
                // 遞歸收集所有文本節點和HTML標籤
                function collectNodes(node) {
                    if (node.nodeType === Node.TEXT_NODE) {
                        // 文本節點按字符分割
                        const textChunks = Array.from(node.textContent);
                        nodes.push(...textChunks.map(char => ({
                            type: 'text',
                            content: char
                        })));
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        // HTML標籤
                        const tagName = node.tagName.toLowerCase();
                        
                        // 起始標籤
                        const attributes = Array.from(node.attributes)
                            .map(attr => ` ${attr.name}="${attr.value}"`)
                            .join('');
                        nodes.push({
                            type: 'tag',
                            content: `<${tagName}${attributes}>`
                        });
                        
                        // 處理子節點
                        Array.from(node.childNodes).forEach(collectNodes);
                        
                        // 結束標籤
                        nodes.push({
                            type: 'tag',
                            content: `</${tagName}>`
                        });
                    }
                }
                
                // 收集所有節點
                Array.from(tempDiv.childNodes).forEach(collectNodes);
                
                // 逐個顯示節點
                let output = '';
                let i = 0;
                
                function showNextNode() {
                    if (i >= nodes.length) {
                        // 完成所有節點顯示
                        isTypingComplete = true;
                        if (typeof onComplete === 'function') {
                            onComplete();
                        }
                        return;
                    }
                    
                    const node = nodes[i++];
                    
                    // 根據節點類型處理
                    if (node.type === 'tag') {
                        // HTML標籤直接添加
                        output += node.content;
                        element.innerHTML = output;
                        // 立即顯示下一個
                        showNextNode();
                    } else {
                        // 文本節點，統一速度顯示
                        output += node.content;
                        element.innerHTML = output;
                        typewriterTimeout = setTimeout(showNextNode, typeWriterSpeed);
                    }
                }
                
                // 開始顯示
                if (typewriterTimeout) {
                    clearTimeout(typewriterTimeout);
                    typewriterTimeout = null;
                }
                
                showNextNode();
                
            } catch (error) {
                console.error("打字機效果錯誤:", error);
                // 出錯時直接顯示完整內容
                element.innerHTML = htmlContent;
                isTypingComplete = true;
                if (typeof onComplete === 'function') onComplete();
            }
        }
        
        // 游戏数据
        const gameData = {
            levels: [
                {
                    id: 1,
                    title: "童年時光",
                    description: "請將描述詩中女子童年時期的詩句按照正確順序排列。",
                    pieces: [
                        { id: "p1", text: "妾髮初覆額，折花門前劇。" },
                        { id: "p2", text: "郎騎竹馬來，繞床弄青梅。" },
                        { id: "p3", text: "同居長干里，兩小無嫌猜。" }
                    ],
                    correctOrder: ["p1", "p2", "p3"],
                    knowledge: `<p>這幾句是李白《長干行》的開篇，描述了男女主人公童年時的天真無邪。<span class="highlight">「妾髮初覆額」</span>表示女子幼時頭髮剛長到能蓋住額頭，<span class="highlight">「郎騎竹馬來」</span>則是<span class="highlight">「青梅竹馬」</span>典故的來源。<span class="highlight">「兩小無嫌猜」</span>則是<span class="highlight">「兩小無猜」</span>成語的出處，表示兩個小孩子之間沒有猜忌之心。</p>`,
                    scene: {
                        background: "radial-gradient(circle, #a8e6cf 0%, #dcedc1 100%)",
                        emotion: { label: "天真爛漫", color: "#FFD166" },
                        monologue: "童年時光如同清風，無憂無慮地在長干里嬉戲玩耍。青梅竹馬，天真童趣，每一天都如花朵般綻放在記憶中。"
                    },
                    quiz: {
                        question: "從「妾髮初覆額」到「兩小無嫌猜」，詩中女子幼時的性格特點是什麼？",
                        options: [
                            { id: "a", text: "活潑天真，喜歡與人玩耍" },
                            { id: "b", text: "安靜內向，喜歡獨處" },
                            { id: "c", text: "憂鬱多思，早熟敏感" },
                            { id: "d", text: "嚴肅認真，不喜遊戲" }
                        ],
                        correctId: "a",
                        explanation: "從「折花門前劇」可見女子活潑愛玩，而「兩小無嫌猜」則表明她天真單純，沒有成人世界的猜忌心理。李白通過這樣的描寫，勾勒出了一個活潑可愛的小女孩形象。"
                    }
                },
                {
                    id: 2,
                    title: "新婚時期",
                    description: "請將描述詩中女子婚後初期的詩句按照正確順序排列。",
                    pieces: [
                        { id: "p1", text: "十四為君婦，羞顏未嘗開。" },
                        { id: "p2", text: "低頭向暗壁，千喚不一回。" },
                        { id: "p3", text: "十五始展眉，願同塵與灰。" },
                        { id: "p4", text: "常存抱柱信，豈上望夫台。" }
                    ],
                    correctOrder: ["p1", "p2", "p3", "p4"],
                    knowledge: `<p>這幾句描述了女子十四歲嫁人時的羞澀，以及十五歲時逐漸適應婚姻生活的過程。<span class="highlight">「願同塵與灰」</span>表示願與丈夫共同生活到老；<span class="highlight">「抱柱信」</span>典出尾生抱柱的典故，表示堅貞的信念；<span class="highlight">「望夫台」</span>則是古代婦女思念遠行丈夫，登高眺望的地方。詩中通過「羞顏未嘗開」和「十五始展眉」的對比，生動地刻畫了少女從羞澀到逐漸接受婚姻的心理變化過程。</p>`,
                    scene: {
                        background: "linear-gradient(135deg, #ff9a9e 0%, #fad0c4 100%)",
                        emotion: { label: "羞澀", color: "#EF767A" },
                        monologue: "初為人婦的羞怯漸漸被堅定的情感替代，如同冰雪消融，心中湧動著對未來的期許和對愛情的忠誠。"
                    },
                    quiz: {
                        question: "從詩中可以看出，女子從羞澀到坦然的心理變化，反映了她什麼樣的情感特質？",
                        options: [
                            { id: "a", text: "好奇心與冒險精神" },
                            { id: "b", text: "脆弱與依賴性格" },
                            { id: "c", text: "執著與專一的愛情態度" },
                            { id: "d", text: "對婚姻的懷疑與不安" }
                        ],
                        correctId: "c",
                        explanation: "「願同塵與灰」表達了女子希望與丈夫共同生活到老的願望，「常存抱柱信」更是表明她對愛情的堅貞執著，如尾生不離信諾而抱柱而死。這些描寫表明了古代女子對愛情專一忠貞的態度。"
                    }
                },
                {
                    id: 3,
                    title: "別離之苦",
                    description: "請將描述詩中丈夫遠行後女子思念之情的詩句按照正確順序排列。",
                    pieces: [
                        { id: "p1", text: "十六君遠行，瞿塘灩澦堆。" },
                        { id: "p2", text: "五月不可觸，猿聲天上哀。" },
                        { id: "p3", text: "門前遲行跡，一一生綠苔。" },
                        { id: "p4", text: "苔深不能掃，落葉秋風早。" }
                    ],
                    correctOrder: ["p1", "p2", "p3", "p4"],
                    knowledge: `<p>這幾句描述了女子十六歲時丈夫遠行後的思念之情。<span class="highlight">「瞿塘灩澦堆」</span>是長江三峽中瞿塘峽的險灘，<span class="highlight">「猿聲天上哀」</span>表現了環境的淒清與女子的愁緒。<span class="highlight">「門前遲行跡，一一生綠苔」</span>則表現了時間的流逝和等待的漫長。詩中通過環境與心境的巧妙結合，暗示了女主人公獨處時光中的孤獨與思念。「苔深不能掃，落葉秋風早」進一步加強了時光流逝、季節更迭的感覺，與女子持續不變的等待形成強烈對比。</p>`,
                    scene: {
                        background: "linear-gradient(to right, #4facfe 0%, #00f2fe 100%)",
                        emotion: { label: "思念", color: "#4E8098" },
                        monologue: "時光在思念中流逝，連門前的足跡都滋生了青苔。那猿啼似乎也在為我的孤獨而哀鳴，一切都與我的心境相呼應。"
                    },
                    quiz: {
                        question: "詩中「門前遲行跡，一一生綠苔」展現了女子怎樣的情感？",
                        options: [
                            { id: "a", text: "焦慮和不安" },
                            { id: "b", text: "希望與期待" },
                            { id: "c", text: "悲傷與孤獨" },
                            { id: "d", text: "等待與時間流逝的感慨" }
                        ],
                        correctId: "d",
                        explanation: "「門前遲行跡，一一生綠苔」是詩中最為動人的意象之一，女子獨自等待丈夫歸來，在門前踱步留下的足跡因長時間無人行走而長滿青苔，生動地表現了時間的流逝和等待的漫長，也暗示了女子對丈夫歸期漫長的無奈與感傷。"
                    }
                },
                {
                    id: 4,
                    title: "相思之情",
                    description: "請將描述詩中女子對丈夫深切思念以及期盼重逢的詩句按照正確順序排列。",
                    pieces: [
                        { id: "p1", text: "八月蝴蝶來，雙飛西園草。" },
                        { id: "p2", text: "感此傷妾心，坐愁紅顏老。" },
                        { id: "p3", text: "早晚下三巴，預將書報家。" },
                        { id: "p4", text: "相迎不道遠，直至長風沙。" }
                    ],
                    correctOrder: ["p1", "p2", "p3", "p4"],
                    knowledge: `<p>這是詩歌的最後部分，<span class="highlight">「八月蝴蝶來，雙飛西園草」</span>中的蝴蝶雙飛引發了女子對自己孤獨處境的感慨。<span class="highlight">「感此傷妾心，坐愁紅顏老」</span>表達了因思念而憂愁，擔心青春易逝。最後四句表達了期盼丈夫歸來的心情，<span class="highlight">「相迎不道遠，直至長風沙」</span>體現了女子對愛情的忠貞，願意不畏路途遙遠前去迎接。詩的結尾處女主人公從被動等待轉變為主動迎接的心態變化，展現了她內心的堅定與對愛情的執著追求。</p>`,
                    scene: {
                        background: "linear-gradient(to top, #fbc2eb 0%, #a6c1ee 100%)",
                        emotion: { label: "期盼", color: "#9381FF" },
                        monologue: "蝴蝶雙飛勾起了心底的思念，但比起被動地坐守，我更願意主動尋找與你重逢的機會。無論路途多遠，我都願意走向你。"
                    },
                    quiz: {
                        question: "「早晚下三巴，預將書報家。相迎不道遠，直至長風沙。」反映了詩中女子什麼樣的心理變化？",
                        options: [
                            { id: "a", text: "從悲傷絕望到麻木接受" },
                            { id: "b", text: "從被動等待到主動迎接" },
                            { id: "c", text: "從少女情懷到成熟冷靜" },
                            { id: "d", text: "從熱烈期待到理性規劃" }
                        ],
                        correctId: "b",
                        explanation: "詩的結尾四句顯示了女子心理的重要變化。前面的詩句中，女子都是被動地等待，但在最後，她表達了主動迎接丈夫的決心，「相迎不道遠，直至長風沙」展現了她不畏路途遙遠，願意主動前去迎接的積極態度，體現了女子對愛情的執著和勇氣。"
                    }
                }
            ],
            currentLevel: 0,
            completedLevels: [],
            // 添加学习进度跟踪
            progress: {
                // 每个关卡的进度：0=未开始，1=完成排序，2=查看知识点，3=完成心境探索
                1: 0,
                2: 0,
                3: 0,
                4: 0
            }
        };

        // 定义DOM元素变量
        let mainMenu, gameView, levelDisplay, levelDescription, poemPieces, poemSequence;
        let checkButton, hintButton, knowledgeTab, knowledgeContent, quizTab, quizQuestion;
        let quizOptions, quizFeedback, submitQuizButton, toExploreButton, nextLevelButton;
        let startGameButton, showInstructionsButton, showPoemButton, showFullPoemButton;
        let viewCompletePoemButton, instructionsModal, closeInstructionsButton, poemModal;
        let closePoemButton, successToast, successMessage, gameCompleteModal, restartGameButton;
        let backToMenuButton, musicButton, tabButtons, errorMessageContainer;
        let progressLineFill, stepCircles, stepLabels;

        // 游戏状态变量 - 拖拽相关
        let isDragging = false;     // 是否處於拖拽狀態
        let draggedElement = null;  // 當前被拖拽的元素
        let dragClone = null;       // 拖拽時的克隆體
        let initialMouseX, initialMouseY; // 開始拖拽時鼠標位置
        let offsetX, offsetY;       // 鼠標在元素內的偏移
        let dropIndicator = null;   // 放置指示器
        let emotionChart = null;
        // 觸控長按拖拽控制
        let longPressTimer = null;
        let touchStartX = 0;
        let touchStartY = 0;
        
        // 显示错误消息的函数
        function showError(message) {
            console.error(message);
            if (errorMessageContainer) {
                errorMessageContainer.textContent = message;
                errorMessageContainer.classList.remove('hidden');
                setTimeout(() => {
                    errorMessageContainer.classList.add('hidden');
                }, 5000);
            }
        }
        
        // 验证DOM元素是否存在
        function validateDomElements() {
            try {
                // 分為必要元素和非必要元素
                const criticalElements = {
                    'mainMenu': mainMenu,
                    'gameView': gameView
                };
                
                const importantElements = {
                    'knowledgeTab': knowledgeTab,
                    'knowledgeContent': knowledgeContent,
                    'poemPieces': poemPieces,
                    'poemSequence': poemSequence,
                    'checkButton': checkButton,
                    'quizTab': quizTab
                };
                
                const nonCriticalElements = {
                    'toExploreButton': toExploreButton,
                    'nextLevelButton': nextLevelButton,
                    'tabButtons': tabButtons && tabButtons.length > 0
                };
                
                // 檢查關鍵元素 - 這些必須存在
                let missingCritical = [];
                for (const [name, element] of Object.entries(criticalElements)) {
                    if (!element) {
                        missingCritical.push(name);
                    }
                }
                
                if (missingCritical.length > 0) {
                    showError(`缺少關鍵元素，無法繼續: ${missingCritical.join(', ')}`);
                    return false;
                }
                
                // 檢查重要元素
                let missingImportant = [];
                for (const [name, element] of Object.entries(importantElements)) {
                    if (!element) {
                        missingImportant.push(name);
                    }
                }
                
                if (missingImportant.length > 0) {
                    console.warn(`缺少重要元素，可能影響功能: ${missingImportant.join(', ')}`);
                }
                
                // 檢查非關鍵元素
                let missingNonCritical = [];
                for (const [name, element] of Object.entries(nonCriticalElements)) {
                    if (!element) {
                        missingNonCritical.push(name);
                    }
                }
                
                if (missingNonCritical.length > 0) {
                    console.warn(`缺少非關鍵元素: ${missingNonCritical.join(', ')}`);
                }
                
                return true;
            } catch (error) {
                console.error("驗證DOM元素錯誤:", error);
                return false;
            }
        }
        
        // 更新进度指示器
        function updateProgressIndicator(step) {
            try {
                // 檢查所有需要的元素是否存在
                if (!progressLineFill) {
                    console.warn("進度線元素不存在");
                }
                
                if (!stepCircles) {
                    console.warn("步驟圖示元素不存在");
                    return; // 無法更新步驟
                }
                
                if (!stepLabels || stepLabels.length < 3) {
                    console.warn("步驟標籤元素不存在或不完整");
                }
                
                // 更新进度条 (如果存在)
                if (progressLineFill) {
                    let fillWidth = "0%";
                    if (step === 1) fillWidth = "0%";
                    else if (step === 2) fillWidth = "50%";
                    else if (step === 3) fillWidth = "100%";
                    
                    progressLineFill.style.width = fillWidth;
                }
                
                // 更新步骤状态
                for (let i = 1; i <= 3; i++) {
                    // 更新圓圈狀態 (如果存在)
                    if (stepCircles && i-1 < stepCircles.length && stepCircles[i-1]) {
                        const circle = stepCircles[i-1];
                        
                        if (i < step) {
                            // 已完成的步骤
                            circle.classList.add('completed');
                            circle.classList.remove('active');
                        } else if (i === step) {
                            // 当前步骤
                            circle.classList.add('active');
                            circle.classList.remove('completed');
                        } else {
                            // 未完成的步骤
                            circle.classList.remove('active', 'completed');
                        }
                    }
                    
                    // 更新標籤狀態 (如果存在)
                    if (stepLabels && stepLabels.length >= i && stepLabels[i-1]) {
                        const label = stepLabels[i-1];
                        
                        if (i < step) {
                            // 已完成的步骤
                            label.classList.add('completed');
                            label.classList.remove('active');
                        } else if (i === step) {
                            // 当前步骤
                            label.classList.add('active');
                            label.classList.remove('completed');
                        } else {
                            // 未完成的步骤
                            label.classList.remove('active', 'completed');
                        }
                    }
                }
            } catch (error) {
                console.error("更新進度指示器錯誤:", error);
            }
        }
        
        // 在DOM加载完成后初始化应用
        document.addEventListener('DOMContentLoaded', function() {
            try {
                // 初始化DOM元素引用
                initializeDomReferences();
                
                // 验证DOM元素存在
                if (!validateDomElements()) {
                    return;
                }
                
                // 应用程序启动时立即强制隐藏下一关按钮
                if (nextLevelButton) {
                    console.log("初始化時強制隱藏下一關按鈕");
                    nextLevelButton.style.display = 'none';
                    nextLevelButton.classList.add('hidden');
                    // 移除所有可能的事件监听器
                    const newBtn = nextLevelButton.cloneNode(true);
                    if (nextLevelButton.parentNode) {
                        nextLevelButton.parentNode.replaceChild(newBtn, nextLevelButton);
                        nextLevelButton = newBtn;
                    }
                } else {
                    console.warn("初始化時找不到下一關按鈕");
                }
                
                // 设置事件监听器
                setupEventListeners();
                
                // 设置暗黑模式
                setupDarkMode();
                
                console.log("游戏初始化完成");
                
                // 初始化後再次確認下一關按鈕隱藏
                setTimeout(() => {
                    const btn = document.getElementById('next-level-button');
                    if (btn) {
                        btn.style.display = 'none';
                        btn.classList.add('hidden');
                    }
                }, 500);
            } catch (error) {
                console.error("初始化错误:", error);
                showError(`初始化错误: ${error.message}`);
            }
        });
        
        // 初始化DOM元素引用
        function initializeDomReferences() {
            console.log("初始化DOM元素引用...");
            mainMenu = document.getElementById('main-menu');
            gameView = document.getElementById('game-view');
            levelDisplay = document.getElementById('level-display');
            levelDescription = document.getElementById('level-description');
            poemPieces = document.getElementById('poem-pieces');
            poemSequence = document.getElementById('poem-sequence');
            checkButton = document.getElementById('check-button');
            hintButton = document.getElementById('hint-button');
            knowledgeTab = document.getElementById('knowledgeTab');
            knowledgeContent = document.getElementById('knowledge-content');
            quizTab = document.getElementById('quizTab');
            quizQuestion = document.getElementById('quiz-question');
            quizOptions = document.getElementById('quiz-options');
            quizFeedback = document.getElementById('quiz-feedback');
            submitQuizButton = document.getElementById('submit-quiz');
            toExploreButton = document.getElementById('to-explore-button');
            nextLevelButton = document.getElementById('next-level-button');
            startGameButton = document.getElementById('start-game');
            showInstructionsButton = document.getElementById('show-instructions');
            showPoemButton = document.getElementById('show-poem');
            showFullPoemButton = document.getElementById('show-full-poem');
            viewCompletePoemButton = document.getElementById('view-complete-poem');
            instructionsModal = document.getElementById('instructions-modal');
            closeInstructionsButton = document.getElementById('close-instructions');
            poemModal = document.getElementById('poem-modal');
            closePoemButton = document.getElementById('close-poem');
            successToast = document.getElementById('success-toast');
            successMessage = document.getElementById('success-message');
            gameCompleteModal = document.getElementById('game-complete-modal');
            restartGameButton = document.getElementById('restart-game');
            backToMenuButton = document.getElementById('back-to-menu');
            musicButton = document.getElementById('music-button');
            tabButtons = document.querySelectorAll('.tab-button');
            errorMessageContainer = document.getElementById('error-message');
            
            // 获取进度指示器元素
            progressLineFill = document.querySelector('.progress-line-fill');
            
            // 防止stepCircles中有null值
            const step1 = document.getElementById('step-1');
            const step2 = document.getElementById('step-2');
            const step3 = document.getElementById('step-3');
            
            if (step1 && step2 && step3) {
                stepCircles = [step1, step2, step3];
            } else {
                console.warn("步驟指示器元素不完整");
                stepCircles = null;
            }
            
            stepLabels = document.querySelectorAll('.step-label');
            if (stepLabels.length === 0) {
                console.warn("找不到步驟標籤");
                stepLabels = null;
            }
            
            // 驗證關鍵元素
            const criticalElements = {
                'mainMenu': mainMenu,
                'gameView': gameView,
                'tabButtons': tabButtons && tabButtons.length > 0
            };
            
            for (const [name, element] of Object.entries(criticalElements)) {
                if (!element) {
                    console.error(`關鍵元素 ${name} 未找到`);
                }
            }
        }

        // 暗黑模式检测
        function setupDarkMode() {
            try {
                if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
                    document.documentElement.classList.add('dark');
                }
                window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', event => {
                    if (event.matches) {
                        document.documentElement.classList.add('dark');
                    } else {
                        document.documentElement.classList.remove('dark');
                    }
                });
            } catch (error) {
                console.error("设置暗黑模式错误:", error);
            }
        }
        
        // 设置所有事件监听器
        function setupEventListeners() {
            try {
                // 开始游戏
                if (startGameButton) {
                    startGameButton.addEventListener('click', () => {
                        if (!mainMenu || !gameView) {
                            showError("找不到主菜单或游戏视图元素");
                            return;
                        }
                        mainMenu.classList.add('hidden');
                        gameView.classList.remove('hidden');
                        loadLevel(1);
                        
                        // 显示明显的音乐控制提示
                        setTimeout(() => {
                            showToast('背景音樂已自動播放，點擊右下角圓形音樂控制按鈕可關閉');
                        }, 1000);
                    });
                }
                
                // 切换标签页
                if (tabButtons) {
                    tabButtons.forEach(button => {
                        if (button) {
                            button.addEventListener('click', () => {
                                const tabId = button.getAttribute('data-tab');
                                if (!button.disabled && tabId) {
                                    switchTab(tabId);
                                }
                            });
                        }
                    });
                }
                
                // 显示游戏说明
                if (showInstructionsButton && instructionsModal) {
                    showInstructionsButton.addEventListener('click', () => {
                        instructionsModal.classList.remove('hidden');
                    });
                }
                
                // 关闭游戏说明
                if (closeInstructionsButton && instructionsModal) {
                    closeInstructionsButton.addEventListener('click', () => {
                        instructionsModal.classList.add('hidden');
                    });
                }
                
                // 显示完整诗文
                if (showPoemButton && poemModal) {
                    showPoemButton.addEventListener('click', () => {
                        poemModal.classList.remove('hidden');
                    });
                }
                
                // 游戏中显示完整诗文
                if (showFullPoemButton && poemModal) {
                    showFullPoemButton.addEventListener('click', () => {
                        poemModal.classList.remove('hidden');
                    });
                }
                
                // 游戏完成后显示专用诗文弹窗
                if (viewCompletePoemButton) {
                    viewCompletePoemButton.addEventListener('click', () => {
                        // 打开恭喜专用詩文彈窗
                        const congratsPoemModal = document.getElementById('congrats-poem-modal');
                        if (congratsPoemModal) {
                            congratsPoemModal.classList.remove('hidden');
                        }
                    });
                }
                
                // 关闭恭喜詩文彈窗 - X 按钮
                const closeCongratsPoemBtn = document.getElementById('close-congrats-poem');
                if (closeCongratsPoemBtn) {
                    closeCongratsPoemBtn.addEventListener('click', () => {
                        const congratsPoemModal = document.getElementById('congrats-poem-modal');
                        if (congratsPoemModal) {
                            congratsPoemModal.classList.add('hidden');
                        }
                    });
                }
                
                // 关闭恭喜詩文彈窗 - 返回按钮
                const closeCongratsPoemButton = document.getElementById('close-congrats-poem-btn');
                if (closeCongratsPoemButton) {
                    closeCongratsPoemButton.addEventListener('click', () => {
                        const congratsPoemModal = document.getElementById('congrats-poem-modal');
                        if (congratsPoemModal) {
                            congratsPoemModal.classList.add('hidden');
                        }
                    });
                }
                
                // 点击背景关闭恭喜詩文彈窗
                const congratsPoemBackdrop = document.getElementById('congrats-poem-backdrop');
                if (congratsPoemBackdrop) {
                    congratsPoemBackdrop.addEventListener('click', () => {
                        const congratsPoemModal = document.getElementById('congrats-poem-modal');
                        if (congratsPoemModal) {
                            congratsPoemModal.classList.add('hidden');
                        }
                    });
                }
                
                // 关闭完整诗文 - X按钮
                if (closePoemButton && poemModal) {
                    closePoemButton.addEventListener('click', () => {
                        poemModal.classList.add('hidden');
                    });
                }
                
                // 关闭完整诗文 - 底部关闭按钮
                const closePoemBtn = document.getElementById('close-poem-btn');
                if (closePoemBtn && poemModal) {
                    closePoemBtn.addEventListener('click', () => {
                        poemModal.classList.add('hidden');
                    });
                }
                
                // 点击空白区域关闭模态框
                document.querySelectorAll('.fixed.inset-0').forEach(modal => {
                    if (modal) {
                        modal.addEventListener('click', (e) => {
                            if (e.target === modal) {
                                modal.classList.add('hidden');
                            }
                        });
                    }
                });
                
                // 从知识点进入心境探索
                if (toExploreButton) {
                    toExploreButton.addEventListener('click', () => {
                        const currentLevelId = gameData.currentLevel;
                        
                        // 更新进度
                        if (gameData.progress[currentLevelId] === 1) {
                            gameData.progress[currentLevelId] = 2;
                        }
                        
                        // 切换到心境探索标签
                        switchTab("quizTab");
                        
                        // 更新进度指示器
                        updateProgressIndicator(3);
                    });
                }
                
                // 下一关按钮 - 完成心境探索后显示
                if (nextLevelButton) {
                    nextLevelButton.addEventListener('click', () => {
                        proceedToNextLevel();
                    });
                }
                
                // 重新开始游戏
                if (restartGameButton && gameCompleteModal) {
                    restartGameButton.addEventListener('click', () => {
                        gameCompleteModal.classList.add('hidden');
                        gameData.currentLevel = 0;
                        gameData.completedLevels = [];
                        
                        // 重置所有关卡进度
                        for (let i = 1; i <= gameData.levels.length; i++) {
                            gameData.progress[i] = 0;
                        }
                        
                        loadLevel(1);
                    });
                }
                
                // 返回主菜单
                if (backToMenuButton && gameCompleteModal && gameView && mainMenu) {
                    backToMenuButton.addEventListener('click', () => {
                        gameCompleteModal.classList.add('hidden');
                        gameView.classList.add('hidden');
                        mainMenu.classList.remove('hidden');
                    });
                }
                
                // 提示按钮
                if (hintButton) {
                    hintButton.addEventListener('click', () => {
                        showHint();
                    });
                }
                
                // 检查排序
                if (checkButton) {
                    checkButton.addEventListener('click', () => {
                        checkSequence();
                    });
                }
                
                // 音樂按鈕 - 控制背景音樂
                if (musicButton) {
                    const music = document.getElementById('background-music');
                    let isPlaying = false;
                    
                    // 更新初始提示文字
                    const tooltip = musicButton.querySelector('.music-tooltip');
                    if (tooltip) {
                        tooltip.innerHTML = `
                            <p class="font-medium mb-2">背景音樂控制</p>
                            <p class="mb-2">點擊可關閉背景音樂</p>
                        `;
                    }
                    
                    // 嘗試在頁面載入後立即播放音樂
                    const playBackgroundMusic = function() {
                        if (!isPlaying) {
                            music.volume = 0.3; // 設置適當的音量
                            music.play().then(() => {
                                isPlaying = true;
                                
                                // 更新按鈕圖標為暫停圖標
                                const svg = musicButton.querySelector('svg');
                                if (svg) {
                                    svg.innerHTML = `
                                        <rect x="6" y="4" width="4" height="16"></rect>
                                        <rect x="14" y="4" width="4" height="16"></rect>
                                    `;
                                }
                                
                                // 更新提示文字
                                if (tooltip) {
                                    tooltip.innerHTML = `
                                        <p class="font-medium mb-2">背景音樂已開啟</p>
                                        <p class="mb-2">點擊可關閉背景音樂</p>
                                    `;
                                }
                            }).catch(error => {
                                console.error('音樂播放失敗：', error);
                            });
                        }
                    };
                    
                    // 按鈕點擊事件 - 切換音樂播放狀態
                    musicButton.addEventListener('click', (e) => {
                        e.preventDefault();
                        
                        if (isPlaying) {
                            // 如果正在播放，則暫停音樂
                            music.pause();
                            isPlaying = false;
                            showToast('背景音樂已關閉');
                            
                            // 恢復原始音樂圖標
                            const svg = musicButton.querySelector('svg');
                            if (svg) {
                                svg.innerHTML = `
                                    <path d="M9 18V5l12-2v13"></path>
                                    <circle cx="6" cy="18" r="3"></circle>
                                    <circle cx="18" cy="16" r="3"></circle>
                                `;
                            }
                            
                            // 更新提示文字
                            if (tooltip) {
                                tooltip.innerHTML = `
                                    <p class="font-medium mb-2">背景音樂已關閉</p>
                                    <p class="mb-2">點擊開啟背景音樂</p>
                                `;
                            }
                        } else {
                            // 如果已暫停，則開始播放音樂
                            playBackgroundMusic();
                            showToast('背景音樂已開啟');
                        }
                    });
                    
                    // 為用戶交互後的音頻播放做準備
                    document.addEventListener('click', function() {
                        // 預加載音頻
                        music.load();
                        // 嘗試播放背景音樂
                        playBackgroundMusic();
                    }, { once: true });
                    
                    // 遊戲開始時播放音樂
                    if (startGameButton) {
                        startGameButton.addEventListener('click', function() {
                            playBackgroundMusic();
                        });
                    }
                }
                
                // 提交问答答案
                if (submitQuizButton) {
                    submitQuizButton.addEventListener('click', () => {
                        submitQuizAnswer();
                    });
                }
                
                // ESC键关闭模态框
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        if (instructionsModal) instructionsModal.classList.add('hidden');
                        if (poemModal) poemModal.classList.add('hidden');
                        if (gameCompleteModal) gameCompleteModal.classList.add('hidden');
                    }
                });
            } catch (error) {
                console.error("设置事件监听器错误:", error);
                showError(`设置事件监听器错误: ${error.message}`);
            }
        }
        
        // 徹底重寫版 - 進入下一關
        function proceedToNextLevel() {
            try {
                // 嚴格檢查當前關卡ID (確保是數字)
                const currentLevelId = Number(gameData.currentLevel);
                if (isNaN(currentLevelId)) {
                    console.error("當前關卡ID無效:", gameData.currentLevel);
                    alert("關卡ID無效，請刷新頁面重試");
                    return;
                }
                
                // 記錄全面的調試信息
                console.log("==== 進入下一關 - 全面調試 ====");
                console.log("當前遊戲狀態:", {
                    currentLevel: currentLevelId,
                    completedLevels: gameData.completedLevels,
                    progress: gameData.progress
                });
                
                // 檢查當前關卡是否有效
                const currentLevel = gameData.levels.find(l => l.id === currentLevelId);
                if (!currentLevel) {
                    console.error(`當前關卡ID ${currentLevelId} 在gameData.levels中不存在!`);
                    showError(`無法識別當前關卡，請刷新重試`);
                    return;
                }
                
                // 打印詳細的關卡數據
                console.table(gameData.levels.map(l => ({id: l.id, title: l.title})));
                
                // 計算下一個關卡ID (固定加1)
                // 此處關卡ID應從1, 2, 3, 4...順序遞增
                const nextLevelId = currentLevelId + 1;
                console.log(`計算下一關: ${currentLevelId} -> ${nextLevelId}`);
                
                // 確認下一關是否存在
                const nextLevel = gameData.levels.find(l => l.id === nextLevelId);
                if (!nextLevel) {
                    if (nextLevelId > gameData.levels.length) {
                        console.log(`已到達最終關卡，無法繼續 (嘗試進入第${nextLevelId}關)`);
                        showToast("已經是最後一關！");
                        return;
                    } else {
                        console.error(`嚴重錯誤: ID為${nextLevelId}的關卡在數據中不存在!`);
                        console.log("關卡數據:", JSON.stringify(gameData.levels));
                        alert(`系統錯誤：找不到第${nextLevelId}關`);
                        return;
                    }
                }
                
                // 顯示將要載入的關卡
                console.log(`準備載入第${nextLevelId}關: "${nextLevel.title}"`);
                
                // 確保正確設置nextLevelButton的行為
                const nextLevelButton = document.getElementById('next-level-button');
                if (nextLevelButton) {
                    // 先移除所有現有事件監聽器
                    nextLevelButton.replaceWith(nextLevelButton.cloneNode(true));
                    
                    // 更新遊戲狀態前確保按鈕隱藏
                    nextLevelButton.style.display = 'none';
                }
                
                // 先更新遊戲狀態，確保狀態一致
                gameData.currentLevel = nextLevelId;
                console.log(`遊戲狀態已更新: currentLevel = ${gameData.currentLevel}`);
                
                // 然後加載新關卡
                console.log(`正在調用loadLevel(${nextLevelId})加載關卡...`);
                setTimeout(() => { // 短暫延遲確保狀態已更新
                    loadLevel(nextLevelId);
                    
                    // 確認加載後的狀態
                    setTimeout(() => {
                        console.log(`關卡加載完成，當前關卡ID: ${gameData.currentLevel}`);
                        if (gameData.currentLevel !== nextLevelId) {
                            console.error("警告: 關卡加載後ID不一致!");
                        }
                    }, 100);
                }, 10);
                
            } catch (error) {
                console.error("進入下一關時發生嚴重錯誤:", error);
                alert(`進入下一關時發生錯誤: ${error.message}`);
            }
        }
        
        // 处理关卡选择
        function loadLevel(levelId) {
            try {
                // 找到关卡数据
                const level = gameData.levels.find(level => level.id === levelId);
                if (!level) {
                    showError(`找不到关卡${levelId}`);
                    return;
                }
                
                // 更新游戏状态
                gameData.currentLevel = levelId;
                
                // 重置关卡进度指示器（如果是新关卡）
                if (gameData.progress[levelId] === 0) {
                    updateProgressIndicator(1);
                }
                
                // 更新界面
                if (levelDisplay) levelDisplay.textContent = `${level.id} / ${gameData.levels.length} - ${level.title}`;
                if (levelDescription) levelDescription.textContent = level.description;
                
                // 清空诗句区域
                if (poemPieces) poemPieces.innerHTML = '';
                if (poemSequence) poemSequence.innerHTML = '';
                
                // 创建打字机效果的函数和变量
                const typeWriterSpeed = 40; // 打字速度，数值越小越快
                let typewriterTimeout = null;
                
                function typeWriter(element, text, i = 0) {
                    if (typewriterTimeout) {
                        clearTimeout(typewriterTimeout);
                    }
                    
                    if (i < text.length) {
                        element.innerHTML = text.substring(0, i + 1);
                        typewriterTimeout = setTimeout(() => {
                            typeWriter(element, text, i + 1);
                        }, typeWriterSpeed);
                    }
                }
                
                // 预填知识点内容 (确保内容始终存在，但不立即显示)
                if (knowledgeContent) {
                    // 先保存知识点内容，但不立即显示
                    knowledgeContent.setAttribute('data-content', level.knowledge);
                    knowledgeContent.innerHTML = '';
                    
                    // 立即記錄下來，確保後續能找到
                    console.log("知識點內容已保存:", knowledgeContent.getAttribute('data-content'));
                }
                
                // 预先填充问答区域
                if (quizQuestion) quizQuestion.textContent = level.quiz.question;
                if (quizOptions) {
                    // 清空现有选项
                    quizOptions.innerHTML = '';
                    
                    // 重置反馈区域和下一关按钮
                    if (quizFeedback) {
                        quizFeedback.classList.add('hidden');
                        quizFeedback.innerHTML = '';
                    }
                    
                    // 不管关卡状态如何，都强制隐藏下一关按钮
                    if (nextLevelButton) {
                        nextLevelButton.style.display = 'none';
                        nextLevelButton.classList.add('hidden');
                    }
                    
                    // 创建新选项
                    level.quiz.options.forEach(option => {
                        const optionElement = document.createElement('div');
                        optionElement.className = 'quiz-option p-4 bg-white dark:bg-gray-800 rounded-md shadow-elegant border border-gray-200 dark:border-gray-700 text-gray-800 dark:text-gray-200 cursor-pointer hover:shadow-hover transition-all';
                        optionElement.setAttribute('data-id', option.id);
                        optionElement.innerHTML = `<span class="font-medium">${option.id.toUpperCase()}.</span> ${option.text}`;
                        
                        // 添加点击事件 - 确保每次点击都强制隐藏下一关按钮
                        optionElement.addEventListener('click', () => {
                            // 移除其他选项的选中状态
                            document.querySelectorAll('.quiz-option').forEach(el => {
                                if (el) {
                                    el.classList.remove('selected');
                                    el.classList.remove('animate__animated');
                                    el.classList.remove('animate__pulse');
                                }
                            });
                            
                            // 添加选中状态和动画效果
                            optionElement.classList.add('selected');
                            optionElement.classList.add('animate__animated');
                            optionElement.classList.add('animate__pulse');
                            
                            // 确保选择选项时隐藏"下一关"按钮 - 这是关键步骤
                            if (nextLevelButton) {
                                console.log("点击选项，强制隐藏下一关按钮");
                                nextLevelButton.style.display = 'none';
                                nextLevelButton.classList.add('hidden');
                            }
                            
                            // 也隐藏反馈区域，强制用户点击确认按钮
                            if (quizFeedback) {
                                quizFeedback.classList.add('hidden');
                            }
                        });
                        
                        quizOptions.appendChild(optionElement);
                    });
                    
                    // 重要：加载关卡时，确保所有选项都是未选中状态
                    document.querySelectorAll('.quiz-option').forEach(el => {
                        if (el) {
                            el.classList.remove('selected');
                            el.style.borderColor = '';
                            el.style.backgroundColor = '';
                        }
                    });
                }
                
                // 隐藏问答反馈
                if (quizFeedback) quizFeedback.classList.add('hidden');
                
                // 始终隐藏下一关按钮，尤其对于第四关
                if (nextLevelButton) {
                    nextLevelButton.classList.add('hidden');
                    nextLevelButton.style.display = 'none';
                }
                
                // 根据进度设置界面状态
                const levelProgress = gameData.progress[levelId] || 0;
                if (levelProgress === 0) {
                    // 新关卡：只启用排序标签
                    updateTabsAvailability(false);
                    switchTab("puzzleTab");
                } else {
                    // 之前完成过的关卡：启用所有标签
                    updateTabsAvailability(true);
                    
                    // 根据进度更新显示
                    if (levelProgress === 1) {
                        // 已完成排序，未看知识点
                        updateProgressIndicator(2);
                        switchTab("knowledgeTab");
                    } else if (levelProgress === 2) {
                        // 已看知识点，未完成心境探索
                        updateProgressIndicator(3);
                        switchTab("quizTab");
                    } else if (levelProgress === 3) {
                        // 已完成所有内容
                        updateProgressIndicator(3);
                        
                        // 修改：不在關卡載入時顯示下一關按鈕，確保只有在用戶確認答案後才顯示
                        // 即使關卡已完成，也統一隱藏按鈕
                        if (nextLevelButton) {
                            nextLevelButton.style.display = 'none';
                            nextLevelButton.classList.add('hidden');
                        }
                        
                        switchTab("quizTab");
                    }
                }
                
                // 在最后一关成功后显示完整诗文按钮
                if (showFullPoemButton) {
                    if (gameData.completedLevels.length === gameData.levels.length) {
                        showFullPoemButton.classList.remove('hidden');
                    } else {
                        showFullPoemButton.classList.add('hidden');
                    }
                }
                
                // 更新场景
                updateScene(level.scene);
                
                // 更新情感图表
                updateEmotionChart(levelId - 1);
                
                // 打乱诗句顺序并加载
                if (poemPieces) {
                    const shuffledPieces = [...level.pieces].sort(() => Math.random() - 0.5);
                    
                    // 根据诗句数量决定布局
                    poemPieces.classList.add('poem-grid');
                    
                    shuffledPieces.forEach(piece => {
                        const pieceElement = createPoemPiece(piece);
                        poemPieces.appendChild(pieceElement);
                    });
                }
                
                // 添加拖拽事件
                setupDragAndDrop();
            } catch (error) {
                console.error("加载关卡错误:", error);
                showError(`加载关卡错误: ${error.message}`);
            }
        }
        
        // 更新标签可用性
        function updateTabsAvailability(isCompleted) {
            try {
                // 图标
                const checkIcon = `<span class="achievement-badge ${isCompleted ? 'show' : ''}">✓</span>`;
                
                if (!tabButtons) {
                    showError("找不到标签按钮元素");
                    return;
                }
                
                tabButtons.forEach(btn => {
                    if (!btn) return;
                    
                    const tabId = btn.getAttribute('data-tab');
                    if (!tabId) return;
                    
                    // 首先移除之前可能添加的成就标记
                    const existingBadge = btn.querySelector('.achievement-badge');
                    if (existingBadge) {
                        existingBadge.remove();
                    }
                    
                    if (isCompleted) {
                        // 启用所有标签
                        btn.disabled = false;
                        btn.classList.remove('opacity-50');
                        btn.classList.remove('cursor-not-allowed');
                        
                        // 添加成就标记到每个标签
                        if (tabId !== 'puzzleTab') {
                            btn.style.position = 'relative';
                            btn.insertAdjacentHTML('beforeend', checkIcon);
                        }
                    } else {
                        // 只启用拼图标签，禁用其他标签
                        if (tabId !== 'puzzleTab') {
                            btn.disabled = true;
                            btn.classList.add('opacity-50');
                            btn.classList.add('cursor-not-allowed');
                        } else {
                            btn.disabled = false;
                            btn.classList.remove('opacity-50');
                            btn.classList.remove('cursor-not-allowed');
                        }
                    }
                });
            } catch (error) {
                console.error("更新标签可用性错误:", error);
            }
        }
        
        // 切换标签
        function switchTab(tabId) {
            try {
                console.log("切换到标签:", tabId);
                
                if (!tabId) {
                    showError("無效的標籤ID");
                    return;
                }
                
                // 每次切換標籤時都確保下一關按鈕隱藏
                if (nextLevelButton) {
                    nextLevelButton.style.display = 'none';
                    nextLevelButton.classList.add('hidden');
                    console.log("切換標籤時隱藏下一關按鈕");
                }
                
                // 如果切換到心境探索標籤頁，清除所有選項的選擇狀態
                if (tabId === 'quizTab') {
                    document.querySelectorAll('.quiz-option').forEach(el => {
                        if (el) {
                            el.classList.remove('selected');
                            el.style.borderColor = '';
                            el.style.backgroundColor = '';
                        }
                    });
                    
                    // 隱藏反饋區域
                    if (quizFeedback) {
                        quizFeedback.classList.add('hidden');
                    }
                }
                
                // 檢查標籤按鈕是否存在
                if (!tabButtons || tabButtons.length === 0) {
                    console.warn("找不到標籤按鈕元素");
                } else {
                    // 移除所有标签的活动状态
                    tabButtons.forEach(btn => {
                        if (!btn) return;
                        
                        try {
                            btn.classList.remove('active');
                            btn.classList.remove('bg-primary-600');
                            btn.classList.remove('text-white');
                            btn.classList.add('border-gray-200');
                            btn.classList.add('text-gray-600');
                            btn.classList.add('dark:border-gray-700');
                            btn.classList.add('dark:text-gray-400');
                        } catch (e) {
                            console.warn("無法修改標籤按鈕樣式:", e);
                        }
                    });
                    
                    // 添加当前标签的活动状态
                    const activeTab = document.querySelector(`.tab-button[data-tab="${tabId}"]`);
                    if (activeTab) {
                        try {
                            activeTab.classList.add('active');
                            activeTab.classList.add('bg-primary-600');
                            activeTab.classList.add('text-white');
                            activeTab.classList.remove('border-gray-200');
                            activeTab.classList.remove('text-gray-600');
                            activeTab.classList.remove('dark:border-gray-700');
                            activeTab.classList.remove('dark:text-gray-400');
                        } catch (e) {
                            console.warn("無法設置活動標籤樣式:", e);
                        }
                    } else {
                        console.warn(`找不到標籤按鈕: ${tabId}`);
                    }
                }
                
                // 隐藏所有内容区域
                const tabContainers = document.querySelectorAll('.tab-container');
                if (!tabContainers || tabContainers.length === 0) {
                    console.warn("找不到標籤內容容器元素");
                } else {
                    tabContainers.forEach(container => {
                        if (!container) return;
                        
                        try {
                            container.classList.remove('active');
                            container.classList.remove('animate__animated');
                            container.classList.remove('animate__fadeIn');
                            container.style.display = 'none'; // 确保直接隐藏
                        } catch (e) {
                            console.warn("無法隱藏標籤內容:", e);
                        }
                    });
                }
                
                // 显示相关的内容区域
                const tabContent = document.getElementById(tabId);
                if (!tabContent) {
                    console.warn(`找不到標籤內容: ${tabId}`);
                    return;
                }
                
                try {
                    tabContent.classList.add('active');
                    tabContent.classList.add('animate__animated');
                    tabContent.classList.add('animate__fadeIn');
                    tabContent.classList.add('animate__faster');
                    tabContent.style.display = 'block'; // 确保直接显示
                } catch (e) {
                    console.warn("無法顯示標籤內容:", e);
                    
                    // 嘗試最基本的顯示方式
                    try {
                        tabContent.style.display = 'block';
                    } catch (e2) {
                        console.error("無法顯示標籤內容，即使使用基本方式:", e2);
                    }
                }
                
                // 确保切换到知识点标签时内容正确显示，并使用打字机效果
                if (tabId === 'knowledgeTab') {
                    if (!knowledgeContent) {
                        console.warn("找不到知識點內容元素");
                    } else {
                        const level = gameData.levels.find(level => level.id === gameData.currentLevel);
                        if (level) {
                            try {
                                // 先清空内容并隐藏探索按钮
                                knowledgeContent.innerHTML = '';
                                if (toExploreButton) {
                                    toExploreButton.style.display = 'none';
                                }
                                
                                console.log("準備啟動打字機效果...");
                                
                                // 获取保存的知识点内容
                                const savedContent = knowledgeContent.getAttribute('data-content') || level.knowledge;
                                
                                console.log("知識點內容:", savedContent ? savedContent.substring(0, 50) + "..." : "未找到內容");
                                
                                // 使用全局打字机函数，添加完成回调来显示按钮
                                window.setTimeout(() => {
                                    console.log("開始打字機效果");
                                    typeWriter(knowledgeContent, savedContent, () => {
                                        // 打字机效果完成后显示探索按钮
                                        console.log("打字機效果完成，顯示探索按鈕");
                                        if (toExploreButton) {
                                            toExploreButton.style.display = 'block';
                                            toExploreButton.classList.add('animate__animated', 'animate__fadeIn');
                                        }
                                    });
                                }, 100);
                            } catch (e) {
                                console.warn("無法設置知識點內容:", e);
                                // 出错时直接显示内容和按钮
                                try {
                                    knowledgeContent.innerHTML = level.knowledge;
                                    if (toExploreButton) {
                                        toExploreButton.style.display = 'block';
                                    }
                                } catch (err) {
                                    console.error("直接顯示知識點內容也失敗:", err);
                                }
                            }
                        } else {
                            console.warn("找不到當前關卡數據");
                        }
                    }
                }
            } catch (error) {
                console.error("切換標籤錯誤:", error);
                showError(`切換標籤錯誤: ${error.message}`);
            }
        }
        
        // 更新场景
        function updateScene(scene) {
            try {
                const sceneIllustration = document.getElementById('scene-illustration');
                const emotionBadge = document.getElementById('emotion-badge');
                const characterMonologue = document.getElementById('character-monologue');
                
                // 设置背景
                if(sceneIllustration) {
                    sceneIllustration.style.background = scene.background;
                }
                
                // 设置情感徽章
                if(emotionBadge) {
                    emotionBadge.textContent = scene.emotion.label;
                    emotionBadge.style.backgroundColor = scene.emotion.color;
                }
                
                // 设置独白
                if(characterMonologue) {
                    characterMonologue.textContent = scene.monologue;
                }
            } catch (error) {
                console.error("更新场景错误:", error);
            }
        }
        
        // 情感曲线数据
        const emotionData = {
            labels: ['童年時光', '新婚時期', '別離之苦', '相思之情'],
            datasets: [
                {
                    label: '天真爛漫',
                    data: [100, 40, 10, 5],
                    borderColor: '#FFD166',
                    backgroundColor: 'rgba(255, 209, 102, 0.3)',
                    borderWidth: 2,
                    hoverBorderWidth: 3,
                },
                {
                    label: '羞澀',
                    data: [20, 100, 50, 30],
                    borderColor: '#EF767A',
                    backgroundColor: 'rgba(239, 118, 122, 0.3)',
                    borderWidth: 2,
                    hoverBorderWidth: 3,
                },
                {
                    label: '思念',
                    data: [0, 30, 100, 85],
                    borderColor: '#4E8098',
                    backgroundColor: 'rgba(78, 128, 152, 0.3)',
                    borderWidth: 2,
                    hoverBorderWidth: 3,
                },
                {
                    label: '期盼',
                    data: [10, 40, 60, 100],
                    borderColor: '#9381FF',
                    backgroundColor: 'rgba(147, 129, 255, 0.3)',
                    borderWidth: 2,
                    hoverBorderWidth: 3,
                }
            ]
        };
        
        // 更新情感图表
        function updateEmotionChart(levelIndex) {
            try {
                // 获取图表容器
                const chartCanvas = document.getElementById('emotion-chart');
                const chartContainer = document.querySelector('.emotion-chart-container');
                
                if(!chartCanvas) {
                    console.log("找不到图表容器");
                    return;
                }
                
                // 先添加淡出效果
                if (chartContainer) {
                    chartContainer.classList.add('animate__animated', 'animate__fadeOut');
                    chartContainer.style.animationDuration = '0.3s';
                }
                
                // 短暫延遲後重新創建圖表
                setTimeout(() => {
                    const ctx = chartCanvas.getContext('2d');
                    
                    // 确保彻底销毁现有图表
                    if (emotionChart) {
                        emotionChart.destroy();
                    }
                    
                    // 移除舊的動畫效果並準備添加新的
                    if (chartContainer) {
                        chartContainer.classList.remove('animate__animated', 'animate__fadeOut', 'animate__fadeIn');
                    }
                    
                    // 计算不同情感在此关卡的强度
                    const dataForCurrentLevel = emotionData.datasets.map(dataset => ({
                        label: dataset.label,
                        data: [dataset.data[levelIndex]],
                        backgroundColor: dataset.backgroundColor,
                        borderColor: dataset.borderColor,
                        borderWidth: dataset.borderWidth,
                        hoverBorderWidth: dataset.hoverBorderWidth,
                        borderRadius: 4,
                        hoverBorderRadius: 6
                    }));
                    
                    // 创建横向条形图 - 确保每次都有完整动画效果
                    emotionChart = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: [''],  // 使用空字符串替代"情感強度"
                            datasets: dataForCurrentLevel
                        },
                        options: {
                            indexAxis: 'y',
                            maintainAspectRatio: false,
                            scales: {
                                x: {
                                    beginAtZero: true,
                                    max: 100,
                                    grid: {
                                        display: false,
                                        drawBorder: false
                                    },
                                    ticks: {
                                        font: {
                                            size: 10
                                        },
                                        callback: function(value) {
                                            return value + '%';  // 添加百分比符號
                                        }
                                    }
                                },
                                y: {
                                    grid: {
                                        display: false,
                                        drawBorder: false
                                    },
                                    ticks: {
                                        font: {
                                            size: 11,
                                            family: "'Noto Serif TC', serif"
                                        }
                                    }
                                }
                            },
                            plugins: {
                                legend: {
                                    position: 'top',
                                    align: 'center',
                                    labels: {
                                        usePointStyle: true,
                                        boxWidth: 12,
                                        padding: 12,
                                        font: {
                                            size: 12,
                                            family: "'Noto Sans TC', sans-serif"
                                        }
                                    }
                                },
                                tooltip: {
                                    callbacks: {
                                        label: function(context) {
                                            return `${context.dataset.label}: ${context.raw}%`;
                                        }
                                    },
                                    backgroundColor: 'rgba(50, 50, 50, 0.9)',
                                    titleFont: {
                                        size: 13,
                                        family: "'Noto Sans TC', sans-serif",
                                        weight: 'bold'
                                    },
                                    bodyFont: {
                                        size: 12,
                                        family: "'Noto Sans TC', sans-serif"
                                    },
                                    padding: 10,
                                    cornerRadius: 4,
                                    displayColors: true
                                }
                            },
                            animation: {
                                duration: 1500,
                                easing: 'easeOutQuart',
                                delay: 100 // 添加延遲確保動畫更明顯
                            },
                            hover: {
                                mode: 'index',
                                intersect: false
                            }
                        }
                    });
                    
                    // 圖表創建後添加淡入效果
                    if (chartContainer) {
                        chartContainer.classList.add('animate__animated', 'animate__fadeIn');
                        chartContainer.style.animationDuration = '0.8s';
                        chartContainer.style.animationDelay = '0.1s';
                    }
                    
                }, 350); // 等待淡出效果完成後再創建新圖表
            } catch (error) {
                console.error("更新情感图表错误:", error);
            }
        }
        
        // 创建诗句卡片 - 适应大小并居中
        function createPoemPiece(piece) {
            try {
                const pieceElement = document.createElement('div');
                pieceElement.className = 'poem-card p-4 bg-white dark:bg-gray-800 rounded-md shadow border border-gray-200 dark:border-gray-700 text-gray-800 dark:text-gray-200 select-none font-serif';
                pieceElement.setAttribute('data-id', piece.id);
                pieceElement.textContent = piece.text;
                
                // 根据诗句长度自动调整宽度
                if (piece.text.length > 17) {
                    pieceElement.style.width = "100%";
                } else {
                    pieceElement.style.width = "95%";
                }
                
                return pieceElement;
            } catch (error) {
                console.error("创建诗句卡片错误:", error);
                return document.createElement('div');
            }
        }
        
        // 显示提示
        function showHint() {
            try {
                const level = gameData.levels.find(level => level.id === gameData.currentLevel);
                if (!level) {
                    console.error("找不到当前关卡数据");
                    return;
                }
                
                const firstCorrectId = level.correctOrder[0];
                const firstPiece = level.pieces.find(piece => piece.id === firstCorrectId);
                
                if (firstPiece) {
                    showToast(`提示：第一句詩應為「${firstPiece.text}」`);
                }
            } catch (error) {
                console.error("显示提示错误:", error);
            }
        }
        
        // 显示提示消息
        function showToast(message) {
            try {
                if (!successMessage || !successToast) {
                    console.error("找不到提示消息元素");
                    return;
                }
                
                successMessage.textContent = message;
                successToast.classList.remove('hidden');
                successToast.classList.add('animate__animated');
                successToast.classList.add('animate__fadeInUp');
                
                setTimeout(() => {
                    successToast.classList.remove('animate__fadeInUp');
                    successToast.classList.add('animate__fadeOutDown');
                    
                    setTimeout(() => {
                        successToast.classList.add('hidden');
                        successToast.classList.remove('animate__fadeOutDown');
                    }, 500);
                }, 3000);
            } catch (error) {
                console.error("显示提示消息错误:", error);
            }
        }
        
        // 设置拖拽事件 - 使用MouseEvent實現精確拖拽
        function setupDragAndDrop() {
            console.log("設置精確拖拽功能...");
            try {
                // 確保拖拽區域存在
                if (!poemPieces || !poemSequence) {
                    console.error("詩句區域不存在，無法設置拖拽功能");
                    return;
                }
                
                // 為所有詩句卡片添加滑鼠事件
                const poemCards = document.querySelectorAll('.poem-card');
                
                // 記錄找到的卡片數量
                console.log(`找到 ${poemCards.length} 個詩句卡片`);
                
                if (poemCards.length === 0) {
                    console.warn("未找到詩句卡片，可能尚未加載");
                    return;
                }
                
                // 為每個卡片添加事件處理
                poemCards.forEach(card => {
                    // 滑鼠按下事件 - 開始拖拽
                    card.addEventListener('mousedown', function(e) {
                        // 防止文本選擇
                        e.preventDefault();
                        
                        // 開始拖拽
                        startDrag(this, e.clientX, e.clientY);
                        
                        // 設置初始位置和偏移
                        const rect = this.getBoundingClientRect();
                        initialMouseX = e.clientX;
                        initialMouseY = e.clientY;
                        offsetX = e.clientX - rect.left;
                        offsetY = e.clientY - rect.top;
                    });
                    
                    // 觸摸開始事件 (移動設備支持) - 使用長按啟動拖拽，避免攔截正常滾動
                    card.addEventListener('touchstart', function(e) {
                        if (e.touches.length !== 1) return;
                        const touch = e.touches[0];
                        touchStartX = touch.clientX;
                        touchStartY = touch.clientY;

                        // 預先計算偏移，供長按後使用
                        const rect = this.getBoundingClientRect();
                        offsetX = touch.clientX - rect.left;
                        offsetY = touch.clientY - rect.top;
                        initialMouseX = touch.clientX;
                        initialMouseY = touch.clientY;

                        // 設置長按計時器（約280ms）
                        clearTimeout(longPressTimer);
                        longPressTimer = setTimeout(() => {
                            // 若在長按期間無明顯移動，開始拖拽並阻止滾動
                            startDrag(this, initialMouseX, initialMouseY);
                        }, 280);
                    }, { passive: true });

                    // 觸摸移動：若在長按觸發前移動幅度過大，視為滾動，取消拖拽啟動
                    card.addEventListener('touchmove', function(e) {
                        if (!longPressTimer) return;
                        if (e.touches.length !== 1) return;
                        const t = e.touches[0];
                        const dx = t.clientX - touchStartX;
                        const dy = t.clientY - touchStartY;
                        const moveDist = Math.hypot(dx, dy);
                        if (moveDist > 10) {
                            clearTimeout(longPressTimer);
                            longPressTimer = null;
                            // 不阻止默認，讓頁面可正常滾動
                        }
                    }, { passive: true });
                });
                
                // 滑鼠移動事件 - 更新拖拽位置
                document.addEventListener('mousemove', function(e) {
                    if (!isDragging || !draggedElement) return;
                    
                    // 移動克隆體
                    updateDragPosition(e.clientX, e.clientY);
                    
                    // 檢測放置位置
                    detectDropTarget(e.clientX, e.clientY);
                });
                
                // 觸摸移動事件
                document.addEventListener('touchmove', function(e) {
                    if (!isDragging || !draggedElement || e.touches.length === 0) return;
                    const touch = e.touches[0];

                    // 只有在已進入拖拽狀態時才阻止頁面滾動
                    e.preventDefault();

                    // 移動克隆體
                    updateDragPosition(touch.clientX, touch.clientY);
                    
                    // 檢測放置位置
                    detectDropTarget(touch.clientX, touch.clientY);
                }, { passive: false });
                
                // 滑鼠釋放事件 - 完成拖拽
                document.addEventListener('mouseup', function(e) {
                    if (isDragging) {
                        finishDrag(e.clientX, e.clientY);
                    }
                });
                
                    // 觸摸結束事件
                    document.addEventListener('touchend', function(e) {
                        // 結束長按等待
                        clearTimeout(longPressTimer);
                        longPressTimer = null;
                        if (isDragging && e.changedTouches.length > 0) {
                            const touch = e.changedTouches[0];
                            finishDrag(touch.clientX, touch.clientY);
                        }
                    });
                
                // 防止離開視窗時元素懸掛
                document.addEventListener('mouseleave', function() {
                    if (isDragging) {
                        cancelDrag();
                    }
                });
                
                console.log("拖拽事件設置完成");
            } catch (error) {
                console.error("設置拖拽事件錯誤:", error);
                showError("設置拖拽功能時發生錯誤");
            }
        }
        
        // 開始拖拽
        function startDrag(element, clientX, clientY) {
            try {
                // 防止重複啟動拖拽
                if (isDragging) return;
                
                console.log("開始拖拽", element.textContent);
                
                // 設置拖拽狀態
                isDragging = true;
                draggedElement = element;
                
                // 視覺反饋 - 原元素半透明
                draggedElement.classList.add('dragging');
                
                // 創建拖拽克隆體
                createDragClone(element, clientX, clientY);
                
                // 觸覺反饋
                if (navigator.vibrate) {
                    navigator.vibrate(50);
                }
            } catch (error) {
                console.error("開始拖拽錯誤:", error);
                isDragging = false;
                draggedElement = null;
            }
        }
        
        // 更新拖拽位置
        function updateDragPosition(clientX, clientY) {
            if (!dragClone) return;
            
            try {
                // 使用 transform 而不是 left/top，性能更好
                dragClone.style.left = `${clientX - offsetX}px`;
                dragClone.style.top = `${clientY - offsetY}px`;
            } catch (error) {
                console.warn("更新拖拽位置錯誤:", error);
            }
        }
        
        // 檢測放置目標
        function detectDropTarget(clientX, clientY) {
            try {
                // 檢查是否在排序區域
                const sequenceRect = poemSequence.getBoundingClientRect();
                const piecesRect = poemPieces.getBoundingClientRect();
                
                // 清除所有高亮
                poemSequence.classList.remove('highlight');
                poemPieces.classList.remove('highlight');
                
                // 移除現有指示器
                removeDropIndicator();
                
                if (isWithinRect(clientX, clientY, sequenceRect)) {
                    // 鼠標在排序區域內
                    poemSequence.classList.add('highlight');
                    
                    // 找出應插入的位置
                    const insertPosition = findInsertPositionVertical(poemSequence, clientY);
                    
                    // 創建放置指示器
                    createDropIndicator(poemSequence, insertPosition);
                } else if (isWithinRect(clientX, clientY, piecesRect)) {
                    // 鼠標在原始區域內
                    poemPieces.classList.add('highlight');
                    
                    // 找出應插入的位置
                    const insertPosition = findInsertPositionHorizontal(poemPieces, clientX, clientY);
                    
                    // 如果當前不在原始區域，則創建指示器
                    if (draggedElement.parentElement !== poemPieces) {
                        createDropIndicator(poemPieces, insertPosition);
                    }
                }
            } catch (error) {
                console.warn("檢測放置目標錯誤:", error);
            }
        }
        
        // 完成拖拽 - 修复参考节点错误
        function finishDrag(clientX, clientY) {
            try {
                if (!isDragging || !draggedElement) return;
                
                console.log("完成拖拽");
                
                // 取得目標區域
                const sequenceRect = poemSequence.getBoundingClientRect();
                const piecesRect = poemPieces.getBoundingClientRect();
                
                let targetContainer = null;
                
                if (isWithinRect(clientX, clientY, sequenceRect)) {
                    // 放入排序區域
                    targetContainer = poemSequence;
                    console.log("放入排序區域");
                } else if (isWithinRect(clientX, clientY, piecesRect)) {
                    // 放回原始區域
                    targetContainer = poemPieces;
                    console.log("放回原始區域");
                }
                
                // 執行放置操作
                if (targetContainer) {
                    // 恢復元素樣式
                    draggedElement.classList.remove('dragging');
                    
                    // 從原位置移除
                    if (draggedElement.parentNode) {
                        draggedElement.parentNode.removeChild(draggedElement);
                    }
                    
                    // 安全方式插入元素 - 修复关键问题
                    try {
                        // 根据目标容器类型确定插入位置
                        if (targetContainer === poemSequence) {
                            // 在垂直排序区域，计算基于Y坐标的位置
                            const mouseY = clientY;
                            const cards = Array.from(targetContainer.querySelectorAll('.poem-card:not(.dragging)'));
                            
                            // 找到鼠标位置下方的第一个元素
                            let insertBeforeElement = null;
                            for (let i = 0; i < cards.length; i++) {
                                const card = cards[i];
                                const rect = card.getBoundingClientRect();
                                if (mouseY < rect.top + rect.height / 2) {
                                    insertBeforeElement = card;
                                    break;
                                }
                            }
                            
                            // 确保参考节点是当前容器的子节点
                            if (insertBeforeElement && insertBeforeElement.parentNode === targetContainer) {
                                targetContainer.insertBefore(draggedElement, insertBeforeElement);
                                console.log("垂直放置: 插入到指定元素前");
                            } else {
                                // 如果没有找到合适的位置，或参考节点不是当前容器的子节点，则添加到末尾
                                targetContainer.appendChild(draggedElement);
                                console.log("垂直放置: 添加到末尾");
                            }
                        } else {
                            // 在水平网格布局中，直接添加到末尾最安全
                            targetContainer.appendChild(draggedElement);
                            console.log("水平放置: 添加到末尾");
                        }
                        
                        // 添加放置动画效果
                        draggedElement.style.animation = 'pop 0.3s ease-out';
                        setTimeout(() => {
                            if (draggedElement) {  // 确保元素仍然存在
                                draggedElement.style.animation = '';
                            }
                        }, 300);
                    } catch (insertError) {
                        console.error("插入节点错误:", insertError);
                        // 失败时的备用方案: 直接添加到末尾
                        try {
                            targetContainer.appendChild(draggedElement);
                            console.log("使用备用方案添加元素");
                        } catch (fallbackError) {
                            console.error("备用方案也失败:", fallbackError);
                            // 最终备用: 将元素恢复到原始容器
                            if (draggedElement.parentNode !== poemPieces) {
                                poemPieces.appendChild(draggedElement);
                                console.log("恢复到原始容器");
                            }
                        }
                    }
                } else {
                    // 没有找到合适的目标区域，恢复原状
                    if (draggedElement) {
                        draggedElement.classList.remove('dragging');
                    }
                }
                
                // 清理拖拽状态
                cleanupDrag();
                
                // 触觉反馈
                if (navigator.vibrate) {
                    navigator.vibrate(20);
                }
            } catch (error) {
                console.error("完成拖拽错误:", error);
                cancelDrag();
            }
        }
        
        // 取消拖拽
        function cancelDrag() {
            try {
                console.log("取消拖拽");
                
                if (draggedElement) {
                    // 恢復拖拽元素的樣式
                    draggedElement.classList.remove('dragging');
                }
                
                // 清理拖拽狀態
                cleanupDrag();
            } catch (error) {
                console.error("取消拖拽錯誤:", error);
            }
        }
        
        // 清理拖拽狀態
        function cleanupDrag() {
            try {
                // 移除克隆體
                if (dragClone && dragClone.parentNode) {
                    dragClone.parentNode.removeChild(dragClone);
                }
                
                // 移除放置指示器
                removeDropIndicator();
                
                // 清除高亮效果
                if (poemSequence) poemSequence.classList.remove('highlight');
                if (poemPieces) poemPieces.classList.remove('highlight');
                
                // 重置拖拽狀態
                isDragging = false;
                draggedElement = null;
                dragClone = null;
                dropIndicator = null;
            } catch (error) {
                console.warn("清理拖拽狀態錯誤:", error);
            }
        }
        
        // 創建拖拽克隆體
        function createDragClone(element, clientX, clientY) {
            try {
                // 創建克隆體
                dragClone = element.cloneNode(true);
                if (!dragClone) return;  // 檢查克隆是否成功
                
                dragClone.classList.add('drag-clone');
                
                // 設置初始樣式和位置
                const rect = element.getBoundingClientRect();
                dragClone.style.width = `${rect.width}px`;
                dragClone.style.height = `${rect.height}px`;
                dragClone.style.left = `${clientX - offsetX}px`;
                dragClone.style.top = `${clientY - offsetY}px`;
                
                // 添加到文檔中
                document.body.appendChild(dragClone);
            } catch (error) {
                console.error("創建拖拽克隆體錯誤:", error);
            }
        }
        
        // 創建放置指示器
        function createDropIndicator(container, insertBefore) {
            try {
                // 先移除現有指示器
                removeDropIndicator();
                
                // 創建新指示器
                dropIndicator = document.createElement('div');
                dropIndicator.className = 'drop-indicator';
                
                // 添加到容器
                if (insertBefore) {
                    container.insertBefore(dropIndicator, insertBefore);
                } else {
                    container.appendChild(dropIndicator);
                }
            } catch (error) {
                console.warn("創建放置指示器錯誤:", error);
            }
        }
        
        // 移除放置指示器
        function removeDropIndicator() {
            try {
                const indicators = document.querySelectorAll('.drop-indicator');
                indicators.forEach(indicator => {
                    if (indicator && indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                });
                dropIndicator = null;
            } catch (error) {
                console.warn("移除放置指示器錯誤:", error);
            }
        }
        
        // 檢查點是否在矩形內
        function isWithinRect(x, y, rect) {
            return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
        }
        
        // 查找垂直插入位置
        function findInsertPositionVertical(container, y) {
            try {
                const cards = Array.from(container.querySelectorAll('.poem-card:not(.dragging)'));
                
                return cards.find(card => {
                    const rect = card.getBoundingClientRect();
                    return y < rect.top + rect.height / 2;
                });
            } catch (error) {
                console.warn("查找垂直插入位置錯誤:", error);
                return null;
            }
        }
        
        // 查找水平插入位置 (網格布局)
        function findInsertPositionHorizontal(container, x, y) {
            try {
                const cards = Array.from(container.querySelectorAll('.poem-card:not(.dragging)'));
                
                // 計算每個卡片的中心點並找出最接近的
                let closestCard = null;
                let minDistance = Infinity;
                
                cards.forEach(card => {
                    const rect = card.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const centerY = rect.top + rect.height / 2;
                    const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));
                    
                    if (distance < minDistance) {
                        minDistance = distance;
                        closestCard = card;
                    }
                });
                
                // 如果有找到最接近的卡片，則根據點擊位置決定是在之前還是之後插入
                if (closestCard) {
                    const rect = closestCard.getBoundingClientRect();
                    if (x > rect.left + rect.width / 2) {
                        // 點在卡片右側，在後面插入
                        return closestCard.nextElementSibling;
                    } else {
                        // 點在卡片左側，在前面插入
                        return closestCard;
                    }
                }
                
                return null;
            } catch (error) {
                console.warn("查找水平插入位置錯誤:", error);
                return null;
            }
        }
        
        // 检查排序
        function checkSequence() {
            try {
                if (!poemSequence) {
                    console.error("找不到排序区域元素");
                    return;
                }
                
                const currentSequence = Array.from(poemSequence.children)
                    .filter(child => child.classList.contains('poem-card'))  // 只選取詩句卡片，排除指示器
                    .map(card => card.getAttribute('data-id'));
                    
                const level = gameData.levels.find(level => level.id === gameData.currentLevel);
                
                if (!level) {
                    console.error("找不到当前关卡数据");
                    return;
                }
                
                // 检查是否所有诗句都已排序
                if (currentSequence.length !== level.pieces.length) {
                    showToast("請將所有詩句放入排序區域");
                    return;
                }
                
                // 检查顺序是否正确
                const isCorrect = level.correctOrder.every((id, index) => id === currentSequence[index]);
                
                if (isCorrect) {
                    // 显示成功提示
                    showToast("排序正確！解鎖知識點與心境探索");
                    
                    // 添加到已完成关卡
                    if (!gameData.completedLevels.includes(gameData.currentLevel)) {
                        gameData.completedLevels.push(gameData.currentLevel);
                    }
                    
                    // 更新关卡进度
                    const currentLevelId = gameData.currentLevel;
                    gameData.progress[currentLevelId] = 1; // 设置为已完成排序
                    
                    // 启用所有标签并更新标签状态
                    updateTabsAvailability(true);
                    
                    // 给完成的诗句添加动画效果
                    const poemCards = poemSequence.querySelectorAll('.poem-card');
                    poemCards.forEach((card, index) => {
                        if (card) {
                            setTimeout(() => {
                                card.classList.add('animate__animated');
                                card.classList.add('animate__pulse');
                            }, index * 200);
                        }
                    });
                    
                    // 确保知识点内容已加载
                    if (knowledgeContent && level.knowledge) {
                        knowledgeContent.innerHTML = level.knowledge;
                    }
                    
                    // 更新进度指示器
                    updateProgressIndicator(2);
                    
                    // 延迟切换到知识点标签
                    setTimeout(() => {
                        // 使用最可靠的方法切换标签
                        console.log("自动切换到知识点标签");
                        switchTab("knowledgeTab");
                        
                        // 检查是否成功切换
                        setTimeout(() => {
                            if (!knowledgeTab || !knowledgeTab.classList.contains('active')) {
                                console.log("知识点标签未正确激活，尝试直接设置样式");
                                
                                // 直接修改样式和类
                                if (knowledgeTab) {
                                    knowledgeTab.style.display = 'block';
                                    knowledgeTab.classList.add('active');
                                }
                                
                                // 修改按钮状态
                                tabButtons.forEach(btn => {
                                    if (!btn) return;
                                    const tabId = btn.getAttribute('data-tab');
                                    if (tabId === 'knowledgeTab') {
                                        btn.classList.add('active');
                                    }
                                });
                            }
                        }, 500);
                    }, 1000);
                } else {
                    showToast("排序有誤，請重新嘗試");
                    
                    // 给错误的排序添加震动动画
                    if (poemSequence) {
                        poemSequence.classList.add('animate__animated');
                        poemSequence.classList.add('animate__shakeX');
                        
                        setTimeout(() => {
                            poemSequence.classList.remove('animate__animated');
                            poemSequence.classList.remove('animate__shakeX');
                        }, 1000);
                    }
                }
            } catch (error) {
                console.error("检查排序错误:", error);
                showError(`检查排序错误: ${error.message}`);
            }
        }
        
        // 提交问答答案 - 完全重写的新版本
        function submitQuizAnswer() {
            try {
                console.log("===== 提交問答答案開始 =====");
                
                // 第一步：無條件強制隱藏下一關按鈕
                const hideNextLevelButton = function() {
                    console.log("強制隱藏所有下一關按鈕 (submitQuizAnswer開始)");
                    const allButtons = document.querySelectorAll('#next-level-button, .next-level-btn');
                    allButtons.forEach(btn => {
                        if (btn) {
                            btn.style.display = 'none';
                            btn.classList.add('hidden');
                        }
                    });
                };
                
                // 立即執行隱藏按鈕
                hideNextLevelButton();
                
                // 第二步：檢查是否選擇了選項
                const selectedOption = document.querySelector('.quiz-option.selected');
                if (!selectedOption) {
                    console.log("未選擇任何選項");
                    showToast("請選擇一個選項");
                    return;
                }
                
                // 第三步：獲取當前關卡數據
                const currentLevelId = Number(gameData.currentLevel);
                console.log(`當前關卡ID: ${currentLevelId}`);
                
                if (isNaN(currentLevelId)) {
                    console.error("當前關卡ID無效");
                    showError("關卡數據錯誤，請刷新頁面");
                    return;
                }
                
                const level = gameData.levels.find(level => level.id === currentLevelId);
                if (!level) {
                    console.error(`找不到關卡數據: ID=${currentLevelId}`);
                    showError("找不到關卡數據");
                    return;
                }
                
                // 第四步：檢查答案是否正確
                const selectedId = selectedOption.getAttribute('data-id');
                console.log(`選擇選項ID: ${selectedId}, 正確選項ID: ${level.quiz.correctId}`);
                const isCorrect = selectedId === level.quiz.correctId;
                
                // 第五步：顯示反饋信息
                if (quizFeedback) {
                    const feedbackHTML = `
                        <div class="p-3 rounded-md ${isCorrect ? 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-100' : 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-100'} animate__animated animate__fadeIn">
                            <p class="font-bold text-base mb-1">${isCorrect ? '✓ 正確！' : '✗ 不正確'}</p>
                            <p class="text-sm leading-relaxed">${level.quiz.explanation}</p>
                        </div>
                    `;
                    
                    quizFeedback.innerHTML = feedbackHTML;
                    quizFeedback.classList.remove('hidden');
                    
                    // 滾動到反饋區域
                    setTimeout(() => {
                        if (quizFeedback) {
                            quizFeedback.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                        }
                    }, 100);
                }
                
                // 第六步：處理回答錯誤的情況
                if (!isCorrect) {
                    console.log("答案不正確");
                    
                    // 給錯誤選項添加樣式
                    selectedOption.style.borderColor = '#FC8181';
                    selectedOption.style.backgroundColor = 'rgba(252, 129, 129, 0.1)';
                    
                    // 標記正確選項
                    const correctOption = document.querySelector(`.quiz-option[data-id="${level.quiz.correctId}"]`);
                    if (correctOption) {
                        correctOption.style.borderColor = '#68D391';
                        correctOption.style.backgroundColor = 'rgba(104, 211, 145, 0.1)';
                    }
                    
                    // 再次確保下一關按鈕隱藏
                    hideNextLevelButton();
                    
                    // 退出函數
                    return;
                }
                
                // 如果答案正確，繼續處理
                console.log("答案正確");
                
                // 第七步：給正確選項添加樣式
                selectedOption.style.borderColor = '#68D391';
                selectedOption.style.backgroundColor = 'rgba(104, 211, 145, 0.1)';
                
                // 第八步：更新關卡進度
                gameData.progress[currentLevelId] = 3; // 設置為已完成心境探索
                console.log(`更新進度: progress[${currentLevelId}] = 3`);
                
                // 第九步：處理最後一關和非最後一關的不同邏輯
                setTimeout(() => {
                    // 重新獲取當前關卡ID，以防在延遲期間有變化
                    const verifiedLevelId = Number(gameData.currentLevel);
                    console.log(`確認關卡ID: ${verifiedLevelId}`);
                    
                    if (verifiedLevelId === 4) { // 硬編碼判斷最後一關
                        console.log("這是最後一關，顯示恭喜窗口");
                        
                        // 確保下一關按鈕隱藏
                        hideNextLevelButton();
                        
                        // 顯示恭喜窗口
                        if (gameCompleteModal) {
                            setTimeout(() => {
                                gameCompleteModal.classList.remove('hidden');
                                console.log("顯示遊戲完成模態框");
                            }, 1500);
                        } else {
                            console.error("找不到遊戲完成模態框");
                        }
                    } else {
                        console.log("這不是最後一關，準備顯示下一關按鈕");
                        
                        // 使用專門的函數顯示下一關按鈕
                        setTimeout(() => {
                            createAndShowNextLevelButton(verifiedLevelId);
                        }, 200);
                    }
                }, 500);
                
                console.log("===== 提交問答答案結束 =====");
                
            } catch (error) {
                console.error("提交问答答案严重错误:", error);
                showError(`系统错误: ${error.message}`);
                
                // 出错时确保下一关按钮隐藏
                if (nextLevelButton) {
                    nextLevelButton.style.display = 'none';
                    nextLevelButton.classList.add('hidden');
                }
            }
        }
        
        // 创建并显示下一关按钮的专用函数
        function createAndShowNextLevelButton(currentLevelId) {
            try {
                console.log("===== 创建并显示下一关按钮 =====");
                // 获取当前关卡ID (再次验证)
                currentLevelId = Number(currentLevelId);
                if (isNaN(currentLevelId)) {
                    console.error("无效的关卡ID");
                    return;
                }
                
                console.log(`当前关卡ID: ${currentLevelId}`);
                
                // 硬编码验证是否最后一关
                if (currentLevelId === 4) {
                    console.log("这是最后一关，不显示按钮");
                    return;
                }
                
                // 获取下一关ID
                const nextLevelId = currentLevelId + 1;
                console.log(`下一关ID: ${nextLevelId}`);
                
                // 删除旧按钮，创建全新按钮
                const oldButton = document.getElementById('next-level-button');
                if (oldButton && oldButton.parentNode) {
                    console.log("移除旧按钮");
                    oldButton.parentNode.removeChild(oldButton);
                }
                
                // 获取按钮容器
                const buttonContainer = document.querySelector('.quiz-content > div:last-child');
                if (!buttonContainer) {
                    console.error("找不到按钮容器");
                    return;
                }
                
                // 创建全新按钮
                const newButton = document.createElement('button');
                newButton.id = 'next-level-button';
                newButton.className = 'btn-primary next-level-btn px-6 py-2 animate__animated animate__fadeIn';
                newButton.innerHTML = `
                    <span class="ancient-icon">
                        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" class="w-5 h-5">
                            <path d="M5 12h14"></path>
                            <path d="m12 5 7 7-7 7"></path>
                        </svg>
                    </span>進入第${nextLevelId}關
                `;
                
                // 直接添加点击事件
                newButton.addEventListener('click', function(e) {
                    e.preventDefault();
                    console.log(`点击下一关按钮，当前关卡: ${gameData.currentLevel}`);
                    
                    // 立即隐藏自己，防止多次点击
                    this.style.display = 'none';
                    
                    // 直接调用进入下一关
                    proceedToNextLevel();
                });
                
                // 添加按钮到容器
                buttonContainer.appendChild(newButton);
                
                // 确保按钮显示
                newButton.style.display = 'block';
                
                console.log("下一关按钮已创建并显示");
                
                // 检查是否成功显示
                setTimeout(() => {
                    const btn = document.getElementById('next-level-button');
                    if (btn && (btn.style.display !== 'block' || btn.classList.contains('hidden'))) {
                        console.warn("按钮未正确显示，强制显示");
                        btn.style.display = 'block';
                        btn.classList.remove('hidden');
                    }
                }, 100);
                
            } catch (error) {
                console.error("创建下一关按钮发生错误:", error);
            }
        }
        
        // 完全重寫 - 顯示"進入下一關"按鈕（修復關鍵問題）
        function showNextLevelButton() {
            try {
                // 記錄詳細調試信息
                console.log("==== 顯示下一關按鈕 - 詳細調試 ====");
                
                // 獲取當前關卡ID (確保是數字類型)
                const currentLevelId = Number(gameData.currentLevel);
                console.log(`當前關卡ID: ${currentLevelId}, 類型: ${typeof currentLevelId}`);
                
                // 硬編碼判斷是否為最後一關 (ID = 4)
                if (currentLevelId === 4) {
                    console.log("這是最後一關(ID=4)，不顯示下一關按鈕");
                    
                    // 獲取並隱藏所有可能的下一關按鈕
                    const allNextButtons = document.querySelectorAll('#next-level-button, .next-level-btn');
                    allNextButtons.forEach(btn => {
                        console.log("隱藏按鈕:", btn.id || "未知按鈕");
                        btn.style.display = 'none';
                        btn.classList.add('hidden');
                    });
                    
                    return; // 最後一關直接返回，不顯示按鈕
                }
                
                // 記錄非最終關的情況
                console.log(`這是第${currentLevelId}關，不是最後一關，將顯示下一關按鈕`);
                
                // 獲取下一關按鈕元素
                const nextBtn = document.getElementById('next-level-button');
                if (!nextBtn) {
                    console.error("致命錯誤：找不到下一關按鈕元素");
                    showError("系統錯誤：找不到下一關按鈕");
                    return;
                }
                
                // 徹底重置按鈕，移除所有現有事件監聽器
                const newBtn = nextBtn.cloneNode(true);
                if (nextBtn.parentNode) {
                    nextBtn.parentNode.replaceChild(newBtn, nextBtn);
                }
                
                // 使用新的按鈕引用
                const freshBtn = document.getElementById('next-level-button');
                if (!freshBtn) {
                    console.error("重置按鈕後找不到元素");
                    return;
                }
                
                // 設置按鈕樣式和內容
                freshBtn.style.display = 'block';
                freshBtn.classList.remove('hidden');
                freshBtn.innerHTML = '<span class="ancient-icon">➡️</span>進入下一關 (第' + (currentLevelId + 1) + '關)';
                
                // 添加動畫效果
                freshBtn.classList.add('animate__animated', 'animate__fadeIn', 'bounce-animation');
                
                // 直接綁定點擊事件 - 確保不使用箭頭函數避免this綁定問題
                freshBtn.onclick = function() {
                    console.log("下一關按鈕被點擊，當前關卡:", gameData.currentLevel);
                    
                    // 額外安全檢查
                    if (gameData.currentLevel !== currentLevelId) {
                        console.warn(`警告：點擊時關卡ID已變更 ${currentLevelId} -> ${gameData.currentLevel}`);
                    }
                    
                    // 調用進入下一關函數
                    proceedToNextLevel();
                };
                
                // 備份點擊事件到data屬性確保其保留
                freshBtn.setAttribute('data-next-level', currentLevelId + 1);
                
                // 記錄按鈕狀態以便調試
                console.log("按鈕顯示狀態:", freshBtn.style.display);
                console.log("下一關按鈕設置完成，將進入關卡ID:", currentLevelId + 1);
                
                // 最後檢查
                setTimeout(() => {
                    const checkBtn = document.getElementById('next-level-button');
                    if (checkBtn && checkBtn.style.display !== 'block') {
                        console.warn("警告：設置後按鈕未正確顯示，強制顯示");
                        checkBtn.style.display = 'block';
                    }
                }, 100);
                
            } catch (error) {
                console.error("顯示下一關按鈕時發生錯誤:", error);
                showError(`無法顯示下一關按鈕: ${error.message}`);
            }
        }
    </script>
</body>
</html>
