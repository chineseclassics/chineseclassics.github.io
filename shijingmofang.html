<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¯—å¢ƒé­”æ–¹ - Poetry Cube 3D</title>
    
    <!-- Three.js (ä½¿ç”¨å…¼å®¹ç‰ˆæœ¬) -->
    <script src="https://unpkg.com/three@0.128.0/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    
    <!-- GSAP åŠ¨ç”»åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
    
    <!-- Excel å¯¼å…¥å¯¼å‡º -->
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'KaiTi', 'æ¥·ä½“', serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        /* é¡¶éƒ¨æ  */
        .top-bar {
            background: rgba(255, 255, 255, 0.95);
            padding: 15px 30px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .top-bar h1 {
            font-size: 28px;
            color: #333;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .top-bar-buttons {
            display: flex;
            gap: 15px;
        }
        
        .icon-btn {
            background: white;
            border: 2px solid #ddd;
            width: 45px;
            height: 45px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .icon-btn:hover {
            transform: scale(1.1);
            border-color: #667eea;
        }
        
        /* ä¸»æ¸¸æˆåŒºåŸŸ */
        .game-container {
            max-width: 1200px;
            margin: 30px auto;
            padding: 0 20px;
        }
        
        /* é­”æ–¹å®¹å™¨ */
        #cube-container {
            width: 100%;
            max-width: 600px;
            height: 600px;
            margin: 0 auto 30px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        
        /* æç¤ºä¿¡æ¯ */
        .hint-area {
            text-align: center;
            margin-bottom: 20px;
        }
        
        .poem-hint {
            background: rgba(255, 255, 255, 0.95);
            display: inline-block;
            padding: 15px 30px;
            border-radius: 15px;
            font-size: 20px;
            font-weight: bold;
            color: #333;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        /* ç­”é¢˜åŒº */
        .answer-area {
            background: rgba(255, 255, 255, 0.95);
            padding: 30px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        
        .answer-boxes {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .answer-box {
            width: 70px;
            height: 70px;
            border: 3px solid #ddd;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            font-weight: bold;
            background: white;
            transition: all 0.3s;
        }
        
        .answer-box.filled {
            border-color: #667eea;
            background: #f0f4ff;
            color: #333;
        }
        
        /* æ§åˆ¶æŒ‰é’® */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            flex-wrap: wrap;
        }
        
        .btn {
            padding: 12px 30px;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
            font-family: 'KaiTi', 'æ¥·ä½“', serif;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .btn-secondary {
            background: white;
            color: #333;
            border: 2px solid #ddd;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        /* è¿›åº¦æ¡ */
        .progress-area {
            text-align: center;
            color: white;
            font-size: 18px;
            margin-top: 20px;
        }
        
        /* æ¨¡æ€æ¡† */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.7);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        
        .modal.active {
            display: flex;
        }
        
        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            width: 90%;
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-header h2 {
            font-size: 24px;
            color: #333;
        }
        
        .close-btn {
            background: none;
            border: none;
            font-size: 30px;
            cursor: pointer;
            color: #999;
        }
        
        .close-btn:hover {
            color: #333;
        }
        
        .setting-item {
            margin-bottom: 20px;
        }
        
        .setting-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #555;
        }
        
        .setting-item select,
        .setting-item input[type="range"] {
            width: 100%;
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 16px;
        }
        
        /* å®ŒæˆåŠ¨ç”» */
        .completion-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }
        
        .completion-overlay.active {
            display: flex;
        }
        
        .completion-card {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            animation: popIn 0.5s ease-out;
        }
        
        @keyframes popIn {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        .completion-card h2 {
            font-size: 36px;
            color: #667eea;
            margin-bottom: 20px;
        }
        
        .completion-card .poem-full {
            font-size: 24px;
            line-height: 1.8;
            margin: 20px 0;
            color: #333;
        }
        
        .completion-card .stars {
            font-size: 40px;
            margin: 20px 0;
        }
        
        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            #cube-container {
                height: 400px;
            }
            
            .answer-box {
                width: 50px;
                height: 50px;
                font-size: 28px;
            }
            
            .poem-hint {
                font-size: 16px;
                padding: 10px 20px;
            }
        }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading {
            text-align: center;
            padding: 50px;
            color: white;
            font-size: 20px;
        }
        
        .spinner {
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨æ  -->
    <div class="top-bar">
        <h1>ğŸ® è¯—å¢ƒé­”æ–¹</h1>
        <div class="top-bar-buttons">
            <button class="icon-btn" id="soundBtn" title="éŸ³æ•ˆ">ğŸ”Š</button>
            <button class="icon-btn" id="settingsBtn" title="è®¾ç½®">âš™ï¸</button>
        </div>
    </div>
    
    <!-- ä¸»æ¸¸æˆåŒºåŸŸ -->
    <div class="game-container">
        <!-- æç¤ºä¿¡æ¯ -->
        <div class="hint-area">
            <div class="poem-hint" id="poemHint">
                <span id="poemName">é™å¤œæ€</span> Â· 
                <span id="poemAuthor">æç™½</span> Â· 
                <span id="charCount">5å­—</span>
            </div>
        </div>
        
        <!-- 3D é­”æ–¹å®¹å™¨ -->
        <div id="cube-container">
            <div class="loading">
                <div class="spinner"></div>
                <p>æ­£åœ¨åŠ è½½é­”æ–¹...</p>
            </div>
        </div>
        
        <!-- ç­”é¢˜åŒº -->
        <div class="answer-area">
            <div class="answer-boxes" id="answerBoxes">
                <!-- åŠ¨æ€ç”Ÿæˆç­”é¢˜æ¡† -->
            </div>
            
            <div class="controls">
                <button class="btn btn-secondary" id="clearBtn">æ¸…ç©º</button>
                <button class="btn btn-primary" id="submitBtn">æäº¤ç­”æ¡ˆ</button>
                <button class="btn btn-secondary" id="skipBtn">è·³è¿‡</button>
            </div>
        </div>
        
        <!-- è¿›åº¦ä¿¡æ¯ -->
        <div class="progress-area">
            <p>å·²å®Œæˆ: <span id="completedCount">0</span> / <span id="totalCount">100</span> é¦– â­â­â­</p>
        </div>
    </div>
    
    <!-- è®¾ç½®æ¨¡æ€æ¡† -->
    <div class="modal" id="settingsModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>âš™ï¸ æ¸¸æˆè®¾ç½®</h2>
                <button class="close-btn" id="closeSettings">&times;</button>
            </div>
            
            <div class="setting-item">
                <label>ğŸ“š è¯—è¯åº“</label>
                <select id="poemLibrarySelect">
                    <option value="all">å…¨éƒ¨è¯—è¯</option>
                    <option value="å”è¯—">å”è¯—</option>
                    <option value="å®‹è¯">å®‹è¯</option>
                    <option value="å°å­¦ç”Ÿè¯—è¯">å°å­¦ç”Ÿè¯—è¯</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label>ğŸ’¡ æ™ºèƒ½æç¤º</label>
                <select id="hintLevel">
                    <option value="none">æ— æç¤ºï¼ˆâ­â­â­ï¼‰</option>
                    <option value="highlight">é«˜äº®æç¤ºï¼ˆâ­â­ï¼‰</option>
                    <option value="auto">è‡ªåŠ¨æ—‹è½¬ï¼ˆâ­ï¼‰</option>
                </select>
            </div>
            
            <div class="setting-item">
                <label>ğŸ”Š éŸ³æ•ˆéŸ³é‡</label>
                <input type="range" id="volumeSlider" min="0" max="100" value="70">
            </div>
            
            <div class="setting-item">
                <h4>ğŸ“Š æ•°æ®ç®¡ç†</h4>
                <button class="btn btn-secondary" id="exportExcel" style="width: 100%; margin-bottom: 10px;">ğŸ“¥ å¯¼å‡ºè¯—è¯åº“ï¼ˆExcelï¼‰</button>
                <button class="btn btn-secondary" id="importExcel" style="width: 100%; margin-bottom: 10px;">ğŸ“¤ å¯¼å…¥è¯—è¯åº“ï¼ˆExcelï¼‰</button>
                <input type="file" id="excelFile" accept=".xlsx,.xls" style="display: none;">
                <button class="btn btn-secondary" id="downloadTemplate" style="width: 100%;">ğŸ“„ ä¸‹è½½æ¨¡æ¿</button>
            </div>
            
            <div class="setting-item">
                <h4>ğŸ“ˆ æ¸¸æˆç»Ÿè®¡</h4>
                <p>æ€»å®Œæˆæ•°: <span id="totalCompleted">0</span></p>
                <p>æ€»ç”¨æ—¶: <span id="totalTime">0</span> åˆ†é’Ÿ</p>
                <button class="btn btn-secondary" id="resetProgress" style="width: 100%; margin-top: 10px;">ğŸ”„ é‡ç½®è¿›åº¦</button>
            </div>
        </div>
    </div>
    
    <!-- å®ŒæˆåŠ¨ç”»è¦†ç›–å±‚ -->
    <div class="completion-overlay" id="completionOverlay">
        <div class="completion-card">
            <h2>ğŸ‰ æ­å–œå®Œæˆï¼</h2>
            <div class="poem-full" id="poemFull"></div>
            <div class="stars" id="starsDisplay">â­â­â­</div>
            <p>ç”¨æ—¶: <span id="timeSpent">0</span> ç§’</p>
            <button class="btn btn-primary" id="nextRoundBtn" style="margin-top: 20px;">ä¸‹ä¸€é¦–</button>
        </div>
    </div>

    <script>
        // ==================== æ•°æ®åº“è®¾è®¡ ====================
        
        const STORAGE_KEYS = {
            userLibrary: 'cube3d_user_library',
            gameProgress: 'cube3d_game_progress',
            settings: 'cube3d_settings'
        };
        
        // å†…ç½®è¯—è¯åº“
        const BUILTIN_POEMS = [
            // æç™½
            { line: "åºŠå‰æ˜æœˆå…‰", author: "æç™½", poem: "é™å¤œæ€", tags: ["å”è¯—", "äº”è¨€ç»å¥", "æç™½"] },
            { line: "ç–‘æ˜¯åœ°ä¸Šéœœ", author: "æç™½", poem: "é™å¤œæ€", tags: ["å”è¯—", "äº”è¨€ç»å¥", "æç™½"] },
            { line: "ä¸¾å¤´æœ›æ˜æœˆ", author: "æç™½", poem: "é™å¤œæ€", tags: ["å”è¯—", "äº”è¨€ç»å¥", "æç™½"] },
            { line: "ä½å¤´æ€æ•…ä¹¡", author: "æç™½", poem: "é™å¤œæ€", tags: ["å”è¯—", "äº”è¨€ç»å¥", "æç™½"] },
            
            // ç‹ä¹‹æ¶£
            { line: "ç™½æ—¥ä¾å±±å°½", author: "ç‹ä¹‹æ¶£", poem: "ç™»é¹³é›€æ¥¼", tags: ["å”è¯—", "äº”è¨€ç»å¥", "ç‹ä¹‹æ¶£"] },
            { line: "é»„æ²³å…¥æµ·æµ", author: "ç‹ä¹‹æ¶£", poem: "ç™»é¹³é›€æ¥¼", tags: ["å”è¯—", "äº”è¨€ç»å¥", "ç‹ä¹‹æ¶£"] },
            { line: "æ¬²çª®åƒé‡Œç›®", author: "ç‹ä¹‹æ¶£", poem: "ç™»é¹³é›€æ¥¼", tags: ["å”è¯—", "äº”è¨€ç»å¥", "ç‹ä¹‹æ¶£"] },
            { line: "æ›´ä¸Šä¸€å±¤æ¨“", author: "ç‹ä¹‹æ¶£", poem: "ç™»é¹³é›€æ¥¼", tags: ["å”è¯—", "äº”è¨€ç»å¥", "ç‹ä¹‹æ¶£"] },
            
            // å­Ÿæµ©ç„¶
            { line: "æ˜¥çœ ä¸è§‰æ™“", author: "å­Ÿæµ©ç„¶", poem: "æ˜¥æ™“", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "å¤„å¤„é—»å•¼é¸Ÿ", author: "å­Ÿæµ©ç„¶", poem: "æ˜¥æ™“", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "å¤œæ¥é£é›¨å£°", author: "å­Ÿæµ©ç„¶", poem: "æ˜¥æ™“", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "èŠ±è½çŸ¥å¤šå°‘", author: "å­Ÿæµ©ç„¶", poem: "æ˜¥æ™“", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            
            // éª†å®¾ç‹
            { line: "é¹…é¹…é¹…", author: "éª†å®¾ç‹", poem: "å’é¹…", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "æ›²é¡¹å‘å¤©æ­Œ", author: "éª†å®¾ç‹", poem: "å’é¹…", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "ç™½æ¯›æµ®ç»¿æ°´", author: "éª†å®¾ç‹", poem: "å’é¹…", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "çº¢æŒæ‹¨æ¸…æ³¢", author: "éª†å®¾ç‹", poem: "å’é¹…", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            
            // æç»…
            { line: "é”„ç¦¾æ—¥å½“åˆ", author: "æç»…", poem: "æ‚¯å†œ", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "æ±—æ»´ç¦¾ä¸‹åœŸ", author: "æç»…", poem: "æ‚¯å†œ", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "è°çŸ¥ç›˜ä¸­é¤", author: "æç»…", poem: "æ‚¯å†œ", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] },
            { line: "ç²’ç²’çš†è¾›è‹¦", author: "æç»…", poem: "æ‚¯å†œ", tags: ["å”è¯—", "å°å­¦ç”Ÿè¯—è¯"] }
        ];
        
        // ä¸»é¢˜é…ç½®
        const CUBE_THEMES = {
            'å”è¯—': {
                primaryColor: '#F5E6D3',
                accentColor: '#8B4513',
                fontFamily: 'KaiTi, æ¥·ä½“',
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
            },
            'å®‹è¯': {
                primaryColor: '#E8F4F8',
                accentColor: '#2C5F2D',
                fontFamily: 'STSong, å®‹ä½“',
                background: 'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'
            },
            'å°å­¦ç”Ÿè¯—è¯': {
                primaryColor: '#FFE5E5',
                accentColor: '#FF69B4',
                fontFamily: 'KaiTi, æ¥·ä½“',
                background: 'linear-gradient(135deg, #ffecd2 0%, #fcb69f 100%)'
            },
            'default': {
                primaryColor: '#FFFFFF',
                accentColor: '#333333',
                fontFamily: 'KaiTi, æ¥·ä½“',
                background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
            }
        };
        
        // ==================== æ•°æ®ç®¡ç† ====================
        
        function loadUserLibrary() {
            const raw = localStorage.getItem(STORAGE_KEYS.userLibrary);
            try {
                const data = raw ? JSON.parse(raw) : { poems: [] };
                return Array.isArray(data.poems) ? data : { poems: [] };
            } catch (e) {
                return { poems: [] };
            }
        }
        
        function saveUserLibrary(data) {
            localStorage.setItem(STORAGE_KEYS.userLibrary, JSON.stringify(data));
        }
        
        function loadGameProgress() {
            const raw = localStorage.getItem(STORAGE_KEYS.gameProgress);
            try {
                return raw ? JSON.parse(raw) : { playedPoems: [], totalCompleted: 0, totalTime: 0 };
            } catch (e) {
                return { playedPoems: [], totalCompleted: 0, totalTime: 0 };
            }
        }
        
        function saveGameProgress(data) {
            localStorage.setItem(STORAGE_KEYS.gameProgress, JSON.stringify(data));
        }
        
        function getAllPoems() {
            const builtinPoems = BUILTIN_POEMS.map(p => ({
                ...p,
                tags: p.tags || ['å†…ç½®è¯—è¯åº“']
            }));
            const userPoems = loadUserLibrary().poems || [];
            return [...builtinPoems, ...userPoems];
        }
        
        function getPoemsByTag(tag) {
            const allPoems = getAllPoems();
            if (tag === 'all') return allPoems;
            return allPoems.filter(p => p.tags && p.tags.includes(tag));
        }
        
        function selectNextPoem(tag) {
            const pool = getPoemsByTag(tag);
            const progress = loadGameProgress();
            
            let unplayed = pool.filter(p => !progress.playedPoems.includes(p.line));
            
            if (unplayed.length === 0) {
                progress.playedPoems = [];
                saveGameProgress(progress);
                unplayed = pool;
            }
            
            return unplayed[Math.floor(Math.random() * unplayed.length)];
        }
        
        // Excel å¯¼å…¥å¯¼å‡º
        function exportAsExcel() {
            const poems = getAllPoems();
            const rows = poems.map(p => ({
                line: p.line,
                author: p.author,
                poem: p.poem,
                tags: (p.tags || []).join('ï¼›')
            }));
            
            const ws = XLSX.utils.json_to_sheet(rows);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'poems');
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'poetry-cube-export.xlsx';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }
        
        function importFromExcelFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const ws = workbook.Sheets[workbook.SheetNames[0]];
                    const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
                    
                    const poems = rows.map(r => ({
                        line: r.line || '',
                        author: r.author || '',
                        poem: r.poem || '',
                        tags: (r.tags || '').split(/[ï¼›;ï¼Œ,ã€]+/).filter(Boolean)
                    }));
                    
                    saveUserLibrary({ poems });
                    alert(`å·²å¯¼å…¥ ${poems.length} é¦–è¯—è¯`);
                } catch (e) {
                    alert('å¯¼å…¥å¤±è´¥ï¼š' + e.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function downloadTemplate() {
            const template = [
                { line: "åºŠå‰æ˜æœˆå…‰", author: "æç™½", poem: "é™å¤œæ€", tags: "å”è¯—ï¼›äº”è¨€ç»å¥" },
                { line: "ç¤ºä¾‹å¥å­2", author: "ä½œè€…å", poem: "è¯—å", tags: "æ ‡ç­¾1ï¼›æ ‡ç­¾2" }
            ];
            
            const ws = XLSX.utils.json_to_sheet(template);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'è¯—è¯æ¨¡æ¿');
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'cube3d-è¯—è¯æ¨¡æ¿.xlsx';
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
        }
        
        // ==================== 3D é­”æ–¹ç±» ====================
        
        class Cube3D {
            constructor(container) {
                this.container = container;
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                this.cubeGroup = new THREE.Group();
                this.pieces = [];
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                
                this.init();
            }
            
            init() {
                // æ¸…ç©ºå®¹å™¨
                this.container.innerHTML = '';
                
                // è®¾ç½®æ¸²æŸ“å™¨
                const width = this.container.offsetWidth;
                const height = this.container.offsetHeight;
                this.renderer.setSize(width, height);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.container.appendChild(this.renderer.domElement);
                
                // è®¾ç½®ç›¸æœº
                this.camera.aspect = width / height;
                this.camera.updateProjectionMatrix();
                this.camera.position.set(5, 5, 5);
                this.camera.lookAt(0, 0, 0);
                
                // æ·»åŠ å…‰æº
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.4);
                directionalLight.position.set(10, 10, 5);
                this.scene.add(directionalLight);
                
                // åˆ›å»ºé­”æ–¹
                this.createCube();
                
                // æ·»åŠ æ§åˆ¶å™¨
                this.setupControls();
                
                // æ·»åŠ ç‚¹å‡»äº‹ä»¶
                this.renderer.domElement.addEventListener('click', (e) => this.onMouseClick(e));
                
                // å¼€å§‹æ¸²æŸ“
                this.animate();
            }
            
            createCube() {
                const size = 0.9;
                const gap = 0.05;
                const colors = [0xFF6B6B, 0x4ECDC4, 0xFFE66D, 0xF0F0F0, 0x95E1D3, 0xF38181];
                
                // åˆ›å»º 3x3x3 é­”æ–¹
                for (let x = -1; x <= 1; x++) {
                    for (let y = -1; y <= 1; y++) {
                        for (let z = -1; z <= 1; z++) {
                            const geometry = new THREE.BoxGeometry(size, size, size);
                            const materials = [];
                            
                            for (let i = 0; i < 6; i++) {
                                const canvas = document.createElement('canvas');
                                canvas.width = 256;
                                canvas.height = 256;
                                const ctx = canvas.getContext('2d');
                                
                                ctx.fillStyle = '#' + colors[i].toString(16).padStart(6, '0');
                                ctx.fillRect(0, 0, 256, 256);
                                
                                ctx.strokeStyle = '#333';
                                ctx.lineWidth = 4;
                                ctx.strokeRect(0, 0, 256, 256);
                                
                                const texture = new THREE.CanvasTexture(canvas);
                                materials.push(new THREE.MeshPhongMaterial({ map: texture }));
                            }
                            
                            const piece = new THREE.Mesh(geometry, materials);
                            piece.position.set(x * (size + gap), y * (size + gap), z * (size + gap));
                            piece.userData = { x, y, z, chars: {} };
                            
                            this.pieces.push(piece);
                            this.cubeGroup.add(piece);
                        }
                    }
                }
                
                this.scene.add(this.cubeGroup);
            }
            
            drawTextOnFace(pieceIndex, faceIndex, text, theme) {
                const piece = this.pieces[pieceIndex];
                const material = piece.material[faceIndex];
                
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = theme.primaryColor;
                ctx.fillRect(0, 0, 256, 256);
                
                ctx.strokeStyle = '#333';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, 256, 256);
                
                ctx.font = `bold 120px ${theme.fontFamily}`;
                ctx.fillStyle = theme.accentColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(text, 128, 128);
                
                material.map = new THREE.CanvasTexture(canvas);
                material.needsUpdate = true;
                
                // è®°å½•å­—ç¬¦
                piece.userData.chars[faceIndex] = text;
            }
            
            setupControls() {
                this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.enableZoom = true;
                this.controls.minDistance = 3;
                this.controls.maxDistance = 10;
            }
            
            onMouseClick(event) {
                const rect = this.renderer.domElement.getBoundingClientRect();
                this.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                this.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                
                this.raycaster.setFromCamera(this.mouse, this.camera);
                const intersects = this.raycaster.intersectObjects(this.pieces);
                
                if (intersects.length > 0) {
                    const piece = intersects[0].object;
                    const faceIndex = Math.floor(intersects[0].faceIndex / 2);
                    const char = piece.userData.chars[faceIndex];
                    
                    if (char && window.game) {
                        window.game.onCharClick(char);
                    }
                }
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // ==================== æ¸¸æˆé€»è¾‘ ====================
        
        class PoetryGame {
            constructor() {
                this.currentPoem = null;
                this.selectedChars = [];
                this.startTime = null;
                this.mistakes = 0;
                this.currentTag = 'all';
                this.soundEnabled = true;
                
                this.initUI();
                this.startNewRound();
            }
            
            initUI() {
                // è®¾ç½®æŒ‰é’®
                document.getElementById('settingsBtn').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.add('active');
                });
                
                document.getElementById('closeSettings').addEventListener('click', () => {
                    document.getElementById('settingsModal').classList.remove('active');
                });
                
                // æ§åˆ¶æŒ‰é’®
                document.getElementById('clearBtn').addEventListener('click', () => this.clearAnswer());
                document.getElementById('submitBtn').addEventListener('click', () => this.checkAnswer());
                document.getElementById('skipBtn').addEventListener('click', () => this.startNewRound());
                document.getElementById('nextRoundBtn').addEventListener('click', () => {
                    document.getElementById('completionOverlay').classList.remove('active');
                    this.startNewRound();
                });
                
                // Excel å¯¼å…¥å¯¼å‡º
                document.getElementById('exportExcel').addEventListener('click', () => exportAsExcel());
                document.getElementById('importExcel').addEventListener('click', () => {
                    document.getElementById('excelFile').click();
                });
                document.getElementById('excelFile').addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        importFromExcelFile(e.target.files[0]);
                    }
                });
                document.getElementById('downloadTemplate').addEventListener('click', () => downloadTemplate());
                
                // è¯—è¯åº“é€‰æ‹©
                document.getElementById('poemLibrarySelect').addEventListener('change', (e) => {
                    this.currentTag = e.target.value;
                    this.startNewRound();
                });
                
                // éŸ³æ•ˆæŒ‰é’®
                document.getElementById('soundBtn').addEventListener('click', () => {
                    this.soundEnabled = !this.soundEnabled;
                    document.getElementById('soundBtn').textContent = this.soundEnabled ? 'ğŸ”Š' : 'ğŸ”‡';
                });
                
                // é‡ç½®è¿›åº¦
                document.getElementById('resetProgress').addEventListener('click', () => {
                    if (confirm('ç¡®å®šè¦é‡ç½®æ‰€æœ‰è¿›åº¦å—ï¼Ÿ')) {
                        saveGameProgress({ playedPoems: [], totalCompleted: 0, totalTime: 0 });
                        this.updateProgressDisplay();
                        alert('è¿›åº¦å·²é‡ç½®');
                    }
                });
                
                this.updateProgressDisplay();
            }
            
            startNewRound() {
                // é€‰æ‹©è¯—å¥
                this.currentPoem = selectNextPoem(this.currentTag);
                if (!this.currentPoem) {
                    alert('è¯¥è¯—è¯åº“æš‚æ— è¯—å¥');
                    return;
                }
                
                // é‡ç½®çŠ¶æ€
                this.selectedChars = [];
                this.startTime = Date.now();
                this.mistakes = 0;
                
                // æ›´æ–°æç¤º
                document.getElementById('poemName').textContent = this.currentPoem.poem;
                document.getElementById('poemAuthor').textContent = this.currentPoem.author;
                document.getElementById('charCount').textContent = this.currentPoem.line.length + 'å­—';
                
                // åˆ›å»ºç­”é¢˜æ¡†
                this.createAnswerBoxes();
                
                // åˆå§‹åŒ–é­”æ–¹
                if (!this.cube) {
                    this.cube = new Cube3D(document.getElementById('cube-container'));
                }
                
                // åˆ†é…å­—ç¬¦åˆ°é­”æ–¹
                this.assignCharacters();
            }
            
            createAnswerBoxes() {
                const container = document.getElementById('answerBoxes');
                container.innerHTML = '';
                
                for (let i = 0; i < this.currentPoem.line.length; i++) {
                    const box = document.createElement('div');
                    box.className = 'answer-box';
                    box.id = `answer-${i}`;
                    container.appendChild(box);
                }
            }
            
            assignCharacters() {
                const poemChars = this.currentPoem.line.split('');
                const distractorChars = this.generateDistractors(poemChars, 54 - poemChars.length);
                const allChars = [...poemChars, ...distractorChars];
                
                // æ‰“ä¹±
                for (let i = allChars.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [allChars[i], allChars[j]] = [allChars[j], allChars[i]];
                }
                
                // è·å–ä¸»é¢˜
                const theme = this.getTheme();
                
                // åˆ†é…åˆ°é­”æ–¹
                let charIndex = 0;
                this.cube.pieces.forEach((piece, pieceIndex) => {
                    const visibleFaces = this.getVisibleFaces(piece.userData);
                    
                    visibleFaces.forEach(faceIndex => {
                        if (charIndex < allChars.length) {
                            this.cube.drawTextOnFace(pieceIndex, faceIndex, allChars[charIndex], theme);
                            charIndex++;
                        }
                    });
                });
            }
            
            getVisibleFaces(position) {
                const { x, y, z } = position;
                const faces = [];
                
                if (x === 1) faces.push(0);
                if (x === -1) faces.push(1);
                if (y === 1) faces.push(2);
                if (y === -1) faces.push(3);
                if (z === 1) faces.push(4);
                if (z === -1) faces.push(5);
                
                return faces;
            }
            
            generateDistractors(poemChars, count) {
                const allPoems = getAllPoems();
                const allChars = allPoems
                    .map(p => p.line.split(''))
                    .flat()
                    .filter(c => !poemChars.includes(c));
                
                const unique = [...new Set(allChars)];
                
                for (let i = unique.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [unique[i], unique[j]] = [unique[j], unique[i]];
                }
                
                return unique.slice(0, count);
            }
            
            getTheme() {
                const tags = this.currentPoem.tags || [];
                for (const tag of tags) {
                    if (CUBE_THEMES[tag]) {
                        return CUBE_THEMES[tag];
                    }
                }
                return CUBE_THEMES['default'];
            }
            
            onCharClick(char) {
                if (this.selectedChars.length >= this.currentPoem.line.length) {
                    return;
                }
                
                this.playSound('click');
                
                this.selectedChars.push(char);
                this.updateAnswerDisplay();
                
                if (this.selectedChars.length === this.currentPoem.line.length) {
                    setTimeout(() => this.checkAnswer(), 500);
                }
            }
            
            updateAnswerDisplay() {
                this.selectedChars.forEach((char, index) => {
                    const box = document.getElementById(`answer-${index}`);
                    if (box) {
                        box.textContent = char;
                        box.classList.add('filled');
                    }
                });
            }
            
            clearAnswer() {
                this.selectedChars = [];
                for (let i = 0; i < this.currentPoem.line.length; i++) {
                    const box = document.getElementById(`answer-${i}`);
                    if (box) {
                        box.textContent = '';
                        box.classList.remove('filled');
                    }
                }
            }
            
            checkAnswer() {
                const answer = this.selectedChars.join('');
                const correct = answer === this.currentPoem.line;
                
                if (correct) {
                    this.onCorrect();
                } else {
                    this.onWrong();
                }
            }
            
            onCorrect() {
                this.playSound('success');
                
                const timeSpent = Math.floor((Date.now() - this.startTime) / 1000);
                const stars = this.calculateStars(timeSpent, this.mistakes);
                
                // ä¿å­˜è¿›åº¦
                const progress = loadGameProgress();
                progress.playedPoems.push(this.currentPoem.line);
                progress.totalCompleted++;
                progress.totalTime += timeSpent;
                saveGameProgress(progress);
                
                this.updateProgressDisplay();
                
                // æ˜¾ç¤ºå®Œæˆç•Œé¢
                this.showCompletion(timeSpent, stars);
            }
            
            onWrong() {
                this.playSound('wrong');
                this.mistakes++;
                
                // æŠ–åŠ¨åŠ¨ç”»
                const answerArea = document.querySelector('.answer-area');
                answerArea.style.animation = 'shake 0.5s';
                setTimeout(() => {
                    answerArea.style.animation = '';
                }, 500);
                
                alert('ç­”æ¡ˆä¸æ­£ç¡®ï¼Œè¯·é‡è¯•ï¼');
                this.clearAnswer();
            }
            
            calculateStars(timeSpent, mistakes) {
                if (mistakes === 0 && timeSpent < 30) return 3;
                if (mistakes <= 2 && timeSpent < 60) return 2;
                return 1;
            }
            
            showCompletion(timeSpent, stars) {
                document.getElementById('poemFull').textContent = this.currentPoem.line;
                document.getElementById('timeSpent').textContent = timeSpent;
                document.getElementById('starsDisplay').textContent = 'â­'.repeat(stars);
                document.getElementById('completionOverlay').classList.add('active');
            }
            
            updateProgressDisplay() {
                const progress = loadGameProgress();
                document.getElementById('completedCount').textContent = progress.totalCompleted;
                document.getElementById('totalCompleted').textContent = progress.totalCompleted;
                document.getElementById('totalTime').textContent = Math.floor(progress.totalTime / 60);
            }
            
            playSound(type) {
                if (!this.soundEnabled) return;
                
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                if (type === 'click') {
                    oscillator.frequency.value = 600;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.1);
                } else if (type === 'success') {
                    const notes = [523.25, 587.33, 659.25, 783.99];
                    notes.forEach((freq, i) => {
                        setTimeout(() => {
                            const osc = audioContext.createOscillator();
                            const gain = audioContext.createGain();
                            osc.connect(gain);
                            gain.connect(audioContext.destination);
                            osc.frequency.value = freq;
                            gain.gain.setValueAtTime(0.3, audioContext.currentTime);
                            gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                            osc.start(audioContext.currentTime);
                            osc.stop(audioContext.currentTime + 0.2);
                        }, i * 150);
                    });
                } else if (type === 'wrong') {
                    oscillator.frequency.value = 200;
                    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.2);
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + 0.2);
                }
            }
        }
        
        // ==================== å¯åŠ¨æ¸¸æˆ ====================
        
        window.addEventListener('load', () => {
            window.game = new PoetryGame();
        });
        
        // æ·»åŠ æŠ–åŠ¨åŠ¨ç”»
        const style = document.createElement('style');
        style.textContent = `
            @keyframes shake {
                0%, 100% { transform: translateX(0); }
                10%, 30%, 50%, 70%, 90% { transform: translateX(-10px); }
                20%, 40%, 60%, 80% { transform: translateX(10px); }
            }
        `;
        document.head.appendChild(style);
    </script>
</body>
</html>

