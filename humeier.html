<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>èƒ¡åªšå…’é­”ç“¶ - å”ä»£å‚³å¥‡äº’å‹•æ¼”ç¤º</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @font-face {
            font-family: 'GuJi';
            src: url('files/fonts/ååº·å¤ç±æœ¨å…°GBK.TTF');
        }

        body {
            font-family: 'GuJi', 'Microsoft YaHei', sans-serif;
            overflow: hidden;
            background: linear-gradient(135deg, #f5e6d3 0%, #e8d5c4 100%);
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: relative;
            cursor: default;
        }

        #canvas-container canvas {
            display: block;
        }

        /* æ ‡é¢˜ */
        .title {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 36px;
            color: #8b4513;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
            z-index: 100;
            pointer-events: none;
        }

        /* æ•…äº‹åŸæ–‡é¢æ¿ */
        .story-panel {
            position: absolute;
            left: 20px;
            top: 80px;
            width: 320px;
            max-height: 70vh;
            background: rgba(255, 248, 240, 0.95);
            border: 2px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 4px 4px 12px rgba(0,0,0,0.3);
            z-index: 10;
            pointer-events: auto;
        }

        .story-panel h3 {
            font-size: 24px;
            color: #8b4513;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #d4a574;
            padding-bottom: 10px;
        }

        .story-panel p {
            font-size: 16px;
            line-height: 1.8;
            color: #333;
            margin-bottom: 12px;
            text-indent: 2em;
        }

        .story-panel .highlight {
            background: linear-gradient(120deg, #ffd54f 0%, #ffb74d 100%);
            padding: 2px 4px;
            border-radius: 3px;
            font-weight: bold;
            transition: all 0.3s ease;
        }

        .story-panel .highlight.active {
            background: linear-gradient(120deg, #ff6b6b 0%, #ff8e53 100%);
            color: white;
            transform: scale(1.05);
        }

        /* æ§åˆ¶é¢æ¿ */
        .control-panel {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 280px;
            background: rgba(255, 248, 240, 0.95);
            border: 2px solid #8b4513;
            border-radius: 10px;
            padding: 20px;
            box-shadow: 4px 4px 12px rgba(0,0,0,0.3);
            z-index: 10;
            pointer-events: auto;
        }

        .control-panel h3 {
            font-size: 20px;
            color: #8b4513;
            margin-bottom: 15px;
            text-align: center;
            border-bottom: 2px solid #d4a574;
            padding-bottom: 10px;
        }

        .control-panel .instruction {
            font-size: 14px;
            line-height: 1.6;
            color: #555;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(255, 255, 255, 0.6);
            border-radius: 5px;
        }

        .control-panel button {
            width: 100%;
            padding: 12px;
            margin: 8px 0;
            font-size: 16px;
            font-family: 'GuJi', sans-serif;
            background: linear-gradient(135deg, #d4a574 0%, #b8945f 100%);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .control-panel button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }

        .control-panel button:active {
            transform: translateY(0);
        }

        /* æµ®åŠ¨æ–‡å­—æç¤º */
        .floating-text {
            position: absolute;
            font-size: 18px;
            color: #8b4513;
            pointer-events: none;
            z-index: 50;
            white-space: nowrap;
            text-shadow: 2px 2px 4px rgba(255,255,255,0.8);
            animation: floatUp 2s ease-out forwards;
            font-weight: bold;
        }

        @keyframes floatUp {
            0% {
                opacity: 0;
                transform: translateY(0);
            }
            20% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-50px);
            }
        }

        /* åŠ è½½æç¤º */
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #8b4513;
            z-index: 1000;
            text-align: center;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(139, 69, 19, 0.2);
            border-top-color: #8b4513;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ç‰©ä½“æ ‡ç­¾ */
        .object-label {
            position: absolute;
            background: rgba(139, 69, 19, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            z-index: 5;
        }

        /* çŠ¶æ€ä¿¡æ¯ */
        .status-info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(139, 69, 19, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .status-info.show {
            opacity: 1;
        }

        /* æ»šåŠ¨æ¡ç¾åŒ– */
        .story-panel::-webkit-scrollbar {
            width: 8px;
        }

        .story-panel::-webkit-scrollbar-track {
            background: rgba(212, 165, 116, 0.2);
            border-radius: 4px;
        }

        .story-panel::-webkit-scrollbar-thumb {
            background: #d4a574;
            border-radius: 4px;
        }

        .story-panel::-webkit-scrollbar-thumb:hover {
            background: #b8945f;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    
    <div class="title">èƒ¡åªšå…’é­”ç“¶</div>
    
    <div class="loading" id="loading">
        <div>è¼‰å…¥ä¸­...</div>
        <div class="loading-spinner"></div>
    </div>

    <div class="story-panel">
        <h3>èƒ¡åªšå…’å‚³å¥‡</h3>
        <p>å”è²å…ƒä¸­ï¼Œæ¥Šå·åŠå·¿é–“å¿½æœ‰ä¸€å¦“è¡“ä¸ä¹è€…ï¼Œä¸çŸ¥æ‰€å¾ä¾†ã€‚è‡ªç¨±å§“èƒ¡ï¼Œååªšå…’ï¼Œæ‰€ç‚ºé —ç”šæ€ªç•°ã€‚</p>
        <p>ä¸€æ—¦æ‡·ä¸­å‡ºä¸€ç‰ç’ƒç“¶å­ï¼Œå¯å—åŠå‡ï¼Œ<span class="highlight" data-key="transparent">è¡¨è£çƒ˜æ˜ï¼Œå¦‚ä¸éš”ç‰©</span>ã€‚é‚ç½®æ–¼å¸­ä¸Šï¼Œåˆè¬‚è§€è€…æ›°ï¼šã€Œæœ‰äººæ–½èˆ‡æ»¿æ­¤ç“¶å­ï¼Œå‰‡è¶³çŸ£ã€‚ã€<span class="highlight" data-key="bottlemouth">ç“¶å£å‰›å¦‚è‘¦ç®¡å¤§</span>ã€‚</p>
        <p>æœ‰äººèˆ‡ä¹‹ç™¾éŒ¢ï¼Œ<span class="highlight" data-key="coin">æŠ•ä¹‹ï¼Œç¤ç„¶æœ‰è²ï¼Œå‰‡è¦‹ç“¶é–“å¤§å¦‚ç²Ÿç²’</span>ã€‚è¡†çš†ç•°ä¹‹ã€‚å¾©æœ‰äººèˆ‡ä¹‹åƒéŒ¢ï¼ŒæŠ•ä¹‹å¦‚å‰ã€‚åˆæœ‰èˆ‡è¬éŒ¢è€…ï¼Œäº¦å¦‚ä¹‹ã€‚</p>
        <p>ä¿„æœ‰å¥½äº‹äººï¼Œèˆ‡ä¹‹åè¬äºŒåè¬ï¼Œçš†å¦‚ä¹‹ã€‚æˆ–æœ‰<span class="highlight" data-key="horse">ä»¥é¦¬é©¢å…¥ä¹‹ç“¶ä¸­ï¼Œè¦‹äººé¦¬çš†å¦‚è …å¤§ï¼Œå‹•è¡Œå¦‚æ•…</span>ã€‚</p>
        <p>é ˆè‡¾ï¼Œæœ‰åº¦æ”¯å…©ç¨…ç¶±ï¼Œè‡ªæšå­é™¢éƒ¨è¼•è²¨æ•¸åè»Šè‡³ã€‚é§è§€ä¹‹ï¼Œä»¥å…¶ä¸€æ™‚å…¥ï¼Œæˆ–çµ‚ä¸èƒ½è‡´å°‡ä»–ç‰©å¾€ï¼Œä¸”è¬‚å®˜ç‰©ä¸è¶³ç–‘è€…ã€‚ä¹ƒè¬‚åªšå…’æ›°ï¼šã€Œçˆ¾èƒ½ä»¤è«¸è»Šçš†å…¥æ­¤ä¸­ä¹ï¼Ÿã€åªšå…’æ›°ï¼šã€Œè¨±ä¹‹å‰‡å¯ã€‚ã€ç¶±æ›°ï¼šã€Œä¸”è©¦ä¹‹ã€‚ã€</p>
        <p>åªšå…’ä¹ƒå¾®å´ç“¶å£ï¼Œå¤§å–ï¼Œ<span class="highlight" data-key="cart">è«¸è»Šè¼…è¼…ç›¸ç¹¼ï¼Œæ‚‰å…¥ç“¶ï¼Œç“¶ä¸­æ­·æ­·å¦‚è¡ŒèŸ»ç„¶</span>ã€‚æœ‰é ƒï¼Œæ¼¸ä¸è¦‹ï¼Œåªšå…’å³è·³èº«å…¥ç“¶ä¸­ã€‚</p>
        <p><span class="highlight" data-key="break">ç¶±ä¹ƒå¤§é©šï¼Œé½å–æ’²ç ´ï¼Œæ±‚ä¹‹ä¸€ç„¡æ‰€æœ‰</span>ï¼Œå¾æ­¤å¤±åªšå…’æ‰€åœ¨ã€‚</p>
        <p>å¾Œæœˆé¤˜æ—¥ï¼Œæœ‰äººæ–¼æ¸…æ²³åŒ—é€¢åªšå…’ï¼Œéƒ¨é ˜è»Šä¹˜ï¼Œè¶¨æ±å¹³è€Œå»ã€‚æ˜¯æ™‚æå¸«é“ç‚ºæ±å¹³å¸¥ä¹Ÿã€‚</p>
    </div>

    <div class="control-panel">
        <h3>æ“ä½œèªªæ˜</h3>
        <div class="instruction" style="background: rgba(255,230,100,0.5); font-weight: bold; font-size: 15px;">
            ğŸ‘† <strong>å·¦éµ</strong>é»æ“Šä¸¦æ‹–å‹•ç‰©é«”åˆ°ç“¶å£
        </div>
        <div class="instruction" style="font-size: 14px;">
            ğŸ”„ <strong>å³éµæŒ‰ä½ä¸¦æ‹–å‹•</strong>æ—‹è½‰è¦–è§’
        </div>
        <div class="instruction" style="font-size: 14px;">
            ğŸ” <strong>æ»¾è¼ª</strong>ç¸®æ”¾è¦–è§’
        </div>
        <div class="instruction" id="debug-info" style="background: rgba(150,220,255,0.3); font-size: 12px; padding: 6px;">
            ç­‰å¾…æ“ä½œ...
        </div>
        <button id="btn-reset">é‡æ–°é–‹å§‹</button>
        <button id="btn-empty">å€’å‡ºç‰©å“</button>
        <button id="btn-break">æ‰“ç ´ç“¶å­</button>
        <button id="btn-view-inside">è§€å¯Ÿç“¶å…§</button>
    </div>

    <div class="status-info" id="status-info"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.11.4/gsap.min.js"></script>

    <script>
        // ========== å…¨å±€å˜é‡ ==========
        let scene, camera, renderer, controls;
        let bottle, bottleNeck;
        let draggableObjects = [];
        let objectsInBottle = [];
        let raycaster, mouse;
        let selectedObject = null;
        let dragPlane;
        let isBroken = false;

        // åœºæ™¯å¸¸é‡
        const BOTTLE_HEIGHT = 4;
        const BOTTLE_RADIUS = 1;
        const BOTTLE_NECK_HEIGHT = 1.5;
        const BOTTLE_NECK_RADIUS = 0.15;
        const BOTTLE_MOUTH_Y = BOTTLE_HEIGHT / 2 + BOTTLE_NECK_HEIGHT;
        
        // éŸ³æ•ˆå¸¸é‡
        const SOUND_ENABLED = true;

        // ========== åˆå§‹åŒ– ==========
        function init() {
            console.log('é–‹å§‹åˆå§‹åŒ–...');
            console.log('THREE.js ç‰ˆæœ¬:', THREE.REVISION);
            
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf5e6d3);
            scene.fog = new THREE.Fog(0xf5e6d3, 20, 50);
            console.log('å ´æ™¯å·²å‰µå»º');

            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(
                50,
                window.innerWidth / window.innerHeight,
                0.1,
                1000
            );
            camera.position.set(8, 6, 8);
            camera.lookAt(0, 2, 0);
            console.log('ç›¸æ©Ÿå·²è¨­ç½®ï¼Œä½ç½®:', camera.position);

            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('canvas-container').appendChild(renderer.domElement);
            console.log('æ¸²æŸ“å™¨å·²å‰µå»º');

            // æ§åˆ¶å™¨ - æš‚æ—¶ç¦ç”¨ï¼Œç¨åæ‰‹åŠ¨å¯ç”¨
            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.minDistance = 3;
            controls.maxDistance = 20;
            controls.maxPolarAngle = Math.PI / 1.8;
            controls.enabled = false;  // åˆå§‹ç¦ç”¨ï¼Œç”±æˆ‘ä»¬çš„ä»£ç æ§åˆ¶
            
            console.log('æ§åˆ¶å™¨å·²å‰µå»ºï¼ˆåˆå§‹ç¦ç”¨ï¼‰');

            // å…‰æº
            setupLights();
            console.log('å…‰æºå·²æ·»åŠ ');

            // åˆ›å»ºç‰ç’ƒç“¶
            createBottle();
            console.log('ç“¶å­å‰µå»ºå®Œæˆ');

            // åˆ›å»ºåœ°é¢
            createGround();
            console.log('åœ°é¢å‰µå»ºå®Œæˆ');

            // æ·»åŠ åæ ‡è½´è¾…åŠ©å™¨ï¼ˆçº¢è‰²Xè½´ï¼Œç»¿è‰²Yè½´ï¼Œè“è‰²Zè½´ï¼‰
            const axesHelper = new THREE.AxesHelper(5);
            scene.add(axesHelper);
            console.log('åæ¨™è»¸å·²æ·»åŠ ');

            // æ·»åŠ æµ‹è¯•ç«‹æ–¹ä½“ï¼ˆç¡®ä¿åœºæ™¯æ¸²æŸ“æ­£å¸¸ï¼‰
            const testGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            const testMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 });
            const testCube = new THREE.Mesh(testGeometry, testMaterial);
            testCube.position.set(2, 0.25, 0);
            scene.add(testCube);
            console.log('æ¸¬è©¦ç«‹æ–¹é«”å·²æ·»åŠ ï¼ˆç´…è‰²ï¼‰');

            // åˆ›å»ºå¯æ‹–åŠ¨ç‰©ä½“
            createDraggableObjects();
            console.log('å¯æ‹–å‹•ç‰©é«”æ•¸é‡:', draggableObjects.length);

            // å°„çº¿æ£€æµ‹
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();
            dragPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

            // äº‹ä»¶ç›‘å¬
            setupEventListeners();
            console.log('äº‹ä»¶ç›£è½å·²è¨­ç½®');

            // éšè—åŠ è½½æç¤º
            document.getElementById('loading').style.display = 'none';

            // å¼€å§‹åŠ¨ç”»
            animate();
            console.log('å‹•ç•«é–‹å§‹');

            // æ˜¾ç¤ºæ¬¢è¿ä¿¡æ¯
            showStatus('æ­¡è¿ï¼æ‹–å‹•ç‰©é«”åˆ°ç“¶å£ï¼Œè§€å¯Ÿç¥å¥‡çš„ç¸®å°æ•ˆæœ');
            
            console.log('å ´æ™¯ç‰©é«”æ•¸é‡:', scene.children.length);
            console.log('ğŸ‰ åˆå§‹åŒ–å®Œæˆï¼');
            console.log('ğŸ–±ï¸ äº‹ä»¶ç›£è½å™¨å·²ç¶å®šåˆ°:', renderer.domElement);
            console.log('ğŸ“¦ draggableObjects åŒ…å«:', draggableObjects.map(obj => obj.userData.name));
            
            // æµ‹è¯•ï¼šæ˜¾ç¤ºæ‰€æœ‰å¯æ‹–åŠ¨ç‰©ä½“çš„è¾¹ç•Œæ¡†
            draggableObjects.forEach(obj => {
                const box = new THREE.BoxHelper(obj, 0xff0000);
                scene.add(box);
            });
            console.log('ğŸ”² ç´…è‰²é‚Šç•Œæ¡†å·²æ·»åŠ ï¼Œå¹«åŠ©è­˜åˆ¥å¯æ‹–å‹•ç‰©é«”');
        }

        // ========== å…‰æºè®¾ç½® ==========
        function setupLights() {
            // ç¯å¢ƒå…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            // ä¸»å…‰æº
            const mainLight = new THREE.DirectionalLight(0xfff5e1, 0.8);
            mainLight.position.set(5, 10, 5);
            mainLight.castShadow = true;
            mainLight.shadow.camera.left = -10;
            mainLight.shadow.camera.right = 10;
            mainLight.shadow.camera.top = 10;
            mainLight.shadow.camera.bottom = -10;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            // è¡¥å…‰
            const fillLight = new THREE.DirectionalLight(0xffd4a3, 0.3);
            fillLight.position.set(-5, 5, -5);
            scene.add(fillLight);

            // ç‚¹å…‰æºå¢å¼ºç“¶å­é€æ˜æ„Ÿ
            const bottleLight = new THREE.PointLight(0xffffff, 0.5);
            bottleLight.position.set(0, BOTTLE_MOUTH_Y, 0);
            scene.add(bottleLight);
        }

        // ========== åˆ›å»ºç‰ç’ƒç“¶ ==========
        function createBottle() {
            const bottleGroup = new THREE.Group();

            // æ›´æ˜æ˜¾çš„ç“¶å­æè´¨ï¼ˆé€æ˜ç»ç’ƒæ•ˆæœï¼‰
            const bottleMaterial = new THREE.MeshStandardMaterial({
                color: 0x88ccff,
                transparent: true,
                opacity: 0.3,
                roughness: 0.1,
                metalness: 0.1,
                side: THREE.DoubleSide
            });

            // ç“¶èº«ï¼ˆä½¿ç”¨çƒä½“å’Œåœ†æŸ±ç»„åˆï¼‰
            const bodyGeometry = new THREE.SphereGeometry(BOTTLE_RADIUS, 32, 32, 0, Math.PI * 2, 0, Math.PI / 1.3);
            bottle = new THREE.Mesh(bodyGeometry, bottleMaterial);
            bottle.position.y = BOTTLE_HEIGHT / 2;
            bottle.castShadow = true;
            bottle.receiveShadow = true;
            bottleGroup.add(bottle);

            // ç“¶é¢ˆ
            const neckGeometry = new THREE.CylinderGeometry(
                BOTTLE_NECK_RADIUS,
                BOTTLE_RADIUS * 0.4,
                BOTTLE_NECK_HEIGHT,
                32
            );
            bottleNeck = new THREE.Mesh(neckGeometry, bottleMaterial);
            bottleNeck.position.y = BOTTLE_HEIGHT / 2 + BOTTLE_NECK_HEIGHT / 2;
            bottleNeck.castShadow = true;
            bottleGroup.add(bottleNeck);

            // ç“¶å£è¾¹ç¼˜ï¼ˆæ›´æ˜æ˜¾ï¼‰
            const mouthGeometry = new THREE.TorusGeometry(BOTTLE_NECK_RADIUS, 0.03, 16, 32);
            const edgeMaterial = new THREE.MeshStandardMaterial({
                color: 0x6699cc,
                transparent: true,
                opacity: 0.6,
                roughness: 0.3,
                metalness: 0.3
            });
            const mouthEdge = new THREE.Mesh(mouthGeometry, edgeMaterial);
            mouthEdge.position.y = BOTTLE_MOUTH_Y;
            mouthEdge.rotation.x = Math.PI / 2;
            bottleGroup.add(mouthEdge);

            // æ·»åŠ è½®å»“çº¿å¸®åŠ©å¯è§æ€§
            const outlineMaterial = new THREE.MeshBasicMaterial({
                color: 0x4488aa,
                transparent: true,
                opacity: 0.4,
                side: THREE.BackSide
            });

            const bodyOutline = new THREE.Mesh(bodyGeometry, outlineMaterial);
            bodyOutline.position.y = BOTTLE_HEIGHT / 2;
            bodyOutline.scale.multiplyScalar(1.02);
            bottleGroup.add(bodyOutline);

            const neckOutline = new THREE.Mesh(neckGeometry, outlineMaterial);
            neckOutline.position.y = BOTTLE_HEIGHT / 2 + BOTTLE_NECK_HEIGHT / 2;
            neckOutline.scale.multiplyScalar(1.03);
            bottleGroup.add(neckOutline);

            // æ·»åŠ å†…éƒ¨å…‰æ™•æ•ˆæœ
            const glowGeometry = new THREE.SphereGeometry(BOTTLE_RADIUS * 0.8, 32, 32);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xccffff,
                transparent: true,
                opacity: 0.15,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            glow.position.y = BOTTLE_HEIGHT / 2;
            bottleGroup.add(glow);

            console.log('ç“¶å­å·²åˆ›å»º', bottleGroup);
            scene.add(bottleGroup);
            bottleGroup.userData.isBottle = true;
            
            return bottleGroup;
        }

        // ========== åˆ›å»ºåœ°é¢ ==========
        function createGround() {
            const groundGeometry = new THREE.PlaneGeometry(30, 30);
            const groundMaterial = new THREE.MeshStandardMaterial({
                color: 0xe8d5c4,
                roughness: 0.8,
                metalness: 0.2
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = 0;
            ground.receiveShadow = true;
            scene.add(ground);

            // æ·»åŠ ç½‘æ ¼è¾…åŠ©çº¿
            const gridHelper = new THREE.GridHelper(30, 30, 0xd4a574, 0xd4a574);
            gridHelper.material.opacity = 0.2;
            gridHelper.material.transparent = true;
            scene.add(gridHelper);
        }

        // ========== åˆ›å»ºå¯æ‹–åŠ¨ç‰©ä½“ ==========
        function createDraggableObjects() {
            console.log('ğŸ“¦ é–‹å§‹å‰µå»ºå¯æ‹–å‹•ç‰©é«”...');
            
            // 1. é“œé’±
            for (let i = 0; i < 3; i++) {
                const coin = createCoin();
                coin.position.set(-4 + i * 2, 0.1, 4);
                coin.userData.type = 'coin';
                coin.userData.name = `éŠ…éŒ¢${i + 1}`;
                coin.userData.highlightKey = 'coin';
                coin.userData.text = 'æŠ•ä¹‹ï¼Œç¤ç„¶æœ‰è²ï¼Œå‰‡è¦‹ç“¶é–“å¤§å¦‚ç²Ÿç²’';
                draggableObjects.push(coin);
                scene.add(coin);
                console.log(`  âœ… å‰µå»ºéŠ…éŒ¢${i + 1}ï¼Œä½ç½®:`, coin.position);
            }

            // 2. é©¬
            const horse = createHorse();
            horse.position.set(4, 0.5, 3);
            horse.userData.type = 'horse';
            horse.userData.name = 'é¦¬';
            horse.userData.highlightKey = 'horse';
            horse.userData.text = 'è¦‹äººé¦¬çš†å¦‚è …å¤§ï¼Œå‹•è¡Œå¦‚æ•…';
            draggableObjects.push(horse);
            scene.add(horse);
            console.log('  âœ… å‰µå»ºé¦¬ï¼Œä½ç½®:', horse.position);

            // 3. ç‰›è½¦
            const cart = createCart();
            cart.position.set(-4, 0.5, -2);
            cart.userData.type = 'cart';
            cart.userData.name = 'ç‰›è»Š1';
            cart.userData.highlightKey = 'cart';
            cart.userData.text = 'è«¸è»Šè¼…è¼…ç›¸ç¹¼ï¼Œæ‚‰å…¥ç“¶ï¼Œç“¶ä¸­æ­·æ­·å¦‚è¡ŒèŸ»ç„¶';
            draggableObjects.push(cart);
            scene.add(cart);
            console.log('  âœ… å‰µå»ºç‰›è»Š1ï¼Œä½ç½®:', cart.position);

            // 4. å¦ä¸€è¾†è½¦
            const cart2 = createCart();
            cart2.position.set(-2, 0.5, -2);
            cart2.userData.type = 'cart';
            cart2.userData.name = 'ç‰›è»Š2';
            cart2.userData.highlightKey = 'cart';
            cart2.userData.text = 'è«¸è»Šè¼…è¼…ç›¸ç¹¼ï¼Œæ‚‰å…¥ç“¶';
            draggableObjects.push(cart2);
            scene.add(cart2);
            console.log('  âœ… å‰µå»ºç‰›è»Š2ï¼Œä½ç½®:', cart2.position);
            
            console.log(`ğŸ“¦ å‰µå»ºå®Œæˆï¼å…± ${draggableObjects.length} å€‹å¯æ‹–å‹•ç‰©é«”`);
        }

        // ========== åˆ›å»ºé“œé’± ==========
        function createCoin() {
            const group = new THREE.Group();
            
            // å¤–åœ†
            const outerGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.05, 32);
            const coinMaterial = new THREE.MeshStandardMaterial({
                color: 0xcd7f32,
                metalness: 0.8,
                roughness: 0.3
            });
            const outer = new THREE.Mesh(outerGeometry, coinMaterial);
            outer.rotation.x = Math.PI / 2;
            outer.castShadow = true;
            group.add(outer);

            // å†…æ–¹å­”
            const holeGeometry = new THREE.BoxGeometry(0.08, 0.08, 0.06);
            const holeMaterial = new THREE.MeshStandardMaterial({
                color: 0x000000,
                transparent: true,
                opacity: 0.9
            });
            const hole = new THREE.Mesh(holeGeometry, holeMaterial);
            group.add(hole);

            group.userData.originalScale = 1;
            group.userData.inBottle = false;
            
            return group;
        }

        // ========== åˆ›å»ºé©¬ ==========
        function createHorse() {
            const group = new THREE.Group();
            const horseMaterial = new THREE.MeshStandardMaterial({
                color: 0x8b4513,
                roughness: 0.7
            });

            // èº«ä½“
            const bodyGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.4);
            const body = new THREE.Mesh(bodyGeometry, horseMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // å¤´
            const headGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.3);
            const head = new THREE.Mesh(headGeometry, horseMaterial);
            head.position.set(0.5, 0.7, 0);
            head.castShadow = true;
            group.add(head);

            // è…¿
            const legGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
            const positions = [
                [0.3, 0.25, 0.15],
                [0.3, 0.25, -0.15],
                [-0.3, 0.25, 0.15],
                [-0.3, 0.25, -0.15]
            ];
            positions.forEach(pos => {
                const leg = new THREE.Mesh(legGeometry, horseMaterial);
                leg.position.set(...pos);
                leg.castShadow = true;
                group.add(leg);
            });

            group.userData.originalScale = 1;
            group.userData.inBottle = false;
            group.userData.animate = true;

            return group;
        }

        // ========== åˆ›å»ºç‰›è½¦ ==========
        function createCart() {
            const group = new THREE.Group();
            const cartMaterial = new THREE.MeshStandardMaterial({
                color: 0x654321,
                roughness: 0.8
            });

            // è½¦å¢
            const bodyGeometry = new THREE.BoxGeometry(0.8, 0.5, 0.6);
            const body = new THREE.Mesh(bodyGeometry, cartMaterial);
            body.position.y = 0.5;
            body.castShadow = true;
            group.add(body);

            // è½¦è½®
            const wheelGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.1, 16);
            const wheelMaterial = new THREE.MeshStandardMaterial({
                color: 0x3d2817,
                roughness: 0.9
            });
            
            const wheel1 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel1.rotation.z = Math.PI / 2;
            wheel1.position.set(0.3, 0.2, 0.35);
            wheel1.castShadow = true;
            group.add(wheel1);

            const wheel2 = new THREE.Mesh(wheelGeometry, wheelMaterial);
            wheel2.rotation.z = Math.PI / 2;
            wheel2.position.set(0.3, 0.2, -0.35);
            wheel2.castShadow = true;
            group.add(wheel2);

            const wheel3 = wheel1.clone();
            wheel3.position.set(-0.3, 0.2, 0.35);
            group.add(wheel3);

            const wheel4 = wheel2.clone();
            wheel4.position.set(-0.3, 0.2, -0.35);
            group.add(wheel4);

            group.userData.originalScale = 1;
            group.userData.inBottle = false;
            group.userData.wheels = [wheel1, wheel2, wheel3, wheel4];

            return group;
        }

        // ========== äº‹ä»¶ç›‘å¬ ==========
        function setupEventListeners() {
            // é¼ æ ‡äº‹ä»¶
            renderer.domElement.addEventListener('mousedown', onMouseDown, false);
            renderer.domElement.addEventListener('mousemove', onMouseMove, false);
            renderer.domElement.addEventListener('mouseup', onMouseUp, false);
            renderer.domElement.addEventListener('contextmenu', (e) => e.preventDefault(), false);  // ç¦ç”¨å³é”®èœå•
            
            console.log('âœ… äº‹ä»¶ç›£è½å™¨å·²ç¶å®š');

            // çª—å£è°ƒæ•´
            window.addEventListener('resize', onWindowResize, false);

            // æŒ‰é’®äº‹ä»¶
            document.getElementById('btn-reset').addEventListener('click', resetScene);
            document.getElementById('btn-empty').addEventListener('click', emptyBottle);
            document.getElementById('btn-break').addEventListener('click', breakBottle);
            document.getElementById('btn-view-inside').addEventListener('click', viewInside);
        }

        // ========== é¼ æ ‡æŒ‰ä¸‹ ==========
        function onMouseDown(event) {
            console.log('ğŸ–±ï¸ é¼ æ¨™æŒ‰ä¸‹ï¼æŒ‰éµ:', event.button, '(0=å·¦ï¼Œ1=ä¸­ï¼Œ2=å³)');
            
            // å³é”®ï¼šå¯ç”¨ç›¸æœºæ§åˆ¶
            if (event.button === 2) {
                console.log('ğŸ”„ å³éµæŒ‰ä¸‹ï¼Œå•Ÿç”¨ç›¸æ©Ÿæ—‹è½‰');
                controls.enabled = true;
                return;
            }
            
            // å·¦é”®ï¼šæ‹–åŠ¨ç‰©ä½“
            if (event.button === 0) {
                console.log('ğŸ‘† å·¦éµæŒ‰ä¸‹ï¼Œæº–å‚™æ‹–å‹•ç‰©é«”');
                
                if (isBroken) {
                    console.log('âš ï¸ ç“¶å­å·²ç ´ç¢ï¼Œç„¡æ³•æ“ä½œ');
                    return;
                }
                
                // ç¦ç”¨ç›¸æœºæ§åˆ¶
                controls.enabled = false;
                
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
                console.log('ğŸ–±ï¸ é¼ æ¨™ä½ç½®:', mouse.x.toFixed(2), mouse.y.toFixed(2));

                raycaster.setFromCamera(mouse, camera);
                
                // æ”¶é›†æ‰€æœ‰å¯æ‹–åŠ¨ç‰©ä½“çš„å­ç½‘æ ¼
                let allMeshes = [];
                draggableObjects.forEach(obj => {
                    obj.traverse(child => {
                        if (child.isMesh) {
                            allMeshes.push(child);
                        }
                    });
                });
                
                console.log('ğŸ“¦ å¯æ‹–å‹•ç‰©é«”æ•¸é‡:', draggableObjects.length);
                console.log('ğŸ”· ç¸½ç¶²æ ¼æ•¸é‡:', allMeshes.length);
                
                const intersects = raycaster.intersectObjects(allMeshes, false);
                console.log('âœ¨ é»æ“Šæª¢æ¸¬:', intersects.length, 'å€‹äº¤é»');
                
                if (intersects.length > 0) {
                    console.log('ğŸ“ äº¤é»ä½ç½®:', intersects[0].point);
                    console.log('ğŸ¯ äº¤é»ç‰©é«”:', intersects[0].object);
                }
                
                const debugInfo = document.getElementById('debug-info');
                debugInfo.textContent = `æª¢æ¸¬åˆ° ${intersects.length} å€‹äº¤é»ï¼Œç¶²æ ¼: ${allMeshes.length}ï¼Œç‰©é«”: ${draggableObjects.length}`;

                if (intersects.length > 0) {
                    // æ‰¾åˆ°é¡¶å±‚ç‰©ä½“
                    let object = intersects[0].object;
                    while (object.parent && !draggableObjects.includes(object)) {
                        object = object.parent;
                    }
                    
                    console.log('é¸ä¸­ç‰©é«”:', object.userData.name);
                    debugInfo.textContent = `âœ… é¸ä¸­: ${object.userData.name}`;
                    
                    if (draggableObjects.includes(object) && !object.userData.inBottle) {
                        selectedObject = object;
                        
                        // é«˜äº®æç¤º
                        highlightText(object.userData.highlightKey);
                        
                        // æ”¹å˜é¢œè‰²è¡¨ç¤ºé€‰ä¸­
                        selectedObject.traverse(child => {
                            if (child.isMesh) {
                                child.userData.originalColor = child.material.color.clone();
                                child.material.color.lerp(new THREE.Color(0xffff00), 0.3);
                            }
                        });
                        
                        showStatus(`âœ… é¸ä¸­äº† ${object.userData.name}ï¼Œæ‹–å‹•é¼ æ¨™ç§»å‹•å®ƒï¼`);
                        console.log('âœ… ç‰©é«”å·²é¸ä¸­ï¼Œå¯ä»¥æ‹–å‹•');
                    }
                } else {
                    console.log('æœªæª¢æ¸¬åˆ°ä»»ä½•ç‰©é«”');
                    debugInfo.textContent = `æœªæª¢æ¸¬åˆ°ç‰©é«”ï¼Œå¯æ‹–å‹•: ${draggableObjects.length}å€‹`;
                }
            }
        }

        // ========== é¼ æ ‡ç§»åŠ¨ ==========
        function onMouseMove(event) {
            event.preventDefault();
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            // å¦‚æœæ­£åœ¨æ‹–åŠ¨ç‰©ä½“
            if (selectedObject && !isBroken) {
                console.log('ğŸš€ æ‹–å‹•ä¸­...', selectedObject.userData.name);
                
                raycaster.setFromCamera(mouse, camera);
                
                // åœ¨y=ç‰©ä½“å½“å‰é«˜åº¦çš„å¹³é¢ä¸Šç§»åŠ¨
                const currentY = selectedObject.position.y;
                dragPlane.constant = -currentY;
                
                const intersectPoint = new THREE.Vector3();
                if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
                    console.log('ğŸ“ æ–°ä½ç½®:', intersectPoint.x.toFixed(2), intersectPoint.z.toFixed(2));
                    
                    selectedObject.position.x = intersectPoint.x;
                    selectedObject.position.z = intersectPoint.z;
                    
                    // æ£€æŸ¥ä¸ç“¶å£çš„è·ç¦»ï¼ŒåŠ¨æ€ç¼©æ”¾
                    checkBottleProximity(selectedObject);
                    
                    // æ›´æ–°è°ƒè¯•ä¿¡æ¯
                    const debugInfo = document.getElementById('debug-info');
                    debugInfo.textContent = `æ‹–å‹•ä¸­ï¼šä½ç½®(${intersectPoint.x.toFixed(1)}, ${intersectPoint.z.toFixed(1)})`;
                } else {
                    console.log('âš ï¸ ç„¡æ³•è¨ˆç®—äº¤é»');
                }
            } else if (!isBroken) {
                // é¼ æ ‡æ‚¬åœæ•ˆæœ
                raycaster.setFromCamera(mouse, camera);
                
                let allMeshes = [];
                draggableObjects.forEach(obj => {
                    if (!obj.userData.inBottle) {
                        obj.traverse(child => {
                            if (child.isMesh) {
                                allMeshes.push(child);
                            }
                        });
                    }
                });
                
                const intersects = raycaster.intersectObjects(allMeshes, false);
                
                // é‡ç½®æ‰€æœ‰ç‰©ä½“çš„é¼ æ ‡æ ·å¼
                renderer.domElement.style.cursor = 'default';
                
                if (intersects.length > 0) {
                    // æ”¹å˜é¼ æ ‡æ ·å¼
                    renderer.domElement.style.cursor = 'pointer';
                }
            }
        }

        // ========== é¼ æ ‡é‡Šæ”¾ ==========
        function onMouseUp(event) {
            console.log('ğŸ–±ï¸ é¼ æ¨™é‡‹æ”¾ï¼æŒ‰éµ:', event.button);
            
            // å³é”®é‡Šæ”¾ï¼šç¦ç”¨ç›¸æœºæ§åˆ¶
            if (event.button === 2) {
                console.log('ğŸ”„ å³éµé‡‹æ”¾ï¼Œç¦ç”¨ç›¸æ©Ÿæ—‹è½‰');
                controls.enabled = false;
                return;
            }
            
            // å·¦é”®é‡Šæ”¾ï¼šé‡Šæ”¾é€‰ä¸­çš„ç‰©ä½“
            if (event.button === 0 && selectedObject) {
                console.log('ğŸ‘† å·¦éµé‡‹æ”¾ç‰©é«”:', selectedObject.userData.name);
                
                // æ¢å¤é¢œè‰²
                selectedObject.traverse(child => {
                    if (child.isMesh && child.userData.originalColor) {
                        child.material.color.copy(child.userData.originalColor);
                    }
                });
                
                selectedObject = null;
                const debugInfo = document.getElementById('debug-info');
                debugInfo.textContent = 'ç‰©é«”å·²é‡‹æ”¾';
            }
        }

        // ========== æ£€æŸ¥ç‰©ä½“ä¸ç“¶å£çš„è·ç¦» ==========
        function checkBottleProximity(object) {
            const bottleMouthPos = new THREE.Vector3(0, BOTTLE_MOUTH_Y, 0);
            const distance = object.position.distanceTo(bottleMouthPos);
            
            const SHRINK_START_DISTANCE = 3;
            const ENTER_DISTANCE = 0.5;
            
            if (distance < SHRINK_START_DISTANCE && !object.userData.inBottle) {
                // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹ï¼ˆè·ç¦»è¶Šè¿‘ï¼Œç¼©æ”¾è¶Šå°ï¼‰
                const scale = Math.max(0.01, (distance / SHRINK_START_DISTANCE) * object.userData.originalScale);
                object.scale.set(scale, scale, scale);
                
                // å¦‚æœéå¸¸æ¥è¿‘ç“¶å£ï¼Œè¿›å…¥ç“¶ä¸­
                if (distance < ENTER_DISTANCE) {
                    enterBottle(object);
                }
            } else if (distance >= SHRINK_START_DISTANCE && object.scale.x !== object.userData.originalScale) {
                // è¿œç¦»æ—¶æ¢å¤å¤§å°
                gsap.to(object.scale, {
                    x: object.userData.originalScale,
                    y: object.userData.originalScale,
                    z: object.userData.originalScale,
                    duration: 0.3
                });
            }
        }

        // ========== ç‰©ä½“è¿›å…¥ç“¶å­ ==========
        function enterBottle(object) {
            if (object.userData.inBottle) return;
            
            object.userData.inBottle = true;
            objectsInBottle.push(object);
            
            // æ’­æ”¾éŸ³æ•ˆ
            playSound('ç¤ç„¶');
            
            // æ˜¾ç¤ºæ–‡å­—
            showFloatingText(object.userData.text, object.position);
            showStatus(`${object.userData.name} é€²å…¥ç“¶ä¸­ï¼${object.userData.text}`);
            
            // åŠ¨ç”»ï¼šèºæ—‹è¿›å…¥ç“¶å†…
            const targetY = BOTTLE_HEIGHT / 2 - BOTTLE_RADIUS * 0.5 + Math.random() * 0.5;
            const targetScale = 0.05 + Math.random() * 0.03;
            
            gsap.to(object.position, {
                x: (Math.random() - 0.5) * BOTTLE_RADIUS * 0.6,
                y: targetY,
                z: (Math.random() - 0.5) * BOTTLE_RADIUS * 0.6,
                duration: 1,
                ease: 'power2.inOut'
            });
            
            gsap.to(object.scale, {
                x: targetScale,
                y: targetScale,
                z: targetScale,
                duration: 1,
                ease: 'power2.inOut'
            });
            
            gsap.to(object.rotation, {
                y: object.rotation.y + Math.PI * 2,
                duration: 1,
                ease: 'power2.inOut'
            });
            
            // é«˜äº®å¯¹åº”æ–‡å­—
            highlightText(object.userData.highlightKey, true);
            
            // ä»å¯æ‹–åŠ¨åˆ—è¡¨ä¸­ç§»é™¤
            const index = draggableObjects.indexOf(object);
            if (index > -1) {
                draggableObjects.splice(index, 1);
            }
        }

        // ========== é«˜äº®æ–‡æœ¬ ==========
        function highlightText(key, permanent = false) {
            const elements = document.querySelectorAll(`[data-key="${key}"]`);
            elements.forEach(el => {
                el.classList.add('active');
                if (!permanent) {
                    setTimeout(() => el.classList.remove('active'), 2000);
                }
            });
        }

        // ========== æ˜¾ç¤ºæµ®åŠ¨æ–‡å­— ==========
        function showFloatingText(text, position) {
            const vector = position.clone().project(camera);
            const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
            const y = (-vector.y * 0.5 + 0.5) * window.innerHeight;
            
            const floatingText = document.createElement('div');
            floatingText.className = 'floating-text';
            floatingText.textContent = text;
            floatingText.style.left = x + 'px';
            floatingText.style.top = y + 'px';
            document.body.appendChild(floatingText);
            
            setTimeout(() => floatingText.remove(), 2000);
        }

        // ========== æ˜¾ç¤ºçŠ¶æ€ä¿¡æ¯ ==========
        function showStatus(text, duration = 3000) {
            const statusInfo = document.getElementById('status-info');
            statusInfo.textContent = text;
            statusInfo.classList.add('show');
            
            setTimeout(() => {
                statusInfo.classList.remove('show');
            }, duration);
        }

        // ========== æ’­æ”¾éŸ³æ•ˆ ==========
        function playSound(type) {
            if (!SOUND_ENABLED) return;
            
            // ç®€å•çš„éŸ³æ•ˆæç¤ºï¼ˆå¯ä»¥æ›¿æ¢ä¸ºå®é™…éŸ³é¢‘ï¼‰
            console.log(`ğŸ”Š æ’­æ”¾éŸ³æ•ˆ: ${type}`);
        }

        // ========== é‡ç½®åœºæ™¯ ==========
        function resetScene() {
            // æ¢å¤ç“¶å­
            if (isBroken) {
                location.reload();
                return;
            }
            
            // å°†ç“¶å†…ç‰©ä½“æ¢å¤
            objectsInBottle.forEach(obj => {
                obj.userData.inBottle = false;
                
                // éšæœºæ”¾ç½®åœ¨ç“¶å­å‘¨å›´
                const angle = Math.random() * Math.PI * 2;
                const radius = 3 + Math.random() * 2;
                
                gsap.to(obj.position, {
                    x: Math.cos(angle) * radius,
                    y: 0.5,
                    z: Math.sin(angle) * radius,
                    duration: 1,
                    ease: 'back.out'
                });
                
                gsap.to(obj.scale, {
                    x: obj.userData.originalScale,
                    y: obj.userData.originalScale,
                    z: obj.userData.originalScale,
                    duration: 1,
                    ease: 'back.out'
                });
                
                draggableObjects.push(obj);
            });
            
            objectsInBottle = [];
            
            // æ¸…é™¤é«˜äº®
            document.querySelectorAll('.highlight.active').forEach(el => {
                el.classList.remove('active');
            });
            
            showStatus('å ´æ™¯å·²é‡ç½®');
        }

        // ========== å€’å‡ºç‰©å“ ==========
        function emptyBottle() {
            if (objectsInBottle.length === 0) {
                showStatus('ç“¶ä¸­æ²’æœ‰ç‰©å“');
                return;
            }
            
            showStatus('å€’å‡ºç“¶ä¸­ç‰©å“...');
            
            objectsInBottle.forEach((obj, index) => {
                obj.userData.inBottle = false;
                
                // ä»ç“¶å£é£å‡º
                const angle = (index / objectsInBottle.length) * Math.PI * 2;
                const radius = 2;
                
                gsap.to(obj.position, {
                    x: Math.cos(angle) * radius,
                    y: 0.5,
                    z: Math.sin(angle) * radius,
                    duration: 1,
                    delay: index * 0.1,
                    ease: 'back.out'
                });
                
                gsap.to(obj.scale, {
                    x: obj.userData.originalScale,
                    y: obj.userData.originalScale,
                    z: obj.userData.originalScale,
                    duration: 1,
                    delay: index * 0.1,
                    ease: 'back.out'
                });
                
                draggableObjects.push(obj);
            });
            
            objectsInBottle = [];
        }

        // ========== æ‰“ç ´ç“¶å­ ==========
        function breakBottle() {
            if (isBroken) return;
            
            isBroken = true;
            highlightText('break', true);
            showStatus('é½å–æ’²ç ´ï¼Œæ±‚ä¹‹ä¸€ç„¡æ‰€æœ‰ï¼', 5000);
            
            // ç“¶å­ç ´ç¢åŠ¨ç”»
            bottle.traverse(child => {
                if (child.isMesh) {
                    gsap.to(child.material, {
                        opacity: 0,
                        duration: 1
                    });
                }
            });
            
            bottleNeck.traverse(child => {
                if (child.isMesh) {
                    gsap.to(child.material, {
                        opacity: 0,
                        duration: 1
                    });
                }
            });
            
            // ç‰©ä½“æ¶ˆå¤±
            objectsInBottle.forEach(obj => {
                gsap.to(obj.scale, {
                    x: 0,
                    y: 0,
                    z: 0,
                    duration: 0.8,
                    ease: 'power2.in'
                });
            });
            
            setTimeout(() => {
                showStatus('å¾æ­¤å¤±åªšå…’æ‰€åœ¨...ï¼ˆé»æ“Šé‡æ–°é–‹å§‹æ¢å¾©å ´æ™¯ï¼‰', 5000);
            }, 1500);
        }

        // ========== è§‚å¯Ÿç“¶å†… ==========
        function viewInside() {
            if (objectsInBottle.length === 0) {
                showStatus('ç“¶ä¸­æ²’æœ‰ç‰©å“å¯è§€å¯Ÿ');
                return;
            }
            
            // ç›¸æœºç§»å‹•åˆ°ç“¶å†…è§†è§’
            gsap.to(camera.position, {
                x: 0,
                y: BOTTLE_HEIGHT / 2,
                z: 0.3,
                duration: 2,
                ease: 'power2.inOut',
                onUpdate: () => {
                    camera.lookAt(0, BOTTLE_HEIGHT / 2 - 0.5, 0);
                },
                onComplete: () => {
                    showStatus('è§€å¯Ÿç“¶å…§å¾®ç¸®ä¸–ç•Œï¼Œæ»¾å‹•ç¸®æ”¾ã€å³éµæ—‹è½‰è¦–è§’');
                    setTimeout(() => {
                        // æ¢å¤è§†è§’
                        gsap.to(camera.position, {
                            x: 8,
                            y: 6,
                            z: 8,
                            duration: 2,
                            ease: 'power2.inOut'
                        });
                    }, 5000);
                }
            });
        }

        // ========== åŠ¨ç”»å¾ªç¯ ==========
        function animate() {
            requestAnimationFrame(animate);
            
            // æ›´æ–°æ§åˆ¶å™¨
            controls.update();
            
            // ç“¶å†…ç‰©ä½“çš„å¾®åŠ¨ç”»
            objectsInBottle.forEach(obj => {
                if (obj.userData.animate) {
                    obj.rotation.y += 0.005;
                }
                
                // è½»å¾®æ¼‚æµ®
                obj.position.y += Math.sin(Date.now() * 0.001 + obj.id) * 0.0002;
                
                // è½¦è½®æ—‹è½¬
                if (obj.userData.wheels) {
                    obj.userData.wheels.forEach(wheel => {
                        wheel.rotation.z += 0.01;
                    });
                }
            });
            
            // æ¸²æŸ“
            renderer.render(scene, camera);
        }

        // ========== çª—å£è°ƒæ•´ ==========
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ========== å¯åŠ¨ ==========
        init();
    </script>
</body>
</html>

