<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>南風詩詞組句</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <!-- Supabase UMD 與全域登入狀態列 -->
    <script src="https://unpkg.com/@supabase/supabase-js@2.56.0/dist/umd/supabase.js"></script>
    <script>
        // 指定本頁使用的 Supabase 專案參數（覆蓋預設）
        window.SUPABASE_URL = 'https://onregacmigwiyomhmjyt.supabase.co';
        window.SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Im9ucmVnYWNtaWd3aXlvbWhtanl0Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTg5NzIzMDcsImV4cCI6MjA3NDU0ODMwN30.VxLyR3SMlnVYubFLdQNJqYMyJnT5foo7wUkVEmi4QcY';
    </script>
    <script src="assets/js/cc-auth.js"></script>
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        // 现代蓝紫渐变主色系
                        primary: {
                            50: '#f0f9ff',
                            100: '#e0f2fe', 
                            400: '#38bdf8',
                            500: '#0ea5e9', // 主蓝色
                            600: '#0284c7',
                            700: '#0369a1',
                            900: '#0c4a6e'
                        },
                        // 现代薄荷绿辅助色
                        secondary: {
                            400: '#4ade80',
                            500: '#22c55e', // 主绿色
                            600: '#16a34a',
                            700: '#15803d'
                        },
                        // 现代紫色强调色
                        accent: {
                            400: '#a78bfa',
                            500: '#8b5cf6', // 紫色强调
                            600: '#7c3aed'
                        },
                        // 现代中性色背景
                        surface: {
                            50: '#fafafa',
                            100: '#f4f4f5',
                            200: '#e4e4e7',
                            800: '#27272a',
                            900: '#18181b'
                        }
                    },
                    fontFamily: {
                        'sans': ['Inter', 'system-ui', 'sans-serif'],
                        'kai': ['KaiTi', 'SimKai', 'serif'],
                        'modern': ['Inter', '-apple-system', 'BlinkMacSystemFont', 'sans-serif']
                    },
                    animation: {
                        'slide-up': 'slideUp 0.5s cubic-bezier(0.4, 0, 0.2, 1)',
                        'bounce-gentle': 'bounceGentle 2s ease-in-out infinite',
                        'pulse-modern': 'pulseModern 2s cubic-bezier(0.4, 0, 0.6, 1) infinite',
                        'scale-in': 'scaleIn 0.3s cubic-bezier(0.4, 0, 0.2, 1)',
                    }
                }
            }
        }
    </script>
    
    <!-- 添加动画效果 -->
    <style>
        /* 已選字樣式（清晰區分） */
        .character-btn.selected {
            background-color: rgba(59, 121, 96, 0.15);
            border-color: #3B7960;
            box-shadow: 0 0 0 2px rgba(59,121,96,0.35) inset;
            color: #0f172a;
        }
        .character-btn.selected::after {
            content: "✓";
            position: absolute;
            top: 4px;
            right: 6px;
            font-size: 0.9rem;
            color: #3B7960;
            opacity: 0.95;
        }
        /* 選中字保持選中樣式，不受 hover 綠色影響 */
        .character-btn.selected:hover {
            background-color: rgba(59, 121, 96, 0.15);
            border-color: #3B7960;
            box-shadow: 0 0 0 2px rgba(59,121,96,0.35) inset;
            color: #0f172a;
        }
        /* 字符按钮点击动画 */
        @keyframes buttonPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); box-shadow: 0 0 10px rgba(59, 121, 96, 0.5); }
            100% { transform: scale(1); }
        }
        
        .animate-click {
            animation: buttonPulse 0.3s ease-in-out;
        }
        
        /* 正确答案动画 */
        @keyframes correctAnswer {
            0% { transform: scale(1); }
            10% { transform: scale(1.05); }
            20% { transform: scale(1); }
            30% { transform: scale(1.05); }
            40% { transform: scale(1); }
            50% { transform: scale(1.05); }
            60% { transform: scale(1); }
        }
        
        .animate-correct {
            animation: correctAnswer 1s ease-in-out;
            box-shadow: 0 0 15px rgba(52, 211, 153, 0.7);
        }
        
        /* 错误答案动画 */
        @keyframes wrongAnswer {
            0% { transform: translateX(0); }
            10% { transform: translateX(-5px); }
            20% { transform: translateX(5px); }
            30% { transform: translateX(-5px); }
            40% { transform: translateX(5px); }
            50% { transform: translateX(-5px); }
            60% { transform: translateX(5px); }
            70% { transform: translateX(-5px); }
            80% { transform: translateX(5px); }
            90% { transform: translateX(-5px); }
            100% { transform: translateX(0); }
        }
        
        .animate-wrong {
            animation: wrongAnswer 0.5s ease-in-out;
        }
        
        /* 分数变化动画 */
        @keyframes scoreChange {
            0% { transform: scale(1); }
            50% { transform: scale(1.5); color: #DAA520; }
            100% { transform: scale(1); }
        }
        
        .animate-score {
            animation: scoreChange 0.8s ease-in-out;
        }
        
        /* 面板淡入动画 */
        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        
        .animate-fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        /* 新增：淡入上浮進場 */
        @keyframes fadeUp {
            0% { opacity: 0; transform: translateY(12px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .animate-fade-up { animation: fadeUp 500ms ease-out both; }

        /* 新增：縮放進場 */
        @keyframes scaleIn {
            0% { opacity: 0; transform: scale(0.92); }
            100% { opacity: 1; transform: scale(1); }
        }
        .animate-scale-in { animation: scaleIn 420ms ease-out both; }

        /* 新增：慢速脈動（用於緊張時刻） */
        @keyframes pulseSlow {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.12); }
        }
        .timer-warning { color: #dc2626; animation: pulseSlow 1s ease-in-out infinite; }

        /* 新增：按鈕抬升與微互動 */
        .interactive {
            transition: transform 160ms ease, box-shadow 200ms ease, background-color 200ms ease, color 200ms ease;
        }
        .interactive:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(0,0,0,0.12); }
        .interactive:active { transform: translateY(0); box-shadow: 0 2px 6px rgba(0,0,0,0.12); }

        /* 下一輪按鈕：尺寸+10% 並加入吸引點擊的柔和脈動與光暈 */
        .next-round-button {
            border-radius: 1rem; /* 與 rounded-2xl 對齊 */
            position: relative;
            transition: transform 180ms ease, box-shadow 240ms ease, filter 240ms ease;
            animation: nextRoundPulse 1.25s ease-in-out infinite;
        }
        .next-round-button:hover {
            box-shadow: 0 16px 40px rgba(14,165,233,0.6), 0 0 0 2px rgba(255,255,255,0.24) inset;
            filter: brightness(1.1);
        }
        .next-round-button:active {
            transform: translateY(0) scale(1.02);
        }
        /* 外環光暈（非 transform 動畫，避免與 hover 縮放衝突） */
        .next-round-button::after {
            content: "";
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            width: 125%;
            height: 150%;
            border-radius: 1.2rem;
            pointer-events: none;
            background: radial-gradient(closest-side, rgba(14,165,233,0.5), rgba(14,165,233,0) 74%);
            opacity: 0.0;
            animation: nextRoundGlow 1.5s ease-in-out infinite;
        }
        @keyframes nextRoundPulse {
            0%, 100% { box-shadow: 0 12px 26px rgba(14,165,233,0.46); }
            50% { box-shadow: 0 20px 46px rgba(14,165,233,0.78); }
        }
        @keyframes nextRoundGlow {
            0%, 100% { opacity: 0.38; }
            50% { opacity: 0.78; }
        }

        /* 對戰模式積分卡片樣式 */
        #battleScoreboard { pointer-events: none; }
        #battleScoreboard .player-score-card { pointer-events: auto; }
        .player-score-card {
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            padding: 1rem;
            border-radius: 1.25rem; /* 20px */
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            text-align: center;
        }

        .player-score-card.active {
            transform: scale(1.1);
            border-color: rgba(255, 255, 255, 0.9);
            animation: pulse-gentle 1.5s infinite;
        }
        
        /* 6种不同的玩家主题色 (背景渐变) */
        .player-theme-1 { background: linear-gradient(180deg, rgba(142, 68, 173, 0.3), rgba(142, 68, 173, 0.1)); } /* 紫 */
        .player-theme-2 { background: linear-gradient(180deg, rgba(41, 128, 185, 0.3), rgba(41, 128, 185, 0.1)); } /* 蓝 */
        .player-theme-3 { background: linear-gradient(180deg, rgba(39, 174, 96, 0.3), rgba(39, 174, 96, 0.1)); } /* 绿 */
        .player-theme-4 { background: linear-gradient(180deg, rgba(241, 196, 15, 0.3), rgba(241, 196, 15, 0.1)); } /* 黄 */
        .player-theme-5 { background: linear-gradient(180deg, rgba(230, 126, 34, 0.3), rgba(230, 126, 34, 0.1)); } /* 橙 */
        .player-theme-6 { background: linear-gradient(180deg, rgba(192, 57, 43, 0.3), rgba(192, 57, 43, 0.1)); } /* 红 */

        .player-theme-1.active { box-shadow: 0 0 30px rgba(142, 68, 173, 0.8); }
        .player-theme-2.active { box-shadow: 0 0 30px rgba(41, 128, 185, 0.8); }
        .player-theme-3.active { box-shadow: 0 0 30px rgba(39, 174, 96, 0.8); }
        .player-theme-4.active { box-shadow: 0 0 30px rgba(241, 196, 15, 0.8); }
        .player-theme-5.active { box-shadow: 0 0 30px rgba(230, 126, 34, 0.8); }
        .player-theme-6.active { box-shadow: 0 0 30px rgba(192, 57, 43, 0.8); }

        .player-name {
            font-family: 'modern', 'KaiTi', sans-serif;
            font-weight: 700;
            font-size: 1.25rem; 
            color: #1F2937; /* 深灰色，提高对比度 */
            margin-bottom: 0.5rem;
            text-shadow: 1px 1px 2px rgba(255,255,255,0.2);
        }
        
        .player-score {
            font-family: 'modern', sans-serif;
            font-size: 2.25rem;
            font-weight: 900;
            color: #FFFFFF;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.5); /* 加深阴影 */
        }

        .current-turn-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 12px;
            height: 12px;
            background-color: #34D399; /* 鲜绿色指示灯 */
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 0 10px #34D399, 0 0 20px #34D399;
            animation: pulse-gentle 1.5s infinite;
        }

        @keyframes pulse-gentle {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
        }

        /* 新增：字卡微動效與點擊波紋容器 */
        .character-btn {
            position: relative; overflow: hidden;
            transition: transform 120ms ease, box-shadow 180ms ease, background-color 180ms ease, color 180ms ease;
        }
        .character-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 14px rgba(0,0,0,0.10); }
        .character-btn:active { transform: translateY(0); }
        .character-btn:disabled { transform: none !important; box-shadow: none !important; }

        /* 適度放大桌面端待選字，不改padding，避免影響點擊與排版 */
        .character-btn.char-modern { font-size: 1.75rem; line-height: 1; }
        @media (min-width: 768px) {
            .character-btn.char-modern { font-size: 2rem; }
        }

        /* 新增：點擊波紋 */
        .ripple {
            position: absolute; border-radius: 9999px; transform: translate(-50%, -50%);
            background: rgba(59, 121, 96, 0.25); pointer-events: none; width: 10px; height: 10px;
            animation: ripple 600ms ease-out forwards;
        }
        @keyframes ripple {
            from { opacity: 0.35; transform: translate(-50%, -50%) scale(1); }
            to { opacity: 0; transform: translate(-50%, -50%) scale(16); }
        }
    </style>
    
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&family=Noto+Serif+SC:wght@400;600;700&display=swap');
        
        /* 自定义字体样式 - 使用更通用的字体堆栈 */
        .font-title {
            font-family: 'Microsoft YaHei', 'PingFang SC', 'STHeiti', 'SimHei', 'Heiti SC', 'Noto Sans CJK SC', 'Source Han Sans SC', sans-serif;
            font-weight: 700;
        }
        
        .font-text {
            font-family: 'Microsoft YaHei', 'PingFang SC', 'STHeiti', 'SimHei', 'Heiti SC', 'Noto Sans CJK SC', 'Source Han Sans SC', sans-serif;
        }
        
        /* 滚动条样式 */
        ::-webkit-scrollbar {
            width: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
        }
        
        ::-webkit-scrollbar-thumb {
            background: #C03A5C;
            border-radius: 4px;
        }
        
        /* 中国传统装饰边框 */
        .border-chinese {
            border-image: url('https://cdn.jsdelivr.net/gh/ant-design/ant-design@4.10.0/components/style/color/images/colorPalette.less') 30 stretch;
        }
        
        /* 水墨风格背景 */
        .bg-chinese-light {
            background-color: #f9f5e9;
            background-image: 
                linear-gradient(rgba(249, 245, 233, 0.7), rgba(249, 245, 233, 0.7)),
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%23C03A5C' fill-opacity='0.08' fill-rule='evenodd'/%3E%3C/svg%3E");
        }
        
        .bg-chinese-dark {
            background-color: #1a1a1a;
            background-image: 
                linear-gradient(rgba(26, 26, 26, 0.7), rgba(26, 26, 26, 0.7)),
                url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M11 18c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm48 25c3.866 0 7-3.134 7-7s-3.134-7-7-7-7 3.134-7 7 3.134 7 7 7zm-43-7c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm63 31c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM34 90c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zm56-76c1.657 0 3-1.343 3-3s-1.343-3-3-3-3 1.343-3 3 1.343 3 3 3zM12 86c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm28-65c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm23-11c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-6 60c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm29 22c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zM32 63c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm57-13c2.76 0 5-2.24 5-5s-2.24-5-5-5-5 2.24-5 5 2.24 5 5 5zm-9-21c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM60 91c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM35 41c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2zM12 60c1.105 0 2-.895 2-2s-.895-2-2-2-2 .895-2 2 .895 2 2 2z' fill='%23C03A5C' fill-opacity='0.12' fill-rule='evenodd'/%3E%3C/svg%3E");
        }

        /* 中国风纸张效果 */
        .paper-effect {
            background-color: #FFF6E5; /* 暖宣紙 */
            box-shadow: 0 6px 18px rgba(12, 16, 39, 0.08);
            position: relative;
            border: 1px solid rgba(46, 125, 109, 0.18);
        }
        
        .paper-effect::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-image: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M77 63a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 3a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm-50-3a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 3a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm2-32a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 3a6 6 0 1 1 0-12 6 6 0 0 1 0 12zm48-3a3 3 0 1 0 0-6 3 3 0 0 0 0 6zm0 3a6 6 0 1 1 0-12 6 6 0 0 1 0 12z' fill='%23000000' fill-opacity='0.03' fill-rule='evenodd'/%3E%3C/svg%3E");
            opacity: 0.5;
            z-index: 0;
        }
        
        .paper-effect > * {
            position: relative;
            z-index: 1;
        }
        
        .dark .paper-effect {
            background-color: #2a2a2a;
        }

        /* 印章效果 */
        .seal {
            position: relative;
        }
        
        .seal::after {
            content: "詩";
            position: absolute;
            bottom: 10px;
            right: 10px;
            font-family: 'Microsoft YaHei', 'PingFang SC', 'STHeiti', 'SimHei', sans-serif;
            color: rgba(192, 58, 92, 0.50);
            font-size: 2.5rem;
            font-weight: bold;
            transform: rotate(-15deg);
            border: 2px solid rgba(192, 58, 92, 0.50);
            border-radius: 50%;
            width: 3rem;
            height: 3rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0.8;
        }
        
        /* 毛笔光标效果 - 使用经过Base64编码的内嵌毛笔图标 */
        .character-btn, 
        #clearSelection, 
        #submitPoem, 
        #nextRound,
        #adminModeToggle,
        #saveCustomPoem,
        button,
        select,
        a {
            cursor: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAF8WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDYwLCAyMDIwLzA1LzEyLTE2OjA0OjE3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDgtMDhUMTA6MTA6MDcrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA4LTA4VDEwOjEyOjE5KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIwLTA4LTA4VDEwOjEyOjE5KzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExZDYwN2VkLTM0NzAtNGRhOC1hZTBmLTU2YTRhNmEyNWVkMCIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjE3YmRlN2E4LWZjMmMtM2I0Zi05NWJlLWIyYWZjYzA2YmExNSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjc1ODRkNTJhLTY5MDUtNGI0OS1iNTBkLTk0OTEwNGU2ZWI1ZCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NzU4NGQ1MmEtNjkwNS00YjQ5LWI1MGQtOTQ5MTA0ZTZlYjVkIiBzdEV2dDp3aGVuPSIyMDIwLTA4LTA4VDEwOjEwOjA3KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MTFkNjA3ZWQtMzQ3MC00ZGE4LWFlMGYtNTZhNGE2YTI1ZWQwIiBzdEV2dDp3aGVuPSIyMDIwLTA4LTA4VDEwOjEyOjE5KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6s3PW0AAAGS0lEQVRYhe2XW2wc1RnHf+fM7M7O7K69u77EMSROY1yTUiUlJCqElqZQXCmKVBrCrYAqSEiAhMQD4oHS9AklXngBISQEVYAXArRRaZuWAiIoUFWlSvNAAoi6SRwIie/r9e7s7F7m8jC21zHeLeqL9H87c77zne87/++c811QVW5kWDeUHuiP5bGzEsxB7NzLXgm8yF5xt57y1r0zGG4+lLrF+UNvtkEPIhLhcxfFT5Y6K98OOF58Y6TlXa+jNOvBLPxYsOeW1xoATZZs5Pl75M+RP4mWNKVadlvQwuWiZrOHVPW9T9VH2b9nIzAA6Jx/ILpRRH4GbEUxPLM5V/cAXm3LXtPO/9Yd6+sKF/xbX4wOb/pDYs9xWA/8+Mujw6LWVWDzBxeLNwzHi+FYYYdv+28B3UFjzVbTiO3oLK0rXfWQUv4vCDR9D+cXhWJhXW2K9qbG3JpGj5sA/T85kQJ2M3OcsgmBnQ3ZrmVEq7/PwtJYrj8Zs9LLW3l5aMPIJT8Cze8M16LJHQqra5d6wuH0WjEi24AO4J++NXRxf+bEbVvTO7uGwhPpBw+mF2/JjKdP6+mdnxnY2gS0AxTyZC70MG//M8nBhkM9Dy5Jnz5QUV8E2AhsSpcCbYNHD84fTh+y4tFHXduevCbRz4iAKt4DJxBjh2fZvyQSjUvU2gwUgIuhTLlHKKFEASzHsYJQpqqyEkh9GsKMoHLDuVXhOPzH7Og7ApkxAI/rAKAjF4+sL9dGPz1/KrjVqxmn4T0P8O56j6qf/3BKy+5/psvNe1y3qCJmYxlxdZtv2wcB9m7fGwU2ASXgjB3PvdPqvbmuPLDmGRG5M0i9FjWX1aWiSybLt3yDhZ8+ghEKzajyZXTHXG+OBJZVzwL0p8f2Ae3V7YTHxhrKIzU5NTQPoFYg56ta0eaHjnH60XpO/KCO/ptixCpiJFsW0frTp6nYfFfs7Fu4KvFEAEZfRaWJPVmQEJ7j3NObOQvQxHIZcLtKhYjBttfV1lY9N3qXEat/JTOe/XD3QAfBLUd8EZEFzCRUAPU6B/+XkZoM9LTnzw+uKxX94pDLXX3p2pnNxqMN09vu5SIg0nj4Xag+D6SCnTlU4GBDrr7Pc/aV6Ww96Tgf7R5qebB3aXB9hk+I6jjyP4kIBsYd0ZpLxejQYxhjIZ5iiYMKgD4gvGfbFgF5GDAAz0/mxsJpY6iISBeXdEZK3qmx7KeEq+gD/8kEUHnddg1uVaEawRiXQ/s1FPX/2P3G3c9XPnEfWFegxPHh7IXyVNLu/VBD7ePMvlAF0NKV3OC7Xut0t2cbn9R0d/uIXDx4+U9/vvOJc2xnTUoiG2bYAgLbDtwcXgcVwqwXHiOw3cuzNTKwLAV9z+S19iQv9Ldk2yZ8/VNvfbbd3zx5x9AjM3kA9G0ZwvB2A9a1Z0BwHLTU1ppL2I/3LPwDBwfb+z+/DP1v5FvDI8mF50cS55rKy9wWwpHLzhnPcbsV0WvSvUGgoihGBKIr1kBoCTC0GnStVNAYQnF3zx0QijMdGp8lZrP0lhUfhJrTGQBvMj2BcM1wXY/A4OTr75y+gvCsPpdZ8cKk0/ysb5d+ZRhjcaH1A0LLVwGUJsbGgbrrIqCaRMZOVZlRu+PfKxvbZoJHXvyZlkd+RaS6mUjDN4l1PUvLz56CQhLgHJCZTVL4GqiI0nA0vbBtjFgNhbE3MRYvksmb53fQev+vady0A3xFBTxnBLBOj5ze3ck9b2HbNcD8TxcYgTwqqKE9i7sG0g+NjBl7+hsWdHa08uLOteTa1qMa4BfTRFz4VhORMBOH3sOMVBGqnMf1k/jjTB0mIEtmdHCTCxgawAj6dMEVQsMGElW0Pfon3Pcp0M0q7vH0kZ+yM3UIcDeA/wFmJLRzcQNZNQGGU/3jw2M3leKB11oGGrJVw2nK9eDdFXZ93s89PpxpWJRVMZFrZ/lKsMCYihxMj51NjPVfbTw+4evKh6/K8M9DqICiXlPh3MTRjsUWqjQDGUH+BF+9XR/5rNbSHQA87QnVdEpEvgCiS+M+u2fH7v4bqgZoA30OAgLaIQB6vf8m+q9fwpcZdwCW+xvg/wHA/4vAjbiM/wJrDSl2bWPqbQAAAABJRU5ErkJggg==") 1 25, auto;
        }
        
        /* 确保鼠标悬停状态下也使用毛笔光标 */
        .character-btn:hover,
        button:hover,
        select:hover,
        a:hover {
            cursor: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAACXBIWXMAAAsTAAALEwEAmpwYAAAF8WlUWHRYTUw6Y29tLmFkb2JlLnhtcAAAAAAAPD94cGFja2V0IGJlZ2luPSLvu78iIGlkPSJXNU0wTXBDZWhpSHpyZVN6TlRjemtjOWQiPz4gPHg6eG1wbWV0YSB4bWxuczp4PSJhZG9iZTpuczptZXRhLyIgeDp4bXB0az0iQWRvYmUgWE1QIENvcmUgNi4wLWMwMDIgNzkuMTY0NDYwLCAyMDIwLzA1LzEyLTE2OjA0OjE3ICAgICAgICAiPiA8cmRmOlJERiB4bWxuczpyZGY9Imh0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMiPiA8cmRmOkRlc2NyaXB0aW9uIHJkZjphYm91dD0iIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1sbnM6cGhvdG9zaG9wPSJodHRwOi8vbnMuYWRvYmUuY29tL3Bob3Rvc2hvcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RFdnQ9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZUV2ZW50IyIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIgeG1wOkNyZWF0ZURhdGU9IjIwMjAtMDgtMDhUMTA6MTA6MDcrMDg6MDAiIHhtcDpNb2RpZnlEYXRlPSIyMDIwLTA4LTA4VDEwOjEyOjE5KzA4OjAwIiB4bXA6TWV0YWRhdGFEYXRlPSIyMDIwLTA4LTA4VDEwOjEyOjE5KzA4OjAwIiBkYzpmb3JtYXQ9ImltYWdlL3BuZyIgcGhvdG9zaG9wOkNvbG9yTW9kZT0iMyIgcGhvdG9zaG9wOklDQ1Byb2ZpbGU9InNSR0IgSUVDNjE5NjYtMi4xIiB4bXBNTTpJbnN0YW5jZUlEPSJ4bXAuaWlkOjExZDYwN2VkLTM0NzAtNGRhOC1hZTBmLTU2YTRhNmEyNWVkMCIgeG1wTU06RG9jdW1lbnRJRD0iYWRvYmU6ZG9jaWQ6cGhvdG9zaG9wOjE3YmRlN2E4LWZjMmMtM2I0Zi05NWJlLWIyYWZjYzA2YmExNSIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ4bXAuZGlkOjc1ODRkNTJhLTY5MDUtNGI0OS1iNTBkLTk0OTEwNGU2ZWI1ZCI+IDx4bXBNTTpIaXN0b3J5PiA8cmRmOlNlcT4gPHJkZjpsaSBzdEV2dDphY3Rpb249ImNyZWF0ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6NzU4NGQ1MmEtNjkwNS00YjQ5LWI1MGQtOTQ5MTA0ZTZlYjVkIiBzdEV2dDp3aGVuPSIyMDIwLTA4LTA4VDEwOjEwOjA3KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIvPiA8cmRmOmxpIHN0RXZ0OmFjdGlvbj0ic2F2ZWQiIHN0RXZ0Omluc3RhbmNlSUQ9InhtcC5paWQ6MTFkNjA3ZWQtMzQ3MC00ZGE4LWFlMGYtNTZhNGE2YTI1ZWQwIiBzdEV2dDp3aGVuPSIyMDIwLTA4LTA4VDEwOjEyOjE5KzA4OjAwIiBzdEV2dDpzb2Z0d2FyZUFnZW50PSJBZG9iZSBQaG90b3Nob3AgMjEuMiAoTWFjaW50b3NoKSIgc3RFdnQ6Y2hhbmdlZD0iLyIvPiA8L3JkZjpTZXE+IDwveG1wTU06SGlzdG9yeT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz6s3PW0AAAGS0lEQVRYhe2XW2wc1RnHf+fM7M7O7K69u77EMSROY1yTUiUlJCqElqZQXCmKVBrCrYAqSEiAhMQD4oHS9AklXngBISQEVYAXArRRaZuWAiIoUFWlSvNAAoi6SRwIie/r9e7s7F7m8jC21zHeLeqL9H87c77zne87/++c811QVW5kWDeUHuiP5bGzEsxB7NzLXgm8yF5xt57y1r0zGG4+lLrF+UNvtkEPIhLhcxfFT5Y6K98OOF58Y6TlXa+jNOvBLPxYsOeW1xoATZZs5Pl75M+RP4mWNKVadlvQwuWiZrOHVPW9T9VH2b9nIzAA6Jx/ILpRRH4GbEUxPLM5V/cAXm3LXtPO/9Yd6+sKF/xbX4wOb/pDYs9xWA/8+Mujw6LWVWDzBxeLNwzHi+FYYYdv+28B3UFjzVbTiO3oLK0rXfWQUv4vCDR9D+cXhWJhXW2K9qbG3JpGj5sA/T85kQJ2M3OcsgmBnQ3ZrmVEq7/PwtJYrj8Zs9LLW3l5aMPIJT8Cze8M16LJHQqra5d6wuH0WjEi24AO4J++NXRxf+bEbVvTO7uGwhPpBw+mF2/JjKdP6+mdnxnY2gS0AxTyZC70MG//M8nBhkM9Dy5Jnz5QUV8E2AhsSpcCbYNHD84fTh+y4tFHXduevCbRz4iAKt4DJxBjh2fZvyQSjUvU2gwUgIuhTLlHKKFEASzHsYJQpqqyEkh9GsKMoHLDuVXhOPzH7Og7ApkxAI/rAKAjF4+sL9dGPz1/KrjVqxmn4T0P8O56j6qf/3BKy+5/psvNe1y3qCJmYxlxdZtv2wcB9m7fGwU2ASXgjB3PvdPqvbmuPLDmGRG5M0i9FjWX1aWiSybLt3yDhZ8+ghEKzajyZXTHXG+OBJZVzwL0p8f2Ae3V7YTHxhrKIzU5NTQPoFYg56ta0eaHjnH60XpO/KCO/ptixCpiJFsW0frTp6nYfFfs7Fu4KvFEAEZfRaWJPVmQEJ7j3NObOQvQxHIZcLtKhYjBttfV1lY9N3qXEat/JTOe/XD3QAfBLUd8EZEFzCRUAPU6B/+XkZoM9LTnzw+uKxX94pDLXX3p2pnNxqMN09vu5SIg0nj4Xag+D6SCnTlU4GBDrr7Pc/aV6Ww96Tgf7R5qebB3aXB9hk+I6jjyP4kIBsYd0ZpLxejQYxhjIZ5iiYMKgD4gvGfbFgF5GDAAz0/mxsJpY6iISBeXdEZK3qmx7KeEq+gD/8kEUHnddg1uVaEawRiXQ/s1FPX/2P3G3c9XPnEfWFegxPHh7IXyVNLu/VBD7ePMvlAF0NKV3OC7Xut0t2cbn9R0d/uIXDx4+U9/vvOJc2xnTUoiG2bYAgLbDtwcXgcVwqwXHiOw3cuzNTKwLAV9z+S19iQv9Ldk2yZ8/VNvfbbd3zx5x9AjM3kA9G0ZwvB2A9a1Z0BwHLTU1ppL2I/3LPwDBwfb+z+/DP1v5FvDI8mF50cS55rKy9wWwpHLzhnPcbsV0WvSvUGgoihGBKIr1kBoCTC0GnStVNAYQnF3zx0QijMdGp8lZrP0lhUfhJrTGQBvMj2BcM1wXY/A4OTr75y+gvCsPpdZ8cKk0/ysb5d+ZRhjcaH1A0LLVwGUJsbGgbrrIqCaRMZOVZlRu+PfKxvbZoJHXvyZlkd+RaS6mUjDN4l1PUvLz56CQhLgHJCZTVL4GqiI0nA0vbBtjFgNhbE3MRYvksmb53fQev+vady0A3xFBTxnBLBOj5ze3ck9b2HbNcD8TxcYgTwqqKE9i7sG0g+NjBl7+hsWdHa08uLOteTa1qMa4BfTRFz4VhORMBOH3sOMVBGqnMf1k/jjTB0mIEtmdHCTCxgawAj6dMEVQsMGElW0Pfon3Pcp0M0q7vH0kZ+yM3UIcDeA/wFmJLRzcQNZNQGGU/3jw2M3leKB11oGGrJVw2nK9eDdFXZ93s89PpxpWJRVMZFrZ/lKsMCYihxMj51NjPVfbTw+4evKh6/K8M9DqICiXlPh3MTRjsUWqjQDGUH+BF+9XR/5rNbSHQA87QnVdEpEvgCiS+M+u2fH7v4bqgZoA30OAgLaIQB6vf8m+q9fwpcZdwCW+xvg/wHA/4vAjbiM/wJrDSl2bWPqbQAAAABJRU5ErkJggg==") 1 25, pointer;
        }
        
        /* 禁用状态仍然使用默认光标 */
        .character-btn:disabled {
            cursor: not-allowed;
        }
        
        /* iframe環境優化 */
        @supports (-webkit-touch-callout: none) {
            /* iOS Safari 在 iframe 中的特殊處理 */
            html, body {
                width: 100% !important;
                height: 100% !important;
                margin: 0 !important;
                padding: 0 !important;
                overflow: hidden !important;
                -webkit-overflow-scrolling: touch;
                position: fixed !important;
                top: 0 !important;
                left: 0 !important;
            }
        }
        
        /* 強制元素不超出邊界 */
        * {
            box-sizing: border-box;
        }
        
        /* 確保字符按鈕可點擊 */
        .character-btn {
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
        }

        /* 移動端iframe全屏優化 */
        @media (max-width: 768px) {
            /* 主容器優化 */
            .max-w-5xl {
                padding: 0.25rem !important;
                height: 100vh !important;
                height: 100dvh !important;
            }

            /* 头部区域压缩 */
            .flex.justify-between.items-center.mb-3 {
                margin-bottom: 0.5rem !important;
            }

            /* 标题区域压缩 */
            .font-title {
                font-size: 1.5rem !important;
                margin-bottom: 0.5rem !important;
            }

            /* 控制按钮区域压缩 */
            .flex.items-center.justify-end.space-x-2.mb-2 {
                margin-bottom: 0.25rem !important;
            }

            /* 诗句显示区域优化 */
            .paper-effect.p-3.rounded-lg.shadow-md.border.border-secondary\/30.seal {
                padding: 0.5rem !important;
                margin-bottom: 0.5rem !important;
            }

            /* 汉字选择区域标题压缩 */
            #charactersGrid + div h2 {
                font-size: 1rem !important;
                margin-bottom: 0.5rem !important;
            }

            /* 字符按钮大小调整 */
            .character-btn {
                padding: 0.5rem !important;
                font-size: 1.25rem !important;
            }

            /* 诗歌显示框移动端优化 - 保持一行高度 */
            #poemDisplay {
                font-size: 1.25rem !important;
                height: 2.5rem !important;
                line-height: 2.5rem !important;
                padding: 0.25rem !important;
                overflow: hidden !important;
                white-space: nowrap !important;
            }

            /* 按钮区域压缩 */
            .flex.justify-center.space-x-20.mt-4 {
                margin-top: 0.5rem !important;
                gap: 1rem !important;
            }

            .flex.justify-center.space-x-20.mt-4 button {
                padding: 0.5rem 1rem !important;
                font-size: 1rem !important;
            }

            /* 字符网格优化 - 确保显示3行，去掉滚动条 */
            #charactersGrid {
                grid-template-rows: repeat(3, 1fr) !important;
                gap: 0.25rem !important;
                min-height: auto !important;
                max-height: none !important;
                overflow: visible !important;
                padding: 4px !important;
            }

            /* 汉字选择区域容器优化 */
            .paper-effect.p-3.rounded-lg.shadow-md.border.border-secondary\/30 {
                overflow: visible !important;
                max-height: none !important;
            }

            /* 游戏消息区域移动端优化 */
            #gameMessage {
                width: 95vw !important;
                top: 50% !important;
                left: 50% !important;
            }

            #gameMessage .glass-card-strong {
                padding: 1rem !important;
            }

            #correctAnswer {
                font-size: 2rem !important; /* 移动端适中大小 */
                padding: 0.75rem !important;
            }
        }

        /* 超小屏幕进一步优化 */
        @media (max-width: 480px) {
            .character-btn {
                padding: 0.375rem !important;
                font-size: 1.125rem !important;
            }

            #poemDisplay {
                font-size: 1.125rem !important;
                height: 2.25rem !important;
                line-height: 2.25rem !important;
                overflow: hidden !important;
                white-space: nowrap !important;
            }

            .font-title {
                font-size: 1.25rem !important;
            }
        }

        /* 现代化动画效果 */
        @keyframes slideUp {
            0% { 
                transform: translateY(20px);
                opacity: 0;
            }
            100% { 
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes bounceGentle {
            0%, 100% { 
                transform: translateY(0); 
            }
            50% { 
                transform: translateY(-4px); 
            }
        }

        @keyframes pulseModern {
            0%, 100% { 
                transform: scale(1);
                opacity: 1;
            }
            50% { 
                transform: scale(1.03);
                opacity: 0.9;
            }
        }

        /* 浮窗专用动画 */
        @keyframes modalSlideIn {
            0% { 
                transform: translate(-50%, -50%) scale(0.9);
                opacity: 0;
            }
            100% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
        }

        @keyframes modalSlideOut {
            0% { 
                transform: translate(-50%, -50%) scale(1);
                opacity: 1;
            }
            100% { 
                transform: translate(-50%, -50%) scale(0.9);
                opacity: 0;
            }
        }

        /* 玻璃拟态效果 */
        .glass-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }

        .glass-card-strong {
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
        }

        /* 設置模態窗口 - 現代玻璃擬態與更高對比 */
        .glass-modal {
            background: linear-gradient(180deg, rgba(255,255,255,0.94), rgba(255,255,255,0.88));
            backdrop-filter: blur(24px) saturate(120%);
            -webkit-backdrop-filter: blur(24px) saturate(120%);
            border: 1px solid rgba(0, 0, 0, 0.06);
            box-shadow: 0 25px 60px rgba(0, 0, 0, 0.18);
        }

        /* 自定义滚动条样式 - 适配低透明度背景 */
        .custom-scrollbar {
            scrollbar-width: thin;
            scrollbar-color: rgba(0, 0, 0, 0.3) transparent;
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: transparent;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            border: 2px solid transparent;
            background-clip: content-box;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(0, 0, 0, 0.4);
            background-clip: content-box;
        }

        /* 现代化按钮效果 */
        .modern-button {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(0);
        }

        .modern-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.15);
        }

        .modern-button:active {
            transform: translateY(0);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        /* 字符按钮现代化 */
        .char-modern {
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(0, 0, 0, 0.1);
        }

        .char-modern:hover {
            transform: translateY(-4px) scale(1.02);
            box-shadow: 0 16px 32px rgba(0, 0, 0, 0.12);
            background: rgba(255, 255, 255, 0.95);
        }

        /* 渐变背景 */
        .gradient-bg {
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 50%, #f0f9ff 100%);
        }

        .gradient-primary {
            background: linear-gradient(135deg, #0ea5e9 0%, #38bdf8 100%);
        }

        .gradient-secondary {
            background: linear-gradient(135deg, #22c55e 0%, #4ade80 100%);
        }

        .gradient-accent {
            background: linear-gradient(135deg, #8b5cf6 0%, #a78bfa 100%);
        }

        /* AI 解讀專用樣式，與主按鈕色系區分且協調 */
        .ai-explain-button {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%);
            color: #111827;
        }
        .ai-explain-button:hover { filter: brightness(1.05); }
        .ai-explain-loading { opacity: 0.7; pointer-events: none; }

        /* AI 內容美化 */
        .ai-section {
            border-radius: 1rem;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.6);
            backdrop-filter: blur(14px);
            padding: 12px 14px;
        }
        .ai-title {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-weight: 700;
            font-size: 0.9rem;
            color: #0f172a;
            background: linear-gradient(135deg, #e0f2fe, #fae8ff);
            border: 1px solid rgba(255,255,255,0.6);
            border-radius: 999px;
            padding: 4px 10px;
            margin-bottom: 8px;
        }
        .ai-body { color: #0f172a; line-height: 1.7; font-size: 0.95rem; }
        .ai-poem-block {
            white-space: pre-wrap;
            font-family: ui-serif, Georgia, "Noto Serif CJK TC", serif;
            font-size: 1rem;
            color: #0f172a;
            background: rgba(255,255,255,0.75);
            border: 1px dashed rgba(15,23,42,0.2);
            border-radius: 0.75rem;
            padding: 10px 12px;
        }
        .ai-highlight {
            background: linear-gradient(180deg, rgba(250,204,21,0.45), rgba(250,204,21,0.15));
            border-radius: 8px;
            padding: 0 4px;
            font-weight: 800;
            color: #92400e;
        }
        .ai-toggle {
            margin-top: 8px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 0.85rem;
            color: #0f172a;
            background: rgba(255,255,255,0.7);
            border: 1px solid rgba(255,255,255,0.6);
            border-radius: 999px;
            padding: 6px 10px;
        }

        /* AI 載入動畫 */
        @keyframes aiSpin { to { transform: rotate(360deg); } }
        .ai-loading-wrap { display: flex; flex-direction: column; align-items: center; justify-content: center; padding: 18px 0; }
        .ai-spinner {
            width: 28px; height: 28px; border-radius: 9999px;
            border: 3px solid rgba(15,23,42,0.15);
            border-top-color: #8b5cf6; /* 與 accent 協調 */
            animation: aiSpin 1s linear infinite;
        }
        .ai-loading-text { margin-top: 10px; font-size: 0.9rem; color: #334155; }

        /* 對戰結果窗口美化 */
        #battleResultModal .winner-card {
            position: relative;
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.22), rgba(255, 165, 0, 0.12));
            border: 2px solid rgba(255, 215, 0, 0.6);
            box-shadow: 0 12px 32px rgba(212, 163, 0, 0.25);
            overflow: hidden;
        }
        #battleResultModal .winner-card::after {
            content: "";
            position: absolute;
            left: -60%;
            top: -50%;
            width: 60%;
            height: 200%;
            transform: rotate(25deg);
            background: linear-gradient(90deg, rgba(255,255,255,0.0), rgba(255,255,255,0.35), rgba(255,255,255,0.0));
            animation: winnerShine 2.6s ease-in-out infinite;
        }
        @keyframes winnerShine {
            0% { left: -60%; }
            60% { left: 120%; }
            100% { left: 120%; }
        }

        #battleResultModal .rank-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem 1rem;
            border-radius: 0.9rem;
            background: rgba(255, 255, 255, 0.92);
            border: 1px solid rgba(17, 24, 39, 0.08);
            box-shadow: 0 12px 24px rgba(0,0,0,0.12);
            opacity: 0;
            transform: translateY(10px);
            animation: slideIn 540ms ease-out forwards;
        }

        #battleResultModal .rank-item:hover {
            transform: translateY(0) scale(1.01);
            box-shadow: 0 16px 28px rgba(0,0,0,0.14);
        }

        #battleResultModal .rank-medal { font-size: 1.25rem; }
        #battleResultModal .rank-name { color: #0f172a; font-weight: 700; }
        #battleResultModal .rank-score { margin-left: auto; font-weight: 800; color: #0f172a; }

        @keyframes slideIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Ma+Shan+Zheng&display=swap" rel="stylesheet">
    <style>
        @font-face {
            font-family: 'XiqueGuZiDian';
            src: url('https://chineseclassics.github.io/files/fonts/%E5%96%9C%E9%B9%8A%E5%8F%A4%E5%AD%97%E5%85%B8%E4%BD%93(%E7%AE%80+%E7%B9%81%E4%BD%93).ttf') format('truetype');
            font-display: swap;
        }
        @font-face {
            font-family: 'HuaKangGuJiMiLiuGBK';
            src: url('https://chineseclassics.github.io/files/fonts/%E5%8D%8E%E5%BA%B7%E5%8F%A4%E7%B1%8D%E7%B3%B8%E6%9F%B3GBK.TTF') format('truetype');
            font-display: swap;
        }
        .font-xique-guzidian {
            font-family: 'XiqueGuZiDian', serif;
        }
        .font-huakang-miliu {
            font-family: 'HuaKangGuJiMiLiuGBK', serif;
        }
        .font-ma-shan-zheng {
            font-family: 'Ma Shan Zheng', cursive;
        }
    </style>
</head>
<body class="font-modern gradient-bg" style="margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; display: flex; flex-direction: column;">
    <div class="max-w-5xl mx-auto" style="height: 100%; width: 100%; display: flex; flex-direction: column; padding: 6px; box-sizing: border-box; position: relative;">
        <!-- 選手積分顯示區域（左右兩側固定） -->
        <div id="battleScoreboard" class="hidden z-10">
            <!-- 左側選手積分（固定在左） -->
            <div id="leftPlayers" class="fixed left-2 top-1/2 -translate-y-1/2 flex flex-col space-y-2 w-40"></div>
            
            <!-- 右側選手積分（固定在右） -->
            <div id="rightPlayers" class="fixed right-2 top-1/2 -translate-y-1/2 flex flex-col space-y-2 w-40"></div>
        </div>
        <div class="flex justify-between items-center mb-3">
            <!-- 左侧得分/輪次显示 - 现代化 -->
            <div class="glass-card p-3 sm:p-4 rounded-2xl flex items-center animate-slide-up modern-button" style="animation-delay:40ms">
                <span id="scoreLabel" class="font-modern text-sm sm:text-base text-surface-800 font-medium">分數</span>
                <span id="score" class="text-2xl sm:text-4xl font-bold text-primary-500 ml-2 sm:ml-3">0</span>
            </div>
            
            <!-- 中间标题 - 现代化 -->
            <div class="flex-grow flex flex-col items-center justify-center mx-3 relative animate-slide-up" style="animation-delay:80ms">
                <!-- 游戏标题 -->
                <div class="flex-grow flex items-center justify-center">
                    <h1 class="text-3xl sm:text-4xl text-black font-huakang-miliu font-black leading-none" style="text-shadow: 1px 1px 3px rgba(255,255,255,0.2);">南風詩詞組句</h1>
                </div>
                
                <!-- 副标题 -->
                <div class="text-xs text-surface-800/70 mt-1 font-modern tracking-wide">
                    中文經典AI實驗室
                </div>
            </div>
            
            <!-- 右侧倒计时 - 现代化 -->
            <div class="glass-card-strong p-3 sm:p-4 rounded-2xl flex items-center animate-slide-up modern-button gradient-accent" style="animation-delay:120ms">
                <span id="timer" class="text-2xl sm:text-4xl font-bold text-white font-modern">30</span>
                <span class="font-modern text-sm sm:text-base text-white/90 ml-1 font-medium">秒</span>
            </div>
        </div>
        
        <!-- 倒計時進度條 - 现代化 -->
        <div id="timeBarContainer" class="w-full h-3 bg-surface-200 rounded-full overflow-hidden mb-3 animate-scale-in shadow-inner">
            <div id="timeBarFill" class="h-full gradient-primary rounded-full transition-all duration-300 ease-out" style="width: 100%"></div>
        </div>
        
        <div class="flex items-center justify-end space-x-3 mb-2">
            <div id="difficultySelector" class="inline-block glass-card px-3 py-2 rounded-xl hidden animate-slide-up">
                <span class="font-modern text-xs text-surface-800 mr-2 font-medium">難度：</span>
                <select id="difficultySelect" class="bg-white/90 rounded-lg px-3 py-1 text-xs border-none focus:ring-2 focus:ring-primary-400 font-modern">
                    <option value="easy">簡單</option>
                    <option value="medium" selected>中等</option>
                    <option value="hard">困難</option>
                </select>
            </div>
            <button id="soundToggle" class="glass-card hover:glass-card-strong text-surface-800 px-3 py-2 rounded-xl text-xs flex items-center modern-button font-modern">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3 mr-1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" />
                </svg>
                音效開
            </button>
            <button id="adminModeToggle" class="glass-card hover:glass-card-strong text-surface-800 px-3 py-2 rounded-xl text-xs flex items-center modern-button font-modern">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-3 h-3 mr-1.5">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.324.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128c-.331.183-.581.495-.644.869l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281c-.062-.374-.312-.686-.644-.87a6.52 6.52 0 01-.22-.127c-.325-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.751.072 1.076-.124.072-.044.146-.087.22-.128.332-.183.582-.495.644-.869l.214-1.281z" />
                    <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                </svg>
                設置
            </button>
        </div>
        
        <!-- 對戰結束總結窗口 -->
        <div id="battleResultModal" class="fixed inset-0 z-50 hidden backdrop-blur-sm bg-surface-900/30 flex items-center justify-center animate-slide-up">
            <div class="glass-modal rounded-3xl shadow-2xl w-[min(500px,90vw)] max-h-[85vh] border border-white/20 animate-scale-in flex flex-col overflow-hidden">
                <!-- 窗口標題 -->
                <div class="flex justify-center items-center p-6 border-b border-white/20 gradient-primary rounded-t-3xl flex-shrink-0">
                    <h2 class="text-2xl font-modern font-bold text-white">🏆 對戰結果</h2>
                </div>
                
                <!-- 可滚动内容区域 -->
                <div class="overflow-y-auto custom-scrollbar flex-grow p-6">
                    <!-- 获胜者卡片 -->
                    <div id="winnerCard" class="winner-card p-6 rounded-2xl text-center mb-6 transform transition-all duration-500 hover:scale-105">
                        <div class="text-2xl font-modern font-black mb-2 text-surface-900" id="winnerAnnouncement"></div>
                        <div class="text-lg font-modern font-semibold text-surface-700" id="winnerScore"></div>
                    </div>
            
                    <!-- 选手排行榜 -->
                    <div>
                        <h3 class="text-xl font-modern font-bold mb-4 text-center text-surface-900">📊 最終排行榜</h3>
                        <div id="battleRankings" class="space-y-3">
                            <!-- 排行榜将由JavaScript动态生成 -->
                        </div>
                    </div>
                </div>
                
                <!-- 底部按鈕 -->
                <div class="flex justify-center space-x-4 p-6 border-t border-white/20 glass-card rounded-b-3xl flex-shrink-0">
                    <button id="newBattleBtn" class="gradient-primary text-white px-6 py-3 rounded-xl font-modern font-semibold shadow-md modern-button transform transition-transform hover:scale-105">
                        🔄 再來一局
                    </button>
                    <button id="exitBattleBtn" class="glass-card text-surface-800 px-6 py-3 rounded-xl font-modern font-semibold border border-white/30 modern-button transform transition-transform hover:scale-105">
                        🏠 回到單人模式
                    </button>
                </div>
            </div>
        </div>

        <!-- 設置模態彈窗 -->
        <div id="settingsModal" class="fixed inset-0 z-50 hidden backdrop-blur-sm bg-surface-900/30 flex items-center justify-center animate-slide-up">
            <div class="glass-modal rounded-3xl shadow-2xl w-[min(600px,90vw)] max-h-[85vh] border border-white/20 animate-scale-in flex flex-col overflow-hidden">
                <!-- 彈窗標題 -->
                <div class="flex justify-between items-center p-6 border-b border-white/20 gradient-primary rounded-t-3xl flex-shrink-0">
                    <h2 class="text-2xl font-modern font-bold text-white">⚙️ 遊戲設置</h2>
                    <button id="closeSettingsModal" class="text-white/80 hover:text-white text-2xl font-bold transform transition-transform hover:scale-110">&times;</button>
                </div>
                
                <!-- 可滚动内容区域 -->
                <div class="overflow-y-auto custom-scrollbar flex-grow">
                    <!-- 設置內容 -->
                    <div class="p-6 space-y-6">
                        <!-- 1. 遊戲模式選擇 -->
                        <div class="glass-card rounded-2xl p-4 border border-white/10">
                            <h3 class="text-lg font-modern font-semibold text-surface-800 mb-3">🎮 遊戲模式</h3>
                            <div class="space-y-2">
                                <label class="flex items-center space-x-3 cursor-pointer">
                                    <input type="radio" name="gameMode" value="single" checked class="text-primary focus:ring-primary">
                                    <span class="font-modern">單人模式</span>
                                </label>
                                <label class="flex items-center space-x-3 cursor-pointer">
                                    <input type="radio" name="gameMode" value="battle" class="text-primary focus:ring-primary">
                                    <span class="font-modern">對戰模式</span>
                                </label>
                            </div>
            
                            <!-- 1.1 對戰模式設置（緊跟在遊戲模式後） -->
                            <div id="battleModeSettings" class="mt-4 pt-4 border-t border-white/20 hidden">
                                <h4 class="text-md font-modern font-semibold text-surface-700 mb-3">🏆 對戰設置</h4>
                                <div class="space-y-4">
                                    <div class="flex items-center justify-between">
                                        <span class="font-modern text-sm text-surface-800">選手數量：</span>
                                        <select id="playerCount" class="glass-card rounded-lg px-3 py-1 border border-white/30 focus:ring-2 focus:ring-primary text-sm font-modern">
                                            <option value="2" selected>2名選手</option>
                                            <option value="3">3名選手</option>
                                            <option value="4">4名選手</option>
                                            <option value="5">5名選手</option>
                                            <option value="6">6名選手</option>
                                        </select>
                                    </div>
                                    <div id="playerNamesContainer" class="grid grid-cols-1 sm:grid-cols-2 gap-3">
                                        <!-- 選手名稱輸入框將由JavaScript動態生成 -->
                                    </div>
                                    <div class="flex items-center justify-between gap-3">
                                        <label for="roundsPerPlayer" class="font-modern text-sm text-surface-800">每輪題目數：</label>
                                        <input id="roundsPerPlayer" type="number" min="1" max="50" value="5" class="glass-card rounded-lg px-3 py-1 border border-white/30 focus:ring-2 focus:ring-primary text-sm font-modern w-28" />
                                    </div>
                                    <div class="flex items-center justify-between gap-3">
                                        <label for="speedMode" class="font-modern text-sm text-surface-800">速度模式（答題越快得分越高）</label>
                                        <input id="speedMode" type="checkbox" class="w-5 h-5 accent-blue-600" />
                                    </div>
                                </div>
                            </div>
                        </div>
            
                        <!-- 2. 詩詞庫選擇 -->
                        <div class="glass-card rounded-2xl p-4 border border-white/10">
                            <h3 class="text-lg font-modern font-semibold text-surface-800 mb-3">📚 詩詞庫（標籤）</h3>
                            <div class="space-y-3">
                                <div class="flex items-center gap-3">
                                    <label class="text-sm font-modern text-surface-800">選擇詩詞庫：</label>
                                    <select id="userLibraryTagSelect" class="glass-card rounded-lg px-3 py-1 border border-white/30 focus:ring-2 focus:ring-primary text-sm font-modern"></select>
                                </div>
                                <div class="flex flex-wrap gap-2">
                                    <button id="exportExcelBtn" class="glass-card text-surface-800 px-3 py-1.5 rounded-lg modern-button text-sm border border-white/30">導出 Excel</button>
                                    <button id="importExcelBtn" class="gradient-secondary text-white px-3 py-1.5 rounded-lg modern-button text-sm">導入 Excel</button>
                                    <input id="importExcelInput" type="file" accept=".xlsx,.xls,.csv" class="hidden" />
                                </div>
                                <p class="text-xs text-surface-600">提示：Excel 模板欄位為 line（詩句）、author（作者）、poem（詩名）、tags（可用中文分號「；」或中文逗號「，」分隔；亦支援多列 tag1、tag2...）。</p>
                            </div>
                        
                            
                        </div>
            
                        <!-- 3. 遊戲難度設置 -->
                        <div class="glass-card rounded-2xl p-4 border border-white/10">
                            <h3 class="text-lg font-modern font-semibold text-surface-800 mb-3">⚙️ 遊戲難度</h3>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-5">
                                <div class="p-3 rounded-xl bg-gradient-to-br from-white/80 to-blue-50 border border-gray-200 backdrop-blur-sm shadow-sm hover:shadow-md hover:ring-1 hover:ring-blue-200 transition">
                                    <label class="flex items-center justify-between text-sm font-modern font-medium mb-2 text-surface-800">
                                        <span>⏱️ 時間限制</span>
                                        <span class="inline-flex items-center gap-1">
                                            <span id="timeLimitValue" class="font-semibold text-blue-600">30</span>
                                            <span class="text-xs text-surface-600">秒</span>
                                        </span>
                                    </label>
                                    <input type="range" id="timeLimit" min="10" max="60" step="5" value="30" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500">
                                    <div class="flex justify-between mt-1 text-sm text-surface-600">
                                        <span>10</span>
                                        <span>60</span>
                                    </div>
                                </div>
                                <div class="p-3 rounded-xl bg-gradient-to-br from-white/80 to-emerald-50 border border-gray-200 backdrop-blur-sm shadow-sm hover:shadow-md hover:ring-1 hover:ring-emerald-200 transition">
                                    <label class="flex items-center justify-between text-sm font-modern font-medium mb-2 text-surface-800">
                                        <span>🔣 待選字數量</span>
                                        <span class="inline-flex items-center gap-1">
                                            <span id="charCountValue" class="font-semibold text-emerald-600">20</span>
                                            <span class="text-xs text-surface-600">字</span>
                                        </span>
                                    </label>
                                    <input type="range" id="charCount" min="10" max="30" step="5" value="20" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-emerald-500">
                                    <div class="flex justify-between mt-1 text-sm text-surface-600">
                                        <span>10</span>
                                        <span>30</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- 彈窗底部按鈕 -->
                <div class="flex justify-end items-center p-6 border-t border-white/20 glass-card rounded-b-3xl flex-shrink-0">
                    <div class="flex space-x-3">
                        <button id="cancelSettings" class="glass-card text-surface-800 px-6 py-3 rounded-xl font-modern font-semibold border border-white/30 modern-button transform transition-transform hover:scale-105">
                            取消
                        </button>
                        <button id="saveSettings" class="gradient-primary text-white px-6 py-3 rounded-xl font-modern font-semibold shadow-md modern-button transform transition-transform hover:scale-105">
                            保存設置
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- 對戰模式開場預覽 -->
        <div id="battlePreviewModal" class="fixed inset-0 z-50 hidden backdrop-blur-sm bg-surface-900/40 flex items-center justify-center animate-slide-up">
            <div class="glass-modal rounded-3xl shadow-2xl w-[min(640px,92vw)] max-h-[88vh] border border-white/20 animate-scale-in flex flex-col overflow-hidden">
                <div class="flex justify-between items-center p-6 border-b border-white/20 gradient-accent rounded-t-3xl flex-shrink-0">
                    <div>
                        <h2 class="text-2xl font-modern font-bold text-white">⚔️ 對戰即將開始</h2>
                        <p class="text-sm text-white/80 mt-1 font-modern">確認參賽資訊，準備華麗的詩詞對決</p>
                    </div>
                    <button id="battlePreviewClose" class="text-white/80 hover:text-white text-2xl font-bold transform transition-transform hover:scale-110">&times;</button>
                </div>
                <div class="overflow-y-auto custom-scrollbar flex-grow p-6 space-y-5">
                    <div class="grid gap-4 md:grid-cols-2">
                        <div class="glass-card rounded-2xl p-4 border border-white/15 shadow-sm">
                            <h3 class="text-sm font-modern text-surface-600 mb-2">參賽隊伍</h3>
                            <div class="flex items-center gap-2">
                                <span class="text-3xl font-bold text-primary-600" id="battlePreviewPlayerCount">0</span>
                                <span class="text-sm font-modern text-surface-700">位選手輪流應戰</span>
                            </div>
                        </div>
                        <div class="glass-card rounded-2xl p-4 border border-white/15 shadow-sm">
                            <h3 class="text-sm font-modern text-surface-600 mb-2">每位題數</h3>
                            <div class="flex items-center gap-2">
                                <span class="text-3xl font-bold text-secondary-600" id="battlePreviewRounds">0</span>
                                <span class="text-sm font-modern text-surface-700">題／選手</span>
                            </div>
                        </div>
                    </div>
                    <div class="grid gap-4 md:grid-cols-2">
                        <div class="glass-card rounded-2xl p-4 border border-white/15 shadow-sm">
                            <h3 class="text-sm font-modern text-surface-600 mb-2">總題數</h3>
                            <div class="flex items-center gap-2">
                                <span class="text-3xl font-bold text-amber-600" id="battlePreviewTotalQuestions">0</span>
                                <span class="text-sm font-modern text-surface-700">題即將出題</span>
                            </div>
                        </div>
                        <div class="glass-card rounded-2xl p-4 border border-white/15 shadow-sm">
                            <h3 class="text-sm font-modern text-surface-600 mb-2">回合設定</h3>
                            <div class="space-y-1 text-sm font-modern text-surface-700">
                                <div>答題時限：<span class="font-semibold text-surface-900" id="battlePreviewTimeLimit">0 秒</span></div>
                                <div>待選字數：<span class="font-semibold text-surface-900" id="battlePreviewCharCount">0 字</span></div>
                            </div>
                        </div>
                    </div>
                    <div class="glass-card rounded-2xl p-4 border border-white/15 shadow-md">
                        <div class="flex items-center justify-between mb-3">
                            <h3 class="text-base font-modern font-semibold text-surface-800">參賽名單</h3>
                            <span class="text-xs text-surface-500 font-modern">將依次上場答題</span>
                        </div>
                        <div id="battlePreviewPlayersList" class="grid gap-3 sm:grid-cols-2"></div>
                    </div>
                    <div id="battlePreviewSpeedRow" class="glass-card rounded-2xl p-4 border border-accent-200/60 bg-accent-50 shadow-inner hidden">
                        <h3 class="text-base font-modern font-semibold text-accent-700 mb-2">⏱️ 速度模式加分</h3>
                        <p id="battlePreviewSpeedText" class="text-sm font-modern text-accent-700"></p>
                    </div>
                    <div class="glass-card rounded-2xl p-4 border border-white/15">
                        <h3 class="text-base font-modern font-semibold text-surface-800 mb-2">對戰提示</h3>
                        <p id="battlePreviewNote" class="text-sm font-modern text-surface-600 leading-relaxed"></p>
                    </div>
                </div>
                <div class="flex justify-between items-center p-6 border-t border-white/20 glass-card rounded-b-3xl flex-shrink-0">
                    <button id="battlePreviewBack" class="glass-card text-surface-800 px-5 py-2.5 rounded-xl font-modern font-semibold border border-white/30 modern-button transform transition-transform hover:scale-105">返回設置</button>
                    <button id="battlePreviewStart" class="gradient-primary text-white px-6 py-3 rounded-xl font-modern font-semibold shadow-md modern-button transform transition-transform hover:scale-105">開始對戰</button>
                </div>
            </div>
        </div>

        <!-- AI 解讀模態彈窗 -->
        <div id="aiExplainModal" class="fixed inset-0 z-50 hidden backdrop-blur-sm bg-surface-900/30 flex items-center justify-center animate-slide-up">
            <div class="glass-modal rounded-3xl shadow-2xl w-[min(680px,92vw)] max-h-[85vh] border border-white/20 animate-scale-in flex flex-col overflow-hidden">
                <!-- 標題區 -->
                <div class="flex justify-between items-center p-5 border-b border-white/20 gradient-accent rounded-t-3xl flex-shrink-0">
                    <h2 class="text-xl font-modern font-bold text-white">✨ AI 解讀</h2>
                    <button id="aiExplainClose" class="text-white/90 hover:text-white text-2xl font-bold transform transition-transform hover:scale-110">&times;</button>
                </div>
                <!-- 內容區 -->
                <div class="p-5 overflow-auto space-y-4">
                    <div class="glass-card rounded-2xl p-4">
                        <div class="text-xs font-modern text-surface-800/70 mb-1">詩句</div>
                        <div id="aiExplainLine" class="text-2xl font-kai font-bold text-primary-700"></div>
                        <div id="aiExplainMeta" class="text-xs font-modern text-surface-700 mt-1"></div>
                    </div>
                    <div id="aiExplainContent" class="font-modern text-surface-800 space-y-3"></div>
                    <div id="aiExplainError" class="hidden text-red-600 text-sm font-modern"></div>
                </div>
                <!-- 底部按鈕 -->
                <div class="flex justify-end items-center gap-3 p-4 border-t border-white/20 glass-card rounded-b-3xl flex-shrink-0">
                    <button id="aiExplainReload" class="glass-card text-surface-800 px-4 py-2 rounded-xl font-modern font-semibold border border-white/30 modern-button">重新生成</button>
                    <button id="aiExplainOK" class="gradient-primary text-white px-5 py-2 rounded-xl font-modern font-semibold modern-button">關閉</button>
                </div>
            </div>
        </div>

        <!-- 诗句显示区域 - 现代化 -->
        <div class="glass-card-strong p-4 rounded-3xl mb-4 animate-slide-up" style="animation-delay:160ms">
            <!-- 题目作者信息和字数 - 同一行显示 -->
            <div class="text-center mb-5">
                <div class="inline-flex items-center space-x-6">
                    <!-- 题目作者信息 -->
                    <div id="poemHint" class="text-base md:text-lg font-kai font-bold px-5 py-3 rounded-2xl glass-card text-surface-800 transform transition-all duration-500 hover:scale-105 animate-pulse-modern modern-button"></div>
                    
                    <!-- 字数显示 -->
                    <div class="inline-flex items-center space-x-2">
                        <span id="charCountDisplay" class="text-xl font-modern font-black text-white bg-gradient-to-br from-accent-500 to-accent-600 rounded-full w-12 h-12 flex items-center justify-center shadow-lg animate-bounce-gentle modern-button"></span>
                        <span class="text-sm font-modern text-surface-800 font-semibold">字</span>
            </div>
        </div>
            </div>
            
            <!-- 诗句输入框 - 更大字体现代化 -->
            <div class="flex items-center justify-center mb-2">
                <div class="relative w-full">
                    <input id="poemDisplay" type="text" class="w-full px-4 rounded-2xl glass-card text-4xl font-kai font-bold text-center focus:outline-none text-surface-800 transition-all duration-300" readonly style="height: 4.5rem; line-height: 4.5rem; text-align-last: center;">
                    <!-- 错误图标 - 动态定位在文字右侧 -->
                    <div id="poemErrorIcon" class="hidden absolute top-1/2 transform -translate-y-1/2 pointer-events-none">
                        <div class="w-6 h-6 rounded-full bg-gradient-to-br from-red-400 to-red-600 flex items-center justify-center animate-pulse">
                            <svg class="w-3 h-3 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
                            </svg>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 答對情況：AI 解讀按鈕置於玩家答案正下方，同區塊內 -->
            <div id="aiExplainSuccessRow" class="hidden mb-3 flex justify-center">
                <button id="aiExplainBtnSuccess" class="ai-explain-button px-4 py-2 rounded-2xl font-modern font-semibold text-xs shadow-md modern-button" title="AI 解讀此句">✨ AI 解讀</button>
            </div>
            
            <!-- 游戏结果区域 - 位于诗句输入框下方 -->
            <div id="gameMessage" class="hidden mb-3">
                <div class="glass-card p-3 rounded-2xl text-center border border-white/20 backdrop-blur-lg">
                    <!-- 正确答案显示 -->
                    <div id="correctAnswer" class="hidden mb-2">
                        <div class="text-xs font-modern text-surface-800/60 mb-2">正確答案</div>
                        <div id="correctAnswerText" class="text-4xl font-kai font-bold text-primary-600 py-2 px-3 glass-card rounded-xl"></div>
                        <!-- 答錯情況：AI 解讀按鈕置於正確詩句正下方，同區塊內 -->
                        <div id="aiExplainFailRow" class="hidden mt-2 flex justify-center">
                            <button id="aiExplainBtnFail" class="ai-explain-button px-4 py-2 rounded-2xl font-modern font-semibold text-xs shadow-md modern-button" title="AI 解讀此句">✨ AI 解讀</button>
                        </div>
                    </div>
                    
                    <!-- 成功时只显示图标，不显示额外文字 -->
                    <div id="successIcon" class="hidden mb-3">
                        <div class="w-12 h-12 mx-auto rounded-full gradient-secondary flex items-center justify-center">
                            <svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
                            </svg>
                        </div>
                    </div>
                    
                    <!-- 下一轮按钮 -->
                    <button id="closeGameMessage" class="gradient-primary text-white px-8 py-3 rounded-2xl font-modern font-semibold text-sm shadow-lg modern-button next-round-button">
                        下一輪
                    </button>
                </div>
            </div>
            
            <div id="selectionStatus" class="text-right text-xs text-surface-800/70 font-modern font-medium">已選 0 / 0</div>
        </div>
        
        <!-- 汉字选择区域 - 现代化 -->
        <div class="glass-card-strong rounded-3xl p-4 animate-slide-up" style="flex: 1; min-height: 0; display: flex; flex-direction: column; max-height: none; overflow: visible; animation-delay:200ms">
            <h2 class="text-sm font-modern font-semibold mb-3 text-surface-800 animate-slide-up" style="flex-shrink: 0; animation-delay:240ms">點選漢字組成詩句</h2>
            <div id="charactersGrid" class="grid grid-cols-5 gap-3" style="flex: 1; overflow: visible; padding: 8px; display: grid; align-content: start; max-height: none;">
                <!-- Characters will be inserted here by JavaScript -->
            </div>
            
            <!-- 现代化按钮布局 -->
            <div class="flex justify-center space-x-8 mt-4" style="flex-shrink: 0;">
                <button id="clearSelection" class="gradient-secondary text-white px-6 py-3 rounded-2xl font-modern font-semibold text-sm shadow-lg modern-button animate-slide-up" style="animation-delay:280ms">退一字</button>
                <button id="submitPoem" class="gradient-primary text-white px-8 py-3 rounded-2xl font-modern font-semibold text-sm shadow-lg modern-button animate-slide-up" style="animation-delay:320ms">提交</button>
            </div>
        </div>
        
        <!-- Custom notification element - 现代化 -->
        <div id="notification" class="fixed top-6 right-6 left-6 transform transition-all duration-500 ease-out translate-y-[-150%] z-50">
            <div class="max-w-md mx-auto glass-card-strong border border-white/30 shadow-2xl p-4 rounded-2xl animate-slide-up">
                <div class="flex items-center">
                    <div class="text-accent-500 flex-shrink-0">
                        <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd" />
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p id="notificationText" class="text-sm text-surface-800 font-modern font-medium"></p>
                    </div>
                    <div class="ml-auto pl-3">
                        <button id="closeNotification" class="text-surface-800/60 hover:text-surface-800 focus:outline-none modern-button">
                            <svg class="h-5 w-5" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" fill="currentColor">
                                <path fill-rule="evenodd" d="M4.293 4.293a1 1 0 011.414 0L10 8.586l4.293-4.293a1 1 0 111.414 1.414L11.414 10l4.293 4.293a1 1 0 01-1.414 1.414L10 11.414l-4.293 4.293a1 1 0 01-1.414-1.414L8.586 10 4.293 5.707a1 1 0 010-1.414z" clip-rule="evenodd" />
                            </svg>
                        </button>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // 檢測iframe環境並優化布局
        function optimizeForIframe() {
            // 檢測是否在iframe中
            const inIframe = window.parent !== window;
            
            if (inIframe) {
                // 確保body使用實際的iframe尺寸
                const updateBodySize = () => {
                    const body = document.body;
                    const width = window.innerWidth;
                    const height = window.innerHeight;
                    
                    // 強制設置精確尺寸
                    body.style.width = width + 'px';
                    body.style.height = height + 'px';
                    body.style.maxWidth = width + 'px';
                    body.style.maxHeight = height + 'px';
                    body.style.overflow = 'hidden';
                    
                    // 確保沒有多餘的邊距
                    body.style.margin = '0';
                    body.style.padding = '0';
                };
                
                // 初始設置
                updateBodySize();
                
                // 監聽窗口大小變化
                window.addEventListener('resize', updateBodySize);
                window.addEventListener('orientationchange', () => {
                    setTimeout(updateBodySize, 100);
                });
            }
        }

        // ===== Local Storage 工具與鍵名 =====
        const LS_KEYS = {
            settings: 'sczj_settings_v1',
            userLibrary: 'sczj_user_library_v1',
            activeTag: 'sczj_active_library_tag_v1'
        };

        function lsSafeParse(json, fallback) {
            try { return JSON.parse(json); } catch { return fallback; }
        }

        function loadSettings() {
            const raw = localStorage.getItem(LS_KEYS.settings);
            return lsSafeParse(raw, {
                gameMode: 'single',
                poemDatabase: 'default',
                timeLimit: 30,
                charCount: 20,
                difficulty: 'medium',
                soundOn: true,
                battle: { playerCount: 2, roundsPerPlayer: 5, speedMode: false, playerNames: [] }
            });
        }

        function persistSettings(settings) {
            localStorage.setItem(LS_KEYS.settings, JSON.stringify(settings));
        }

        

        // 用戶庫（統一的 poems 陣列）與標籤
        function loadUserLibrary() {
            const raw = localStorage.getItem(LS_KEYS.userLibrary);
            const data = lsSafeParse(raw, { poems: [] });
            return (data && Array.isArray(data.poems)) ? data : { poems: [] };
        }
        function saveUserLibrary(data) {
            localStorage.setItem(LS_KEYS.userLibrary, JSON.stringify(data));
        }
        function loadActiveTag() {
            return localStorage.getItem(LS_KEYS.activeTag) || '';
        }
        function saveActiveTag(tag) {
            localStorage.setItem(LS_KEYS.activeTag, tag || '');
        }

        // 導出/導入工具
        function computePoemStableId(poem) {
            const a = (poem.author || '').trim().toLowerCase();
            const b = (poem.poem || '').trim().toLowerCase();
            const c = (poem.line || '').trim().toLowerCase();
            return `${a}|${b}|${c}`;
        }
        function normalizePoem(poem) {
            return {
                line: String(poem.line || '').trim(),
                author: String(poem.author || '').trim(),
                poem: String(poem.poem || '').trim(),
                tags: Array.isArray(poem.tags)
                    ? poem.tags.map(t => String(t).trim()).filter(Boolean)
                    : []
            };
        }
        function mergePoemsUnique(list) {
            const map = new Map();
            list.forEach(p0 => {
                const p = normalizePoem(p0);
                if (!p.line || !p.author || !p.poem) return;
                const id = computePoemStableId(p);
                if (!map.has(id)) {
                    map.set(id, { ...p, tags: [...new Set(p.tags)] });
                } else {
                    const old = map.get(id);
                    // 以新內容為準（便於外部用 Excel/JSON 修訂）
                    const merged = {
                        line: p.line || old.line,
                        author: p.author || old.author,
                        poem: p.poem || old.poem,
                        tags: Array.from(new Set([...(old.tags||[]), ...(p.tags||[])]))
                    };
                    map.set(id, merged);
                }
            });
            return Array.from(map.values());
        }
        function buildExportPoems() {
            return mergePoemsUnique(getAllPoemsUnified());
        }
        function downloadBlob(filename, blob) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url; a.download = filename;
            document.body.appendChild(a); a.click(); a.remove();
            URL.revokeObjectURL(url);
        }
        function exportAsExcel() {
            const poems = buildExportPoems();
            const rows = poems.map(p => ({
                line: p.line,
                author: p.author,
                poem: p.poem,
                tags: (p.tags || []).join('；')
            }));
            const ws = XLSX.utils.json_to_sheet(rows);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'poems');
            const wbout = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
            const blob = new Blob([wbout], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            downloadBlob('poems-export.xlsx', blob);
        }
        // JSON 導入/導出已移除
        function importFromExcelFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const ws = workbook.Sheets[sheetName];
                    const rows = XLSX.utils.sheet_to_json(ws, { defval: '' });
                    const incoming = rows.map(r => {
                        // 支援多種分隔：中文分號、中文逗號、頓號、英文分號/逗號、換行、空白
                        const rawTags = [];
                        const cell = (r.tags ?? '').toString();
                        if (cell) rawTags.push(...cell.split(/[；;，,、\n\r\t ]+/));
                        // 支援多列 tag1, tag2, 標籤1, 標籤2 ...
                        Object.keys(r).forEach(k => {
                            const kNorm = String(k).toLowerCase();
                            if (/^tag\d+$/.test(kNorm) || /^標籤\d+$/.test(k)) {
                                const v = (r[k] ?? '').toString().trim();
                                if (v) rawTags.push(v);
                            }
                        });
                        const tags = rawTags.map(s => s.trim()).filter(Boolean);
                        return normalizePoem({
                            line: r.line,
                            author: r.author,
                            poem: r.poem,
                            tags
                        });
                    });
                    // 覆蓋模式：以本次 Excel 的內容完全替換用戶庫
                    const replaced = mergePoemsUnique(incoming);
                    saveUserLibrary({ poems: replaced });
                    populateUserTagSelect();
                    showNotification(`已導入 ${incoming.length} 首詩（Excel）`);
                } catch (e) {
                    alert('Excel 導入失敗：' + e.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // 已移除暗色模式自動切換，統一使用亮色主題
        
        // 音效管理類
        class SoundManager {
            constructor() {
                this.audioContext = null;
                this.isMuted = false;
                this.sounds = {};
                this.init();
            }
            
            init() {
                try {
                    // 創建音頻上下文
                    window.AudioContext = window.AudioContext || window.webkitAudioContext;
                    this.audioContext = new AudioContext();
                    
                    // 創建各種音效
                    this.createSounds();
                } catch (e) {
                    console.error('Web Audio API 不支持:', e);
                }
            }
            
            createSounds() {
                // 漢字點擊音效 (古箏音色)
                this.sounds.charClick = {
                    play: () => this.playTone(600, 0.1, "triangle", 0.3)
                };
                
                // 回答正確音效 (中國傳統樂器音色)
                this.sounds.correct = {
                    play: () => {
                        // 模擬中國傳統樂器的音階
                        setTimeout(() => this.playTone(523.25, 0.15, "sine", 0.4), 0);   // C5
                        setTimeout(() => this.playTone(587.33, 0.15, "sine", 0.4), 150); // D5
                        setTimeout(() => this.playTone(659.25, 0.15, "sine", 0.4), 300); // E5
                        setTimeout(() => this.playTone(783.99, 0.3, "sine", 0.4), 450);  // G5
                    }
                };
                
                // 回答錯誤音效
                this.sounds.wrong = {
                    play: () => {
                        setTimeout(() => this.playTone(349.23, 0.2, "sine", 0.4), 0);    // F4
                        setTimeout(() => this.playTone(329.63, 0.3, "sine", 0.4), 250);  // E4
                    }
                };
                
                // 時間警告音效
                this.sounds.timeWarning = {
                    play: () => {
                        setTimeout(() => this.playTone(440, 0.1, "sine", 0.2), 0);  
                        setTimeout(() => this.playTone(440, 0.1, "sine", 0.2), 200);
                    }
                };
                
                // 時間結束音效
                this.sounds.timeUp = {
                    play: () => {
                        setTimeout(() => this.playTone(523.25, 0.15, "sawtooth", 0.3), 0);    // C5
                        setTimeout(() => this.playTone(392.00, 0.15, "sawtooth", 0.3), 200);  // G4
                        setTimeout(() => this.playTone(329.63, 0.3, "sawtooth", 0.3), 400);   // E4
                    }
                };
                
                // 按鈕點擊音效
                this.sounds.buttonClick = {
                    play: () => this.playTone(440, 0.1, "sine", 0.15)
                };
                
                // 新回合開始音效
                this.sounds.newRound = {
                    play: () => {
                        // 類似於中國傳統音樂的五聲音階 (C, D, E, G, A)
                        setTimeout(() => this.playTone(523.25, 0.15, "sine", 0.3), 0);    // C5
                        setTimeout(() => this.playTone(587.33, 0.15, "sine", 0.3), 120);   // D5
                        setTimeout(() => this.playTone(659.25, 0.15, "sine", 0.3), 240);   // E5
                        setTimeout(() => this.playTone(783.99, 0.15, "sine", 0.3), 360);   // G5
                        setTimeout(() => this.playTone(880.00, 0.3, "sine", 0.3), 480);    // A5
                    }
                };
            }
            
            // 播放音調
            playTone(frequency, duration, type = "sine", volume = 0.5) {
                if (this.isMuted || !this.audioContext) return;
                
                try {
                    // 如果音頻上下文被暫停，重啟它
                    if (this.audioContext.state === 'suspended') {
                        this.audioContext.resume();
                    }
                    
                    // 創建振盪器
                    const oscillator = this.audioContext.createOscillator();
                    oscillator.type = type;
                    oscillator.frequency.value = frequency;
                    
                    // 創建音量控制
                    const gainNode = this.audioContext.createGain();
                    gainNode.gain.value = volume;
                    
                    // 連接節點
                    oscillator.connect(gainNode);
                    gainNode.connect(this.audioContext.destination);
                    
                    // 設置衰減
                    gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
                    
                    // 播放聲音
                    oscillator.start();
                    oscillator.stop(this.audioContext.currentTime + duration);
                } catch (e) {
                    console.error('播放音效失敗:', e);
                }
            }
            
            // 切換靜音
            toggleMute() {
                this.isMuted = !this.isMuted;
                return this.isMuted;
            }
            
            // 播放指定音效
            play(soundName) {
                if (this.isMuted || !this.sounds[soundName]) return;
                this.sounds[soundName].play();
            }
        }
        
        // 創建全局音效管理器
        const soundManager = new SoundManager();

        // 小學生詩詞數據庫 - 從提供的文件中選取的經典詩句
        const elementaryPoemLines = [
            // 蘇軾作品
            { line: "荷盡已無擎雨蓋", author: "蘇軾", poem: "贈刘景文" },
            { line: "菊殘猶有傲霜枝", author: "蘇軾", poem: "贈刘景文" },
            { line: "一年好景君須記", author: "蘇軾", poem: "贈刘景文" },
            { line: "最是橙黃橘綠時", author: "蘇軾", poem: "贈刘景文" },
            
            { line: "橫看成嶺側成峰", author: "蘇軾", poem: "題西林壁" },
            { line: "遠近高低各不同", author: "蘇軾", poem: "題西林壁" },
            { line: "不識廬山真面目", author: "蘇軾", poem: "題西林壁" },
            { line: "只緣身在此山中", author: "蘇軾", poem: "題西林壁" },
            
            { line: "竹外桃花三兩枝", author: "蘇軾", poem: "惠崇春江晚景" },
            { line: "春江水暖鴨先知", author: "蘇軾", poem: "惠崇春江晚景" },
            
            { line: "欲把西湖比西子", author: "蘇軾", poem: "飲湖上初晴後雨" },
            { line: "淡妝濃抹總相宜", author: "蘇軾", poem: "飲湖上初晴後雨" },
            
            // 王安石作品
            { line: "墻角數枝梅", author: "王安石", poem: "梅花" },
            { line: "凌寒獨自開", author: "王安石", poem: "梅花" },
            { line: "遙知不是雪", author: "王安石", poem: "梅花" },
            { line: "為有暗香來", author: "王安石", poem: "梅花" },
            
            { line: "春風又綠江南岸", author: "王安石", poem: "泊船瓜洲" },
            { line: "明月何時照我還", author: "王安石", poem: "泊船瓜洲" },
            
            { line: "爆竹聲中一歲除", author: "王安石", poem: "元日" },
            { line: "春風送暖入屠蘇", author: "王安石", poem: "元日" },
            { line: "千門萬戶曈曈日", author: "王安石", poem: "元日" },
            { line: "總把新桃換舊符", author: "王安石", poem: "元日" },
            
            // 楊萬里作品
            { line: "接天蓮葉無窮碧", author: "楊萬里", poem: "晓出净慈寺送林子方" },
            { line: "映日荷花別樣紅", author: "楊萬里", poem: "晓出净慈寺送林子方" },
            
            // 陸游作品
            { line: "王師北定中原日", author: "陸游", poem: "示儿" },
            { line: "家祭無忘告乃翁", author: "陸游", poem: "示儿" },
            
            // 范成大作品
            { line: "梅子金黃杏子肥", author: "范成大", poem: "四时田园杂兴" },
            { line: "麥花雪白菜花稀", author: "范成大", poem: "四时田园杂兴" },
            
            // 邵雍作品
            { line: "一去二三里", author: "邵雍", poem: "山村咏怀" },
            { line: "煙村四五家", author: "邵雍", poem: "山村咏怀" },
            { line: "亭臺六七座", author: "邵雍", poem: "山村咏怀" },
            { line: "八九十枝花", author: "邵雍", poem: "山村咏怀" },
            
            // 朱熹作品
            { line: "等閒識得東風面", author: "朱熹", poem: "春日" },
            { line: "萬紫千紅總是春", author: "朱熹", poem: "春日" },
            
            // 林升作品
            { line: "山外青山樓外樓", author: "林升", poem: "題臨安邸" },
            { line: "西湖歌舞幾時休", author: "林升", poem: "題臨安邸" },
            { line: "暖風熏得遊人醉", author: "林升", poem: "題臨安邸" },
            { line: "直把杭州作汴州", author: "林升", poem: "題臨安邸" },
            
            // 葉紹翁作品
            { line: "春色滿園關不住", author: "葉紹翁", poem: "游园不值" },
            { line: "一枝紅杏出牆來", author: "葉紹翁", poem: "游园不值" },
            
            // 李白作品
            { line: "床前明月光", author: "李白", poem: "静夜思" },
            { line: "疑是地上霜", author: "李白", poem: "静夜思" },
            { line: "舉頭望明月", author: "李白", poem: "静夜思" },
            { line: "低頭思故鄉", author: "李白", poem: "静夜思" },
            
            { line: "李白乘舟將欲行", author: "李白", poem: "赠汪伦" },
            { line: "忽聞岸上踏歌聲", author: "李白", poem: "赠汪伦" },
            { line: "桃花潭水深千尺", author: "李白", poem: "赠汪伦" },
            { line: "不及汪倫送我情", author: "李白", poem: "赠汪伦" },
            
            { line: "天門中斷楚江開", author: "李白", poem: "望天門山" },
            { line: "碧水東流至此回", author: "李白", poem: "望天門山" },
            { line: "兩岸青山相對出", author: "李白", poem: "望天門山" },
            { line: "孤帆一片日邊來", author: "李白", poem: "望天門山" },
            
            { line: "朝辭白帝彩雲間", author: "李白", poem: "早发白帝城" },
            { line: "千里江陵一日還", author: "李白", poem: "早发白帝城" },
            { line: "兩岸猿聲啼不住", author: "李白", poem: "早发白帝城" },
            { line: "輕舟已過萬重山", author: "李白", poem: "早发白帝城" },
            
            { line: "飛流直下三千尺", author: "李白", poem: "望庐山瀑布" },
            { line: "疑是銀河落九天", author: "李白", poem: "望庐山瀑布" },
            
            // 杜甫作品
            { line: "兩個黃鸝鳴翠柳", author: "杜甫", poem: "绝句" },
            { line: "一行白鷺上青天", author: "杜甫", poem: "绝句" },
            { line: "窗含西嶺千秋雪", author: "杜甫", poem: "绝句" },
            { line: "門泊東吳萬里船", author: "杜甫", poem: "绝句" },
            
            { line: "好雨知時節", author: "杜甫", poem: "春夜喜雨" },
            { line: "當春乃發生", author: "杜甫", poem: "春夜喜雨" },
            { line: "隨風潛入夜", author: "杜甫", poem: "春夜喜雨" },
            { line: "潤物細無聲", author: "杜甫", poem: "春夜喜雨" },
            
            // 杜牧作品
            { line: "清明時節雨紛紛", author: "杜牧", poem: "清明" },
            { line: "路上行人欲斷魂", author: "杜牧", poem: "清明" },
            { line: "借問酒家何處有", author: "杜牧", poem: "清明" },
            { line: "牧童遙指杏花村", author: "杜牧", poem: "清明" },
            
            { line: "停車坐愛楓林晚", author: "杜牧", poem: "山行" },
            { line: "霜葉紅於二月花", author: "杜牧", poem: "山行" },
            
            // 李商隱作品
            { line: "夕陽無限好", author: "李商隱", poem: "登樂游原" },
            { line: "只是近黃昏", author: "李商隱", poem: "登樂游原" },
            
            // 白居易作品
            { line: "離離原上草", author: "白居易", poem: "赋得古原草送别" },
            { line: "一歲一枯榮", author: "白居易", poem: "赋得古原草送别" },
            { line: "野火燒不盡", author: "白居易", poem: "赋得古原草送别" },
            { line: "春風吹又生", author: "白居易", poem: "赋得古原草送别" },
            
            // 高適作品
            { line: "莫愁前路無知己", author: "高適", poem: "别董大" },
            { line: "天下誰人不識君", author: "高適", poem: "别董大" },
            
            // 張繼作品
            { line: "月落烏啼霜滿天", author: "張繼", poem: "枫桥夜泊" },
            { line: "江楓漁火對愁眠", author: "張繼", poem: "枫桥夜泊" },
            { line: "姑蘇城外寒山寺", author: "張繼", poem: "枫桥夜泊" },
            { line: "夜半鐘聲到客船", author: "張繼", poem: "枫桥夜泊" },
            
            // 孟郊作品
            { line: "誰言寸草心", author: "孟郊", poem: "游子吟" },
            { line: "報得三春暉", author: "孟郊", poem: "游子吟" },
            
            // 劉禹錫作品
            { line: "舊時王謝堂前燕", author: "劉禹錫", poem: "乌衣巷" },
            { line: "飛入尋常百姓家", author: "劉禹錫", poem: "乌衣巷" },
            
            // 李紳作品
            { line: "鋤禾日當午", author: "李紳", poem: "悯农" },
            { line: "汗滴禾下土", author: "李紳", poem: "悯农" },
            { line: "誰知盤中餐", author: "李紳", poem: "悯农" },
            { line: "粒粒皆辛苦", author: "李紳", poem: "悯农" },
            
            // 崔護作品
            { line: "人面不知何處去", author: "崔護", poem: "题都城南庄" },
            { line: "桃花依舊笑春風", author: "崔護", poem: "题都城南庄" },
            
            // 柳宗元作品
            { line: "千山鳥飛絕", author: "柳宗元", poem: "江雪" },
            { line: "萬徑人蹤滅", author: "柳宗元", poem: "江雪" },
            { line: "孤舟蓑笠翁", author: "柳宗元", poem: "江雪" },
            { line: "獨釣寒江雪", author: "柳宗元", poem: "江雪" },
            
            // 駱賓王作品
            { line: "鵝鵝鵝", author: "駱賓王", poem: "咏鹅" },
            { line: "曲項向天歌", author: "駱賓王", poem: "咏鹅" },
            { line: "白毛浮綠水", author: "駱賓王", poem: "咏鹅" },
            { line: "紅掌撥清波", author: "駱賓王", poem: "咏鹅" },
            
            // 賀知章作品
            { line: "碧玉妝成一樹高", author: "賀知章", poem: "咏柳" },
            { line: "萬條垂下綠絲絡", author: "賀知章", poem: "咏柳" },
            { line: "不知細葉誰裁出", author: "賀知章", poem: "咏柳" },
            { line: "二月春風似剪刀", author: "賀知章", poem: "咏柳" },
            
            // 王之渙作品
            { line: "白日依山盡", author: "王之渙", poem: "登鹳雀楼" },
            { line: "黃河入海流", author: "王之渙", poem: "登鹳雀楼" },
            { line: "欲窮千里目", author: "王之渙", poem: "登鹳雀楼" },
            { line: "更上一層樓", author: "王之渙", poem: "登鹳雀楼" },
            
            // 孟浩然作品
            { line: "春眠不覺曉", author: "孟浩然", poem: "春晓" },
            { line: "處處聞啼鳥", author: "孟浩然", poem: "春晓" },
            { line: "夜來風雨聲", author: "孟浩然", poem: "春晓" },
            { line: "花落知多少", author: "孟浩然", poem: "春晓" },
            
            // 王維作品
            { line: "獨在異鄉為異客", author: "王維", poem: "九月九日忆山东兄弟" },
            { line: "每逢佳節倍思親", author: "王維", poem: "九月九日忆山东兄弟" },
            
            { line: "紅豆生南國", author: "王維", poem: "相思" },
            { line: "春來發幾枝", author: "王維", poem: "相思" },
            { line: "願君多採擷", author: "王維", poem: "相思" },
            { line: "此物最相思", author: "王維", poem: "相思" },
            
            { line: "勸君更盡一杯酒", author: "王維", poem: "送元二使安西" },
            { line: "西出陽關無故人", author: "王維", poem: "送元二使安西" },
            
            // 靜夏的部分
            { line: "小松初數尺", author: "王建", poem: "小松" },
            { line: "未有直生枝", author: "王建", poem: "小松" }
        ];
        
        // 詩詞庫 - 從詩詞庫AI遊戲.docx中導入的詩句
        const tangPoetryLines = [
            // 漢樂府《長歌行》
            { line: "青青園中葵", author: "漢樂府", poem: "長歌行" },
            { line: "朝露待日晞", author: "漢樂府", poem: "長歌行" },
            { line: "少壯不努力", author: "漢樂府", poem: "長歌行" },
            { line: "老大徒傷悲", author: "漢樂府", poem: "長歌行" },
            
            // 古詩十九首《庭中有奇樹》
            { line: "庭中有奇樹", author: "古詩十九首", poem: "庭中有奇樹" },
            { line: "綠葉發華滋", author: "古詩十九首", poem: "庭中有奇樹" },
            { line: "此物何足貴", author: "古詩十九首", poem: "庭中有奇樹" },
            { line: "但感別經時", author: "古詩十九首", poem: "庭中有奇樹" },
            
            // 駱賓王《詠鵝》
            { line: "白毛浮綠水", author: "駱賓王", poem: "詠鵝" },
            { line: "紅掌撥清波", author: "駱賓王", poem: "詠鵝" },
            
            // 賀知章《詠柳》
            { line: "不知細葉誰裁出", author: "賀知章", poem: "詠柳" },
            { line: "二月春風似剪刀", author: "賀知章", poem: "詠柳" },
            
            // 王之渙《登鸛雀樓》
            { line: "欲窮千里目", author: "王之渙", poem: "登鸛雀樓" },
            { line: "更上一層樓", author: "王之渙", poem: "登鸛雀樓" },
            
            // 孟浩然《春曉》
            { line: "夜來風雨聲", author: "孟浩然", poem: "春曉" },
            { line: "花落知多少", author: "孟浩然", poem: "春曉" },
            
            // 王維《九月九日憶山東兄弟》
            { line: "獨在異鄉為異客", author: "王維", poem: "九月九日憶山東兄弟" },
            { line: "每逢佳節倍思親", author: "王維", poem: "九月九日憶山東兄弟" },
            
            // 王維《相思》
            { line: "願君多採擷", author: "王維", poem: "相思" },
            { line: "此物最相思", author: "王維", poem: "相思" },
            
            // 王維《送元二使安西》
            { line: "勸君更盡一杯酒", author: "王維", poem: "送元二使安西" },
            { line: "西出陽關無故人", author: "王維", poem: "送元二使安西" },
            
            // 王維《竹里館》
            { line: "深林人不知", author: "王維", poem: "竹里館" },
            { line: "明月來相照", author: "王維", poem: "竹里館" },
            
            // 王昌齡《出塞》其一
            { line: "但使龍城飛將在", author: "王昌齡", poem: "出塞" },
            { line: "不教胡馬度陰山", author: "王昌齡", poem: "出塞" },
            
            // 王昌齡《從軍行》其一
            { line: "更吹羌笛關山月", author: "王昌齡", poem: "從軍行" },
            { line: "無那金閨萬里愁", author: "王昌齡", poem: "從軍行" },
            
            // 高適《別董大》其一
            { line: "莫愁前路無知己", author: "高適", poem: "別董大" },
            { line: "天下誰人不識君", author: "高適", poem: "別董大" },
            
            // 李白《靜夜思》
            { line: "舉頭望明月", author: "李白", poem: "靜夜思" },
            { line: "低頭思故鄉", author: "李白", poem: "靜夜思" },
            
            // 李白《送友人》
            { line: "浮雲遊子意", author: "李白", poem: "送友人" },
            { line: "落日故人情", author: "李白", poem: "送友人" },
            
            // 李白《贈汪倫》
            { line: "桃花潭水深千尺", author: "李白", poem: "贈汪倫" },
            { line: "不及汪倫送我情", author: "李白", poem: "贈汪倫" },
            
            // 李白《望廬山瀑布》其二
            { line: "飛流直下三千尺", author: "李白", poem: "望廬山瀑布" },
            { line: "疑是銀河落九天", author: "李白", poem: "望廬山瀑布" },
            
            // 李白《獨坐敬亭山》
            { line: "相看兩不厭", author: "李白", poem: "獨坐敬亭山" },
            { line: "只有敬亭山", author: "李白", poem: "獨坐敬亭山" },
            
            // 李白《黃鶴樓送孟浩然之廣陵》
            { line: "孤帆遠影碧空盡", author: "李白", poem: "黃鶴樓送孟浩然之廣陵" },
            { line: "唯見長江天際流", author: "李白", poem: "黃鶴樓送孟浩然之廣陵" },
            
            // 李白《望天門山》
            { line: "兩岸青山相對出", author: "李白", poem: "望天門山" },
            { line: "孤帆一片日邊來", author: "李白", poem: "望天門山" },
            
            // 杜甫《客至》
            { line: "花徑不曾緣客掃", author: "杜甫", poem: "客至" },
            { line: "蓬門今始為君開", author: "杜甫", poem: "客至" },
            
            // 杜甫《春夜喜雨》
            { line: "隨風潛入夜", author: "杜甫", poem: "春夜喜雨" },
            { line: "潤物細無聲", author: "杜甫", poem: "春夜喜雨" },
            { line: "曉看紅濕處", author: "杜甫", poem: "春夜喜雨" },
            { line: "花重錦官城", author: "杜甫", poem: "春夜喜雨" },
            
            // 杜甫《絕句》
            { line: "兩個黃鸝鳴翠柳", author: "杜甫", poem: "絕句" },
            { line: "一行白鷺上青天", author: "杜甫", poem: "絕句" },
            
            // 張籍《楓橋夜泊》
            { line: "月落烏啼霜滿天", author: "張籍", poem: "楓橋夜泊" },
            { line: "江楓漁火對愁眠", author: "張籍", poem: "楓橋夜泊" },
            
            // 孟郊《遊子吟》
            { line: "誰言寸草心", author: "孟郊", poem: "遊子吟" },
            { line: "報得三春暉", author: "孟郊", poem: "遊子吟" },
            
            // 白居易《賦得古原草送別》
            { line: "野火燒不盡", author: "白居易", poem: "賦得古原草送別" },
            { line: "春風吹又生", author: "白居易", poem: "賦得古原草送別" },
            
            // 白居易《暮江吟》
            { line: "一道殘陽鋪水中", author: "白居易", poem: "暮江吟" },
            { line: "半江瑟瑟半江紅", author: "白居易", poem: "暮江吟" },
            
            // 白居易《賣炭翁》
            { line: "可憐身上衣正單", author: "白居易", poem: "賣炭翁" },
            { line: "心憂炭賤願天寒", author: "白居易", poem: "賣炭翁" },
            
            // 白居易《大林寺桃花》
            { line: "人間四月芳菲盡", author: "白居易", poem: "大林寺桃花" },
            { line: "山寺桃花始盛開", author: "白居易", poem: "大林寺桃花" },
            
            // 賈島《尋隱者不遇》
            { line: "只在此山中", author: "賈島", poem: "尋隱者不遇" },
            { line: "雲深不知處", author: "賈島", poem: "尋隱者不遇" },
            
            // 杜牧《山行》
            { line: "停車坐愛楓林晚", author: "杜牧", poem: "山行" },
            { line: "霜葉紅於二月花", author: "杜牧", poem: "山行" },
            
            // 杜牧《江南春》
            { line: "南朝四百八十寺", author: "杜牧", poem: "江南春" },
            { line: "多少樓臺煙雨中", author: "杜牧", poem: "江南春" },
            
            // 張志和《漁歌子》
            { line: "青箬笠", author: "張志和", poem: "漁歌子" },
            { line: "綠蓑衣", author: "張志和", poem: "漁歌子" },
            { line: "斜風細雨不須歸", author: "張志和", poem: "漁歌子" },
            
            // 王安石《梅花》
            { line: "遙知不是雪", author: "王安石", poem: "梅花" },
            { line: "為有暗香來", author: "王安石", poem: "梅花" },
            
            // 王安石《書湖陰先生壁》其一
            { line: "一水護田將綠繞", author: "王安石", poem: "書湖陰先生壁" },
            { line: "兩山排闥送青來", author: "王安石", poem: "書湖陰先生壁" },
            
            // 蘇軾《水調歌頭》
            { line: "但願人長久", author: "蘇軾", poem: "水調歌頭" },
            { line: "千里共嬋娟", author: "蘇軾", poem: "水調歌頭" },
            { line: "人有悲歡離合", author: "蘇軾", poem: "水調歌頭" },
            { line: "月有陰晴圓缺", author: "蘇軾", poem: "水調歌頭" },
            
            // 蘇軾《題西林壁》
            { line: "不識廬山真面目", author: "蘇軾", poem: "題西林壁" },
            { line: "只緣身在此山中", author: "蘇軾", poem: "題西林壁" },
            
            // 蘇軾《飲湖上初晴後雨》
            { line: "欲把西湖比西子", author: "蘇軾", poem: "飲湖上初晴後雨" },
            { line: "淡妝濃抹總相宜", author: "蘇軾", poem: "飲湖上初晴後雨" },
            
            // 楊萬里《曉出淨慈寺送林子方》其二
            { line: "接天蓮葉無窮碧", author: "楊萬里", poem: "曉出淨慈寺送林子方" },
            { line: "映日荷花別樣紅", author: "楊萬里", poem: "曉出淨慈寺送林子方" },
            
            // 朱熹《觀書有感》
            { line: "問渠那得清如許", author: "朱熹", poem: "觀書有感" },
            { line: "為有源頭活水來", author: "朱熹", poem: "觀書有感" },
            
            // 林升《題臨安邸》
            { line: "暖風薰得遊人醉", author: "林升", poem: "題臨安邸" },
            { line: "直把杭州作汴州", author: "林升", poem: "題臨安邸" },
            
            // 馬致遠《天淨沙·秋思》
            { line: "枯藤老樹昏鴉", author: "馬致遠", poem: "天淨沙·秋思" },
            { line: "小橋流水人家", author: "馬致遠", poem: "天淨沙·秋思" },
            { line: "夕陽西下", author: "馬致遠", poem: "天淨沙·秋思" },
            { line: "斷腸人在天涯", author: "馬致遠", poem: "天淨沙·秋思" },
            
            // 《詩經·關雎》
            { line: "關關雎鳩", author: "詩經", poem: "關雎" },
            { line: "在河之洲", author: "詩經", poem: "關雎" },
            { line: "窈窕淑女", author: "詩經", poem: "關雎" },
            { line: "君子好逑", author: "詩經", poem: "關雎" },
            
            // 《詩經·蒹葭》
            { line: "蒹葭蒼蒼", author: "詩經", poem: "蒹葭" },
            { line: "白露為霜", author: "詩經", poem: "蒹葭" },
            { line: "所謂伊人", author: "詩經", poem: "蒹葭" },
            { line: "在水一方", author: "詩經", poem: "蒹葭" },
            
            // 曹植《七哀詩》
            { line: "明月照高樓", author: "曹植", poem: "七哀詩" },
            { line: "流光正徘徊", author: "曹植", poem: "七哀詩" },
            { line: "願為西南風", author: "曹植", poem: "七哀詩" },
            { line: "長逝入君懷", author: "曹植", poem: "七哀詩" },
            
            // 陶淵明《歸園田居》其一
            { line: "羈鳥戀舊林", author: "陶淵明", poem: "歸園田居" },
            { line: "池魚思故淵", author: "陶淵明", poem: "歸園田居" },
            { line: "久在樊籠裏", author: "陶淵明", poem: "歸園田居" },
            { line: "復得返自然", author: "陶淵明", poem: "歸園田居" },
            
            // 陶淵明《飲酒詩》
            { line: "採菊東籬下", author: "陶淵明", poem: "飲酒詩" },
            { line: "悠然見南山", author: "陶淵明", poem: "飲酒詩" },
            { line: "問君何能爾", author: "陶淵明", poem: "飲酒詩" },
            { line: "心遠地自偏", author: "陶淵明", poem: "飲酒詩" },
            
            // 張若虛《春江花月夜》
            { line: "春江潮水連海平", author: "張若虛", poem: "春江花月夜" },
            { line: "海上明月共潮生", author: "張若虛", poem: "春江花月夜" },
            { line: "江畔何人初見月", author: "張若虛", poem: "春江花月夜" },
            { line: "江月何年初照人", author: "張若虛", poem: "春江花月夜" },
            { line: "人生代代無窮已", author: "張若虛", poem: "春江花月夜" },
            { line: "江月年年只相似", author: "張若虛", poem: "春江花月夜" },
            { line: "不知江月待何人", author: "張若虛", poem: "春江花月夜" },
            { line: "但見長江送流水", author: "張若虛", poem: "春江花月夜" },
            
            // 李白《蜀道難》
            { line: "蜀道之難", author: "李白", poem: "蜀道難" },
            { line: "難於上青天", author: "李白", poem: "蜀道難" },
            { line: "一夫當關", author: "李白", poem: "蜀道難" },
            { line: "萬夫莫開", author: "李白", poem: "蜀道難" },
            { line: "連峰去天不盈尺", author: "李白", poem: "蜀道難" },
            { line: "枯松倒掛倚絕壁", author: "李白", poem: "蜀道難" },
            { line: "劍閣崢嶸而崔嵬", author: "李白", poem: "蜀道難" },
            { line: "所守或匪親", author: "李白", poem: "蜀道難" },
            
            // 李白《夢遊天姥吟留別》
            { line: "安能摧眉折腰事權貴", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "使我不得開心顏", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "半壁見海日", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "空中聞天雞", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "霓為衣兮風為馬", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "雲之君兮紛紛而來下", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "且放白鹿青崖間", author: "李白", poem: "夢遊天姥吟留別" },
            { line: "須行即騎訪名山", author: "李白", poem: "夢遊天姥吟留別" },
            
            // 李白《將進酒》
            { line: "君不見黃河之水天上來", author: "李白", poem: "將進酒" },
            { line: "奔流到海不復回", author: "李白", poem: "將進酒" },
            { line: "天生我材必有用", author: "李白", poem: "將進酒" },
            { line: "千金散盡還復來", author: "李白", poem: "將進酒" },
            { line: "古來聖賢皆寂寞", author: "李白", poem: "將進酒" },
            { line: "惟有飲者留其名", author: "李白", poem: "將進酒" },
            
            // 杜甫《登高》
            { line: "無邊落木蕭蕭下", author: "杜甫", poem: "登高" },
            { line: "不盡長江滾滾來", author: "杜甫", poem: "登高" },
            { line: "萬里悲秋常作客", author: "杜甫", poem: "登高" },
            { line: "百年多病獨登臺", author: "杜甫", poem: "登高" },
            
            // 李商隱《無題》
            { line: "春蠶到死絲方盡", author: "李商隱", poem: "無題" },
            { line: "蠟炬成灰淚始乾", author: "李商隱", poem: "無題" },
            { line: "身無彩鳳雙飛翼", author: "李商隱", poem: "無題" },
            { line: "心有靈犀一點通", author: "李商隱", poem: "無題" },
            
            // 白居易《長恨歌》
            { line: "回眸一笑百媚生", author: "白居易", poem: "長恨歌" },
            { line: "六宮粉黛無顏色", author: "白居易", poem: "長恨歌" },
            { line: "在天願作比翼鳥", author: "白居易", poem: "長恨歌" },
            { line: "在地願為連理枝", author: "白居易", poem: "長恨歌" },
            { line: "天長地久有時盡", author: "白居易", poem: "長恨歌" },
            { line: "此恨綿綿無絕期", author: "白居易", poem: "長恨歌" },
            { line: "春風桃李花開日", author: "白居易", poem: "長恨歌" },
            { line: "秋雨梧桐葉落時", author: "白居易", poem: "長恨歌" },
            
            // 李煜《虞美人》
            { line: "問君能有幾多愁", author: "李煜", poem: "虞美人" },
            { line: "恰似一江春水向東流", author: "李煜", poem: "虞美人" },
            
            // 辛棄疾《青玉案·元夕》
            { line: "眾裏尋他千百度", author: "辛棄疾", poem: "青玉案·元夕" },
            { line: "驀然回首", author: "辛棄疾", poem: "青玉案·元夕" },
            { line: "那人卻在", author: "辛棄疾", poem: "青玉案·元夕" },
            { line: "燈火闌珊處", author: "辛棄疾", poem: "青玉案·元夕" },
            
            // 文天祥《過零丁洋》
            { line: "人生自古誰無死", author: "文天祥", poem: "過零丁洋" },
            { line: "留取丹心照汗青", author: "文天祥", poem: "過零丁洋" },
            { line: "山河破碎風飄絮", author: "文天祥", poem: "過零丁洋" },
            { line: "身世浮沉雨打萍", author: "文天祥", poem: "過零丁洋" },
            
            // 納蘭性德《木蘭花·擬古決絕詞》
            { line: "人生若只如初見", author: "納蘭性德", poem: "木蘭花·擬古決絕詞" },
            { line: "何事秋風悲畫扇", author: "納蘭性德", poem: "木蘭花·擬古決絕詞" },
            { line: "等閒變卻故人心", author: "納蘭性德", poem: "木蘭花·擬古決絕詞" },
            { line: "卻道故人心易變", author: "納蘭性德", poem: "木蘭花·擬古決絕詞" },
            
            // 李白《宣州謝脁樓餞別校書叔雲》
            { line: "抽刀斷水水更流", author: "李白", poem: "宣州謝脁樓餞別校書叔雲" },
            { line: "舉杯消愁愁更愁", author: "李白", poem: "宣州謝脁樓餞別校書叔雲" },
            { line: "人生在世不稱意", author: "李白", poem: "宣州謝脁樓餞別校書叔雲" },
            { line: "明朝散髮弄扁舟", author: "李白", poem: "宣州謝脁樓餞別校書叔雲" },
            
            // 李賀《雁門太守行》
            { line: "黑雲壓城城欲摧", author: "李賀", poem: "雁門太守行" },
            { line: "甲光向日金鱗開", author: "李賀", poem: "雁門太守行" },
            { line: "報君黃金臺上意", author: "李賀", poem: "雁門太守行" },
            { line: "提攜玉龍為君死", author: "李賀", poem: "雁門太守行" }
        ];

        // DOM elements
        const charactersGrid = document.getElementById('charactersGrid');
        const poemDisplay = document.getElementById('poemDisplay');
        const poemHint = document.getElementById('poemHint');
        const charCountDisplay = document.getElementById('charCountDisplay');
        const timerElement = document.getElementById('timer');
        const clearSelectionButton = document.getElementById('clearSelection');
        const submitButton = document.getElementById('submitPoem');
        const scoreElement = document.getElementById('score');
        const scoreLabel = document.getElementById('scoreLabel');
        const gameMessage = document.getElementById('gameMessage');
        const resultIcon = document.getElementById('resultIcon');
        const poemErrorIcon = document.getElementById('poemErrorIcon');
        const successIcon = document.getElementById('successIcon');
        const correctAnswer = document.getElementById('correctAnswer');
        const correctAnswerText = document.getElementById('correctAnswerText');
        const closeGameMessage = document.getElementById('closeGameMessage');
        const aiExplainSuccessRow = document.getElementById('aiExplainSuccessRow');
        const aiExplainBtnSuccess = document.getElementById('aiExplainBtnSuccess');
        const aiExplainFailRow = document.getElementById('aiExplainFailRow');
        const aiExplainBtnFail = document.getElementById('aiExplainBtnFail');
        const aiExplainModal = document.getElementById('aiExplainModal');
        const aiExplainClose = document.getElementById('aiExplainClose');
        const aiExplainOK = document.getElementById('aiExplainOK');
        const aiExplainReload = document.getElementById('aiExplainReload');
        const aiExplainLine = document.getElementById('aiExplainLine');
        const aiExplainMeta = document.getElementById('aiExplainMeta');
        const aiExplainContent = document.getElementById('aiExplainContent');
        const aiExplainError = document.getElementById('aiExplainError');
        
        // Notification elements
        const notification = document.getElementById('notification');
        const notificationText = document.getElementById('notificationText');
        const closeNotification = document.getElementById('closeNotification');
        const timeBarFill = document.getElementById('timeBarFill');
        const selectionStatus = document.getElementById('selectionStatus');

        // Difficulty settings
        const difficultySettings = {
            easy: { timeLimit: 45, charCount: 15 },
            medium: { timeLimit: 30, charCount: 15 },
            hard: { timeLimit: 15, charCount: 15 }
        };
        
        // Game state variables
        let timerInterval;
        let timeLeft = 30;
        let charCount = 15;
        let score = 0;
        let currentPoem;
        let isGameActive = false;
        let poemCharacters = [];
        let shuffledCharacters = [];
        let currentGameMode = 'preset'; // 'preset', 'custom', or 'battle'
        let customPoems = [];
        let roundTimeLimit = 30; // 當前回合時間上限，用於進度條比例
        let areCoreListenersBound = false; // 防止重複綁定
        let selectionStack = []; // 已選字堆疊（支持撤回）
        
        // 對戰模式相關變量
        let battleMode = {
            isActive: false,
            players: [],
            currentPlayerIndex: 0,
            roundsPerPlayer: 1,
            currentRound: 0,
            totalRounds: 0
        };
        
        // Difficulty settings elements
        const difficultySelect = document.getElementById('difficultySelect');
        const timeLimitSlider = document.getElementById('timeLimit');
        const timeLimitValue = document.getElementById('timeLimitValue');
        const charCountSlider = document.getElementById('charCount');
        const charCountValue = document.getElementById('charCountValue');
        
        // Custom poem elements (gameMode 已移至設置模態彈窗中的radio按鈕)
        // 已移除自定義詩句功能（相關元素不再使用）
        // 設置模態彈窗元素
        const settingsModal = document.getElementById('settingsModal');
        const closeSettingsModal = document.getElementById('closeSettingsModal');
        const cancelSettings = document.getElementById('cancelSettings');
        const saveSettingsBtn = document.getElementById('saveSettings');
        const adminModeToggle = document.getElementById('adminModeToggle');
        
        // 對戰結束總結窗口元素
        const battleResultModal = document.getElementById('battleResultModal');
        const winnerAnnouncement = document.getElementById('winnerAnnouncement');
        const winnerScore = document.getElementById('winnerScore');
        const battleRankings = document.getElementById('battleRankings');
        const newBattleBtn = document.getElementById('newBattleBtn');
        const exitBattleBtn = document.getElementById('exitBattleBtn');
        
        // 對戰模式元素
        const battleModeSettings = document.getElementById('battleModeSettings');
        const playerCountSelect = document.getElementById('playerCount');
        const playerNamesContainer = document.getElementById('playerNamesContainer');
        const roundsPerPlayerInput = document.getElementById('roundsPerPlayer');
        const speedModeCheckbox = document.getElementById('speedMode');
        const battleScoreboard = document.getElementById('battleScoreboard');
        const leftPlayersContainer = document.getElementById('leftPlayers');
        const rightPlayersContainer = document.getElementById('rightPlayers');
        const battlePreviewModal = document.getElementById('battlePreviewModal');
        const battlePreviewClose = document.getElementById('battlePreviewClose');
        const battlePreviewBack = document.getElementById('battlePreviewBack');
        const battlePreviewStart = document.getElementById('battlePreviewStart');
        const battlePreviewPlayerCount = document.getElementById('battlePreviewPlayerCount');
        const battlePreviewRounds = document.getElementById('battlePreviewRounds');
        const battlePreviewTotalQuestions = document.getElementById('battlePreviewTotalQuestions');
        const battlePreviewTimeLimit = document.getElementById('battlePreviewTimeLimit');
        const battlePreviewCharCount = document.getElementById('battlePreviewCharCount');
        const battlePreviewPlayersList = document.getElementById('battlePreviewPlayersList');
        const battlePreviewSpeedRow = document.getElementById('battlePreviewSpeedRow');
        const battlePreviewSpeedText = document.getElementById('battlePreviewSpeedText');
        const battlePreviewNote = document.getElementById('battlePreviewNote');
        // startBattleBtn 已移除，對戰模式通過保存設置自動啟動
        const customPoemInput = document.getElementById('customPoem');
        const saveCustomPoemButton = document.getElementById('saveCustomPoem');
        const savedPoemsList = document.getElementById('savedPoemsList');
        const noSavedPoems = document.getElementById('noSavedPoems');

        // Show notification
        const showNotification = (message, duration = 3000) => {
            notificationText.textContent = message;
            notification.classList.remove('translate-y-[-150%]');
            notification.classList.add('translate-y-0');
            
            setTimeout(() => {
                notification.classList.remove('translate-y-0');
                notification.classList.add('translate-y-[-150%]');
            }, duration);
        };

        // Close notification manually
        closeNotification.addEventListener('click', () => {
            notification.classList.remove('translate-y-0');
            notification.classList.add('translate-y-[-150%]');
        });

        // Close game message manually
        closeGameMessage.addEventListener('click', () => {
            hideResultModal();
            // 如果是对战模式且游戏结束，则进入下一轮
            if (battleMode.isActive && !isGameActive) {
                // 延迟一下让用户看到关闭动画
                setTimeout(() => {
                    startBattleRound();
                }, 250);
            } else if (!isGameActive) {
                // 单人模式，开始新一轮
                setTimeout(() => {
                    startNewRound();
                }, 250);
            }
        });

        // 计算并设置错误图标位置
        const positionErrorIcon = () => {
            if (!poemDisplay.value || poemDisplay.value === '時間到') return;
            
            // 创建一个临时元素来测量文字宽度
            const tempSpan = document.createElement('span');
            tempSpan.style.font = window.getComputedStyle(poemDisplay).font;
            tempSpan.style.visibility = 'hidden';
            tempSpan.style.position = 'absolute';
            tempSpan.style.whiteSpace = 'nowrap';
            tempSpan.textContent = poemDisplay.value;
            document.body.appendChild(tempSpan);
            
            const textWidth = tempSpan.offsetWidth;
            document.body.removeChild(tempSpan);
            
            // 计算图标位置：容器中心 + 文字宽度的一半 + 间距
            const containerWidth = poemDisplay.offsetWidth;
            const iconLeft = (containerWidth / 2) + (textWidth / 2) + 8; // 8px间距
            
            // 确保图标不超出容器边界
            const maxLeft = containerWidth - 32; // 32px = 图标宽度 + 边距
            poemErrorIcon.style.left = Math.min(iconLeft, maxLeft) + 'px';
        };

        // 显示结果浮窗
        const showResultModal = (isSuccess, message, answer = null) => {
            if (isSuccess) {
                // 答对了：只显示成功图标，用户答案保持绿色
                successIcon.classList.remove('hidden');
                // 不顯示正確答案區（沿用原先邏輯），僅顯示 AI 按鈕
                correctAnswer.classList.add('hidden');
                poemErrorIcon.classList.add('hidden');
                if (aiExplainSuccessRow) aiExplainSuccessRow.classList.remove('hidden');
                if (aiExplainFailRow) aiExplainFailRow.classList.add('hidden');
                
                // 保持用户答案的绿色样式（在endRound中已设置）
            } else {
                // 答错了：显示错误图标在用户答案旁，用户答案变红
                if (poemDisplay.value && poemDisplay.value !== '時間到') {
                    // 只有当有用户答案时才显示错误图标
                    positionErrorIcon();
                    poemErrorIcon.classList.remove('hidden');
                    
                    // 将用户选择的诗句变为红色
                    poemDisplay.classList.remove('text-surface-800', 'text-secondary');
                    poemDisplay.classList.add('text-red-600');
                } else {
                    poemErrorIcon.classList.add('hidden');
                }
                
                if (answer) {
                    correctAnswerText.textContent = answer;
                    correctAnswer.classList.remove('hidden');
                } else {
                    correctAnswer.classList.add('hidden');
                }
                successIcon.classList.add('hidden');
                if (aiExplainFailRow) aiExplainFailRow.classList.remove('hidden');
                if (aiExplainSuccessRow) aiExplainSuccessRow.classList.add('hidden');
            }

            // 根據模式切換下一步按鈕文案：
            // 單人=「下一首」；對戰=「XX 開始答題」（下一位選手）
            if (closeGameMessage) {
                // 遠程限時：統一顯示「下一首」；本地輪流維持原文案
                if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    closeGameMessage.textContent = '下一首';
                } else if (battleMode.isActive && Array.isArray(battleMode.players) && battleMode.players.length > 0) {
                    const nextIndex = (battleMode.currentPlayerIndex + 1) % battleMode.players.length;
                    const nextPlayer = battleMode.players[nextIndex];
                    const name = (nextPlayer && nextPlayer.name) ? nextPlayer.name : '選手';
                    closeGameMessage.textContent = `${name} 開始答題`;
                } else {
                    closeGameMessage.textContent = '下一首';
                }
            }

            // 显示浮窗，使用简单的滑入动画
            gameMessage.classList.remove('hidden');
            const modalContent = gameMessage.querySelector('div');
            modalContent.style.animation = 'slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1) forwards';
            // 確保「下一輪」獨立一行：此處結構上已在另一個容器中，不同 flex 行
        };

        // DeepSeek 代理調用（非串流）
        async function callDeepSeek(messages) {
            const DEFAULT_PROXY = 'https://deepseek-proxy-chi.vercel.app/api/deepseek';
            const url = window.DEEPSEEK_PROXY_URL || localStorage.getItem('DEEPSEEK_PROXY_URL') || DEFAULT_PROXY;
            const resp = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    model: 'deepseek-chat',
                    messages,
                    temperature: 0.7,
                    max_tokens: 900
                })
            });
            if (!resp.ok) throw new Error('HTTP ' + resp.status);
            const data = await resp.json();
            return data.choices && data.choices[0] && data.choices[0].message && data.choices[0].message.content ? data.choices[0].message.content : '';
        }

        // 準備提示詞（適合中學生、先譯文、再原作全文與簡要賞析、重點說明此句之美）
        function buildAiPrompt(poemObj) {
            const line = poemObj?.line || '';
            const author = poemObj?.author || '';
            const poemTitle = poemObj?.poem || '';
            return [
                { role: 'system', content: '你是一位溫柔而專業的國學導師，擅長用清晰、優美、貼近中學生的語言講解古典詩詞。請將總字數控制在約300字，語言精煉、易懂。不要使用粗體或任何 Markdown 語法強調。' },
                { role: 'user', content: `請幫我解讀下面這句詩，輸出結構為三段（約300字）：\n【譯文】用1-2句給出準確、優美的現代文翻譯；\n【原作】說明詩句出處，給出原作全文（若過長可節選核心段落），保持排版清晰；\n【賞析】用2-3句指出整首作品的氣氛與情感，並著重評點題目該句「${line}」的美（意象/節奏/對仗等）。\n請使用繁體中文回答，風格友善，適合中學生。\n詩句：${line}\n作者：${author}\n詩題：${poemTitle}` }
            ];
        }

        function openAiExplainModal() {
            if (!currentPoem) return;
            aiExplainError.classList.add('hidden');
            aiExplainError.textContent = '';
            aiExplainContent.innerHTML = '<div class="ai-loading-wrap"><div class="ai-spinner"></div><div class="ai-loading-text">正在生成解讀，請稍候…</div></div>';
            aiExplainLine.textContent = currentPoem.line || '';
            aiExplainMeta.textContent = currentPoem.author && currentPoem.poem ? `出自《${currentPoem.poem}》·${currentPoem.author}` : '';
            aiExplainModal.classList.remove('hidden');
        }

        async function generateAiExplanation(triggerButton) {
            try {
                if (triggerButton) triggerButton.classList.add('ai-explain-loading');
                aiExplainReload && aiExplainReload.classList.add('ai-explain-loading');
                const messages = buildAiPrompt(currentPoem);
                const content = await callDeepSeek(messages);
                const pretty = formatAiContent(content || '', currentPoem.line || '');
                aiExplainContent.innerHTML = pretty || '<div class="text-surface-700">暫無內容</div>';
                aiExplainError.classList.add('hidden');
            } catch (err) {
                aiExplainError.textContent = '生成失敗，請稍後重試。' + '（' + String(err) + '）';
                aiExplainError.classList.remove('hidden');
            } finally {
                if (triggerButton) triggerButton.classList.remove('ai-explain-loading');
                aiExplainReload && aiExplainReload.classList.remove('ai-explain-loading');
            }
        }

        // 將模型輸出格式化為本站美學風格，並做長度控制與高亮
        function formatAiContent(raw, targetLine) {
            // 去除左右空白與可能的 Markdown 粗體星號
            const text = (raw || '')
                .replace(/\*\*(.*?)\*\*/g, '$1')
                .replace(/^[\s\u200B\ufeff]+|[\s\u200B\ufeff]+$/g, '');
            // 粗略截斷至約300字
            const limited = text.length > 420 ? text.slice(0, 420) + '…' : text;
            // 切分段落（以【】標題或空行為界）
            const parts = limited.split(/\n{2,}|(?=【譯文|【原作|【賞析)/).map(p=>p.trim()).filter(Boolean);
            const esc = (s)=>s.replace(/[&<>]/g,c=>({"&":"&amp;","<":"&lt;",">":"&gt;"}[c]));
            // 目標詩句高亮
            const highlight = (s)=>s.replace(new RegExp(targetLine.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'),'g'), `<span class=\"ai-highlight\">${esc(targetLine)}</span>`);

            const sections = [];
            let y = parts.join('\n');
            // 盡量提取三段
            const yiz = /【譯文】([\s\S]*?)(?=【|$)/.exec(y);
            const yuanz = /【原作】([\s\S]*?)(?=【|$)/.exec(y);
            const shang = /【賞析】([\s\S]*?)(?=【|$)/.exec(y);

            if (yiz) sections.push(`<div class=\"ai-section\"><div class=\"ai-title\">📘 譯文</div><div class=\"ai-body\">${esc(yiz[1].trim())}</div></div>`);
            if (yuanz) sections.push(`<div class=\"ai-section\"><div class=\"ai-title\">📜 原作</div><div class=\"ai-poem-block\">${esc(yuanz[1].trim())}</div></div>`);
            if (shang) sections.push(`<div class=\"ai-section\"><div class=\"ai-title\">🌟 賞析</div><div class=\"ai-body\">${highlight(esc(shang[1].trim()))}</div></div>`);

            if (!sections.length) {
                // 後備：以段落拆分
                const paras = parts.map(p=>`<p>${highlight(esc(p))}</p>`).join('');
                return `<div class=\"ai-section\">${paras}</div>`;
            }
            return sections.join('<div style=\"height:8px\"></div>');
        }
        
        if (aiExplainBtnSuccess) {
            aiExplainBtnSuccess.addEventListener('click', (e) => {
                openAiExplainModal();
                generateAiExplanation(e.currentTarget);
            });
        }
        if (aiExplainBtnFail) {
            aiExplainBtnFail.addEventListener('click', (e) => {
                openAiExplainModal();
                generateAiExplanation(e.currentTarget);
            });
        }
        if (aiExplainClose) {
            aiExplainClose.addEventListener('click', () => {
                aiExplainModal.classList.add('hidden');
            });
        }
        if (aiExplainOK) {
            aiExplainOK.addEventListener('click', () => {
                aiExplainModal.classList.add('hidden');
            });
        }
        if (aiExplainReload) {
            aiExplainReload.addEventListener('click', (e) => {
                openAiExplainModal();
                generateAiExplanation(e.currentTarget);
            });
        }

        // 隐藏结果浮窗
        const hideResultModal = () => {
            const modalContent = gameMessage.querySelector('div');
            modalContent.style.transform = 'translateY(10px)';
            modalContent.style.opacity = '0';
            modalContent.style.transition = 'all 0.2s ease-out';
            
            // 等待动画完成后隐藏元素
            setTimeout(() => {
                gameMessage.classList.add('hidden');
                modalContent.style.transform = '';
                modalContent.style.opacity = '';
                modalContent.style.transition = '';
                // 清理所有状态
                successIcon.classList.add('hidden');
                correctAnswer.classList.add('hidden');
                poemErrorIcon.classList.add('hidden');
                if (aiExplainSuccessRow) aiExplainSuccessRow.classList.add('hidden');
                if (aiExplainFailRow) aiExplainFailRow.classList.add('hidden');
                // 重置用户答案颜色
                poemDisplay.classList.remove('text-red-600', 'text-secondary', 'font-bold');
                poemDisplay.classList.add('text-surface-800');
            }, 200);
        };

        // Shuffle array (Fisher-Yates algorithm)
        const shuffleArray = (array) => {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        };

        // 詩詞數據庫選項
        // 改為使用用戶標籤作為詩詞庫選擇
        let activeDatabase = tangPoetryLines; // 仍保留內建數據作為基礎來源
        function getAllPoemsUnified() {
            // 內建庫加標籤：南風詩詞庫 / 小學生詩詞庫
            const builtinTang = (tangPoetryLines || []).map(p => ({ ...p, tags: Array.isArray(p.tags)? p.tags : ['南風詩詞庫'] }));
            const builtinElem = (elementaryPoemLines || []).map(p => ({ ...p, tags: Array.isArray(p.tags)? p.tags : ['小學生詩詞庫'] }));
            const imported = loadUserLibrary().poems || [];
            return [...builtinTang, ...builtinElem, ...imported];
        }
        function getAllTags() {
            const set = new Set();
            getAllPoemsUnified().forEach(p => {
                (Array.isArray(p.tags) ? p.tags : []).forEach(t => set.add(String(t)));
            });
            // 過濾掉已廢除的「自定義詩句」標籤
            return Array.from(set)
                .filter(t => t !== '自定義詩句')
                .sort((a,b)=>a.localeCompare(b));
        }
        function populateUserTagSelect() {
            const sel = document.getElementById('userLibraryTagSelect');
            if (!sel) return;
            const tags = getAllTags();
            sel.innerHTML = '';
            tags.forEach(t => {
                const opt = document.createElement('option');
                opt.value = t; opt.textContent = t;
                sel.appendChild(opt);
            });
        }
        
        // 根據選擇的數據庫選擇詩句
        const selectRandomPoem = () => {
            return activeDatabase[Math.floor(Math.random() * activeDatabase.length)];
        };
        
        // 詩詞數據庫切換功能已移至設置模態彈窗處理

        // Generate characters for the game
        const generateGameCharacters = () => {
            // Reset character arrays
            poemCharacters = [];
            shuffledCharacters = [];
            
            // Get all characters from the current poem
            poemCharacters = currentPoem.line.split('');
            
            // Create a set of characters for the game based on difficulty
            const totalCharsTarget = Math.max(charCount, poemCharacters.length);
            const distractorCount = Math.max(0, totalCharsTarget - poemCharacters.length);
            
            // Create a pool of distractor characters (excluding those in the poem)
            const allDistractors = [];
            
            // Add characters from other poems as distractors
            tangPoetryLines.forEach(poem => {
                if (poem.line !== currentPoem.line) {
                    poem.line.split('').forEach(char => {
                        // Only add if not already in the poem
                        if (!poemCharacters.includes(char)) {
                            allDistractors.push(char);
                        }
                    });
                }
            });
            
            // Shuffle and take the needed number of distractors
            const shuffledDistractors = shuffleArray([...new Set(allDistractors)]);
            const selectedDistractors = shuffledDistractors.slice(0, distractorCount);
            
            // Combine poem characters with distractors and shuffle
            shuffledCharacters = shuffleArray([...poemCharacters, ...selectedDistractors]);
        };

        // Populate the characters grid with the game characters
        const populateCharactersGrid = () => {
            charactersGrid.innerHTML = '';
            let idx = 0;
            shuffledCharacters.forEach(char => {
                const charButton = document.createElement('button');
                charButton.textContent = char;
                charButton.className = 'character-btn char-modern rounded-2xl p-3 md:p-4 text-2xl md:text-3xl font-kai font-bold animate-slide-up';
                charButton.dataset.char = char;
                charButton.style.animationDelay = `${20 * idx}ms`;
                idx++;
                
                charButton.addEventListener('click', (ev) => {
                    if (isGameActive) {
                        // 達上限則不允許再選（除非是取消選中）
                        const targetLen = currentPoem ? currentPoem.line.length : 0;
                        if (!charButton.classList.contains('selected') && selectionStack.length >= targetLen) {
                            soundManager.play('wrong');
                            charButton.classList.add('animate-wrong');
                            setTimeout(() => charButton.classList.remove('animate-wrong'), 500);
                            if (typeof showNotification === 'function') {
                                showNotification('已達本句字數上限');
                            }
                            return;
                        }

                        // 播放漢字點擊音效
                        soundManager.play('charClick');
                        
                        // 添加点击动画
                        charButton.classList.add('animate-click');
                        setTimeout(() => {
                            charButton.classList.remove('animate-click');
                        }, 300);
                        
                        // 點擊波紋
                        const rect = charButton.getBoundingClientRect();
                        const ripple = document.createElement('span');
                        ripple.className = 'ripple';
                        const offsetX = ev instanceof MouseEvent ? (ev.clientX - rect.left) : rect.width/2;
                        const offsetY = ev instanceof MouseEvent ? (ev.clientY - rect.top) : rect.height/2;
                        ripple.style.left = offsetX + 'px';
                        ripple.style.top = offsetY + 'px';
                        charButton.appendChild(ripple);
                        setTimeout(() => ripple.remove(), 650);
                        
                        // 切換選中狀態
                        const wasSelected = charButton.classList.toggle('selected');
                        if (wasSelected) {
                            // 選中後移除 hover 綠色，保持選中視覺
                            charButton.classList.remove('hover:bg-secondary', 'hover:text-white');
                            selectionStack.push({ char, btn: charButton });
                        } else {
                            // 取消選中需從堆疊移除最近一次對應該字的記錄
                            for (let i = selectionStack.length - 1; i >= 0; i--) {
                                if (selectionStack[i].btn === charButton) {
                                    selectionStack.splice(i, 1);
                                    break;
                                }
                            }
                            // 取消選中恢復 hover 綠色
                            charButton.classList.add('hover:bg-secondary', 'hover:text-white');
                        }

                        // 重建顯示的詩句字串
                        poemDisplay.value = selectionStack.map(x => x.char).join('');

                        // 更新已選字狀態與提交按鈕可用性
                        updateSelectionStatus();
                    }
                });
                
                charactersGrid.appendChild(charButton);
            });
        };

        // Apply difficulty settings (只更新設定顯示；當前回合不變)
        const applyDifficultySettings = (difficulty) => {
            const settings = difficultySettings[difficulty];
            // 更新下回合的預設滑塊值
            timeLimitSlider.value = settings.timeLimit;
            timeLimitValue.textContent = settings.timeLimit;
            charCountSlider.value = settings.charCount;
            charCountValue.textContent = settings.charCount;
            // 不修改當前回合 timeLeft；若非遊戲中，重置顯示
            if (!isGameActive) {
                roundTimeLimit = settings.timeLimit;
                timeLeft = roundTimeLimit;
                if (timerElement) timerElement.textContent = timeLeft;
                if (timeBarFill) timeBarFill.style.width = '100%';
            }
        };
        
        // Select a poem based on current game mode
        const selectPoem = () => {
            const tagSel = document.getElementById('userLibraryTagSelect');
            let activeTag = tagSel?.value || loadActiveTag() || '南風詩詞庫';
            if (activeTag === '自定義詩句') activeTag = '南風詩詞庫';
            const pool = getAllPoemsUnified().filter(p => Array.isArray(p.tags) && p.tags.includes(activeTag));
            if (pool.length === 0) {
                showNotification('該詩詞庫下暫無詩句，請更換標籤或導入更多詩句', 5000);
                return null;
            }
            saveActiveTag(activeTag);
            return pool[Math.floor(Math.random() * pool.length)];
        };
        
        // Start a new game round
        const startNewRound = () => {
            // Reset UI
            selectionStack = [];
            poemDisplay.value = '';
            gameMessage.classList.add('hidden');
            
            // 清除上一輪的所有颜色和图标状态
            poemDisplay.classList.remove('text-secondary', 'text-red-600', 'font-bold');
            poemDisplay.classList.add('text-surface-800');
            poemErrorIcon.classList.add('hidden');
            successIcon.classList.add('hidden');
            correctAnswer.classList.add('hidden');
            
            // 播放新回合音效
            soundManager.play('newRound');
            
            // Select a new poem based on game mode
            currentPoem = selectPoem();
            
            // If no poem is available, return
            if (!currentPoem) {
                return;
            }
            
            // Display the poem hint (author and name) without character count
            poemHint.textContent = `《${currentPoem.poem}》 - ${currentPoem.author}`;
            
            // Display character count separately
            const targetLen = currentPoem.line.length;
            const charCountDisplay = document.getElementById('charCountDisplay');
            if (charCountDisplay) {
                charCountDisplay.textContent = targetLen;
            }
            
            // 應用下回合的字元數（不小於詩句長度）
            charCount = Math.max(parseInt(charCountSlider.value), currentPoem.line.length);
            // Generate and display characters
            generateGameCharacters();
            populateCharactersGrid();
            
            // 在遠程限時模式中，不使用單題倒數，只顯示全局倒數
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                // 限時模式：隱藏單題進度條，只顯示全局秒數
                try { if (timeBarFill) timeBarFill.style.width = '0%'; } catch(_){ }
                try {
                    const remainMs = Math.max(0, (state.timedEndsAt || Date.now()) - Date.now());
                    timerElement.textContent = String(Math.ceil(remainMs / 1000));
                } catch(_){ }
                // 確保不會啟動單題計時器
            } else {
                // Reset timer based on current slider (下一輪生效的設定)
                roundTimeLimit = parseInt(timeLimitSlider.value);
                timeLeft = roundTimeLimit;
                timerElement.textContent = timeLeft;
                if (timeBarFill) {
                    timeBarFill.style.width = '100%';
                    timeBarFill.classList.remove('bg-red-500');
                    timeBarFill.classList.add('bg-primary');
                }
            }
            
            // 确保按钮区域显示和状态正确
            const buttonContainer = clearSelectionButton.parentElement;
            if (buttonContainer) {
                buttonContainer.classList.remove('hidden');
            }
            
            // 重置按钮状态
            updateSelectionStatus();
            
            // Start the game
            isGameActive = true;
            
            // 單題計時：僅在非遠程限時模式下啟用
            clearInterval(timerInterval);
            if (!(window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode)) {
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = timeLeft;
                    if (timeBarFill && roundTimeLimit > 0) {
                        const pct = Math.max(0, Math.min(100, (timeLeft / roundTimeLimit) * 100));
                        timeBarFill.style.width = pct + '%';
                        if (timeLeft <= 10 && timeLeft > 0) {
                            timeBarFill.classList.remove('bg-primary');
                            timeBarFill.classList.add('bg-red-500');
                        }
                    }
                    if (timeLeft === 10) {
                        soundManager.play('timeWarning');
                        timerElement.classList.add('timer-warning');
                        setTimeout(() => timerElement.classList.remove('timer-warning'), 12000);
                    }
                    if (timeLeft <= 0) {
                        endRound(false);
                    }
                }, 1000);
            }

            // 限時模式：5秒未提交顯示「跳過」按鈕
            try {
                const buttonContainer = clearSelectionButton.parentElement;
                if (buttonContainer && window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    let skipBtn = document.getElementById('skipPoem');
                    if (!skipBtn) {
                        skipBtn = document.createElement('button');
                        skipBtn.id = 'skipPoem';
                        skipBtn.className = 'gradient-secondary text-white px-6 py-3 rounded-2xl font-modern font-semibold text-sm shadow-lg modern-button ml-4 opacity-0 pointer-events-none transition-all';
                        skipBtn.textContent = '跳過';
                        buttonContainer.appendChild(skipBtn);
                        skipBtn.addEventListener('click', () => {
                            if (isGameActive) endRound(false, 'skip');
                        });
                    }
                    skipBtn.style.opacity = '0';
                    skipBtn.style.pointerEvents = 'none';
                    setTimeout(() => {
                        if (isGameActive && window.RemoteBattle?.room && state.timedMode) {
                            skipBtn.style.opacity = '1';
                            skipBtn.style.pointerEvents = 'auto';
                        }
                    }, 5000);
                }
            } catch(_){}
        };

        // End the current round
        const endRound = (success, reason = 'timeout') => {
            // Stop the timer
            clearInterval(timerInterval);
            isGameActive = false;
            
            // 不再隐藏按钮，保持按钮区域可见
            
            if (success) {
                // 播放正確音效
                soundManager.play('correct');
                
                // 显示答对动画
                poemDisplay.classList.add('animate-correct');
                
                // 将诗句文字变为绿色（与提交按钮相同的颜色）
                poemDisplay.classList.add('text-secondary');
                poemDisplay.classList.add('font-bold');
                
                setTimeout(() => {
                    poemDisplay.classList.remove('animate-correct');
                }, 1000);
                
                // 更新分數
                if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    // 固定 +10 分；答對
                    applyScoreDelta(10, true);
                } else if (!battleMode.isActive) {
                    score++;
                }
                
                // 添加分数变化动画
                scoreElement.classList.add('animate-score');
                scoreElement.textContent = score;
                setTimeout(() => {
                    scoreElement.classList.remove('animate-score');
                }, 800);
                
                // 限時模式：不彈出本地結果浮窗，僅短暫樣式反饋
                if (!(window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode)) {
                    showResultModal(true, '恭喜！答對了！');
                }
            } else {
                // 播放錯誤/時間到音效
                soundManager.play('timeUp');
                
                // 根据失败原因显示不同内容
                if (reason === 'timeout') {
                    // 时间到：显示红色"時間到"文字
                    poemDisplay.value = '時間到';
                    poemDisplay.classList.remove('text-surface-800');
                    poemDisplay.classList.add('text-red-600', 'font-bold');
                    // 不显示错误图标，因为没有用户答案
                    poemErrorIcon.classList.add('hidden');
                } else {
                    // 用户答错：显示答错动画
                    poemDisplay.classList.add('animate-wrong');
                    setTimeout(() => {
                        poemDisplay.classList.remove('animate-wrong');
                    }, 500);
                }
                
                // 限時模式：不彈出本地結果浮窗
                if (!(window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode)) {
                    showResultModal(false, reason === 'timeout' ? '時間到！' : '答錯了！', currentPoem.line);
                }
                // 限時模式下記一次作答（不加分）
                if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    applyScoreDelta(0, false);
                }
            }
            
            // 限時模式：結束後自動下一題；非限時仍走原邏輯
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                setTimeout(() => { if (!state.timedMode) return; startNewRound(); }, 600);
                return; // 避免落入輪流流程
            } else if (battleMode.isActive) {
                endBattleRound(success);
            }
        };

        // 讓遠端事件可直接呼叫新回合（避免 const 聲明未掛到 window）
        try { window.startNewRound = startNewRound; } catch(_) {}

        // Verify if the current input matches the poem
        const verifyPoem = () => {
            return poemDisplay.value === currentPoem.line;
        };

        function applyScoreDelta(delta, isCorrect){
            try {
                // 本地：單人側計分
                scoreElement.classList.add('animate-score');
                setTimeout(() => scoreElement.classList.remove('animate-score'), 800);
                // 遠程：維護統計並廣播
                if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    const uid = state.user?.id;
                    state.stats[uid] = state.stats[uid] || { score:0, answered:0, correct:0, nickname:'' };
                    const s = state.stats[uid];
                    s.score += delta;
                    s.answered += 1;
                    if (isCorrect) s.correct += 1;
                    s.lastTs = Date.now();
                    window.RemoteBattle.sendGameEvent('score_update', { userId: uid, delta, answeredInc:1, correctInc: isCorrect?1:0 });
                }
            } catch(_){}
        }

        // 更新已選字狀態與提交可用性
        const updateSelectionStatus = () => {
            const selected = poemDisplay.value.length;
            const target = currentPoem ? currentPoem.line.length : 0;
            const statusEl = document.getElementById('selectionStatus');
            if (statusEl) {
                statusEl.textContent = `已選 ${selected} / ${target}`;
                statusEl.classList.remove('text-red-600');
            }
            const submitBtn = document.getElementById('submitPoem');
            if (submitBtn) {
                // 僅在字數完全匹配時允許提交
                const canSubmit = selected === target && target > 0;
                submitBtn.disabled = !canSubmit;
                if (submitBtn.disabled) {
                    submitBtn.classList.add('opacity-60', 'cursor-not-allowed');
                } else {
                    submitBtn.classList.remove('opacity-60', 'cursor-not-allowed');
                }
            }
            // 超出字數提示
            if (selected > target && statusEl) {
                statusEl.classList.add('text-red-600');
            }
        };

        // Event listeners
        clearSelectionButton.addEventListener('click', () => {
            if (isGameActive) {
                soundManager.play('buttonClick');
                // 後退一字：彈出堆疊最後一個字，並還原其按鈕狀態
                const last = selectionStack.pop();
                if (last && last.btn) {
                    last.btn.classList.remove('selected');
                    // 恢復 hover 綠色
                    last.btn.classList.add('hover:bg-secondary', 'hover:text-white');
                }
                poemDisplay.value = selectionStack.map(x => x.char).join('');
                updateSelectionStatus();
            }
        });

        submitButton.addEventListener('click', () => {
            if (isGameActive) {
                // 播放按鈕點擊音效
                soundManager.play('buttonClick');
                
                if (poemDisplay.value.trim().length === 0) {
                    showNotification('請先選擇漢字再提交！');
                    return;
                }
                
                const isCorrect = verifyPoem();
                endRound(isCorrect, isCorrect ? 'correct' : 'wrong');
            }
        });

        // Difficulty select event listener
        difficultySelect.addEventListener('change', () => {
            const difficulty = difficultySelect.value;
            applyDifficultySettings(difficulty);
            
            if (isGameActive) {
                showNotification('難度已變更，將在下一輪生效');
            }
        });
        
        // Time limit slider event listener（只更新顯示，下回合生效）
        timeLimitSlider.addEventListener('input', () => {
            const nextTime = parseInt(timeLimitSlider.value);
            timeLimitValue.textContent = nextTime;
            if (isGameActive) {
                showNotification('時間限制已變更，將在下一輪生效');
            }
        });
        
        // Character count slider event listener
        charCountSlider.addEventListener('input', () => {
            charCount = parseInt(charCountSlider.value);
            charCountValue.textContent = charCount;
            
            if (isGameActive) {
                showNotification('待選字數量已變更，將在下一輪生效');
            }
        });
        
        // 自定義詩句功能已移除
        
        // 舊的事件監聽器已移至設置模態彈窗中處理
        
        // Save custom poem event listener (已在設置模態彈窗中處理)
        
        // Admin mode toggle (舊功能已移至設置模態彈窗)
        const difficultySelector = document.getElementById('difficultySelector');
        let isAdminMode = false;
        
        // 舊的 Toggle admin mode 功能已移至設置模態彈窗
        
        // Enhance characters display
        const enhanceCharacterDisplay = () => {
            // Make the characters larger in the grid
            document.querySelectorAll('.character-btn').forEach(btn => {
                btn.classList.remove('p-3', 'text-xl', 'text-2xl');
                btn.classList.add('p-4', 'text-3xl');
            });
        };
        
        // 安全添加事件监听器的辅助函数
        const safeAddEventListener = (elementId, event, handler) => {
            const element = document.getElementById(elementId);
            if (element) {
                element.addEventListener(event, handler);
            }
        };

        // 安全地检查和添加所有事件监听器
        const setupEventListeners = () => {
            // 已有核心監聽在上方綁定，這裡避免重複
            if (areCoreListenersBound) return;
            areCoreListenersBound = true;
            return;
            
            // 现有的事件监听器设置
            if (clearSelectionButton) {
                clearSelectionButton.addEventListener('click', () => {
                    if (isGameActive) {
                        poemDisplay.value = '';
                        // Re-enable all character buttons
                        document.querySelectorAll('.character-btn').forEach(btn => {
                            btn.disabled = false;
                            btn.classList.remove('opacity-50', 'cursor-not-allowed');
                            btn.classList.add('hover:bg-secondary', 'hover:text-white');
                        });
                    }
                });
            }

            if (submitButton) {
                submitButton.addEventListener('click', () => {
                    if (isGameActive) {
                        if (poemDisplay.value.trim().length === 0) {
                            showNotification('請先選擇漢字再提交！');
                            return;
                        }
                        
                        const isCorrect = verifyPoem();
                        endRound(isCorrect, isCorrect ? 'correct' : 'wrong');
                    }
                });
            }

            if (difficultySelect) {
                difficultySelect.addEventListener('change', () => {
                    const difficulty = difficultySelect.value;
                    applyDifficultySettings(difficulty);
                    
                    if (isGameActive) {
                        showNotification('難度已變更，將在下一輪生效');
                    }
                });
            }

            if (timeLimitSlider) {
                timeLimitSlider.addEventListener('input', () => {
                    timeLeft = parseInt(timeLimitSlider.value);
                    timeLimitValue.textContent = timeLeft;
                    
                    if (isGameActive) {
                        showNotification('時間限制已變更，將在下一輪生效');
                    }
                });
            }

            if (charCountSlider) {
                charCountSlider.addEventListener('input', () => {
                    charCount = parseInt(charCountSlider.value);
                    charCountValue.textContent = charCount;
                    
                    if (isGameActive) {
                        showNotification('待選字數量已變更，將在下一輪生效');
                    }
                });
            }

            if (gameMode) {
                gameMode.addEventListener('change', () => {
                    currentGameMode = gameMode.value;
                    
                    if (currentGameMode === 'custom') {
                        customPoemSettings.classList.remove('hidden');
                        updateSavedPoemsList();
                    } else {
                        customPoemSettings.classList.add('hidden');
                    }
                    
                    if (isGameActive) {
                        showNotification('模式已變更，將在下一輪生效');
                    }
                });
            }

            if (saveCustomPoemButton) {
                saveCustomPoemButton.addEventListener('click', saveCustomPoem);
            }

            // 舊的 adminModeToggle 事件監聽器已移至 setupSettingsEventListeners

            if (closeNotification) {
                closeNotification.addEventListener('click', () => {
                    notification.classList.remove('translate-y-0');
                    notification.classList.add('translate-y-[-150%]');
                });
            }
        };

        // 初始化游戏
        const initGame = () => {
            console.log("初始化遊戲...");
            
            // 首先優化iframe布局
            optimizeForIframe();
            
            // 設置事件監聽器
            // setupEventListeners(); // 已移至setupSettingsEventListeners
            
            // 應用初始難度設置
            if (difficultySelect) {
                applyDifficultySettings(difficultySelect.value);
            }
            
            // 處理音效開關按鈕
            const soundToggle = document.getElementById('soundToggle');
            if (soundToggle) {
                console.log("綁定音效開關按鈕事件");
                
                // 移除所有已有的事件監聽器
                const newSoundToggle = soundToggle.cloneNode(true);
                soundToggle.parentNode.replaceChild(newSoundToggle, soundToggle);
                
                // 添加新的事件監聽器
                newSoundToggle.addEventListener('click', function() {
                    // 播放按鍵點擊音效（在靜音前）
                    soundManager.play('buttonClick');
                    
                    // 切換靜音狀態
                    const isMuted = soundManager.toggleMute();
                    
                    window.soundEnabled = !isMuted;
                    // 更新保存狀態（即時保存）
                    try {
                        const s = loadSettings();
                        s.soundOn = window.soundEnabled;
                        persistSettings(s);
                    } catch {}

                    // 更新按鈕文字和圖示
                    if (isMuted) {
                        newSoundToggle.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 mr-1">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M17.25 9.75L19.5 12m0 0l2.25 2.25M19.5 12l2.25-2.25M19.5 12l-2.25 2.25m-10.5-6l4.72-4.72a.75.75 0 011.28.531V19.94a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.506-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.395C2.806 8.757 3.63 8.25 4.51 8.25H6.75z" />
                            </svg>
                            音效關
                        `;
                    } else {
                        newSoundToggle.innerHTML = `
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4 mr-1">
                                <path stroke-linecap="round" stroke-linejoin="round" d="M19.114 5.636a9 9 0 010 12.728M16.463 8.288a5.25 5.25 0 010 7.424M6.75 8.25l4.72-4.72a.75.75 0 011.28.53v15.88a.75.75 0 01-1.28.53l-4.72-4.72H4.51c-.88 0-1.704-.507-1.938-1.354A9.01 9.01 0 012.25 12c0-.83.112-1.633.322-2.396C2.806 8.756 3.63 8.25 4.51 8.25H6.75z" />
                            </svg>
                            音效開
                        `;
                    }
                });
            }
            
            // 舊的管理員按鈕功能已移至 setupSettingsEventListeners 中的設置模態彈窗
            
            // 從本地存儲恢復 UI 與狀態
            try { restoreFromLocalStorage(); } catch (e) { console.warn('restoreFromLocalStorage failed', e); }
            // 若遠程對戰配置面板已開啟或正處於遠程限時模式，禁止單人模式自動開局
            const rbm = document.getElementById('remoteBattleModal');
            const remotePanelOpen = !!(rbm && !rbm.classList.contains('hidden'));
            const remoteTimed = (typeof state !== 'undefined' && state.timedMode);
            if (!remotePanelOpen && !remoteTimed) {
                startNewRound();
            }
        };

        // 設置模態彈窗相關函數
        let gameWasPaused = false;
        let timerWasActive = false;
        
        function openSettingsModal() {
            // 暫停遊戲
            gameWasPaused = isGameActive;
            timerWasActive = !!timerInterval;
            
            if (timerInterval) {
                clearInterval(timerInterval);
            }
            isGameActive = false;
            
            // 顯示模態彈窗
            settingsModal.classList.remove('hidden');
            
            // 同步當前設置到模態彈窗
            syncSettingsToModal();
        }
        
        function closeSettingsModalFunc() {
            settingsModal.classList.add('hidden');
            
            // 如果遊戲之前是活躍的，恢復遊戲狀態
            if (gameWasPaused && timerWasActive) {
                isGameActive = true;
                // 限時模式：不恢復單題計時器
                if (!(window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode)) {
                    startTimer();
                }
            }
        }
        
        function syncSettingsToModal() {
            // 同步遊戲模式（僅處理單人/對戰）
            const currentMode = battleMode.isActive ? 'battle' : 'single';
            const modeRadio = document.querySelector(`input[name="gameMode"][value="${currentMode}"]`);
            if (modeRadio) modeRadio.checked = true;

            // 根據模式顯示/隱藏相關設置
            updateModalSections();
        }
        
        function updateModalSections() {
            const selectedModeEl = document.querySelector('input[name="gameMode"]:checked');
            const selectedMode = selectedModeEl ? selectedModeEl.value : 'single';

            // 顯示/隱藏對戰模式設置（安全判斷節點存在）
            if (battleModeSettings) {
                if (selectedMode === 'battle') {
                    battleModeSettings.classList.remove('hidden');
                    // 生成選手名稱輸入框
                    generatePlayerNameInputs();
                } else {
                    battleModeSettings.classList.add('hidden');
                }
            }
        }
        
        function openBattlePreviewModal(settings) {
            if (!battlePreviewModal) return;

            const playerCount = settings.battle?.playerCount || 0;
            const roundsPerPlayer = settings.battle?.roundsPerPlayer || 0;
            const players = settings.battle?.playerNames || [];
            const totalRounds = playerCount * roundsPerPlayer;
            const totalQuestions = totalRounds;

            if (battlePreviewPlayerCount) battlePreviewPlayerCount.textContent = String(playerCount);
            if (battlePreviewRounds) battlePreviewRounds.textContent = String(roundsPerPlayer);
            if (battlePreviewTotalQuestions) battlePreviewTotalQuestions.textContent = String(totalQuestions);

            const tl = typeof settings.timeLimit === 'number' ? settings.timeLimit : roundTimeLimit;
            if (battlePreviewTimeLimit) battlePreviewTimeLimit.textContent = `${tl} 秒`;

            const cc = typeof settings.charCount === 'number' ? settings.charCount : charCount;
            if (battlePreviewCharCount) battlePreviewCharCount.textContent = `${cc} 字`;

            if (battlePreviewPlayersList) {
                battlePreviewPlayersList.innerHTML = '';
                players.forEach((name, index) => {
                    const card = document.createElement('div');
                    card.className = 'glass-card rounded-2xl p-3 border border-white/20 flex items-center gap-3 shadow-sm';
                    card.innerHTML = `
                        <div class="w-10 h-10 rounded-2xl bg-gradient-to-br from-primary-100 to-primary-200 flex items-center justify-center text-primary-600 font-modern font-bold">${index + 1}</div>
                        <div>
                            <div class="text-base font-modern font-semibold text-surface-800">${name}</div>
                            <div class="text-xs text-surface-500 font-modern">第 ${index + 1} 位上場</div>
                        </div>
                    `;
                    battlePreviewPlayersList.appendChild(card);
                });
            }

            const isSpeed = !!settings.battle?.speedMode;
            if (battlePreviewSpeedRow) {
                if (isSpeed) {
                    battlePreviewSpeedRow.classList.remove('hidden');
                    if (battlePreviewSpeedText) {
                        battlePreviewSpeedText.textContent = '速度模式已開啟：越快完成答題，越可以獲得額外加分（最高可再加 50%）。';
                    }
                } else {
                    battlePreviewSpeedRow.classList.add('hidden');
                }
            }

            if (battlePreviewNote) {
                const noteLines = [
                    '將按照名單順序輪流答題，系統會自動記錄分數。',
                    '若答錯或超時將不加分，請專心完成每題詩句組合。',
                    isSpeed ? '速度加分會依照剩餘時間即時計算。' : '此場對戰以準確度為主，保持穩定節奏即可。'
                ];
                battlePreviewNote.innerHTML = noteLines.map(line => `<div class="flex items-start gap-2"><span class="text-primary-500">•</span><span>${line}</span></div>`).join('');
            }

            battlePreviewModal.classList.remove('hidden');
        }

        function closeBattlePreviewModal() {
            if (!battlePreviewModal) return;
            battlePreviewModal.classList.add('hidden');
        }

        function saveSettingsFromModal() {
            const selectedMode = document.querySelector('input[name="gameMode"]:checked')?.value || 'single';
            const selectedDB = 'tag';
            
            // 保存遊戲模式
            if (selectedMode === 'battle') {
                currentGameMode = 'battle';
            } else {
                currentGameMode = selectedDB === 'custom' ? 'custom' : 'preset';
            }
            
            // 保存詩詞庫設置
            if (selectedDB === 'default') {
                activeDatabase = tangPoetryLines;
            } else if (selectedDB === 'elementary') {
                activeDatabase = elementaryPoemLines;
            }
            // 詩詞庫改為標籤模式，保存當前選中的標籤
            const tagSel = document.getElementById('userLibraryTagSelect');
            if (tagSel) saveActiveTag(tagSel.value || '');

            // 保存設置到 localStorage
            const settingsToSave = {
                gameMode: selectedMode,
                poemDatabase: selectedDB,
                timeLimit: parseInt(timeLimitSlider?.value || '30'),
                charCount: parseInt(charCountSlider?.value || '20'),
                difficulty: difficultySelect?.value || 'medium',
                soundOn: !!window.soundEnabled,
                battle: {
                    playerCount: parseInt(playerCountSelect?.value || '2'),
                    roundsPerPlayer: Math.max(1, Math.min(50, parseInt(roundsPerPlayerInput?.value || '5'))),
                    speedMode: !!(speedModeCheckbox && speedModeCheckbox.checked),
                    playerNames: Array.from({ length: parseInt(playerCountSelect?.value || '2') }, (_, i) => {
                        const input = document.getElementById(`player${i + 1}Name`);
                        return input ? input.value || `選手${i + 1}` : `選手${i + 1}`;
                    })
                }
            };
            persistSettings(settingsToSave);
            
            // 對戰模式先顯示預覽模態；單人模式需安全退出對戰
            if (selectedMode === 'battle') {
                closeSettingsModalFunc();
                openBattlePreviewModal(settingsToSave);
            } else {
                // 若正處於對戰模式，安全退出並切回單人模式
                if (battleMode.isActive) {
                    battleMode.isActive = false;
                    battleMode.players = [];
                    battleScoreboard && battleScoreboard.classList.add('hidden');
                }
                currentGameMode = 'preset';
                closeSettingsModalFunc();
                showNotification('已切換到單人模式');
                // 立即開始單人新回合
                startNewRound();
            }
        }
        
        function startTimer() {
            // 限時模式：不啟用單題計時器
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) return;
            if (timeLeft > 0) {
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timerElement.textContent = timeLeft;
                    if (timeBarFill && roundTimeLimit > 0) {
                        const pct = Math.max(0, Math.min(100, (timeLeft / roundTimeLimit) * 100));
                        timeBarFill.style.width = pct + '%';
                        if (timeLeft <= 10 && timeLeft > 0) {
                            timeBarFill.classList.remove('bg-primary');
                            timeBarFill.classList.add('bg-red-500');
                        }
                    }
                    
                    if (timeLeft === 10) {
                        soundManager.play('timeWarning');
                    }
                    
                    if (timeLeft <= 0) {
                        endRound(false);
                    }
                }, 1000);
            }
        }

        // 對戰模式相關函數
        function initializeBattleMode() {
            // 生成選手名稱輸入框
            generatePlayerNameInputs();
            
            // 綁定選手數量變更事件
            if (playerCountSelect) {
                playerCountSelect.addEventListener('change', generatePlayerNameInputs);
            }
            if (roundsPerPlayerInput) {
                roundsPerPlayerInput.addEventListener('input', () => {
                    const v = Math.max(1, Math.min(50, parseInt(roundsPerPlayerInput.value || '5')));
                    roundsPerPlayerInput.value = String(isNaN(v) ? 5 : v);
                });
            }
            
            // 開始對戰功能已整合到保存設置中
        }
        
        function generatePlayerNameInputs() {
            const playerCount = parseInt(playerCountSelect.value);
            playerNamesContainer.innerHTML = '';
            
            for (let i = 0; i < playerCount; i++) {
                const inputDiv = document.createElement('div');
                inputDiv.innerHTML = `
                    <label class="block text-sm font-medium mb-1">選手 ${i + 1}：</label>
                    <input type="text" id="player${i + 1}Name" placeholder="輸入選手名稱" 
                           class="w-full p-2 rounded-md border border-gray-300 bg-white text-base" 
                           value="選手${i + 1}">
                `;
                playerNamesContainer.appendChild(inputDiv);
            }

            // 從本地存儲恢復玩家名稱（若有）
            const saved = loadSettings();
            if (saved && saved.battle && Array.isArray(saved.battle.playerNames)) {
                saved.battle.playerNames.forEach((name, idx) => {
                    const input = document.getElementById(`player${idx + 1}Name`);
                    if (input && name) input.value = name;
                });
            }
        }
        
        function confirmStartBattleMode() {
            // 若遠程限時模式進行中，禁止啟動本地輪流，直接返回
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                try { showNotification && showNotification('目前為遠程限時競賽，已禁用本地輪流模式'); } catch(_){ }
                return;
            }
            // 收集選手名稱
            const playerCount = parseInt(playerCountSelect.value);
            battleMode.players = [];
            
            for (let i = 0; i < playerCount; i++) {
                const nameInput = document.getElementById(`player${i + 1}Name`);
                const playerName = nameInput ? nameInput.value || `選手${i + 1}` : `選手${i + 1}`;
                battleMode.players.push({
                    name: playerName,
                    score: 0,
                    displayedScore: 0,
                    isActive: i === 0
                });
            }

            // 寫回保存玩家設置
            const s = loadSettings();
            s.battle = s.battle || {}; 
            s.battle.playerCount = playerCount;
            s.battle.roundsPerPlayer = Math.max(1, Math.min(50, parseInt(roundsPerPlayerInput.value || '5')));
            s.battle.speedMode = !!(speedModeCheckbox && speedModeCheckbox.checked);
            s.battle.playerNames = battleMode.players.map(p => p.name);
            persistSettings(s);
            
            // 設置對戰模式參數
            battleMode.isActive = true;
            battleMode.currentPlayerIndex = 0;
            battleMode.roundsPerPlayer = Math.max(1, Math.min(50, parseInt(roundsPerPlayerInput.value || '5')));
            battleMode.currentRound = 0;
            battleMode.totalRounds = battleMode.players.length * battleMode.roundsPerPlayer;
            
            // 顯示積分板
            updateBattleScoreboard();
            battleScoreboard.classList.remove('hidden');
            
            // 開始第一輪
            // 如果遊戲暫停或尚未啟動，直接開始；若已有計時，重置狀態
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            isGameActive = false;
            startBattleRound();
            showNotification('對戰模式已啟動！');
        }
        
        // 分數數字動畫（從 from 到 to，時長毫秒）
        function animateScoreValue(element, from, to, duration) {
            const start = performance.now();
            const change = to - from;
            if (change === 0) {
                element.textContent = String(to);
                return;
            }
            const easeOutCubic = t => 1 - Math.pow(1 - t, 3);
            function step(now) {
                const elapsed = now - start;
                const progress = Math.min(1, elapsed / duration);
                const eased = easeOutCubic(progress);
                const current = Math.round(from + change * eased);
                element.textContent = String(current);
                if (progress < 1) requestAnimationFrame(step);
            }
            requestAnimationFrame(step);
        }

        function updateBattleScoreboard() {
            leftPlayersContainer.innerHTML = '';
            rightPlayersContainer.innerHTML = '';
            // 遠程限時模式下，按 score 降序展示（同分以 lastTs 先者在前）
            let players = [...battleMode.players];
            try {
                if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    players = players.map((pl, idx) => {
                        const uid = state.rosterUserIds[idx];
                        const st = uid ? state.stats[uid] : null;
                        return { ...pl, score: st ? st.score : pl.score, _last: st ? st.lastTs : 0, isActive: false };
                    }).sort((a, b) => (b.score - a.score) || (a._last - b._last));
                }
            } catch(_){ }

            const leftCount = Math.ceil(players.length / 2);

            players.forEach((player, index) => {
                const isLeftSide = index < leftCount;
                const container = isLeftSide ? leftPlayersContainer : rightPlayersContainer;
                
                const playerCard = document.createElement('div');
                const themeClass = `player-theme-${(index % 6) + 1}`;
                const showActive = !(window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) && !!player.isActive;
                playerCard.className = `player-score-card ${themeClass} ${showActive ? 'active' : ''}`;
                
                playerCard.innerHTML = `
                    <div class="player-name text-lg md:text-xl font-bold">${player.name}</div>
                    <div class="player-score text-2xl md:text-3xl">${typeof player.displayedScore === 'number' ? player.displayedScore : player.score}</div>
                    ${showActive ? '<div class=\"current-turn-indicator\"></div>' : ''}
                `;
                
                container.appendChild(playerCard);

                // 分數滾動動畫（若分數有變化）
                const scoreEl = playerCard.querySelector('.player-score');
                const from = typeof player.displayedScore === 'number' ? player.displayedScore : player.score;
                const to = player.score;
                if (from !== to) {
                    // 觸發縮放動畫（若已定義 animate-score 可一併使用）
                    scoreEl.classList.add('animate-score');
                    animateScoreValue(scoreEl, from, to, 700);
                    // 記錄新的已顯示分數
                    player.displayedScore = to;
                    // 動畫結束後移除類名
                    setTimeout(() => scoreEl.classList.remove('animate-score'), 800);
                }
            });
        }
        
        function startBattleRound() {
            // 限時模式下不使用本地輪流回合
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) return;
            const currentPlayer = battleMode.players[battleMode.currentPlayerIndex];
            showNotification(`${currentPlayer.name} 的回合開始！`);
            
            // 開始新的一輪遊戲
            startNewRound();

            // 左上角顯示對戰輪次（替代分數）
            if (scoreLabel && scoreElement) {
                // 限時模式下維持分數標籤
                if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) {
                    scoreLabel.textContent = '分數';
                    scoreElement.textContent = String(score);
                } else {
                    scoreLabel.textContent = '輪次';
                    scoreElement.textContent = `${battleMode.currentRound + 1} / ${battleMode.totalRounds}`;
                }
            }
        }
        
        function endBattleRound(isCorrect) {
            // 限時模式下不使用本地輪流回合結束
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) return;
            const currentPlayer = battleMode.players[battleMode.currentPlayerIndex];
            
            if (isCorrect) {
                // 基礎分
                let gained = 10;
                // 速度模式加成
                if (speedModeCheckbox && speedModeCheckbox.checked && roundTimeLimit > 0) {
                    const ratio = Math.max(0, Math.min(1, timeLeft / roundTimeLimit));
                    const bonus = Math.floor(gained * 0.5 * ratio);
                    gained += bonus;
                    showNotification(`${currentPlayer.name} 答對！速度加成 +${bonus} 分`);
                } else {
                    showNotification(`${currentPlayer.name} 答對了！獲得${gained}分`);
                }
                currentPlayer.score += gained;
            } else {
                showNotification(`${currentPlayer.name} 答錯了`);
            }
            
            // 檢查是否完成所有回合
            battleMode.currentRound++;
            // 更新左上角輪次顯示
            if (scoreLabel && scoreElement) {
                scoreLabel.textContent = '輪次';
                scoreElement.textContent = `${Math.min(battleMode.currentRound + 1, battleMode.totalRounds)} / ${battleMode.totalRounds}`;
            }
            if (battleMode.currentRound >= battleMode.totalRounds) {
                endBattleMode();
                return;
            }
            
            // 切換到下一個選手
            battleMode.players[battleMode.currentPlayerIndex].isActive = false;
            battleMode.currentPlayerIndex = (battleMode.currentPlayerIndex + 1) % battleMode.players.length;
            battleMode.players[battleMode.currentPlayerIndex].isActive = true;
            
            // 先切換 active，再更新積分板，讓呼吸動畫跟隨目前答題者
            updateBattleScoreboard();
            
            // 開始下一輪 - 移除自动延迟，改为手动控制
            // startBattleRound() 将由浮窗的"下一輪"按钮调用
        }
        
        function endBattleMode() {
            // 限時模式下不走本地輪流結算
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode) return;
            battleMode.isActive = false;
            
            // 隱藏積分板
            battleScoreboard.classList.add('hidden');
            
            // 顯示對戰結果總結窗口
            showBattleResultModal();

            // 恢復單人模式左上角顯示為分數
            if (scoreLabel && scoreElement) {
                scoreLabel.textContent = '分數';
                scoreElement.textContent = String(score);
            }
        }
        
        function showBattleResultModal() {
            // 1) 遠程限時模式：僅允許在 timed_end 流程中顯示（此處保持冪等）
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedMode === true) {
                return; // 進行中不顯示
            }
            if (window.RemoteBattle?.room && typeof state !== 'undefined' && state.timedEndsAt > 0) {
                try {
                    const rows = (state.rosterUserIds || []).map((uid, idx) => {
                        const name = (battleMode.players && battleMode.players[idx] && battleMode.players[idx].name) || (state.stats[uid]?.nickname) || '玩家';
                        const st = state.stats[uid] || { score:0, answered:0, correct:0, lastTs:0 };
                        const acc = st.answered > 0 ? Math.round((st.correct / st.answered) * 100) : 0;
                        return { name, score: st.score||0, answered: st.answered||0, correct: st.correct||0, acc, _last: st.lastTs||0 };
                    }).sort((a,b) => (b.score - a.score) || (a._last - b._last));

                    // 標題
                    winnerAnnouncement.textContent = '競賽結束';
                    if (rows.length && rows[0].score > 0) {
                        winnerScore.textContent = `最高分：${rows[0].name} ${rows[0].score} 分`;
                    } else {
                        winnerScore.textContent = '';
                    }

                    // 表格
                    battleRankings.innerHTML = '';
                    rows.forEach((r, i) => {
                        const rank = i + 1;
                        const rankItem = document.createElement('div');
                        rankItem.className = 'rank-item';
                        rankItem.style.animationDelay = `${i * 0.06}s`;
                        const medals = ['🥇','🥈','🥉'];
                        const rankText = rank <= 3 ? medals[rank-1] : `#${rank}`;
                        rankItem.innerHTML = `
                            <div class="rank-medal w-12 text-center">${rankText}</div>
                            <div class="rank-name flex-grow text-lg">${r.name}</div>
                            <div class="rank-score text-xl">${r.score} <span class="text-sm">分</span></div>
                            <div class="rank-answered text-sm text-slate-600 ml-4">題數：${r.answered}</div>
                            <div class="rank-acc text-sm text-slate-600 ml-4">正確率：${r.acc}%</div>
                        `;
                        battleRankings.appendChild(rankItem);
                    });

                    battleResultModal.classList.remove('hidden');
                    return;
                } catch(_) { /* fallback to舊版 */ }
            }

            // 2) 舊模式（本地輪流）：沿用原排序
            const sortedPlayers = [...battleMode.players].sort((a, b) => b.score - a.score);
            
            // 2. 找出最高分
            const highScore = sortedPlayers.length > 0 ? sortedPlayers[0].score : 0;
            
            // 3. 找出所有获得最高分的玩家
            const winners = sortedPlayers.filter(player => player.score === highScore);

            // 4. 设置获胜者信息
            if (winners.length > 1) {
                // 平局或多人并列第一
                const winnerNames = winners.map(p => p.name).join(', ');
                winnerAnnouncement.textContent = `🏆 平局！`;
                winnerScore.textContent = `${winnerNames} 并列第一!`;
            } else if (winners.length === 1) {
                // 单独获胜者
                const winner = winners[0];
                winnerAnnouncement.textContent = `🎉 恭喜 ${winner.name} 获胜！`;
                winnerScore.textContent = `最终得分: ${winner.score}`;
            } else {
                // 没有玩家的情况
                winnerAnnouncement.textContent = '比赛结束';
                winnerScore.textContent = '没有玩家参与';
            }
            
            // 5. 生成排行榜 (处理并列排名)
            battleRankings.innerHTML = '';
            const medals = ['🥇', '🥈', '🥉'];
            let rank = 1;
            for (let i = 0; i < sortedPlayers.length; i++) {
                const player = sortedPlayers[i];

                // 如果当前玩家分数低于前一个玩家，更新排名
                if (i > 0 && player.score < sortedPlayers[i-1].score) {
                    rank = i + 1;
                }

                const rankItem = document.createElement('div');
                rankItem.className = 'rank-item';
                rankItem.style.animationDelay = `${i * 0.1}s`;

                const rankText = rank <= 3 ? medals[rank - 1] : `#${rank}`;
                
                rankItem.innerHTML = `
                    <div class="rank-medal w-12 text-center">${rankText}</div>
                    <div class="rank-name flex-grow text-lg">${player.name}</div>
                    <div class="rank-score text-xl">${player.score} <span class="text-sm">分</span></div>
                `;
                
                battleRankings.appendChild(rankItem);
            }
            
            // 6. 顯示總結窗口
            battleResultModal.classList.remove('hidden');
        }
        
        function startNewBattle() {
            // 重置對戰數據但保持選手設置
            battleMode.players.forEach(player => {
                player.score = 0;
                player.displayedScore = 0;
                player.isActive = false;
            });
            battleMode.players[0].isActive = true;
            battleMode.currentPlayerIndex = 0;
            battleMode.currentRound = 0;
            battleMode.isActive = true;
            
            // 關閉總結窗口
            battleResultModal.classList.add('hidden');
            
            // 重新開始對戰
            updateBattleScoreboard();
            battleScoreboard.classList.remove('hidden');
            startBattleRound();
            
            showNotification('新的對戰開始！');
        }
        
        function exitBattleMode() {
            // 關閉總結窗口
            battleResultModal.classList.add('hidden');
            
            // 重置對戰模式
            battleMode.isActive = false;
            battleMode.players = [];
            currentGameMode = 'preset';
            
            // 開始單人模式
            showNotification('已切換到單人模式');
            startNewRound();
        }

        // 設置模態彈窗事件監聽器
        function setupSettingsEventListeners() {
            // 設置按鈕點擊事件
            if (adminModeToggle) {
                adminModeToggle.addEventListener('click', openSettingsModal);
            }
            
            // 關閉按鈕事件
            if (closeSettingsModal) {
                closeSettingsModal.addEventListener('click', closeSettingsModalFunc);
            }
            
            if (cancelSettings) {
                cancelSettings.addEventListener('click', closeSettingsModalFunc);
            }
            
            // 保存設置按鈕事件
            if (saveSettingsBtn) {
                saveSettingsBtn.addEventListener('click', () => {
                    saveSettingsFromModal();
                    // 立即刷新 UI 以反映可能的顯示改變
                    updateModalSections();
                });
            }

            // 詩詞庫導出/導入
            const exportExcelBtn = document.getElementById('exportExcelBtn');
            const importExcelBtn = document.getElementById('importExcelBtn');
            const importExcelInput = document.getElementById('importExcelInput');
            if (exportExcelBtn) exportExcelBtn.addEventListener('click', exportAsExcel);
            if (importExcelBtn && importExcelInput) {
                importExcelBtn.addEventListener('click', () => importExcelInput.click());
                importExcelInput.addEventListener('change', (e) => {
                    const file = e.target.files?.[0];
                    if (file) importFromExcelFile(file);
                    importExcelInput.value = '';
                });
            }
            
            // 詩詞庫標籤變更事件
            const tagSel = document.getElementById('userLibraryTagSelect');
            if (tagSel) {
                tagSel.addEventListener('change', () => saveActiveTag(tagSel.value || ''));
            }
            
            // 詩詞庫變更事件（若詩詞庫選項不存在則跳過）
            const poemDBRadios = document.querySelectorAll('input[name="poemDatabase"]');
            if (poemDBRadios && poemDBRadios.length) {
                poemDBRadios.forEach(radio => radio.addEventListener('change', updateModalSections));
            }
            
            // 遊戲模式變更事件（單人/對戰）
            document.querySelectorAll('input[name="gameMode"]').forEach(radio => {
                radio.addEventListener('change', () => {
                    updateModalSections();
                });
            });
            
            // 滑動條事件
            if (timeLimitSlider) {
                timeLimitSlider.addEventListener('input', () => {
                    timeLimitValue.textContent = timeLimitSlider.value;
                });
            }
            
            if (charCountSlider) {
                charCountSlider.addEventListener('input', () => {
                    charCountValue.textContent = charCountSlider.value;
                });
            }
            
            // 自定義詩句保存事件
            if (saveCustomPoemButton) {
                saveCustomPoemButton.addEventListener('click', saveCustomPoem);
            }
            
            // 對戰模式選手數量變更事件
            if (playerCountSelect) {
                playerCountSelect.addEventListener('change', generatePlayerNameInputs);
            }
            
            // 對戰結束總結窗口事件
            if (newBattleBtn) {
                newBattleBtn.addEventListener('click', startNewBattle);
            }
            
            if (exitBattleBtn) {
                exitBattleBtn.addEventListener('click', exitBattleMode);
            }

            if (battlePreviewClose) {
                battlePreviewClose.addEventListener('click', closeBattlePreviewModal);
            }

            if (battlePreviewBack) {
                battlePreviewBack.addEventListener('click', () => {
                    closeBattlePreviewModal();
                    openSettingsModal();
                });
            }

            if (battlePreviewStart) {
                battlePreviewStart.addEventListener('click', () => {
                    closeBattlePreviewModal();
                    confirmStartBattleMode();
                });
            }
        }

        // ===== 初始化：從本地存儲恢復設置與自定義詩句 =====
        function restoreFromLocalStorage() {
            const sRaw = loadSettings();
            const s = sRaw && typeof sRaw === 'object' ? sRaw : {};
            // 詩詞庫標籤下拉
            populateUserTagSelect();
            const tagSel = document.getElementById('userLibraryTagSelect');
            let active = loadActiveTag();
            if (active === '自定義詩句') active = '南風詩詞庫';
            if (tagSel) {
                if (active) {
                    const exists = Array.from(tagSel.options).some(o => o.value === active);
                    tagSel.value = exists ? active : (tagSel.options[0]?.value || '');
                }
                saveActiveTag(tagSel.value || '');
            }
            // 時間限制
            if (typeof s.timeLimit === 'number' && timeLimit && timeLimitValue) {
                timeLimit.value = String(s.timeLimit);
                timeLimitValue.textContent = String(s.timeLimit);
                roundTimeLimit = s.timeLimit;
            }
            // 待選字數量
            if (typeof s.charCount === 'number' && charCount && charCountValue) {
                charCount.value = String(s.charCount);
                charCountValue.textContent = String(s.charCount);
                charactersPerRound = s.charCount;
            }
            // 難度
            if (difficultySelect && s.difficulty) {
                difficultySelect.value = s.difficulty;
            }
            // 聲音
            if (soundToggle) {
                window.soundEnabled = !!s.soundOn;
                const svg = soundToggle.querySelector('svg');
                if (svg) svg.style.opacity = window.soundEnabled ? '1' : '0.5';
            }
            // 對戰設置
            if (s.battle) {
                if (playerCountSelect) playerCountSelect.value = String(s.battle.playerCount || 2);
                if (roundsPerPlayerInput) roundsPerPlayerInput.value = String(Math.max(1, Math.min(50, s.battle.roundsPerPlayer || 5)));
                if (speedModeCheckbox) speedModeCheckbox.checked = !!s.battle.speedMode;
                generatePlayerNameInputs();
                if (Array.isArray(s.battle.playerNames)) {
                    s.battle.playerNames.forEach((name, i) => {
                        const input = document.getElementById(`player${i + 1}Name`);
                        if (input) input.value = name || `選手${i + 1}`;
                    });
                }
            }
            // 自定義詩句功能已移除
            updateModalSections();
        }

        // 確保DOM完全加載後初始化遊戲
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initGame();
                setupSettingsEventListeners();
            });
        } else {
            initGame();
            setupSettingsEventListeners();
        }
    </script>
    
    <!-- 遠程對戰入口與模態（不影響原同機模式） -->
    <div id="remoteBattleBtn" class="fixed bottom-6 right-6 z-50">
        <button class="px-4 py-2 rounded-xl bg-sky-500 text-white shadow-lg interactive">
            遠程對戰
        </button>
    </div>

    <div id="remoteBattleModal" class="fixed inset-0 z-[60] hidden">
        <div class="absolute inset-0 bg-black/40"></div>
        <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[min(92vw,720px)] max-h-[86vh] overflow-auto bg-white rounded-2xl border border-slate-200 shadow-xl p-4">
            <div class="flex items-center justify-between mb-3">
                <div class="text-lg font-semibold text-slate-800">遠程對戰</div>
                <button id="rbClose" class="px-2 py-1 rounded bg-slate-100 hover:bg-slate-200">關閉</button>
            </div>

            <div class="grid md:grid-cols-2 gap-4">
                <div class="space-y-3">
                    <div class="text-sm text-slate-600">我的暱稱</div>
                    <input id="rbNickname" type="text" class="w-full border rounded-lg px-3 py-2" placeholder="輸入你的暱稱">

                    <div class="text-sm text-slate-600">建立房間</div>
                    <input id="rbRoomName" type="text" class="w-full border rounded-lg px-3 py-2" placeholder="房間名稱（可空）">
                    <button id="rbCreateBtn" class="w-full py-2 rounded-lg bg-emerald-500 text-white interactive">建立房間</button>

                    <div id="rbCreatedInfo" class="hidden bg-emerald-50 border border-emerald-200 rounded-lg p-3 text-sm">
                        <div>房間代碼：<span id="rbRoomCodeDisplay" class="font-mono font-semibold"></span></div>
                        <div class="text-slate-600 mt-1">把代碼分享給朋友加入房間</div>
                    </div>

                    <div id="rbHostSettings" class="mt-4 space-y-3 hidden">
                        <div class="text-sm font-semibold text-slate-700">對戰設定（僅房主可見）</div>
                        <div class="grid grid-cols-2 gap-3">
                            <div>
                                <div class="text-xs text-slate-600 mb-1">限時（分鐘 1–10）</div>
                                <input id="rbTimedMinutes" type="number" min="1" max="10" value="3" class="w-full border rounded-lg px-3 py-2">
                            </div>
                            <div>
                                <div class="text-xs text-slate-600 mb-1">詩詞庫</div>
                                <select id="rbPoemTag" class="w-full border rounded-lg px-3 py-2"></select>
                            </div>
                        </div>
                        <button id="rbStartTimedBtn" class="w-full py-2 rounded-lg bg-primary-500 text-white interactive">開始限時競賽</button>
                        <div class="text-xs text-slate-500">開始後，所有選手端將顯示統一計時與記分牌，並可同步作答。</div>
                    </div>
                </div>

                <div class="space-y-3">
                    <div class="text-sm text-slate-600">加入房間</div>
                    <input id="rbJoinCode" type="text" class="w-full border rounded-lg px-3 py-2" placeholder="輸入 6 位房間代碼，例如 ABC123" maxlength="6">
                    <button id="rbJoinBtn" class="w-full py-2 rounded-lg bg-sky-500 text-white interactive">加入房間</button>

                    <div class="mt-4">
                        <div class="text-sm text-slate-600 mb-2">在線玩家</div>
                        <div id="rbPresenceList" class="grid grid-cols-2 md:grid-cols-3 gap-2"></div>
                    </div>
                </div>
            </div>

            <div class="mt-4 p-3 bg-slate-50 border border-slate-200 rounded-lg text-xs text-slate-600">
                建議：房主負責開始比賽、切換回合與結算；玩家在自己裝置作答，結果會即時同步。
            </div>
        </div>
    </div>

    <!-- 限時競賽開賽前 3 秒預備倒計時疊層 -->
    <div id="rbPrepOverlay" class="fixed inset-0 z-[70] hidden items-center justify-center">
        <div class="absolute inset-0 bg-black/60"></div>
        <div class="relative z-[71] bg-white rounded-2xl border border-slate-200 shadow-2xl px-10 py-8 text-center">
            <div class="text-slate-500 text-sm mb-2">比賽即將開始</div>
            <div id="rbPrepNumber" class="text-6xl font-extrabold text-primary-500">3</div>
        </div>
    </div>

    <script>
    (function(){
        const sb = (window.ccAuth && window.ccAuth.getClient && window.ccAuth.getClient()) || window.sb;
        const state = {
            user: null,
            room: null,
            channel: null,
            dbChannel: null,
            roster: [],           // [{user_id, nickname, joined_at}]
            rosterUserIds: [],    // 與 battleMode.players 同順序的 user_id 列表
            turnUserId: null,
            presenceMap: {},
            pendingRoundStart: null
        };

        function getBM(){
            try { return (typeof battleMode !== 'undefined') ? battleMode : (window.battleMode || null); }
            catch(_) { return window.battleMode || null; }
        }

        // 確保匿名登入
        async function ensureAnonLogin(){
            if (!sb || !sb.auth) throw new Error('Supabase client 未就緒');
            const timeout = (ms) => new Promise((_, rej) => setTimeout(() => rej(new Error('auth timeout')), ms));
            const getOrLogin = (async () => {
                const sess = await sb.auth.getSession();
                if (!sess.data.session) await sb.auth.signInAnonymously();
                const user = (await sb.auth.getUser()).data.user;
                return user;
            })();
            state.user = await Promise.race([getOrLogin, timeout(8000)]);
            if (!state.user) throw new Error('anonymous auth failed');
            console.log('[remote] auth user', state.user && state.user.id);
        }

        function genRoomCode(){
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
            let s=''; for(let i=0;i<6;i++){ s += chars[Math.floor(Math.random()*chars.length)]; }
            return s;
        }

        async function createRoom(name, nickname){
            await ensureAnonLogin();
            let room = null; let lastErr = null;
            for (let i=0;i<5;i++) {
                const code = genRoomCode();
                const { data, error } = await sb
                    .from('rooms')
                    .insert({ code, host_id: state.user.id, name })
                    .select()
                    .single();
                if (!error && data) { room = data; break; }
                lastErr = error;
                if (!(error && String(error.code) === '23505')) break; // 唯一鍵衝突才重試
            }
            if (!room) throw lastErr || new Error('建立房間失敗');

            const { error: er2 } = await sb
                .from('room_players')
                .insert({ room_id: room.id, user_id: state.user.id, nickname: nickname || '玩家', is_host: true });
            if (er2) throw er2;

            await joinRealtime(room, nickname || '玩家');
            subscribeDbChanges(room.id);
            return room;
        }

        async function joinRoomByCode(code, nickname){
            await ensureAnonLogin();
            code = String(code||'').trim().toUpperCase();
            const { data: room, error } = await sb.from('rooms').select('*').eq('code', code).single();
            if (error || !room) throw new Error('找不到房間');

            await sb.from('room_players').upsert({
                room_id: room.id, user_id: state.user.id, nickname: nickname || '玩家', is_host: room.host_id === state.user.id
            });

            await joinRealtime(room, nickname || '玩家');
            subscribeDbChanges(room.id);
            return room;
        }

        async function joinRealtime(room, nickname){
            state.room = room;
            if (state.channel) { try { await state.channel.unsubscribe(); } catch(_){} }
            const channel = sb.channel(`room:${room.code}`, { config: { presence: { key: state.user.id } } });

            channel.on('presence', { event: 'sync' }, () => {
                const st = channel.presenceState();
                state.presenceMap = st || {};
                renderPresence(st);
            });

            channel.on('broadcast', { event: 'move' }, (msg) => {
                handleIncomingMove(msg?.payload);
            });

            await channel.subscribe((status) => {
                if (status === 'SUBSCRIBED') channel.track({ nickname });
            });

            state.channel = channel;
            await refreshRoster();
        }

        function subscribeDbChanges(room_id){
            if (state.dbChannel) { try { state.dbChannel.unsubscribe(); } catch(_){} }
            const ch = sb.channel('db:'+room_id)
                .on('postgres_changes', { event: 'INSERT', schema: 'public', table: 'room_events', filter: `room_id=eq.${room_id}` }, (c)=>{
                    handleIncomingMove({ type: c.new.event_type, payload: c.new.payload, fromDb: true, from: c.new.user_id, ts: Date.now() });
                })
                .on('postgres_changes', { event: 'UPDATE', schema: 'public', table: 'rooms', filter: `id=eq.${room_id}` }, (c)=>{
                    handleRoomUpdate(c.new);
                })
                .on('postgres_changes', { event: '*', schema: 'public', table: 'room_players', filter: `room_id=eq.${room_id}` }, async ()=>{
                    await refreshRoster();
                })
                .subscribe();
            state.dbChannel = ch;
        }

        async function refreshRoster(){
            if (!state.room) return;
            const { data, error } = await sb
                .from('room_players')
                .select('user_id, nickname, joined_at')
                .eq('room_id', state.room.id)
                .order('joined_at', { ascending: true });
            let roster = (!error && Array.isArray(data)) ? data : [];
            if (!roster || roster.length === 0) {
                // fallback to presence
                const presence = state.presenceMap || {};
                roster = Object.keys(presence).map(uid => {
                    const meta = (presence[uid] && presence[uid][0]) || {};
                    return { user_id: uid, nickname: meta.nickname || '玩家', joined_at: null };
                });
            }
            state.roster = Array.isArray(roster) ? roster.filter(Boolean) : [];
            // 更新在線清單的顯示
            const list = document.getElementById('rbPresenceList');
            if (list) {
                list.innerHTML = '';
                state.roster.forEach(p => {
                    const div = document.createElement('div');
                    div.className = 'px-3 py-2 rounded-lg border bg-white text-sm';
                    div.textContent = (p && p.nickname) ? p.nickname : '玩家';
                    list.appendChild(div);
                });
            }
        }

        async function sendGameEvent(type, payload){
            if (!state.room || !state.channel) return;
            const out = { type, payload, ts: Date.now(), from: state.user?.id };
            state.channel.send({ type: 'broadcast', event: 'move', payload: out });
            await sb.from('room_events').insert({ room_id: state.room.id, user_id: state.user.id, event_type: type, payload });
        }

        function handleIncomingMove(msg){
            if (!msg) return;
            if (msg.from && state.user && msg.from === state.user.id) return; // 忽略自己事件
            try {
                // 遠程限時模式：嚴格白名單僅允許 timed_start/score_update/timed_end
                if (state && state.timedMode === true) {
                    const allowed = { timed_start:1, score_update:1, timed_end:1 };
                    if (!allowed[msg.type]) {
                        // 忽略任何輪流/配置類事件，避免串台
                        return;
                    }
                }
                switch (msg.type) {
                    case 'battle_config':
                        applyBattleConfig(msg.payload);
                        // 若先前收到 round_start 但尚未配置，現在補觸發
                        if (state.pendingRoundStart) {
                            const pr = state.pendingRoundStart;
                            state.pendingRoundStart = null;
                            state.turnUserId = pr.currentUserId || null;
                            updateSubmitGate();
                            if (typeof window.startBattleRound === 'function') window.startBattleRound();
                        }
                        break;
                    case 'round_start':
                        state.turnUserId = msg.payload?.currentUserId || null;
                        updateSubmitGate();
                        if (!window.battleMode || !Array.isArray(window.battleMode.players) || window.battleMode.players.length === 0) {
                            // 尚未拿到配置，暫存，等 battle_config 到達後再啟動
                            state.pendingRoundStart = { currentUserId: state.turnUserId };
                        } else if (typeof window.startBattleRound === 'function') {
                            window.startBattleRound();
                        }
                        break;
                    case 'round_end':
                        if (typeof window.endBattleRound === 'function') window.endBattleRound(!!msg.payload?.isCorrect);
                        break;
                    case 'battle_end':
                        if (typeof window.endBattleMode === 'function') window.endBattleMode();
                        break;
                    case 'timed_start':
                        // 接收限時開始：同步狀態與玩家列表，顯示3秒預備，然後開始
                        state.timedMode = true;
                        state.timedEndsAt = msg.payload?.endsAt || (Date.now() + (msg.payload?.mins || 3) * 60000);
                        if (Array.isArray(msg.payload?.players)) {
                            applyBattleConfig({ players: msg.payload.players, roundsPerPlayer: 1 });
                            // 限時模式不使用本地輪流：強制關閉輪流旗標，避免 UI/流程混淆
                            try { if (window.battleMode) window.battleMode.isActive = false; } catch(_){}
                        }
                        // 同步詩詞庫到本地
                        if (msg.payload?.tag) {
                            try {
                                const tagSel = document.getElementById('userLibraryTagSelect');
                                if (tagSel) { tagSel.value = msg.payload.tag; saveActiveTag(msg.payload.tag); }
                            } catch(_){}
                        }
                        showPrepCountdown(Math.max(1000, msg.payload?.prepMs || 3000), () => {
                            beginTimedTicker();
                            try { document.getElementById('remoteBattleModal')?.classList.add('hidden'); } catch(_){ }
                            if (typeof window.startNewRound === 'function') window.startNewRound();
                        });
                        break;
                    case 'timed_end':
                        state.timedMode = false;
                        try { clearInterval(state.timedTimer); } catch(_){}
                        // 顯示遠程限時專屬排行榜
                        if (typeof showBattleResultModal === 'function') showBattleResultModal();
                        // 清理：避免本地輪流殘留
                        try { battleMode.isActive = false; } catch(_){}
                        break;
                    case 'score_update':
                        try {
                            const p = msg.payload || {};
                            const uid = p.userId;
                            if (!uid) break;
                            state.stats[uid] = state.stats[uid] || { score:0, answered:0, correct:0, nickname:'' };
                            const s = state.stats[uid];
                            s.score += Number(p.delta || 0);
                            s.answered += Number(p.answeredInc || 0);
                            s.correct += Number(p.correctInc || 0);
                            s.lastTs = Date.now();
                            // 更新記分牌：將 battleMode.players 的分數以 stats 映射
                            if (Array.isArray(window.battleMode?.players)) {
                                window.battleMode.players.forEach((pl, idx) => {
                                    const uidAt = state.rosterUserIds[idx];
                                    const st = uidAt ? state.stats[uidAt] : null;
                                    if (pl && st) pl.score = st.score;
                                });
                                if (typeof window.updateBattleScoreboard === 'function') window.updateBattleScoreboard();
                            }
                        } catch(_){}
                        break;
                    default:
                        console.log('[remote] unhandled move', msg);
                }
            } catch (e) {
                console.warn('[remote] handleIncomingMove error', e);
            }
        }

        function handleRoomUpdate(room){
            // 可選：根據房主更新同步 UI
            console.log('[remote] room update', room);
        }

        function applyBattleConfig(conf){
            try {
                if (!conf) return;
                let bm = getBM();
                if (!bm) {
                    window.battleMode = window.battleMode || {};
                    bm = window.battleMode;
                }
                bm.isActive = true;
                // 支援 {id, name}
                const players = (conf.players || []).filter(Boolean);
                const names = players.map(p => (typeof p === 'string' ? p : ((p && p.name) || '玩家')));
                const ids = players.map(p => (typeof p === 'string' ? null : ((p && p.id) || null)));
                bm.players = names.map((name, i) => ({ name: name || '玩家', score: 0, displayedScore: 0, isActive: i === 0 }));
                state.rosterUserIds = ids;
                // 初始化統計
                (ids || []).forEach((uid, i) => {
                    if (!uid) return;
                    state.stats[uid] = state.stats[uid] || { score:0, answered:0, correct:0, nickname:'', lastTs:0 };
                    state.stats[uid].nickname = names[i] || state.stats[uid].nickname || '玩家';
                });
                bm.currentPlayerIndex = 0;
                bm.roundsPerPlayer = Math.max(1, Math.min(50, parseInt(conf.roundsPerPlayer || '5')));
                bm.currentRound = 0;
                bm.totalRounds = bm.players.length * bm.roundsPerPlayer;
                if (typeof window.updateBattleScoreboard === 'function') window.updateBattleScoreboard();
                const board = document.getElementById('battleScoreboard');
                if (board) board.classList.remove('hidden');
                state.turnUserId = (state.rosterUserIds && state.rosterUserIds[0]) || null;
                updateSubmitGate();
            } catch (e) {
                console.warn('[remote] applyBattleConfig error', e);
            }
        }

        function renderPresence(presenceState){
            const list = document.getElementById('rbPresenceList');
            if (!list) return;
            list.innerHTML = '';
            const users = [];
            Object.keys(presenceState || {}).forEach(uid => {
                (presenceState[uid] || []).forEach(meta => users.push(meta.nickname || '玩家'));
            });
            users.forEach(name => {
                const div = document.createElement('div');
                div.className = 'px-3 py-2 rounded-lg border bg-white text-sm';
                div.textContent = name;
                list.appendChild(div);
            });
        }

        // 填充房主可選的詩詞庫標籤（從主設置的 userLibraryTagSelect 複製）
        window.populatePoemTags = function(){
            try {
                const dst = document.getElementById('rbPoemTag');
                if (!dst) return;
                dst.innerHTML = '';
                const src = document.getElementById('userLibraryTagSelect');
                let filled = false;
                if (src && src.options && src.options.length) {
                    Array.from(src.options).forEach(opt => {
                        const o = document.createElement('option');
                        o.value = opt.value;
                        o.textContent = opt.textContent || opt.value;
                        dst.appendChild(o);
                    });
                    filled = true;
                }
                if (!filled) {
                    // 後備：給出一個常用預設
                    const o = document.createElement('option');
                    o.value = '南風詩詞庫';
                    o.textContent = '南風詩詞庫';
                    dst.appendChild(o);
                }
                // 預設選中當前啟用標籤
                try {
                    const active = (typeof loadActiveTag === 'function') ? (loadActiveTag() || '南風詩詞庫') : '南風詩詞庫';
                    const has = Array.from(dst.options).some(op => op.value === active);
                    dst.value = has ? active : (dst.options[0]?.value || '南風詩詞庫');
                } catch(_){}
            } catch(_){}
        }

        // 封裝到全域，供後續遊戲流程調用
        window.RemoteBattle = {
            get user(){ return state.user; },
            get room(){ return state.room; },
            get channel(){ return state.channel; },
            isHost(){ return !!(state.room && state.user && state.room.host_id === state.user.id); },
            ensureAnonLogin,
            createRoom,
            joinRoomByCode,
            sendGameEvent
        };

        // ====== UI 綁定 ======
        function $(id){ return document.getElementById(id); }
        const btn = $('remoteBattleBtn')?.querySelector('button');
        const modal = $('remoteBattleModal');
        const closeBtn = $('rbClose');
        const nicknameInput = $('rbNickname');
        const roomNameInput = $('rbRoomName');
        const createBtn = $('rbCreateBtn');
        const createdInfo = $('rbCreatedInfo');
        const codeDisplay = $('rbRoomCodeDisplay');
        const joinCodeInput = $('rbJoinCode');
        const joinBtn = $('rbJoinBtn');
        const hostSettings = document.getElementById('rbHostSettings');
        const timedMinInput = document.getElementById('rbTimedMinutes');
        const startTimedBtn = document.getElementById('rbStartTimedBtn');
        const poemTagSelect = document.getElementById('rbPoemTag');
        const startBtn = document.getElementById('startBtn');

        function openModal(){
            modal?.classList.remove('hidden');
            // 打開遠程模態時暫停單人模式，避免背景自動運行
            try { clearInterval(timerInterval); } catch(_){}
            isGameActive = false;
        }
        function closeModal(){ modal?.classList.add('hidden'); }

        btn?.addEventListener('click', openModal);
        closeBtn?.addEventListener('click', closeModal);

        createBtn?.addEventListener('click', async () => {
            try {
                console.log('[remote] create clicked');
                if (!sb) { alert('Supabase 未就緒'); return; }
                const nickname = (nicknameInput?.value || '').trim() || '玩家';
                const name = (roomNameInput?.value || '').trim() || '';
                if (createBtn) { createBtn.disabled = true; createBtn.textContent = '建立中…'; }
                const room = await createRoom(name, nickname);
                console.log('[remote] room created', room && room.code);
                if (codeDisplay) codeDisplay.textContent = room.code;
                createdInfo?.classList.remove('hidden');
                if (window.RemoteBattle?.isHost()) {
                    hostSettings?.classList.remove('hidden');
                    populatePoemTags();
                }
                if (createBtn) { createBtn.textContent = '已建立'; setTimeout(()=>{ createBtn.disabled = false; createBtn.textContent = '建立房間'; }, 1200); }
            } catch (e) {
                console.warn('[remote] create error', e);
                if (createBtn) { createBtn.disabled = false; createBtn.textContent = '建立房間'; }
                alert('建立失敗：' + (e?.message || e));
            }
        });

        joinBtn?.addEventListener('click', async () => {
            try {
                console.log('[remote] join clicked');
                const nickname = (nicknameInput?.value || '').trim() || '玩家';
                const code = (joinCodeInput?.value || '').trim();
                const room = await joinRoomByCode(code, nickname);
                console.log('[remote] joined room', room && room.code);
                if (codeDisplay) codeDisplay.textContent = room.code;
                createdInfo?.classList.remove('hidden');
                hostSettings?.classList.add('hidden');
            } catch (e) {
                console.warn('[remote] join error', e);
                alert('加入失敗：' + (e?.message || e));
            }
        });

        // 開始對戰（僅房主）
        startBtn?.addEventListener('click', async () => {
            try {
                if (!window.RemoteBattle?.isHost()) { alert('僅房主可開始'); return; }
                await refreshRoster();
                let roster = state.roster;
                if (!roster || roster.length === 0) { alert('尚無玩家加入'); return; }
                const rpp = Math.max(1, Math.min(50, parseInt((roundsInput?.value || '5'), 10)));
                const conf = {
                    players: (roster || []).filter(Boolean).map(p => ({ id: p.user_id, name: (p && p.nickname) ? p.nickname : '玩家' })),
                    roundsPerPlayer: rpp
                };
                // 先發配置，再本地套用；網路上可能先到 round_start，故亦本地立即套用
                window.RemoteBattle.sendGameEvent('battle_config', conf);
                applyBattleConfig(conf);
                // 更新 rooms 狀態
                try { await sb.from('rooms').update({ status: 'playing' }).eq('id', state.room.id); } catch(_){ }
                // 立即開始第一輪
                const bm = getBM();
                const currentIdx = (bm && bm.currentPlayerIndex) || 0;
                const currentUserId = (state.rosterUserIds && state.rosterUserIds[currentIdx]) || null;
                state.turnUserId = currentUserId;
                updateSubmitGate();
                // 先本地啟動，後廣播（避免他端先收到 round_start 而你端未配置）
                if ((bm && Array.isArray(bm.players) && bm.players.length > 0)
                    && typeof window.startBattleRound === 'function') window.startBattleRound();
                window.RemoteBattle.sendGameEvent('round_start', { currentUserId });
            } catch (e) {
                alert('無法開始對戰：' + (e?.message || e));
            }
        });

        // 非輪到本人則禁用提交（攔截）
        function isMyTurn(){
            if (!window.RemoteBattle?.room) return true; // 非遠程模式，不限制
            if (!state.turnUserId) return false;
            return !!(state.user && state.user.id === state.turnUserId);
        }
        function updateSubmitGate(){
            const btn = document.getElementById('submitPoem');
            if (!btn) return;
            if (isMyTurn()) {
                btn.removeAttribute('data-remote-locked');
                btn.style.opacity = '';
                btn.style.pointerEvents = '';
            } else {
                btn.setAttribute('data-remote-locked', '1');
                btn.style.opacity = '0.6';
                btn.style.pointerEvents = 'auto';
            }
        }
        const submitBtnEl = document.getElementById('submitPoem');
        if (submitBtnEl) {
            submitBtnEl.addEventListener('click', function(e){
                // 在限時模式下，所有人可答題；輪流模式才限制
                if (!state.timedMode && !isMyTurn()) {
                    e.stopImmediatePropagation();
                    e.preventDefault();
                    try { window.showNotification && window.showNotification('尚未輪到你作答'); } catch(_){}
                }
            }, true);
        }

        // ===== 包裝現有遊戲函式：由房主廣播事件 =====
        try {
            if (typeof window.confirmStartBattleMode === 'function') {
                const _origConfirm = window.confirmStartBattleMode;
                window.confirmStartBattleMode = function(){
                    const r = _origConfirm.apply(this, arguments);
                    // 房主廣播對戰配置
                    if (window.RemoteBattle?.isHost() && window.battleMode?.isActive) {
                        // 限時模式下不廣播本地輪流配置
                        if (state && state.timedMode === true) return r;
                        const players = (window.battleMode.players || []).map(p => p.name);
                        const roundsPerPlayer = window.battleMode.roundsPerPlayer || 5;
                        window.RemoteBattle.sendGameEvent('battle_config', { players, roundsPerPlayer });
                    }
                    return r;
                };
            }
            if (typeof window.startBattleRound === 'function') {
                const _origStart = window.startBattleRound;
                window.startBattleRound = function(){
                    // 防護：無玩家則不啟動
                    const bm = getBM();
                    if (!bm || !Array.isArray(bm.players) || bm.players.length === 0) {
                        console.warn('[remote] startBattleRound skipped: no players');
                        return;
                    }
                    // 容錯：若 currentPlayerIndex 超界，重設為 0
                    if (typeof bm.currentPlayerIndex !== 'number' || bm.currentPlayerIndex < 0 || bm.currentPlayerIndex >= bm.players.length) {
                        bm.currentPlayerIndex = 0;
                    }
                    // 容錯：缺少姓名時給預設名
                    const p = bm.players[bm.currentPlayerIndex];
                    if (p && !p.name) p.name = '玩家';
                    const r = _origStart.apply(this, arguments);
                    // 限時模式下不廣播本地輪流回合開始
                    if (state && state.timedMode === true) return r;
                    if (window.RemoteBattle?.isHost()) {
                        const idx = (bm && bm.currentPlayerIndex) || 0;
                        const currentUserId = (state.rosterUserIds && state.rosterUserIds[idx]) || null;
                        state.turnUserId = currentUserId;
                        updateSubmitGate();
                        window.RemoteBattle.sendGameEvent('round_start', { currentUserId });
                    }
                    return r;
                };
            }
            if (typeof window.endBattleRound === 'function') {
                const _origEnd = window.endBattleRound;
                window.endBattleRound = function(isCorrect){
                    const r = _origEnd.apply(this, arguments);
                    // 限時模式下不廣播本地輪流回合結束
                    if (state && state.timedMode === true) return r;
                    if (window.RemoteBattle?.isHost()) {
                        window.RemoteBattle.sendGameEvent('round_end', { isCorrect: !!isCorrect });
                        // 限時模式不輪換；輪流模式自動下一輪
                        if (!state.timedMode) {
                            setTimeout(() => {
                                if (typeof window.startBattleRound === 'function') window.startBattleRound();
                            }, 600);
                        }
                    }
                    return r;
                };
            }

        // ===== 限時競賽：開始、計時與結算 =====
        state.timedMode = false;
        state.timedEndsAt = 0;
        state.timedTimer = null;
        state.stats = {}; // userId -> { score, answered, correct, nickname, lastTs }

        startTimedBtn?.addEventListener('click', async () => {
            try {
                console.log('[remote] startTimed clicked');
                if (!window.RemoteBattle?.isHost()) { alert('僅房主可開始'); return; }
                await refreshRoster();
                const roster = state.roster || [];
                if (roster.length === 0) { alert('尚無玩家加入'); return; }
                const mins = Math.max(1, Math.min(10, parseInt((timedMinInput?.value || '3'), 10)));
                const endsAt = Date.now() + mins * 60 * 1000;
                // 建立對戰板（玩家名單），但不開啟輪流限制
                const activeTag = (poemTagSelect?.value || loadActiveTag() || '南風詩詞庫');
                const conf = { players: roster.map(p => ({ id: p.user_id, name: p.nickname || '玩家' })), roundsPerPlayer: 1 };
                applyBattleConfig(conf);
                state.timedMode = true;
                try { if (window.battleMode) window.battleMode.isActive = false; } catch(_){}
                state.timedEndsAt = endsAt;
                // 保險：清理任何單題計時與本地回合狀態
                try { clearInterval(timerInterval); } catch(_){ }
                try { timerInterval = null; } catch(_){ }
                try { isGameActive = false; } catch(_){ }
                try { if (typeof hideResultModal === 'function') hideResultModal(); } catch(_){ }
                try { gameMessage?.classList.add('hidden'); } catch(_){ }
                try { if (timeBarFill) timeBarFill.style.width = '0%'; } catch(_){ }
                // 廣播包含 players，並附帶 3 秒預備
                window.RemoteBattle.sendGameEvent('timed_start', { endsAt, mins, players: conf.players, prepMs: 3000, tag: activeTag });
                showPrepCountdown(3000, () => {
                    beginTimedTicker();
                    // 關閉遠程模態
                    try { document.getElementById('remoteBattleModal')?.classList.add('hidden'); } catch(_){ }
                    // 立即開始作答
                    if (typeof window.startNewRound === 'function') window.startNewRound();
                });
            } catch (e) {
                alert('無法開始限時競賽：' + (e?.message || e));
            }
        });

        // 事件代理保險（避免按鈕被重建導致監聽丟失）
        document.getElementById('remoteBattleModal')?.addEventListener('click', function(ev){
            const t = ev.target;
            if (!t) return;
            if (t.id === 'rbStartTimedBtn' || t.closest?.('#rbStartTimedBtn')) {
                ev.preventDefault();
                try { startTimedBtn?.click(); } catch(_) {}
            }
        }, true);

        function beginTimedTicker(){
            try { clearInterval(state.timedTimer); } catch(_){}
            updateTimedUI();
            state.timedTimer = setInterval(() => {
                updateTimedUI();
                if (!state.timedMode) { clearInterval(state.timedTimer); return; }
                if (Date.now() >= state.timedEndsAt) {
                    clearInterval(state.timedTimer);
                    state.timedMode = false;
                    window.RemoteBattle.sendGameEvent('timed_end', {});
                    showBattleResultModal && showBattleResultModal();
                }
            }, 1000);
        }

        function updateTimedUI(){
            const remainMs = Math.max(0, state.timedEndsAt - Date.now());
            const remainSec = Math.ceil(remainMs / 1000);
            const timer = document.getElementById('timer');
            if (timer && state.timedMode) timer.textContent = String(remainSec);
        }

        function showPrepCountdown(ms, onDone){
            const overlay = document.getElementById('rbPrepOverlay');
            const num = document.getElementById('rbPrepNumber');
            if (!overlay || !num) { if (onDone) onDone(); return; }
            overlay.classList.remove('hidden');
            let remain = Math.max(1, Math.round(ms/1000));
            num.textContent = String(remain);
            const iv = setInterval(() => {
                remain -= 1;
                if (remain <= 0) {
                    clearInterval(iv);
                    overlay.classList.add('hidden');
                    if (onDone) onDone();
                } else {
                    num.textContent = String(remain);
                }
            }, 1000);
        }
            if (typeof window.endBattleMode === 'function') {
                const _origEndMode = window.endBattleMode;
                window.endBattleMode = function(){
                    const r = _origEndMode.apply(this, arguments);
                    if (window.RemoteBattle?.isHost()) window.RemoteBattle.sendGameEvent('battle_end', {});
                    return r;
                };
            }
        } catch (e) { console.warn('[remote] wrap error', e); }
    })();
    </script>
    
</body>
</html>
