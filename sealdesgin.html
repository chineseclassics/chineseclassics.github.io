<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>弘立書院印章設計</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700&display=swap">
    <!-- 加載落霞孤鶩文楷字體 -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css">
    <!-- 加載篆體字體 -->
    <style>
        @font-face {
            font-family: 'ChongXi Seal';
            src: url('https://chineseclassics.github.io/files/chongxi_seal.otf') format('opentype'),
                 url('http://chineseclassics.github.io/files/chongxi_seal.otf') format('opentype');
            font-display: swap;
            font-weight: normal;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'ZiYue Seal';
            src: url('https://chineseclassics.github.io/files/ZIYueJiuDieYinZhuan-Regular.ttf') format('truetype');
            font-display: swap;
            font-weight: normal;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'HuaKang Seal';
            src: url('https://chineseclassics.github.io/files/huakangxinzhuan.ttf') format('truetype');
            font-display: swap;
            font-weight: normal;
            font-style: normal;
        }
        
        @font-face {
            font-family: 'JiaJin Script';
            src: url('https://chineseclassics.github.io/files/jiajinwen.ttf') format('truetype');
            font-display: swap;
            font-weight: normal;
            font-style: normal;
        }
    </style>
    <style>
        :root {
            --primary-color: #8B4513;
            --primary-light: #A0522D;
            --primary-dark: #654321;
            --seal-color: #B22222;
            --accent-gold: #D4AF37;
            --bg-warm: #FAF9F6;
            --bg-card: #FFFFFF;
            --text-primary: #2F2F2F;
            --text-secondary: #666666;
            --border-light: #E8E6E0;
            --shadow-soft: rgba(139, 69, 19, 0.1);
        }
        
        body {
            font-family: 'Noto Serif SC', serif;
            background-color: var(--bg-warm);
            color: var(--text-primary);
        }
        
        .seal-container {
            background-color: white;
            position: relative;
            overflow: hidden;
            width: 400px;
            height: 400px;
            margin: 0 auto;
        }
        
        #sealCanvas {
            max-width: 100%;
            height: auto;
        }
        
        .shape-option {
            cursor: pointer;
            border: 2px solid transparent;
            transition: all 0.2s;
        }
        
        .shape-option:hover, .shape-option.selected {
            border-color: var(--primary-color);
        }
        
        .loader {
            border: 4px solid rgba(0, 0, 0, 0.1);
            border-radius: 50%;
            border-top: 4px solid var(--primary-color);
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 可拖动字符樣式 */
        .draggable-char {
            position: absolute;
            cursor: move;
            user-select: none;
            color: white;
            font-weight: bold;
            text-align: center;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.1s;
            text-shadow: 0 0 2px rgba(0,0,0,0.5);
            border: 2px solid transparent;
            border-radius: 4px;
            padding: 4px;
            pointer-events: auto;
        }
        
        .draggable-char:hover {
            transform: scale(1.05);
        }
        
        .draggable-char.dragging {
            opacity: 0.8;
            z-index: 100;
        }
        
        .draggable-char.selected {
            z-index: 10;
        }
        
        /* 陰刻模式下的選中邊框 */
        .draggable-char.selected.intaglio {
            border-color: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
        }
        
        /* 陽刻模式下的選中邊框 */
        .draggable-char.selected.relief {
            border-color: var(--accent-gold);
            box-shadow: 0 0 8px var(--shadow-soft);
        }
        
        /* 字体大小调整手柄 */
        .resize-handle {
            position: absolute;
            width: 14px;
            height: 14px;
            background: var(--accent-gold);
            border: 2px solid white;
            border-radius: 50%;
            cursor: nw-resize;
            display: none;
            box-shadow: 0 2px 4px var(--shadow-soft);
            z-index: 15;
            /* 确保在移动端也能正常显示 */
            touch-action: none;
            user-select: none;
        }
        
        /* 移动端调整手柄优化 */
        @media (max-width: 1023px) {
            .resize-handle {
                width: 16px;
                height: 16px;
                border-width: 3px;
                /* 增大触摸面积 */
            }
        }
        
        @media (max-width: 640px) {
            .resize-handle {
                width: 18px;
                height: 18px;
                border-width: 3px;
                /* 手机端进一步增大触摸面积 */
            }
        }
        
        .resize-handle.bottom-right {
            bottom: -4px;
            right: -4px;
        }
        
        .resize-handle.top-left {
            top: -4px;
            left: -4px;
        }
        
        .draggable-char.selected .resize-handle {
            display: block;
        }
        
        .resize-handle:hover {
            background: var(--primary-dark);
            transform: scale(1.1);
        }
        
        .resize-handle.resizing {
            background: var(--primary-dark);
            transform: scale(1.2);
        }
        
        /* 提示信息 */
        .drag-instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            text-align: center;
            color: rgba(255,255,255,0.7);
            font-size: 12px;
            pointer-events: none;
            z-index: 5;
        }
        
        /* 字體大小控制區 */
        .font-size-controls {
            margin-top: 12px;
            padding: 8px;
            border-radius: 8px;
            background-color: var(--bg-warm);
            border: 1px solid var(--border-light);
        }
        
        .size-value {
            display: inline-block;
            width: 40px;
            text-align: center;
        }
        
        /* 字體卡片樣式 */
        .font-card {
            background-color: white;
            transition: all 0.3s ease;
        }
        
        .font-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .font-card.selected {
            border-color: var(--primary-color) !important;
            background-color: rgba(139, 69, 19, 0.05);
            box-shadow: 0 6px 20px var(--shadow-soft);
        }
        

        
        .font-preview {
            line-height: 1.2;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 字體選擇容器滾動樣式 */
        .font-selection-container {
            scrollbar-width: thin;
            scrollbar-color: var(--shadow-soft) transparent;
        }
        
        .font-selection-container::-webkit-scrollbar {
            width: 6px;
        }
        
        .font-selection-container::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .font-selection-container::-webkit-scrollbar-thumb {
            background-color: var(--primary-color);
            border-radius: 3px;
            opacity: 0.4;
        }
        
        .font-selection-container::-webkit-scrollbar-thumb:hover {
            opacity: 0.7;
        }
        
        /* 刻印方式卡片樣式 */
        .carving-option {
            background-color: white;
            transition: all 0.3s ease;
        }
        
        .carving-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .carving-option.selected {
            border-color: var(--primary-color) !important;
            background-color: rgba(139, 69, 19, 0.05);
            box-shadow: 0 6px 20px var(--shadow-soft);
        }
        

        
        /* 繪圖畫布樣式 */
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        #drawCanvas {
            z-index: 40;
            cursor: crosshair;
            display: none;
            background-color: transparent;
        }
        
        #displayCanvas {
            z-index: 20;
            pointer-events: none;
            background-color: transparent;
        }
        
        /* 繪圖模式下的cursor */
        .drawing-mode {
            cursor: crosshair !important;
        }
        
        /* 繪圖按鈕和筆畫粗細控制 */
        .drawing-controls {
            margin-top: 12px;
            padding: 8px;
            border-radius: 4px;
            background-color: rgba(0, 0, 0, 0.05);
        }
        

        
        /* 切換按鈕樣式 */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 48px;
            height: 24px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }
        
        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(24px);
        }
        
        /* 自定義滑塊樣式 */
        .thickness-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 80px;
            height: 6px;
            background: linear-gradient(to right, var(--border-light), var(--primary-light));
            border-radius: 3px;
            outline: none;
            transition: all 0.3s ease;
            cursor: pointer;
        }
        
        .thickness-slider:hover {
            box-shadow: 0 2px 8px var(--shadow-soft);
        }
        
        /* WebKit 滑塊拇指樣式 */
        .thickness-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--accent-gold), #B8860B);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(212, 175, 55, 0.3);
            border: 2px solid white;
        }
        
        .thickness-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.5);
        }
        
        /* Firefox 滑塊樣式 */
        .thickness-slider::-moz-range-track {
            width: 100%;
            height: 6px;
            background: linear-gradient(to right, var(--border-light), var(--primary-light));
            border-radius: 3px;
            border: none;
        }
        
        .thickness-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--accent-gold), #B8860B);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(212, 175, 55, 0.3);
            border: 2px solid white;
        }
        
        .thickness-slider::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 4px 12px rgba(212, 175, 55, 0.5);
        }
        
        /* Edge 滑塊樣式 */
        .thickness-slider::-ms-track {
            width: 100%;
            height: 6px;
            background: transparent;
            border-color: transparent;
            color: transparent;
        }
        
        .thickness-slider::-ms-fill-lower {
            background: var(--border-light);
            border-radius: 3px;
        }
        
        .thickness-slider::-ms-fill-upper {
            background: var(--primary-light);
            border-radius: 3px;
        }
        
        .thickness-slider::-ms-thumb {
            width: 18px;
            height: 18px;
            background: linear-gradient(135deg, var(--accent-gold), #B8860B);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 2px 6px rgba(212, 175, 55, 0.3);
            border: 2px solid white;
        }
        
        /* 滑塊容器樣式 */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 4px 8px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            border: 1px solid var(--border-light);
            transition: all 0.3s ease;
        }
        
        .slider-container:hover {
            background: rgba(255, 255, 255, 0.95);
            box-shadow: 0 2px 8px var(--shadow-soft);
        }
        
        /* 滑塊數值顯示 */
        .thickness-value {
            font-size: 11px;
            font-weight: 600;
            color: var(--primary-dark);
            min-width: 20px;
            text-align: center;
            background: var(--bg-warm);
            padding: 2px 6px;
            border-radius: 6px;
            border: 1px solid var(--border-light);
        }
        
        .drawing-mode-label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        #drawingThickness {
            margin-top: 8px;
        }
        
        /* 清空繪圖按鈕 */
        #clearDrawingBtn {
            margin-top: 8px;
        }
        
        /* 當前繪圖狀態指示器 */
        .drawing-status {
            font-size: 12px;
            margin-top: 4px;
            text-align: center;
            padding: 2px 4px;
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.2);
            display: none;
        }
        
        .drawing-status.active {
            display: block;
            background-color: var(--shadow-soft);
            color: var(--primary-color);
        }
        

        
        /* 專門用於下載的隱藏畫布 */
        #downloadCanvas {
            display: none;
            position: absolute;
            pointer-events: none;
        }
        
        /* 下載訊息 */
        #downloadMessage {
            display: none;
            font-size: 14px;
            padding: 8px;
            margin-top: 8px;
            border-radius: 4px;
            text-align: center;
        }
        
        #downloadMessage.success {
            background-color: rgba(16, 185, 129, 0.2);
            color: #10b981;
            display: block;
        }
        
        #downloadMessage.error {
            background-color: rgba(239, 68, 68, 0.2);
            color: #ef4444;
            display: block;
        }

        /* 移動端優化 */
        @media (max-width: 1023px) {
            /* 調整容器間距 */
            .container {
                padding: 0.5rem;
            }
            
            /* 調整標題大小 */
            header h1 {
                font-size: 1.5rem !important;
            }
            
            /* 印章容器在移動端縮小 */
            .seal-container {
                width: 300px;
                height: 300px;
            }
            
            /* 調整字體卡片在移動端的大小 */
            .font-card {
                padding: 0.5rem !important;
            }
            
            .font-preview {
                font-size: 1rem !important;
            }
            
            /* 調整刻印方式卡片 */
            .carving-option {
                padding: 0.5rem !important;
            }
            
            .carving-preview {
                width: 2rem !important;
                height: 2rem !important;
            }
            
            /* 繪圖控制區在移動端的調整 */
            .drawing-controls-mobile {
                flex-direction: column;
                gap: 0.5rem;
            }
            
            /* 按鈕在移動端增大觸摸面積 */
            .mobile-button {
                min-height: 44px;
                font-size: 0.875rem;
            }
            
            /* 滑塊容器在移動端的調整 */
            .slider-container {
                padding: 6px 8px;
            }
            
            /* 調整操作按鈕區域 */
            .action-buttons-mobile {
                gap: 0.75rem;
            }
        }
        
        @media (max-width: 640px) {
            /* 極小屏幕的額外優化 */
            .seal-container {
                width: 250px;
                height: 250px;
            }
            
            /* 繪圖工具在小屏幕上垂直排列 */
            .drawing-tools-small {
                flex-direction: column;
                align-items: stretch;
                gap: 0.5rem;
            }
            
            .drawing-tools-row {
                display: flex;
                justify-content: space-between;
                align-items: center;
                gap: 0.5rem;
            }
            
            /* 調整字體選擇區域高度 */
            .font-selection-container {
                max-height: 200px;
            }
            
            /* 確保觸摸友好的間距 */
            .mobile-spacing {
                margin-bottom: 0.75rem;
            }
        }
    </style>
</head>
<body class="min-h-screen overflow-auto" style="background-color: var(--bg-warm); color: var(--text-primary);">
    <div class="container mx-auto px-4 py-2 max-w-7xl h-full flex flex-col">
        <header class="text-center mb-2 flex-shrink-0">
            <h1 class="text-2xl md:text-3xl font-bold mb-2" style="color: var(--primary-dark);">弘立書院印章設計</h1>
            <p class="text-sm" style="color: var(--text-secondary);">自定義您的專屬印章設計</p>
            <div class="w-12 h-0.5 mx-auto mt-2 rounded-full" style="background-color: var(--accent-gold);"></div>
        </header>
        
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 flex-1 min-h-0">
            <!-- 左側控制面板 -->
            <div class="lg:col-span-1 bg-white shadow-lg rounded-xl p-4 flex flex-col h-full" style="border: 1px solid var(--border-light);">
                <div class="flex items-center justify-center mb-4">
                    <div class="text-center">
                        <h3 class="text-lg font-semibold mb-1" style="color: var(--primary-dark);">設計參數</h3>
                        <div class="w-12 h-0.5 mx-auto" style="background-color: var(--accent-gold);"></div>
                    </div>
                </div>
                
                <div class="mb-3">
                    <label for="nameInput" class="block font-medium mb-2" style="color: var(--text-primary);">印章文字</label>
                    <input id="nameInput" type="text" class="w-full rounded-md px-3 py-2 text-base" style="border: 1px solid var(--border-light); background-color: var(--bg-card); color: var(--text-primary); outline: none;" placeholder="輸入您的姓名或文字" value="王大明印">
                </div>
                
                <div class="mb-3">
                    <label class="block font-medium mb-2" style="color: var(--text-primary);">刻印方式</label>
                    <div class="grid grid-cols-2 gap-2">
                        <div class="carving-option cursor-pointer border-2 border-primary-500 rounded-lg p-2 text-center transition-all duration-200 hover:border-primary-400 selected" data-carving="intaglio">
                            <div class="carving-preview w-10 h-10 mx-auto mb-1 rounded border-2 flex items-center justify-center text-xs font-bold" style="background-color: #d62828; color: white; border-color: #d62828;">
                                印
                            </div>
                            <span class="text-sm">陰刻</span>
                            <div class="text-xs text-gray-500 mt-0.5">凹刻・白字紅底</div>
                        </div>
                        <div class="carving-option cursor-pointer border-2 border-gray-300 rounded-lg p-2 text-center transition-all duration-200 hover:border-primary-400" data-carving="relief">
                            <div class="carving-preview w-10 h-10 mx-auto mb-1 rounded border-2 flex items-center justify-center text-xs font-bold" style="background-color: white; color: #d62828; border-color: #d62828;">
                                印
                            </div>
                            <span class="text-sm">陽刻</span>
                            <div class="text-xs text-gray-500 mt-0.5">凸刻・紅字白底</div>
                        </div>
                    </div>
                </div>
                
                <div class="flex-1 flex flex-col min-h-0">
                    <label class="block font-medium mb-2" style="color: var(--text-primary);">字體選擇</label>
                    <div class="font-selection-container flex-1 overflow-y-auto pr-2" style="min-height: 0;">
                        <div class="grid grid-cols-1 gap-2">
                        <!-- 篆體一卡片 -->
                        <div class="font-card cursor-pointer border-2 border-gray-300 rounded-lg p-3 transition-all duration-200 hover:border-primary-400" data-font="'ChongXi Seal'">
                            <div class="font-preview text-xl font-bold text-gray-800 mb-1" style="font-family: 'ChongXi Seal';">
                                王大明印
                            </div>
                            <div class="font-name text-sm text-gray-600">
                                篆體一
                            </div>
                        </div>
                        
                        <!-- 篆體二卡片 -->
                        <div class="font-card cursor-pointer border-2 border-gray-300 rounded-lg p-3 transition-all duration-200 hover:border-primary-400" data-font="'ZiYue Seal'">
                            <div class="font-preview text-xl font-bold text-gray-800 mb-1" style="font-family: 'ZiYue Seal';">
                                王大明印
                            </div>
                            <div class="font-name text-sm text-gray-600">
                                篆體二
                            </div>
                        </div>
                        
                        <!-- 篆體三卡片 -->
                        <div class="font-card cursor-pointer border-2 border-gray-300 rounded-lg p-3 transition-all duration-200 hover:border-primary-400" data-font="'HuaKang Seal'">
                            <div class="font-preview text-xl font-bold text-gray-800 mb-1" style="font-family: 'HuaKang Seal';">
                                王大明印
                            </div>
                            <div class="font-name text-sm text-gray-600">
                                篆體三
                            </div>
                        </div>
                        
                        <!-- 金文卡片 -->
                        <div class="font-card cursor-pointer border-2 border-gray-300 rounded-lg p-3 transition-all duration-200 hover:border-primary-400" data-font="'JiaJin Script'">
                            <div class="font-preview text-xl font-bold text-gray-800 mb-1" style="font-family: 'JiaJin Script';">
                                王大明印
                            </div>
                            <div class="font-name text-sm text-gray-600">
                                金文
                            </div>
                        </div>
                        
                        <!-- 落霞孤鶩文楷卡片 -->
                        <div class="font-card cursor-pointer border-2 border-primary-500 rounded-lg p-3 transition-all duration-200 hover:border-primary-400 selected" data-font="'LXGW WenKai'">
                            <div class="font-preview text-xl font-bold text-gray-800 mb-1" style="font-family: 'LXGW WenKai';">
                                王大明印
                            </div>
                            <div class="font-name text-sm text-gray-600">
                                落霞孤鶩文楷
                            </div>
                        </div>
                        </div>
                    </div>
                </div>

            </div>
            
            <!-- 右側預覽區 -->
            <div class="lg:col-span-2 flex flex-col h-full">
                <div class="bg-white shadow-lg rounded-xl p-4 flex-1 flex flex-col" style="border: 1px solid var(--border-light);">
                    <div class="flex items-center justify-center mb-3">
                        <div class="text-center">
                            <h3 class="text-lg font-semibold mb-1" style="color: var(--primary-dark);">印章預覽</h3>
                            <div class="w-12 h-0.5 mx-auto" style="background-color: var(--accent-gold);"></div>
                        </div>
                    </div>
                    
                    <!-- 繪圖控制區 -->
                    <div class="bg-gray-50 rounded-lg p-2 mb-2 mt-2" style="border: 1px solid var(--border-light);">
                        <div class="flex flex-col md:flex-row justify-between items-start md:items-center space-y-2 md:space-y-0">
                            <div class="text-sm font-medium" style="color: var(--text-primary);">
                                繪圖工具
                            </div>
                            
                            <div class="flex flex-wrap items-center gap-3 text-sm">
                                <div class="flex items-center space-x-2">
                                    <span style="color: var(--text-secondary);">繪圖:</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="drawingModeToggle">
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                
                                <div class="flex items-center space-x-2">
                                    <span style="color: var(--text-secondary);">橡皮擦:</span>
                                    <label class="toggle-switch">
                                        <input type="checkbox" id="eraserModeToggle">
                                        <span class="toggle-slider"></span>
                                    </label>
                                </div>
                                
                                <div class="slider-container">
                                    <span style="color: var(--text-secondary);">粗細:</span>
                                    <input id="drawingThickness" type="range" min="1" max="20" value="3" class="thickness-slider" />
                                    <span id="thicknessValue" class="thickness-value">3</span>
                                </div>
                                
                                <button id="clearDrawingBtn" class="text-white px-3 py-1 rounded-md text-xs font-medium transition-colors hover:opacity-90" style="background-color: var(--text-secondary);">
                                    清空
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- 印章容器区域 - 適中位置 -->
                    <div class="flex-1 flex items-center justify-center pt-4">
                        <div id="sealContainer" class="seal-container rounded-lg flex items-center justify-center">
                            <div id="loadingIndicator" class="loader hidden"></div>
                            
                            <!-- 印章背景層 -->
                            <div id="sealBackground" class="absolute inset-0 z-10"></div>
                            
                            <!-- 顯示繪圖層 -->
                            <canvas id="displayCanvas" class="canvas-layer"></canvas>
                            
                            <!-- 字符層 - 確保這一層在繪圖層上面 -->
                            <div id="charContainer" class="absolute inset-0 z-30"></div>
                            
                            <!-- 繪圖用Canvas層 - 只在繪圖模式下顯示，位於最上層 -->
                            <canvas id="drawCanvas" class="canvas-layer"></canvas>
                            
                            <!-- 下載用的畫布 -->
                            <canvas id="downloadCanvas"></canvas>
                            
                            <div class="drag-instructions z-5">點擊並拖動字符調整位置，拖拽右下角藍色圓點調整大小</div>
                            
                            <!-- 繪圖狀態指示器 -->
                            <div id="drawingStatus" class="drawing-status">
                                繪圖模式已啟用
                            </div>
                        </div>
                    </div>
                    
                    <!-- 印章預覽底部提示文字 -->
                    <div class="mt-2 text-center">
                        <span id="previewInstructions" class="text-sm text-gray-500">點擊字符可調整大小</span>
                    </div>
                    
                    <!-- 操作按钮区域 -->
                    <div class="mt-4 pt-3 border-t" style="border-color: var(--border-light);">
                        <div class="space-y-3">
                            <div class="grid grid-cols-2 gap-3">
                                <button id="resetPositionsBtn" class="w-full text-white font-medium py-2 px-3 rounded-lg transition-all duration-200 hover:shadow-md transform hover:scale-105 text-sm" style="background-color: var(--text-secondary);">
                                    重置位置
                                </button>
                                <button id="resetSizesBtn" class="w-full text-white font-medium py-2 px-3 rounded-lg transition-all duration-200 hover:shadow-md transform hover:scale-105 text-sm" style="background-color: var(--text-secondary);">
                                    重置大小
                                </button>
                            </div>
                            
                            <div class="space-y-2">
                                <button id="downloadBtn" class="w-full text-white font-medium py-3 px-4 rounded-lg transition-all duration-200 hover:shadow-lg transform hover:scale-105" style="background: linear-gradient(135deg, var(--primary-color), var(--primary-light));">
                                    下載正字印章
                                </button>
                                <button id="downloadSvgBtn" class="w-full text-white font-medium py-3 px-4 rounded-lg transition-all duration-200 hover:shadow-lg transform hover:scale-105" style="background: linear-gradient(135deg, var(--accent-gold), #B8860B);">
                                    下載反字印章
                                </button>
                            </div>
                        </div>
                        
                        <div id="downloadMessage" class="mt-3"></div>
                        <p class="text-xs mt-2 text-center" style="color: var(--text-secondary);">PNG用於查看效果，SVG反字用於激光切割</p>
                    </div>
                </div>
            </div>
        </div>

    </div>

    <script>

        
        // 獲取DOM元素
        const nameInput = document.getElementById('nameInput');
        const downloadBtn = document.getElementById('downloadBtn');
        const resetPositionsBtn = document.getElementById('resetPositionsBtn');
        const resetSizesBtn = document.getElementById('resetSizesBtn');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const sealBackground = document.getElementById('sealBackground');
        const charContainer = document.getElementById('charContainer');
        const sealContainer = document.getElementById('sealContainer');
        const previewInstructions = document.getElementById('previewInstructions');
        const downloadMessage = document.getElementById('downloadMessage');
        
        // 繪圖相關元素 - 完全重構繪圖功能
        const drawCanvas = document.getElementById('drawCanvas');
        const displayCanvas = document.getElementById('displayCanvas');
        const downloadCanvas = document.getElementById('downloadCanvas');
        const drawingModeToggle = document.getElementById('drawingModeToggle');
        const eraserModeToggle = document.getElementById('eraserModeToggle');
        const drawingThickness = document.getElementById('drawingThickness');
        const clearDrawingBtn = document.getElementById('clearDrawingBtn');
        const drawingStatus = document.getElementById('drawingStatus');
        
        // 繪圖上下文
        const drawCtx = drawCanvas.getContext('2d');
        const displayCtx = displayCanvas.getContext('2d');
        const downloadCtx = downloadCanvas.getContext('2d');
        
        // 字體卡片相關元素
        const fontCards = document.querySelectorAll('.font-card');
        let currentFont = "'LXGW WenKai'"; // 默認字體
        
        // 刻印方式相關元素
        const carvingOptions = document.querySelectorAll('.carving-option');
        let currentCarving = 'intaglio'; // 默認陰刻
        
        // 印章形狀選擇
        const shapeOptions = document.querySelectorAll('.shape-option');
        let currentShape = 'square';
        
        // 字符數據
        let charPositions = [];
        let charSizes = {};
        
        // 用於存儲每個字符的dom元素引用
        let charElements = [];
        
        // 當前選中的字符
        let selectedCharIndex = null;
        
        // 印章參數 - 根據屏幕尺寸動態調整
        let sealSize = 350;
        let padding = 30;
        let defaultFontSize = 120;
        
        // 檢測屏幕尺寸並調整參數
        function updateSealParameters() {
            const screenWidth = window.innerWidth;
            
            if (screenWidth <= 640) {
                // 手機端：250x250
                sealSize = 250;
                padding = 20;
                defaultFontSize = 80;
            } else if (screenWidth <= 1023) {
                // 平板端：300x300
                sealSize = 300;
                padding = 25;
                defaultFontSize = 100;
            } else {
                // 桌面端：350x350
                sealSize = 350;
                padding = 30;
                defaultFontSize = 120;
            }
        }
        
        // 初始化參數
        updateSealParameters();
        
        // 拖動狀態
        let isDragging = false;
        let dragTarget = null;
        let dragStartX = 0;
        let dragStartY = 0;
        let targetStartX = 0;
        let targetStartY = 0;
        
        // 字體大小調整狀態
        let isResizing = false;
        let resizeStartX = 0;
        let resizeStartY = 0;
        let initialFontSize = 0;
        let resizeHandleType = 'bottom-right'; // 'top-left' 或 'bottom-right'
        
        // 繪圖狀態 - 重構
        let isDrawing = false;
        let isDrawingMode = false;
        let isEraserMode = false;
        let prevX = 0;
        let prevY = 0;
        
        // 初始化畫布大小
        function updateCanvasSize() {
            drawCanvas.width = sealSize;
            drawCanvas.height = sealSize;
            displayCanvas.width = sealSize;
            displayCanvas.height = sealSize;
            downloadCanvas.width = sealSize;
            downloadCanvas.height = sealSize;
        }
        
        updateCanvasSize();
        
        // 監聽窗口大小變化
        window.addEventListener('resize', function() {
            updateSealParameters();
            updateCanvasSize();
            // 重新生成印章以適應新的參數
            generateSeal();
        });
        
        // 繪圖事件處理函數 - 完全重寫
        function setDrawingMode(enabled) {
            isDrawingMode = enabled;
            
            if (enabled) {
                // 顯示繪圖畫布
                drawCanvas.style.display = 'block';
                sealContainer.classList.add('drawing-mode');
                drawingStatus.classList.add('active');
                
                // 根據刻印方式更新說明和繪圖顏色
                const drawColor = currentCarving === 'intaglio' ? '白色' : '紅色';
                previewInstructions.textContent = `繪圖模式：在印章上繪製${drawColor}線條`;
                document.querySelector('.drag-instructions').textContent = `在印章上繪製${drawColor}線條`;
                
                // 禁用字符交互，但保持字符顯示
                charElements.forEach(char => {
                    char.style.pointerEvents = 'none';
                });
                
                // 清除當前選中狀態
                unselectChar();
            } else {
                // 隱藏繪圖畫布
                drawCanvas.style.display = 'none';
                sealContainer.classList.remove('drawing-mode');
                drawingStatus.classList.remove('active');
                
                // 恢復說明
                previewInstructions.textContent = "點擊字符可調整大小";
                document.querySelector('.drag-instructions').textContent = '點擊並拖動字符調整位置，拖拽右下角藍色圓點調整大小';
                
                // 啟用字符交互
                charElements.forEach(char => {
                    char.style.pointerEvents = 'auto';
                });
            }
        }
        
        // 繪圖開始
        function startDrawing(e) {
            e.preventDefault();
            
            if (!isDrawingMode) return;
            
            isDrawing = true;
            
            const rect = drawCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 計算畫布坐標
            const canvasX = (x / rect.width) * drawCanvas.width;
            const canvasY = (y / rect.height) * drawCanvas.height;
            
            prevX = canvasX;
            prevY = canvasY;
            
            if (isEraserMode) {
                // 橡皮擦模式：擦除內容
                drawCtx.save();
                drawCtx.globalCompositeOperation = 'destination-out';
                drawCtx.beginPath();
                const radius = parseInt(drawingThickness.value) / 2;
                drawCtx.arc(canvasX, canvasY, radius, 0, Math.PI * 2);
                drawCtx.fill();
                drawCtx.restore();
            } else {
                // 繪圖模式：根據刻印方式選擇繪圖顏色
                const drawColor = currentCarving === 'intaglio' ? 'white' : '#d62828';
                
                // 繪製一個點
                drawCtx.beginPath();
                drawCtx.fillStyle = drawColor;
                const radius = parseInt(drawingThickness.value) / 2;
                drawCtx.arc(canvasX, canvasY, radius, 0, Math.PI * 2);
                drawCtx.fill();
            }
            
            // 立即更新顯示畫布
            updateDisplayCanvas();
        }
        
        // 繪圖過程
        function draw(e) {
            e.preventDefault();
            
            if (!isDrawing || !isDrawingMode) return;
            
            const rect = drawCanvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 計算畫布坐標
            const canvasX = (x / rect.width) * drawCanvas.width;
            const canvasY = (y / rect.height) * drawCanvas.height;
            
            if (isEraserMode) {
                // 橡皮擦模式：擦除內容
                drawCtx.save();
                drawCtx.globalCompositeOperation = 'destination-out';
                drawCtx.beginPath();
                drawCtx.lineWidth = parseInt(drawingThickness.value);
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                
                drawCtx.moveTo(prevX, prevY);
                drawCtx.lineTo(canvasX, canvasY);
                drawCtx.stroke();
                drawCtx.restore();
            } else {
                // 繪圖模式：根據刻印方式選擇繪圖顏色
                const drawColor = currentCarving === 'intaglio' ? 'white' : '#d62828';
                
                drawCtx.beginPath();
                drawCtx.strokeStyle = drawColor;
                drawCtx.lineWidth = parseInt(drawingThickness.value);
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                
                drawCtx.moveTo(prevX, prevY);
                drawCtx.lineTo(canvasX, canvasY);
                drawCtx.stroke();
            }
            
            prevX = canvasX;
            prevY = canvasY;
            
            // 更新顯示畫布
            updateDisplayCanvas();
        }
        
        // 觸摸開始
        function touchStartDrawing(e) {
            e.preventDefault();
            
            if (!isDrawingMode) return;
            
            isDrawing = true;
            
            const rect = drawCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // 計算畫布坐標
            const canvasX = (x / rect.width) * drawCanvas.width;
            const canvasY = (y / rect.height) * drawCanvas.height;
            
            prevX = canvasX;
            prevY = canvasY;
            
            if (isEraserMode) {
                // 橡皮擦模式：擦除內容
                drawCtx.save();
                drawCtx.globalCompositeOperation = 'destination-out';
                drawCtx.beginPath();
                const radius = parseInt(drawingThickness.value) / 2;
                drawCtx.arc(canvasX, canvasY, radius, 0, Math.PI * 2);
                drawCtx.fill();
                drawCtx.restore();
            } else {
                // 繪圖模式：根據刻印方式選擇繪圖顏色
                const drawColor = currentCarving === 'intaglio' ? 'white' : '#d62828';
                
                // 繪製一個點
                drawCtx.beginPath();
                drawCtx.fillStyle = drawColor;
                const radius = parseInt(drawingThickness.value) / 2;
                drawCtx.arc(canvasX, canvasY, radius, 0, Math.PI * 2);
                drawCtx.fill();
            }
            
            // 更新顯示畫布
            updateDisplayCanvas();
        }
        
        // 觸摸移動
        function touchDraw(e) {
            e.preventDefault();
            
            if (!isDrawing || !isDrawingMode) return;
            
            const rect = drawCanvas.getBoundingClientRect();
            const touch = e.touches[0];
            const x = touch.clientX - rect.left;
            const y = touch.clientY - rect.top;
            
            // 計算畫布坐標
            const canvasX = (x / rect.width) * drawCanvas.width;
            const canvasY = (y / rect.height) * drawCanvas.height;
            
            if (isEraserMode) {
                // 橡皮擦模式：擦除內容
                drawCtx.save();
                drawCtx.globalCompositeOperation = 'destination-out';
                drawCtx.beginPath();
                drawCtx.lineWidth = parseInt(drawingThickness.value);
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                
                drawCtx.moveTo(prevX, prevY);
                drawCtx.lineTo(canvasX, canvasY);
                drawCtx.stroke();
                drawCtx.restore();
            } else {
                // 繪圖模式：根據刻印方式選擇繪圖顏色
                const drawColor = currentCarving === 'intaglio' ? 'white' : '#d62828';
                
                drawCtx.beginPath();
                drawCtx.strokeStyle = drawColor;
                drawCtx.lineWidth = parseInt(drawingThickness.value);
                drawCtx.lineCap = 'round';
                drawCtx.lineJoin = 'round';
                
                drawCtx.moveTo(prevX, prevY);
                drawCtx.lineTo(canvasX, canvasY);
                drawCtx.stroke();
            }
            
            prevX = canvasX;
            prevY = canvasY;
            
            // 更新顯示畫布
            updateDisplayCanvas();
        }
        
        // 結束繪圖
        function stopDrawing() {
            isDrawing = false;
        }
        
        // 更新顯示畫布（將繪圖結果複製到顯示畫布）
        function updateDisplayCanvas() {
            displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
            displayCtx.drawImage(drawCanvas, 0, 0);
        }
        
        // 清空繪圖
        function clearDrawing() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            updateDisplayCanvas();
        }
        
        // 繪圖模式切換事件
        drawingModeToggle.addEventListener('change', function() {
            setDrawingMode(this.checked);
            
            // 繪圖模式關閉時，自動關閉橡皮擦模式
            if (!this.checked && isEraserMode) {
                eraserModeToggle.checked = false;
                isEraserMode = false;
            }
        });
        
        // 滑塊數值更新事件
        const thicknessValue = document.getElementById('thicknessValue');
        drawingThickness.addEventListener('input', function() {
            thicknessValue.textContent = this.value;
        });
        
        // 橡皮擦模式切換事件
        eraserModeToggle.addEventListener('change', function() {
            isEraserMode = this.checked;
            
            // 橡皮擦模式開啟時，自動開啟繪圖模式
            if (this.checked && !isDrawingMode) {
                drawingModeToggle.checked = true;
                setDrawingMode(true);
            }
            
            // 更新提示文字
            if (isDrawingMode) {
                updateDrawingModeInstructions();
            }
        });
        
        // 更新繪圖模式提示文字
        function updateDrawingModeInstructions() {
            if (isEraserMode) {
                previewInstructions.textContent = "橡皮擦模式：在印章上擦除線條";
                document.querySelector('.drag-instructions').textContent = "在印章上擦除線條";
            } else {
                const drawColor = currentCarving === 'intaglio' ? '白色' : '紅色';
                previewInstructions.textContent = `繪圖模式：在印章上繪製${drawColor}線條`;
                document.querySelector('.drag-instructions').textContent = `在印章上繪製${drawColor}線條`;
            }
        }
        
        // 清空繪圖按鈕事件
        clearDrawingBtn.addEventListener('click', clearDrawing);
        
        // 繪圖事件綁定
        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mouseleave', stopDrawing);
        
        // 觸摸事件綁定
        drawCanvas.addEventListener('touchstart', touchStartDrawing);
        drawCanvas.addEventListener('touchmove', touchDraw);
        drawCanvas.addEventListener('touchend', stopDrawing);
        drawCanvas.addEventListener('touchcancel', stopDrawing);
        
        // 字體卡片選擇事件
        fontCards.forEach(card => {
            card.addEventListener('click', () => {
                // 移除所有卡片的選中狀態
                fontCards.forEach(c => c.classList.remove('selected'));
                // 添加當前卡片的選中狀態
                card.classList.add('selected');
                
                // 更新當前字體
                currentFont = card.getAttribute('data-font');
                
                // 更新字符樣式
                updateCharsStyle();
            });
        });
        
        // 刻印方式選擇事件
        carvingOptions.forEach(option => {
            option.addEventListener('click', () => {
                // 移除所有選項的選中狀態
                carvingOptions.forEach(opt => opt.classList.remove('selected'));
                // 添加當前選項的選中狀態
                option.classList.add('selected');
                
                // 更新當前刻印方式
                currentCarving = option.getAttribute('data-carving');
                
                // 重新繪製印章以應用新的刻印方式
                redrawSealBackground();
                updateCharsStyle();
                
                // 如果處於繪圖模式，更新提示文字
                if (isDrawingMode) {
                    updateDrawingModeInstructions();
                }
            });
        });
        
        // 形狀選擇事件
        shapeOptions.forEach(option => {
            option.addEventListener('click', () => {
                shapeOptions.forEach(opt => opt.classList.remove('selected'));
                option.classList.add('selected');
                currentShape = option.getAttribute('data-shape');
                redrawSealBackground();
            });
        });
        
        // 事件監聽
        nameInput.addEventListener('input', () => {
            // 當文字改變時，重新生成印章
            generateSeal();
        });
        

        

        
        // 點擊印章背景取消選擇
        sealBackground.addEventListener('click', (e) => {
            // 只有在非繪圖模式下，直接點擊背景時才取消選擇
            if (!isDrawingMode && e.target === sealBackground) {
                unselectChar();
            }
        });
        
        // 按鈕事件綁定
        resetPositionsBtn.addEventListener('click', resetCharPositions);
        resetSizesBtn.addEventListener('click', resetAllCharSizes);
        downloadBtn.addEventListener('click', downloadSeal);
        
        // SVG下載按鈕事件
        const downloadSvgBtn = document.getElementById('downloadSvgBtn');
        downloadSvgBtn.addEventListener('click', downloadSvgSeal);
        
        // 等待字體加載完成後初始化
        document.fonts.ready.then(() => {
            // 嘗試加載篆體字體
            async function loadSealFonts() {
                // 加載篆體一 (崇熙篆體)
                const chongxiUrls = [
                    'https://chineseclassics.github.io/files/chongxi_seal.otf',
                    'http://chineseclassics.github.io/files/chongxi_seal.otf'
                ];
                
                for (const url of chongxiUrls) {
                    try {
                        console.log(`嘗試從 ${url} 加載崇熙篆體`);
                        const testFont = new FontFace('ChongXi Seal', `url(${url})`);
                        await testFont.load();
                        document.fonts.add(testFont);
                        console.log('崇熙篆體加載成功');
                        
                        // 測試字體是否真正可用
                        const testDiv = document.createElement('div');
                        testDiv.style.fontFamily = "'ChongXi Seal'";
                        testDiv.style.position = 'absolute';
                        testDiv.style.visibility = 'hidden';
                        testDiv.textContent = '測試';
                        document.body.appendChild(testDiv);
                        
                        const computedStyle = window.getComputedStyle(testDiv);
                        document.body.removeChild(testDiv);
                        
                        if (computedStyle.fontFamily.includes('ChongXi Seal')) {
                            console.log('篆體一驗證成功');
                            break;
                        }
                    } catch (error) {
                        console.warn(`從 ${url} 加載篆體一失敗:`, error);
                    }
                }
                
                // 加載篆體二 (子月九疊印篆)
                try {
                    console.log('嘗試加載篆體二');
                    const ziYueFont = new FontFace('ZiYue Seal', `url(https://chineseclassics.github.io/files/ZIYueJiuDieYinZhuan-Regular.ttf)`);
                    await ziYueFont.load();
                    document.fonts.add(ziYueFont);
                    console.log('篆體二加載成功');
                    
                    // 測試字體是否真正可用
                    const testDiv = document.createElement('div');
                    testDiv.style.fontFamily = "'ZiYue Seal'";
                    testDiv.style.position = 'absolute';
                    testDiv.style.visibility = 'hidden';
                    testDiv.textContent = '測試';
                    document.body.appendChild(testDiv);
                    
                    const computedStyle = window.getComputedStyle(testDiv);
                    document.body.removeChild(testDiv);
                    
                    if (computedStyle.fontFamily.includes('ZiYue Seal')) {
                        console.log('篆體二驗證成功');
                    }
                } catch (error) {
                    console.warn('篆體二加載失敗:', error);
                }
                
                // 加載篆體三 (華康新篆體)
                try {
                    console.log('嘗試加載篆體三');
                    const huaKangFont = new FontFace('HuaKang Seal', `url(https://chineseclassics.github.io/files/huakangxinzhuan.ttf)`);
                    await huaKangFont.load();
                    document.fonts.add(huaKangFont);
                    console.log('篆體三加載成功');
                    
                    // 測試字體是否真正可用
                    const testDiv = document.createElement('div');
                    testDiv.style.fontFamily = "'HuaKang Seal'";
                    testDiv.style.position = 'absolute';
                    testDiv.style.visibility = 'hidden';
                    testDiv.textContent = '測試';
                    document.body.appendChild(testDiv);
                    
                    const computedStyle = window.getComputedStyle(testDiv);
                    document.body.removeChild(testDiv);
                    
                    if (computedStyle.fontFamily.includes('HuaKang Seal')) {
                        console.log('篆體三驗證成功');
                    }
                } catch (error) {
                    console.warn('篆體三加載失敗:', error);
                }
                
                // 加載金文字體
                try {
                    console.log('嘗試加載金文字體');
                    const jinWenFont = new FontFace('JiaJin Script', `url(https://chineseclassics.github.io/files/jiajinwen.ttf)`);
                    await jinWenFont.load();
                    document.fonts.add(jinWenFont);
                    console.log('金文字體加載成功');
                    
                    // 測試字體是否真正可用
                    const testDiv = document.createElement('div');
                    testDiv.style.fontFamily = "'JiaJin Script'";
                    testDiv.style.position = 'absolute';
                    testDiv.style.visibility = 'hidden';
                    testDiv.textContent = '測試';
                    document.body.appendChild(testDiv);
                    
                    const computedStyle = window.getComputedStyle(testDiv);
                    document.body.removeChild(testDiv);
                    
                    if (computedStyle.fontFamily.includes('JiaJin Script')) {
                        console.log('金文字體驗證成功');
                    }
                } catch (error) {
                    console.warn('金文字體加載失敗:', error);
                }
                
                // 重新生成印章以應用已加載的字體
                setTimeout(() => {
                    generateSeal();
                }, 300);
            }
            
            loadSealFonts();
        });
        
        // 初始化（先生成一次，字體加載後會重新生成）
        generateSeal();
        
        // 生成印章
        function generateSeal() {
            // 取消任何選中的字符
            unselectChar();
            
            // 獲取用戶輸入的文字
            const text = nameInput.value.trim() || "印";
            
            // 清空現有字符
            charContainer.innerHTML = '';
            charElements = [];
            
            // 初始化或重置字符大小
            resetCharSizesData(text.length);
            
            // 創建字符位置數據
            createCharPositions(text);
            
            // 繪製印章背景
            redrawSealBackground();
            
            // 創建可拖動字符
            createDraggableChars(text);
            
            // 保持繪圖內容
            // (不清除繪圖內容，除非用戶明確要求)
        }
        
        // 初始化或重置字符大小數據
        function resetCharSizesData(charCount) {
            charSizes = {};
            for (let i = 0; i < charCount; i++) {
                charSizes[i] = defaultFontSize;
            }
        }
        
        // 創建字符位置數據 - 默認使用田字格布局
        function createCharPositions(text) {
            const centerX = sealSize / 2;
            const centerY = sealSize / 2;
            
            charPositions = [];
            
            // 田字排列（古印排版）- 精確的田字格居中布局
            // 使用與印章背景相同的邊距，確保一致性
            const sizeOffset = padding * 0.8; // 與背景邊距一致：24px
            
            // 印章內部可用區域
            const innerWidth = sealSize - sizeOffset * 2;  // 302px
            const innerHeight = sealSize - sizeOffset * 2; // 302px
            
            // 田字格：每個格子的大小
            const cellWidth = innerWidth / 2;   // 151px
            const cellHeight = innerHeight / 2; // 151px
            
            // 計算每個格子的精確中心點
            const positions = [
                // 右上角 (第一字)
                { 
                    x: sizeOffset + cellWidth + cellWidth / 2,    // 24 + 151 + 75.5 = 250.5
                    y: sizeOffset + cellHeight / 2                // 24 + 75.5 = 99.5
                },
                // 右下角 (第二字)
                { 
                    x: sizeOffset + cellWidth + cellWidth / 2,    // 24 + 151 + 75.5 = 250.5
                    y: sizeOffset + cellHeight + cellHeight / 2   // 24 + 151 + 75.5 = 250.5
                },
                // 左上角 (第三字)
                { 
                    x: sizeOffset + cellWidth / 2,                // 24 + 75.5 = 99.5
                    y: sizeOffset + cellHeight / 2                // 24 + 75.5 = 99.5
                },
                // 左下角 (第四字)
                { 
                    x: sizeOffset + cellWidth / 2,                // 24 + 75.5 = 99.5
                    y: sizeOffset + cellHeight + cellHeight / 2   // 24 + 151 + 75.5 = 250.5
                }
            ];
            
            for (let i = 0; i < Math.min(text.length, 4); i++) {
                charPositions.push({
                    x: positions[i].x,
                    y: positions[i].y,
                    rotation: 0
                });
            }
            
            // 如果字數超過4個，按順序排列在印章區域內
            for (let i = 4; i < text.length; i++) {
                charPositions.push({
                    x: centerX + (Math.random() - 0.5) * innerWidth * 0.6,
                    y: centerY + (Math.random() - 0.5) * innerHeight * 0.6,
                    rotation: 0
                });
            }
        }
        
        // 重置字符位置
        function resetCharPositions() {
            const text = nameInput.value.trim() || "印";
            createCharPositions(text);
            updateCharsPosition();
        }
        
        // 重置所有字符大小
        function resetAllCharSizes() {
            const text = nameInput.value.trim() || "印";
            resetCharSizesData(text.length);
            
            // 更新所有字符的大小
            charElements.forEach((char, index) => {
                updateCharSize(char, defaultFontSize);
            });
            
            // 取消選中狀態
            unselectChar();
        }
        
        // 創建可拖動字符
        function createDraggableChars(text) {
            const fontFamily = currentFont;
            
            for (let i = 0; i < text.length; i++) {
                const char = document.createElement('div');
                char.className = 'draggable-char';
                char.textContent = text[i];
                char.dataset.index = i;
                
                // 創建右下角調整手柄
                const resizeHandleBottomRight = document.createElement('div');
                resizeHandleBottomRight.className = 'resize-handle bottom-right';
                resizeHandleBottomRight.dataset.index = i;
                
                // 創建左上角調整手柄
                const resizeHandleTopLeft = document.createElement('div');
                resizeHandleTopLeft.className = 'resize-handle top-left';
                resizeHandleTopLeft.dataset.index = i;
                
                // 添加調整手柄事件
                resizeHandleBottomRight.addEventListener('mousedown', handleResizeMouseDown);
                resizeHandleBottomRight.addEventListener('touchstart', handleResizeTouchStart);
                resizeHandleTopLeft.addEventListener('mousedown', handleResizeMouseDown);
                resizeHandleTopLeft.addEventListener('touchstart', handleResizeTouchStart);
                
                // 將手柄添加到字符容器中
                char.appendChild(resizeHandleBottomRight);
                char.appendChild(resizeHandleTopLeft);
                
                // 設置字符樣式
                char.style.fontFamily = fontFamily;
                
                // 立即應用當前刻印方式的樣式
                char.classList.add(currentCarving);
                const color = '#d62828';
                if (currentCarving === 'intaglio') {
                    char.style.color = 'white';
                    char.style.textShadow = '0 0 2px rgba(0,0,0,0.5)';
                } else {
                    char.style.color = color;
                    char.style.textShadow = '0 0 2px rgba(255,255,255,0.5)';
                }
                char.style.webkitTextStroke = '';
                char.style.webkitTextFillColor = '';
                
                // 設置字體大小
                updateCharSize(char, charSizes[i]);
                
                // 設置初始位置
                updateCharPosition(char, i);
                
                // 在繪圖模式下禁用拖動
                if (isDrawingMode) {
                    char.style.pointerEvents = 'none';
                }
                
                // 添加事件監聽
                char.addEventListener('mousedown', handleCharMouseDown);
                char.addEventListener('touchstart', handleCharTouchStart);
                char.addEventListener('touchmove', handleCharTouchMove);
                char.addEventListener('touchend', handleCharTouchEnd);
                char.addEventListener('click', selectChar);
                
                charContainer.appendChild(char);
                charElements.push(char);
            }
            
            // 添加拖動事件監聽
            document.addEventListener('mousemove', dragMove);
            document.addEventListener('touchmove', dragMove);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchend', endDrag);
            
            // 點擊印章容器的空白區域取消選擇
            sealContainer.addEventListener('click', function(e) {
                if (!isDrawingMode && (e.target === sealContainer || e.target === sealBackground)) {
                    unselectChar();
                }
            });
            
            // 添加全局點擊事件，在印章區域外點擊也可以取消選中
            document.addEventListener('click', function(e) {
                if (!isDrawingMode && selectedCharIndex !== null) {
                    // 檢查點擊是否在印章區域外
                    const sealRect = sealContainer.getBoundingClientRect();
                    const isInsideSeal = e.clientX >= sealRect.left && 
                                       e.clientX <= sealRect.right && 
                                       e.clientY >= sealRect.top && 
                                       e.clientY <= sealRect.bottom;
                    
                    // 如果點擊在印章區域外，取消選中
                    if (!isInsideSeal) {
                        unselectChar();
                    }
                }
            });
        }
        
        // 選擇字符
        function selectChar(e) {
            e.stopPropagation();
            
            // 如果在繪圖模式下或正在拖動，不處理選擇
            if (isDrawingMode || isDragging) return;
            
            // 取消所有字符的選中狀態
            charElements.forEach(char => char.classList.remove('selected'));
            
            // 設置當前字符為選中狀態
            this.classList.add('selected');
            
            // 保存選中的字符索引
            selectedCharIndex = parseInt(this.dataset.index);
        }
        
        // 取消選擇字符
        function unselectChar() {
            // 移除所有字符的選中狀態
            charElements.forEach(char => char.classList.remove('selected'));
            
            // 重置選中索引
            selectedCharIndex = null;
        }
        
        // 鼠標按下事件處理
        function handleCharMouseDown(e) {
            // 在繪圖模式下或非左鍵點擊時不處理拖動
            if (isDrawingMode || e.button !== 0) return;
            
            e.preventDefault();
            startDrag(e, this);
        }
        
        // 觸摸開始事件處理
        function handleCharTouchStart(e) {
            // 在繪圖模式下不處理拖動
            if (isDrawingMode) return;
            
            // 不要立即阻止默認行为，先记录触摸开始时间和位置
            this.touchStartTime = Date.now();
            this.touchStartX = e.touches[0].clientX;
            this.touchStartY = e.touches[0].clientY;
            this.touchMoved = false;
            
            // 延迟启动拖拽，给点击事件留出时间
            this.dragTimeout = setTimeout(() => {
                if (!this.touchMoved) {
                    e.preventDefault();
                    startDrag(e, this);
                }
            }, 150); // 150ms后才开始拖拽
        }
        
        // 更新字符位置
        function updateCharsPosition() {
            for (let i = 0; i < charElements.length; i++) {
                updateCharPosition(charElements[i], i);
            }
        }
        
        // 更新單個字符位置
        function updateCharPosition(charElement, index) {
            if (index >= charPositions.length) return;
            
            const pos = charPositions[index];
            const fontSize = charSizes[index];
            
            // 優化字符容器大小，更贴合字符实际大小
            // 根据屏幕尺寸动态调整容器大小倍数
            let containerSizeMultiplier;
            if (window.innerWidth <= 640) {
                // 手机端：更紧凑
                containerSizeMultiplier = 1.1;
            } else if (window.innerWidth <= 1023) {
                // 平板端：中等
                containerSizeMultiplier = 1.15;
            } else {
                // 桌面端：稍微宽松
                containerSizeMultiplier = 1.2;
            }
            
            const containerSize = fontSize * containerSizeMultiplier;
            
            // 字符中心定位：容器左上角 = 中心點 - 容器大小的一半
            const offsetX = containerSize / 2;
            const offsetY = containerSize / 2;
            
            charElement.style.left = `${pos.x - offsetX}px`;
            charElement.style.top = `${pos.y - offsetY}px`;
            charElement.style.width = `${containerSize}px`;
            charElement.style.height = `${containerSize}px`;
            charElement.style.transform = `rotate(${pos.rotation}rad)`;
        }
        
        // 更新字符大小
        function updateCharSize(charElement, fontSize) {
            charElement.style.fontSize = `${fontSize}px`;
            
            // 獲取字符索引並更新位置
            const index = parseInt(charElement.dataset.index);
            updateCharPosition(charElement, index);
        }
        
        // 更新所有字符的樣式
        function updateCharsStyle() {
            const color = '#d62828'; // 固定使用紅色
            
            charElements.forEach(char => {
                char.style.fontFamily = currentFont;
                
                // 移除舊的刻印方式類
                char.classList.remove('intaglio', 'relief');
                // 添加當前刻印方式類
                char.classList.add(currentCarving);
                
                // 根據刻印方式設置字符顏色
                if (currentCarving === 'intaglio') {
                    // 陰刻：白色字體
                    char.style.color = 'white';
                    char.style.textShadow = '0 0 2px rgba(0,0,0,0.5)';
                    char.style.webkitTextStroke = '';
                    char.style.webkitTextFillColor = '';
                } else {
                    // 陽刻：紅色字體
                    char.style.color = color;
                    char.style.textShadow = '0 0 2px rgba(255,255,255,0.5)';
                    char.style.webkitTextStroke = '';
                    char.style.webkitTextFillColor = '';
                }
            });
        }
        
        // 繪製印章背景
        function redrawSealBackground() {
            const color = '#d62828'; // 固定使用紅色
            const centerX = sealSize / 2;
            const centerY = sealSize / 2;
            const sizeOffset = padding * 0.8; // 調整邊距
            
            // 設置背景色
            sealBackground.style.background = 'transparent';
            
            // 根據刻印方式選擇填充顏色
            const fillColor = currentCarving === 'intaglio' ? color : 'white';
            const strokeColor = currentCarving === 'intaglio' ? 'none' : color;
            const strokeWidth = currentCarving === 'intaglio' ? 0 : 10; // 加粗陽刻邊框
            
            // 創建簡潔的方形印章
            const svgContent = `
                <svg width="${sealSize}" height="${sealSize}" viewBox="0 0 ${sealSize} ${sealSize}">
                    <rect x="${sizeOffset}" y="${sizeOffset}" 
                          width="${sealSize - sizeOffset * 2}" 
                          height="${sealSize - sizeOffset * 2}" 
                          fill="${fillColor}" 
                          stroke="${strokeColor}" 
                          stroke-width="${strokeWidth}" />
                </svg>
            `;
            
            sealBackground.innerHTML = svgContent;
        }
        
        // 開始拖動
        function startDrag(e, target) {
            // 在繪圖模式下不啟動拖動
            if (isDrawingMode) return;
            
            const index = parseInt(target.dataset.index);
            
            // 檢查是否按住Shift鍵進行大小調整
            if (e.shiftKey && selectedCharIndex === index) {
                // 開始字體大小調整
                isResizing = true;
                dragTarget = target;
                
                if (e.type === 'mousedown') {
                    resizeStartY = e.clientY;
                } else {
                    resizeStartY = e.touches[0].clientY;
                }
                
                initialFontSize = charSizes[index];
                target.style.cursor = 'ns-resize';
                
                // 更新提示信息
                document.querySelector('.drag-instructions').textContent = '拖拽調整字體大小';
                
                return;
            }
            
            // 普通拖動移動位置
            isDragging = true;
            dragTarget = target;
            dragTarget.classList.add('dragging');
            
            // 獲取鼠標/觸摸起始位置
            if (e.type === 'mousedown') {
                dragStartX = e.clientX;
                dragStartY = e.clientY;
            } else {
                dragStartX = e.touches[0].clientX;
                dragStartY = e.touches[0].clientY;
            }
            
            // 獲取元素起始位置
            targetStartX = charPositions[index].x;
            targetStartY = charPositions[index].y;
            
            // 防止選擇時觸發拖動
            setTimeout(() => {
                if (isDragging) {
                    // 在拖動時取消字符的選中狀態
                    unselectChar();
                }
            }, 200);
        }
        
        // 拖動移動
        function dragMove(e) {
            if ((!isDragging && !isResizing) || !dragTarget) return;
            
            e.preventDefault();
            
            let clientX, clientY;
            if (e.type === 'mousemove') {
                clientX = e.clientX;
                clientY = e.clientY;
            } else {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            }
            
            const index = parseInt(dragTarget.dataset.index);
            
            if (isResizing) {
                // 字體大小調整模式 - 根據手柄類型調整方向
                const deltaX = clientX - resizeStartX;
                const deltaY = clientY - resizeStartY;
                
                // 計算對角線距離變化
                const diagonalDistance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                
                let direction;
                if (resizeHandleType === 'bottom-right') {
                    // 右下角手柄：右下為增大，左上為縮小
                    direction = (deltaX + deltaY) > 0 ? 1 : -1;
                } else {
                    // 左上角手柄：左上為增大，右下為縮小（與右下角相反）
                    direction = (deltaX + deltaY) < 0 ? 1 : -1;
                }
                
                const sizeChange = direction * diagonalDistance * 0.3; // 調整敏感度
                const newSize = Math.max(20, Math.min(200, initialFontSize + sizeChange));
                
                // 更新字符大小
                charSizes[index] = newSize;
                updateCharSize(dragTarget, newSize);
                
            } else if (isDragging) {
                // 普通拖動移動位置
                const deltaX = clientX - dragStartX;
                const deltaY = clientY - dragStartY;
                
                // 更新字符位置
                charPositions[index].x = targetStartX + deltaX;
                charPositions[index].y = targetStartY + deltaY;
                
                // 更新元素位置
                updateCharPosition(dragTarget, index);
            }
        }
        
        // 調整手柄鼠標按下事件
        function handleResizeMouseDown(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // 在繪圖模式下不處理調整
            if (isDrawingMode) return;
            
            isResizing = true;
            dragTarget = this.parentElement;
            resizeHandleType = this.classList.contains('top-left') ? 'top-left' : 'bottom-right';
            
            const index = parseInt(this.dataset.index);
            
            // 獲取起始位置
            resizeStartX = e.clientX;
            resizeStartY = e.clientY;
            initialFontSize = charSizes[index];
            
            // 添加調整中的樣式
            this.classList.add('resizing');
            
            // 更新提示信息
            document.querySelector('.drag-instructions').textContent = '向外拖拽增大字體，向內拖拽縮小字體';
        }
        
        // 調整手柄觸摸開始事件
        function handleResizeTouchStart(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // 在繪圖模式下不處理調整
            if (isDrawingMode) return;
            
            isResizing = true;
            dragTarget = this.parentElement;
            resizeHandleType = this.classList.contains('top-left') ? 'top-left' : 'bottom-right';
            
            const index = parseInt(this.dataset.index);
            
            // 獲取起始位置
            resizeStartX = e.touches[0].clientX;
            resizeStartY = e.touches[0].clientY;
            initialFontSize = charSizes[index];
            
            // 添加調整中的樣式
            this.classList.add('resizing');
            
            // 更新提示信息
            document.querySelector('.drag-instructions').textContent = '向外拖拽增大字體，向內拖拽縮小字體';
        }
        
        // 移动端触摸移动处理
        function handleCharTouchMove(e) {
            // 在繪圖模式下不处理
            if (isDrawingMode) return;
            
            if (!this.touchStartX || !this.touchStartY) return;
            
            const touch = e.touches[0];
            const deltaX = Math.abs(touch.clientX - this.touchStartX);
            const deltaY = Math.abs(touch.clientY - this.touchStartY);
            
            // 如果移动距离超过阈值，标记为已移动并清除拖拽延时
            if (deltaX > 10 || deltaY > 10) {
                this.touchMoved = true;
                if (this.dragTimeout) {
                    clearTimeout(this.dragTimeout);
                    this.dragTimeout = null;
                }
            }
        }
        
        // 移动端触摸结束处理
        function handleCharTouchEnd(e) {
            // 在繪圖模式下不处理
            if (isDrawingMode) return;
            
            // 清除拖拽延时
            if (this.dragTimeout) {
                clearTimeout(this.dragTimeout);
                this.dragTimeout = null;
            }
            
            const touchDuration = Date.now() - (this.touchStartTime || 0);
            
            // 如果是短时间的触摸且没有移动，触发选择
            if (touchDuration < 300 && !this.touchMoved) {
                // 模拟点击事件来选中字符
                e.preventDefault();
                selectChar.call(this, e);
            }
            
            // 重置触摸状态
            this.touchStartTime = null;
            this.touchStartX = null;
            this.touchStartY = null;
            this.touchMoved = false;
        }
        
        // 結束拖動
        function endDrag() {
            if (dragTarget) {
                dragTarget.classList.remove('dragging');
                
                // 移除調整手柄的調整中樣式
                const resizeHandle = dragTarget.querySelector('.resize-handle');
                if (resizeHandle) {
                    resizeHandle.classList.remove('resizing');
                }
                
                // 恢復提示信息
                if (isResizing) {
                    document.querySelector('.drag-instructions').textContent = '點擊並拖動字符調整位置，拖拽右下角藍色圓點調整大小';
                }
            }
            
            isDragging = false;
            isResizing = false;
            dragTarget = null;
        }
        
        // 完全重寫下載印章功能
        function downloadSeal() {
            try {
                // 顯示加載指示器
                loadingIndicator.classList.remove('hidden');
                downloadMessage.className = '';
                downloadMessage.textContent = '';
                
                // 準備下載用畫布
                downloadCanvas.width = sealSize;
                downloadCanvas.height = sealSize;
                downloadCtx.clearRect(0, 0, sealSize, sealSize);
                
                // 1. 首先繪製背景顏色和形狀（簡潔的方形）
                const color = '#d62828'; // 固定使用紅色
                const centerX = sealSize / 2;
                const centerY = sealSize / 2;
                const sizeOffset = padding * 0.8;
                
                // 根據刻印方式選擇填充顏色
                const fillColor = currentCarving === 'intaglio' ? color : 'white';
                
                downloadCtx.fillStyle = fillColor;
                
                // 創建簡潔的方形印章
                downloadCtx.fillRect(sizeOffset, sizeOffset, 
                                   sealSize - sizeOffset * 2, 
                                   sealSize - sizeOffset * 2);
                
                // 如果是陽刻，添加邊框
                if (currentCarving === 'relief') {
                    downloadCtx.strokeStyle = color;
                    downloadCtx.lineWidth = 10; // 加粗陽刻邊框
                    downloadCtx.strokeRect(sizeOffset, sizeOffset, 
                                         sealSize - sizeOffset * 2, 
                                         sealSize - sizeOffset * 2);
                }
                
                // 2. 繪製使用者繪製的內容
                if (displayCanvas) {
                    downloadCtx.drawImage(displayCanvas, 0, 0);
                }
                
                // 3. 繪製文字
                const text = nameInput.value.trim() || "印";
                const fontFamily = currentFont;
                
                // 根據刻印方式設置文字顏色
                if (currentCarving === 'intaglio') {
                    // 陰刻：白色字體
                    downloadCtx.fillStyle = 'white';
                } else {
                    // 陽刻：紅色字體
                    downloadCtx.fillStyle = color;
                }
                downloadCtx.textAlign = 'center';
                downloadCtx.textBaseline = 'middle';
                
                // 確保使用的字體已加載完成
                document.fonts.ready.then(() => {
                    // 繪製每個字符
                    for (let i = 0; i < text.length; i++) {
                        const pos = charPositions[i];
                        const fontSize = charSizes[i];
                        
                        downloadCtx.save();
                        downloadCtx.translate(pos.x, pos.y);
                        downloadCtx.rotate(pos.rotation);
                        downloadCtx.font = `bold ${fontSize}px ${fontFamily}`;
                        downloadCtx.fillText(text[i], 0, 0);
                        downloadCtx.restore();
                    }
                    
                    // 將畫布轉換為下載連結
                    try {
                        downloadCanvas.toBlob(function(blob) {
                            if (!blob) {
                                throw new Error('無法創建圖片檔案');
                            }
                            
                            // 創建下載連結
                            const url = URL.createObjectURL(blob);
                            const link = document.createElement('a');
                            link.href = url;
                            link.download = '弘立書院印章.png';
                            
                            // 觸發下載
                            document.body.appendChild(link);
                            link.click();
                            
                            // 清理
                            setTimeout(() => {
                                document.body.removeChild(link);
                                URL.revokeObjectURL(url);
                                
                                // 隱藏加載指示器並顯示成功信息
                                loadingIndicator.classList.add('hidden');
                                downloadMessage.className = 'success';
                                downloadMessage.textContent = '印章已成功下載！';
                                
                                // 3秒後隱藏成功信息
                                setTimeout(() => {
                                    downloadMessage.className = '';
                                    downloadMessage.textContent = '';
                                }, 3000);
                            }, 100);
                        }, 'image/png', 1.0);
                    } catch (error) {
                        console.error('Blob 創建失敗:', error);
                        showDownloadError('創建圖片檔案時出錯');
                    }
                }).catch(err => {
                    console.error('字體加載失敗:', err);
                    showDownloadError('字體加載失敗，請嘗試使用標準字體');
                });
                
            } catch (error) {
                console.error('下載過程錯誤:', error);
                showDownloadError('下載過程中發生錯誤');
            }
        }
        
        function showDownloadError(message) {
            loadingIndicator.classList.add('hidden');
            downloadMessage.className = 'error';
            downloadMessage.textContent = message || '下載失敗，請再試一次';
            
            // 5秒後隱藏錯誤信息
            setTimeout(() => {
                downloadMessage.className = '';
                downloadMessage.textContent = '';
            }, 5000);
        }
        
        // 為單個字符創建高質量圖像的函數
        async function renderCharacterToImage(char, fontSize, fontFamily) {
            return new Promise((resolve) => {
                // 等待字體加載完成
                document.fonts.ready.then(() => {
                    try {
                        // 創建高分辨率的Canvas
                        const canvas = document.createElement('canvas');
                        const scale = 3; // 高分辨率倍數，確保字體清晰
                        const padding = fontSize * 0.2; // 添加適當邊距
                        
                        canvas.width = (fontSize + padding * 2) * scale;
                        canvas.height = (fontSize + padding * 2) * scale;
                        
                        const ctx = canvas.getContext('2d');
                        
                        // 設置高質量渲染
                        ctx.imageSmoothingEnabled = true;
                        ctx.imageSmoothingQuality = 'high';
                        ctx.scale(scale, scale);
                        
                        // 設置字體和樣式
                        ctx.font = `bold ${fontSize}px ${fontFamily}`;
                        ctx.fillStyle = 'white'; // 白色字體（反字）
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        
                        // 添加文字陰影以增強效果（可選）
                        ctx.shadowColor = 'rgba(0,0,0,0.3)';
                        ctx.shadowBlur = 2;
                        ctx.shadowOffsetX = 1;
                        ctx.shadowOffsetY = 1;
                        
                        // 在Canvas中心繪製字符
                        const centerX = canvas.width / scale / 2;
                        const centerY = canvas.height / scale / 2;
                        ctx.fillText(char, centerX, centerY);
                        
                        // 轉換為base64圖像
                        const dataUrl = canvas.toDataURL('image/png', 1.0);
                        
                        // 返回圖像信息
                        resolve({
                            dataUrl: dataUrl,
                            width: canvas.width / scale,
                            height: canvas.height / scale
                        });
                        
                    } catch (error) {
                        console.warn(`字符 "${char}" 渲染失敗:`, error);
                        // 返回null表示失敗，將使用備選方案
                        resolve(null);
                    }
                });
            });
        }
        
        // 簡化的繪圖內容處理函數
        function processDrawingForSvg() {
            try {
                if (!displayCanvas || !displayCtx) return '';
                
                const imageData = displayCtx.getImageData(0, 0, sealSize, sealSize);
                if (!imageData || !imageData.data.some(value => value > 0)) return '';
                
                // 將整個繪圖畫布轉換為base64圖像嵌入
                const drawingDataUrl = displayCanvas.toDataURL('image/png');
                return `<image x="0" y="0" width="${sealSize}" height="${sealSize}" href="${drawingDataUrl}" opacity="1" />`;
            } catch (error) {
                console.warn('處理繪圖內容時出錯:', error);
                return '';
            }
        }
        
        // SVG反字下載功能 - 修復版本，確保字符正確顯示
        async function downloadSvgSeal() {
            try {
                // 顯示加載指示器
                loadingIndicator.classList.remove('hidden');
                downloadMessage.className = '';
                downloadMessage.textContent = '正在轉換文字為可靠的矢量格式...';
                
                const text = nameInput.value.trim() || "印";
                const sizeOffset = padding * 0.8;
                
                // 創建SVG內容 - 反字設計，適合激光切割
                let svgContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg width="${sealSize}" height="${sealSize}" viewBox="0 0 ${sealSize} ${sealSize}" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
    <defs>
        <!-- 確保兼容性的字體備選 -->
        <style>
            .seal-text {
                font-family: ${currentFont}, Arial, "Microsoft JhengHei", "PingFang TC", "Noto Sans CJK TC", sans-serif;
                font-weight: bold;
            }
        </style>
    </defs>
    
    <!-- 印章邊框 -->
    <rect x="${sizeOffset}" y="${sizeOffset}" 
          width="${sealSize - sizeOffset * 2}" 
          height="${sealSize - sizeOffset * 2}" 
          fill="black" 
          stroke="none" />
          
    <!-- 反字文字（鏤空，用於激光切割） -->
    <g transform="scale(-1,1) translate(-${sealSize},0)">`;
                
                // 轉換每個字符 - 使用高質量圖像渲染保持字體效果
                for (let i = 0; i < text.length; i++) {
                    const pos = charPositions[i];
                    const fontSize = charSizes[i];
                    const char = text[i];
                    
                    downloadMessage.textContent = `正在處理字符: ${char} (${i + 1}/${text.length})`;
                    
                    try {
                        // 轉換旋轉角度為度數
                        const rotationDeg = pos.rotation * 180 / Math.PI;
                        
                        // 嘗試渲染字符為高質量圖像
                        const charImage = await renderCharacterToImage(char, fontSize, currentFont);
                        
                        if (charImage) {
                            // 使用渲染的圖像，保持原字體效果
                            svgContent += `
        <g transform="translate(${pos.x}, ${pos.y}) rotate(${rotationDeg})">
            <image x="${-charImage.width/2}" y="${-charImage.height/2}" 
                   width="${charImage.width}" height="${charImage.height}" 
                   href="${charImage.dataUrl}" />
        </g>`;
                        } else {
                            // 備選方案：使用文字元素
                            console.warn(`字符 "${char}" 圖像渲染失敗，使用文字備選`);
                            svgContent += `
        <text x="${pos.x}" y="${pos.y}" 
              class="seal-text"
              font-size="${fontSize}" 
              text-anchor="middle" 
              dominant-baseline="central"
              fill="white"
              transform="rotate(${rotationDeg} ${pos.x} ${pos.y})">${char}</text>`;
                        }
                        
                    } catch (error) {
                        console.error(`處理字符 ${char} 時出錯:`, error);
                        // 使用最安全的備選方案
                        const rotationDeg = pos.rotation * 180 / Math.PI;
                        svgContent += `
        <text x="${pos.x}" y="${pos.y}" 
              class="seal-text"
              font-size="${fontSize}" 
              text-anchor="middle" 
              dominant-baseline="central"
              fill="white"
              transform="rotate(${rotationDeg} ${pos.x} ${pos.y})">${char}</text>`;
                    }
                }
                
                // 處理用戶繪圖內容
                downloadMessage.textContent = '正在處理繪圖內容...';
                const drawingContent = processDrawingForSvg();
                if (drawingContent) {
                    svgContent += `
        <!-- 用戶繪圖內容 - 高保真嵌入 -->
        ${drawingContent}`;
                }
                
                svgContent += `
    </g>
    
    <!-- 使用說明註釋 -->
    <!-- 此SVG使用字體備選機制確保文字顯示 -->
    <!-- 適合激光切割：黑色區域切割，白色區域保留 -->
</svg>`;
                
                downloadMessage.textContent = '正在生成下載文件...';
                
                // 創建Blob並下載
                const blob = new Blob([svgContent], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                link.download = '弘立書院印章_反字_激光切割.svg';
                
                // 觸發下載
                document.body.appendChild(link);
                link.click();
                
                // 清理
                setTimeout(() => {
                    document.body.removeChild(link);
                    URL.revokeObjectURL(url);
                    
                    // 隱藏加載指示器並顯示成功信息
                    loadingIndicator.classList.add('hidden');
                    downloadMessage.className = 'success';
                    downloadMessage.textContent = 'SVG反字印章已成功下載！使用高質量字符圖像渲染技術，完美保持設定字體效果，確保在任何設備上都能正確顯示，適合激光切割使用。';
                    
                    // 5秒後隱藏成功信息
                    setTimeout(() => {
                        downloadMessage.className = '';
                        downloadMessage.textContent = '';
                    }, 5000);
                }, 100);
                
            } catch (error) {
                console.error('SVG轉換過程錯誤:', error);
                loadingIndicator.classList.add('hidden');
                downloadMessage.className = 'error';
                downloadMessage.textContent = 'SVG轉換過程中發生錯誤，請重試。';
                
                setTimeout(() => {
                    downloadMessage.className = '';
                    downloadMessage.textContent = '';
                }, 5000);
            }
        }
    </script>
</body>
</html>



