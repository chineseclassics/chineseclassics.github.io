<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è©é¾å¤§å†’éšª - å¤ªè™›å¹»å¢ƒ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 20px;
            max-width: 900px;
            width: 95vw;
            max-height: 95vh;
            overflow: hidden;
        }

        /* é ‚éƒ¨ç‹€æ…‹æ¬„ */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(45deg, #ff6b6b, #ee5a52);
            color: white;
            padding: 15px 25px;
            border-radius: 15px;
            margin-bottom: 20px;
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
        }

        .status-left {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .level-badge {
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 16px;
        }

        .score-display {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .score-label {
            font-size: 12px;
            opacity: 0.8;
        }

        .score-value {
            font-size: 20px;
            font-weight: bold;
        }

        .status-right {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .words-count {
            text-align: center;
        }

        /* éŠæˆ²å€åŸŸ */
        .game-area {
            display: flex;
            gap: 20px;
            height: calc(95vh - 200px);
            max-height: 600px;
        }

        .game-board-container {
            flex: 2;
            display: flex;
            flex-direction: column;
        }

        .game-board {
            background: #f8f9fa;
            border: 3px solid #e9ecef;
            border-radius: 15px;
            position: relative;
            width: 100%;
            height: 100%;
            overflow: hidden;
            padding: 8px;
            box-sizing: border-box;
        }

        .game-cell {
            position: absolute;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            border-radius: 4px;
            transition: all 0.2s ease;
            line-height: 1;
            box-sizing: border-box;
            overflow: hidden;
            padding: 1px;
            text-align: center;
            font-family: 'å¾®è»Ÿæ­£é»‘é«”', 'Microsoft JhengHei', Arial, sans-serif;
        }

        .snake-head {
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
            z-index: 10;
            animation: dragonHeadGlow 2s ease-in-out infinite;
        }

        @keyframes dragonHeadGlow {
            0%, 100% { 
                box-shadow: 0 2px 8px rgba(76, 175, 80, 0.3);
                transform: scale(1);
            }
            50% { 
                box-shadow: 0 4px 15px rgba(76, 175, 80, 0.6);
                transform: scale(1.05);
            }
        }

        .snake-body {
            background: linear-gradient(45deg, #81C784, #66BB6A);
            color: white;
            box-shadow: 0 2px 6px rgba(129, 199, 132, 0.3);
        }

        .food {
            background: linear-gradient(45deg, #FF9800, #F57C00);
            color: white;
            box-shadow: 0 2px 8px rgba(255, 152, 0, 0.3);
        }

        /* éŠæˆ²ä¿¡æ¯é¢æ¿ */
        .game-info {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-panel {
            background: white;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
        }

        .info-panel h3 {
            color: #333;
            margin-bottom: 15px;
            font-size: 18px;
            border-bottom: 2px solid #f0f0f0;
            padding-bottom: 8px;
        }

        .current-dragon {
            font-size: 24px;
            text-align: center;
            padding: 15px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            color: white;
            border-radius: 10px;
            margin-bottom: 15px;
        }

        .dragon-body {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            justify-content: center;
        }

        .dragon-char {
            background: #e3f2fd;
            color: #1976d2;
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            border: 2px solid #bbdefb;
        }

        .recent-words {
            max-height: 200px;
            overflow-y: auto;
        }

        .word-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-bottom: 1px solid #f0f0f0;
        }

        .word-item:last-child {
            border-bottom: none;
        }

        .word-text {
            font-weight: bold;
            color: #333;
        }

        .word-score {
            background: #4CAF50;
            color: white;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
        }

        /* æ§åˆ¶æŒ‰éˆ• */
        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 15px;
        }

        .control-btn {
            background: linear-gradient(45deg, #2196F3, #1976D2);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(33, 150, 243, 0.3);
        }

        .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(33, 150, 243, 0.4);
        }

        .control-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        /* éŠæˆ²çµæŸç•«é¢ */
        .game-over {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .game-over-content {
            background: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
        }

        .game-over h2 {
            color: #333;
            margin-bottom: 20px;
            font-size: 28px;
        }

        .final-stats {
            margin: 20px 0;
            color: #666;
        }

        .final-stats div {
            margin: 8px 0;
            font-size: 16px;
        }

        /* éŸ¿æ‡‰å¼è¨­è¨ˆ */
        @media (max-width: 768px) {
            .game-area {
                flex-direction: column;
                height: auto;
            }
            
            .game-info {
                flex-direction: row;
                overflow-x: auto;
            }
            
            .info-panel {
                min-width: 250px;
            }
            
            .game-board {
                height: 400px;
            }
        }

        /* æˆåŠŸå‹•ç•« */
        .success-animation {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(45deg, #4CAF50, #45a049);
            color: white;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            font-weight: bold;
            z-index: 1000;
            animation: successPop 2s ease-out forwards;
        }

        @keyframes successPop {
            0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
            20% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
            80% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
            100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- é ‚éƒ¨ç‹€æ…‹æ¬„ -->
        <div class="status-bar">
            <div class="status-left">
                <div class="level-badge">
                    ç­‰ç´š <span id="player-level">1</span>
                </div>
                <div class="score-display">
                    <div class="score-label">ç¸½ç©åˆ†</div>
                    <div class="score-value" id="total-points">0</div>
                </div>
            </div>
            <div class="status-right">
                <div class="words-count">
                    <div class="score-label">çµ„è©æˆåŠŸ</div>
                    <div class="score-value" id="words-formed">0</div>
                </div>
                <div class="score-display">
                    <div class="score-label">ç•¶å‰åˆ†æ•¸</div>
                    <div class="score-value" id="current-score">0</div>
                </div>
            </div>
        </div>

        <!-- éŠæˆ²å€åŸŸ -->
        <div class="game-area">
            <div class="game-board-container">
                <div class="game-board" id="game-board"></div>
                <div class="controls">
                    <button class="control-btn" id="start-btn">é–‹å§‹éŠæˆ²</button>
                    <button class="control-btn" id="pause-btn" disabled>æš«åœ</button>
                    <button class="control-btn" id="restart-btn">é‡æ–°é–‹å§‹</button>
                </div>
            </div>

            <div class="game-info">
                <div class="info-panel">
                    <h3>ç•¶å‰è©é¾</h3>
                    <div class="current-dragon">
                        é¾é ­ï¼š<span id="dragon-head">å­¸</span>
                    </div>
                    <div class="dragon-body" id="dragon-body">
                        <div class="dragon-char">ç¿’</div>
                        <div class="dragon-char">çŸ¥</div>
                    </div>
                </div>

                <div class="info-panel">
                    <h3>æœ€è¿‘çµ„è©</h3>
                    <div class="recent-words" id="recent-words">
                        <div class="word-item">
                            <span class="word-text">æº–å‚™é–‹å§‹éŠæˆ²...</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // éŠæˆ²ç‹€æ…‹ç®¡ç†
        class GameState {
            constructor() {
                this.score = 0;
                this.level = 1;
                this.wordsFormed = 0;
                this.totalPoints = this.loadTotalPoints();
                this.isPlaying = false;
                this.isPaused = false;
                this.recentWords = [];
            }

            loadTotalPoints() {
                return parseInt(localStorage.getItem('totalPoints') || '0');
            }

            saveTotalPoints() {
                localStorage.setItem('totalPoints', this.totalPoints.toString());
            }

            addScore(points, word = '') {
                this.score += points;
                this.totalPoints += points;
                this.saveTotalPoints();
                
                if (word) {
                    this.wordsFormed++;
                    this.recentWords.unshift({ word, score: points });
                    if (this.recentWords.length > 10) {
                        this.recentWords.pop();
                    }
                }
                
                // å‡ç´šé‚è¼¯
                const newLevel = Math.floor(this.wordsFormed / 5) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.showSuccessAnimation(`å‡ç´šåˆ°ç­‰ç´š ${this.level}ï¼`);
                }
                
                this.updateDisplay();
            }

            updateDisplay() {
                document.getElementById('current-score').textContent = this.score;
                document.getElementById('total-points').textContent = this.totalPoints;
                document.getElementById('player-level').textContent = this.level;
                document.getElementById('words-formed').textContent = this.wordsFormed;
                
                // æ›´æ–°æœ€è¿‘çµ„è©
                const recentWordsElement = document.getElementById('recent-words');
                if (this.recentWords.length > 0) {
                    recentWordsElement.innerHTML = this.recentWords.map(item => 
                        `<div class="word-item">
                            <span class="word-text">${item.word}</span>
                            <span class="word-score">+${item.score}</span>
                        </div>`
                    ).join('');
                }
            }

            showSuccessAnimation(message) {
                const animation = document.createElement('div');
                animation.className = 'success-animation';
                animation.textContent = message;
                document.body.appendChild(animation);
                
                setTimeout(() => {
                    document.body.removeChild(animation);
                }, 2000);
            }
        }

        // è©åº«ç³»çµ± - çµ±ä¸€ç‰ˆæœ¬ï¼Œä½¿ç”¨æ‚¨æŒ‡å®šçš„è©åº«URL
        class WordDatabase {
            constructor() {
                // æœ¬åœ°è©åº«ï¼ˆå¾å„ªåŒ–çš„å­—å…¸æ–‡ä»¶åŠ è¼‰ï¼‰
                this.words = new Set();
                this.byFirstChar = {}; // æŒ‰é¦–å­—åˆ†çµ„
                this.byLastChar = {};  // æŒ‰å°¾å­—åˆ†çµ„
                this.commonChars = []; // å¸¸ç”¨å­—ç¬¦ï¼ˆç”¨æ–¼ç”Ÿæˆé£Ÿç‰©ï¼‰
                this.isLoaded = false; // åŠ è¼‰ç‹€æ…‹æ¨™è¨˜
            }

            // ç•°æ­¥åˆå§‹åŒ–æ–¹æ³• - ç¢ºä¿è©åº«æ­£ç¢ºåŠ è¼‰
            async initialize() {
                console.log('é–‹å§‹åˆå§‹åŒ–è©åº«...');
                
                // ç¬¬ä¸€å„ªå…ˆï¼šå˜—è©¦åŠ è¼‰å„ªåŒ–è©åº«
                if (await this.loadOptimizedDictionary()) {
                    return;
                }
                
                // ç¬¬äºŒå„ªå…ˆï¼šå˜—è©¦åŠ è¼‰åŸå§‹words.txt
                if (await this.loadFromWordsFile()) {
                    return;
                }
                
                // æœ€å¾Œå‚™æ¡ˆï¼šä½¿ç”¨å…§å»ºè©åº«
                this.loadBuiltinDictionary();
            }

            // åŠ è¼‰å„ªåŒ–è©åº« - ä½¿ç”¨æ‚¨æŒ‡å®šçš„URL
            async loadOptimizedDictionary() {
                try {
                    const targetUrl = 'files/dictionary/cilong_words.json';
                    console.log(`ğŸ¯ å˜—è©¦åŠ è¼‰å„ªåŒ–è©åº«: ${targetUrl}`);
                    console.log(`ğŸ“ å®Œæ•´URL: ${window.location.origin}/${targetUrl}`);
                    
                    const response = await fetch(targetUrl);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status} - ${response.statusText}`);
                    }
                    
                    console.log(`âœ… æˆåŠŸå–å¾—éŸ¿æ‡‰: ${response.status} ${response.statusText}`);
                    console.log(`ğŸ“¦ å…§å®¹é¡å‹: ${response.headers.get('content-type')}`);
                    
                    const dictData = await response.json();
                    
                    // é©—è­‰æ•¸æ“šå®Œæ•´æ€§
                    if (!dictData.words || !Array.isArray(dictData.words)) {
                        throw new Error('è©åº«æ•¸æ“šæ ¼å¼ä¸æ­£ç¢ºï¼šç¼ºå°‘wordsæ•¸çµ„');
                    }
                    
                    // é©—è­‰é—œéµå­—æ®µ
                    const expectedFields = ['version', 'description', 'total_words', 'total_chars', 'words', 'by_first_char', 'by_last_char', 'common_chars'];
                    const missingFields = expectedFields.filter(field => !(field in dictData));
                    if (missingFields.length > 0) {
                        console.warn(`âš ï¸ è©åº«ç¼ºå°‘éƒ¨åˆ†å­—æ®µ: ${missingFields.join(', ')}`);
                    }
                    
                    // è¼‰å…¥è©èªé›†åˆ
                    this.words = new Set(dictData.words);
                    this.byFirstChar = dictData.by_first_char || {};
                    this.byLastChar = dictData.by_last_char || {};
                    this.commonChars = dictData.common_chars || [];
                    
                    this.isLoaded = true;
                    
                    console.log(`ğŸ‰ å„ªåŒ–è©åº«åŠ è¼‰å®Œå…¨æˆåŠŸï¼`);
                    console.log(`ğŸ“– ç‰ˆæœ¬: ${dictData.version || 'æœªçŸ¥'}`);
                    console.log(`ğŸ“ æè¿°: ${dictData.description || 'æœªçŸ¥'}`);
                    console.log(`ğŸ“Š è©èªç¸½æ•¸: ${dictData.total_words || this.words.size}`);
                    console.log(`ğŸ”¤ å­—ç¬¦ç¸½æ•¸: ${dictData.total_chars || 'æœªçŸ¥'}`);
                    console.log(`ğŸ…°ï¸ ä¸åŒé¦–å­—: ${Object.keys(this.byFirstChar).length}`);
                    console.log(`ğŸ…±ï¸ ä¸åŒå°¾å­—: ${Object.keys(this.byLastChar).length}`);
                    console.log(`â­ å¸¸ç”¨å­—ç¬¦: ${this.commonChars.length}`);
                    
                    // æ¸¬è©¦"ç”Ÿå­—"æ˜¯å¦åœ¨è©åº«ä¸­
                    const testWords = ['ç”Ÿå­—', 'å­¸ç”Ÿ', 'å­—é«”', 'æ–‡å­—'];
                    console.log(`ğŸ§ª æ¸¬è©¦è©èª:`);
                    testWords.forEach(word => {
                        const exists = this.words.has(word);
                        console.log(`   "${word}": ${exists ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'}`);
                    });
                    
                    return true;
                } catch (error) {
                    console.error('âŒ åŠ è¼‰å„ªåŒ–è©åº«å¤±æ•—:', error);
                    console.error(`ğŸ” è«‹æª¢æŸ¥URLæ˜¯å¦å¯è¨ªå•: ${window.location.origin}/files/dictionary/cilong_words.json`);
                    return false;
                }
            }

            // å‚™ç”¨ï¼šå¾åŸå§‹words.txtæ–‡ä»¶åŠ è¼‰
            async loadFromWordsFile() {
                try {
                    console.log('å˜—è©¦åŠ è¼‰åŸå§‹è©åº«: files/dictionary/words.txt');
                    const response = await fetch('files/dictionary/words.txt');
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}`);
                    }
                    
                    const text = await response.text();
                    const lines = text.split('\n');
                    
                    // åªä¿ç•™å…©å­—è©èª
                    lines.forEach(line => {
                        const word = line.trim();
                        if (word.length === 2) {
                            this.words.add(word);
                        }
                    });
                    
                    this.buildIndices();
                    this.isLoaded = true;
                    console.log(`âœ… åŸå§‹è©åº«åŠ è¼‰æˆåŠŸï¼Œå…± ${this.words.size} å€‹å…©å­—è©èª`);
                    return true;
                } catch (error) {
                    console.error('âŒ åŠ è¼‰åŸå§‹è©åº«å¤±æ•—:', error);
                    return false;
                }
            }

            // æ§‹å»ºç´¢å¼•
            buildIndices() {
                this.byFirstChar = {};
                this.byLastChar = {};
                const charFreq = {};
                
                this.words.forEach(word => {
                    const firstChar = word[0];
                    const lastChar = word[1];
                    
                    if (!this.byFirstChar[firstChar]) {
                        this.byFirstChar[firstChar] = [];
                    }
                    this.byFirstChar[firstChar].push(word);
                    
                    if (!this.byLastChar[lastChar]) {
                        this.byLastChar[lastChar] = [];
                    }
                    this.byLastChar[lastChar].push(word);
                    
                    // çµ±è¨ˆå­—ç¬¦é »ç‡
                    charFreq[firstChar] = (charFreq[firstChar] || 0) + 1;
                    charFreq[lastChar] = (charFreq[lastChar] || 0) + 1;
                });
                
                // æå–å¸¸ç”¨å­—ç¬¦ï¼ˆå‡ºç¾é »ç‡å‰200çš„å­—ç¬¦ï¼‰
                this.commonChars = Object.entries(charFreq)
                    .sort((a, b) => b[1] - a[1])
                    .slice(0, 200)
                    .map(entry => entry[0]);
            }

            // å…§å»ºå‚™ç”¨è©åº«
            loadBuiltinDictionary() {
                const builtinWords = [
                    'å­¸ç¿’', 'çŸ¥è­˜', 'æ™ºæ…§', 'å¿«æ¨‚', 'ç¾éº—', 'å–„è‰¯', 'å‹‡æ•¢', 'åŠªåŠ›',
                    'æˆåŠŸ', 'å¸Œæœ›', 'å¤¢æƒ³', 'å‹æƒ…', 'æ„›å¿ƒ', 'æº«æš–', 'å…‰æ˜', 'å¥åº·',
                    'å¹³å®‰', 'å¹¸ç¦', 'è‡ªç”±', 'æ­£ç¾©', 'èª å¯¦', 'æ€è€ƒ', 'ç†è§£', 'è¨˜æ†¶',
                    'å‰µé€ ', 'ç™¼ç¾', 'æ¢ç´¢', 'ç ”ç©¶', 'è®€æ›¸', 'å¯«å­—', 'ç”Ÿå­—', 'æ¼¢å­—',
                    'æ–‡å­—', 'æ•¸å­—', 'å­—é«”', 'å­—å…¸', 'å­—æ¯', 'å­¸ç”Ÿ', 'è€å¸«', 'åŒå­¸',
                    'æœ‹å‹', 'å®¶äºº', 'çˆ¶æ¯', 'å­©å­', 'å…„å¼Ÿ', 'å§å¦¹'
                ];
                
                this.words = new Set(builtinWords);
                this.buildIndices();
                this.isLoaded = true;
                console.log(`âš ï¸ ä½¿ç”¨å‚™ç”¨è©åº«ï¼Œå…± ${this.words.size} å€‹å…©å­—è©èª`);
            }

            // æª¢æŸ¥è©èªæ˜¯å¦å­˜åœ¨ï¼ˆç´”æœ¬åœ°æŸ¥è©¢ï¼Œç„¡å»¶é²ï¼‰
            isValidWord(word) {
                return this.words.has(word);
            }

            // åŒæ­¥ç‰ˆæœ¬çš„è©èªé©—è­‰
            isValidWordSync(word) {
                return {
                    exists: this.words.has(word),
                    word: word,
                    source: 'local'
                };
            }

            canFormWord(headChar, newChar) {
                // æª¢æŸ¥æ˜¯å¦èƒ½èˆ‡é¾é ­çµ„æˆè©
                return this.words.has(headChar + newChar) || this.words.has(newChar + headChar);
            }

            calculateScore(word) {
                let score = word.length * 10;
                
                // é›£è©çå‹µ
                if (word.length >= 3) score += 20;
                if (word.length >= 4) score += 50;
                
                return score;
            }

            // ç²å–éš¨æ©Ÿå­—ç¬¦ - ä½¿ç”¨å„ªåŒ–çš„å¸¸ç”¨å­—ç¬¦é›†
            getRandomChar() {
                // å¦‚æœæœ‰å¸¸ç”¨å­—ç¬¦é›†ï¼Œå„ªå…ˆä½¿ç”¨
                if (this.commonChars && this.commonChars.length > 0) {
                    return this.commonChars[Math.floor(Math.random() * this.commonChars.length)];
                }
                
                // å‚™ç”¨å­—ç¬¦é›†ï¼ˆå¦‚æœå­—å…¸æœªæ­£ç¢ºåŠ è¼‰ï¼‰
                const fallbackChars = [
                    'å­¸', 'ç¿’', 'çŸ¥', 'è­˜', 'æ™º', 'æ…§', 'å¿«', 'æ¨‚', 'ç¾', 'éº—',
                    'å–„', 'è‰¯', 'å‹‡', 'æ•¢', 'åŠª', 'åŠ›', 'æˆ', 'åŠŸ', 'å¸Œ', 'æœ›',
                    'å¤¢', 'æƒ³', 'å‹', 'æƒ…', 'æ„›', 'å¿ƒ', 'æº«', 'æš–', 'å…‰', 'æ˜', 
                    'å¥', 'åº·', 'å¹³', 'å®‰', 'å¹¸', 'ç¦', 'è‡ª', 'ç”±', 'æ­£', 'ç¾©',
                    'èª ', 'å¯¦', 'æ€', 'è€ƒ', 'ç†', 'è§£', 'è¨˜', 'æ†¶', 'å‰µ', 'é€ ',
                    'ç™¼', 'ç¾', 'æ¢', 'ç´¢', 'ç ”', 'ç©¶', 'è®€', 'æ›¸', 'å¯«', 'å­—'
                ];
                
                return fallbackChars[Math.floor(Math.random() * fallbackChars.length)];
            }

            // æ–°å¢ï¼šç²å–ä»¥æŒ‡å®šå­—ç¬¦é–‹é ­çš„è©èª
            getWordsByFirstChar(char) {
                return this.byFirstChar[char] || [];
            }

            // æ–°å¢ï¼šç²å–ä»¥æŒ‡å®šå­—ç¬¦çµå°¾çš„è©èª
            getWordsByLastChar(char) {
                return this.byLastChar[char] || [];
            }

            // æ–°å¢ï¼šæ™ºèƒ½é¸æ“‡é£Ÿç‰©å­—ç¬¦ï¼ˆå¢åŠ çµ„è©æˆåŠŸç‡ï¼‰
            getSmartFoodChar(dragonHead) {
                // å…ˆå˜—è©¦æ‰¾èƒ½çµ„è©çš„å­—ç¬¦
                const headChar = dragonHead.char;
                const wordsWithHead = this.getWordsByFirstChar(headChar);
                const wordsEndingWithHead = this.getWordsByLastChar(headChar);
                
                const candidateChars = new Set();
                
                // æ”¶é›†èƒ½èˆ‡é¾é ­çµ„è©çš„å­—ç¬¦
                wordsWithHead.forEach(word => {
                    if (word.length === 2) {
                        candidateChars.add(word[1]); // é¾é ­+æ–°å­—ç¬¦
                    }
                });
                
                wordsEndingWithHead.forEach(word => {
                    if (word.length === 2) {
                        candidateChars.add(word[0]); // æ–°å­—ç¬¦+é¾é ­
                    }
                });
                
                // å¦‚æœæ‰¾åˆ°å€™é¸å­—ç¬¦ï¼Œéš¨æ©Ÿé¸æ“‡ä¸€å€‹
                if (candidateChars.size > 0) {
                    const candidates = Array.from(candidateChars);
                    return candidates[Math.floor(Math.random() * candidates.length)];
                }
                
                // å¦å‰‡å›é€€åˆ°éš¨æ©Ÿå­—ç¬¦
                return this.getRandomChar();
            }
        }

        // è©é¾éŠæˆ²ä¸»é«”
        class WordDragonGame {
            constructor() {
                this.gameState = new GameState();
                this.wordDB = new WordDatabase();
                
                // éŠæˆ²åƒæ•¸
                this.boardWidth = 20;
                this.boardHeight = 15;
                this.cellSize = 30;
                this.gameSpeed = 250;
                
                // éŠæˆ²ç‹€æ…‹  
                this.dragon = [
                    { x: 5, y: 7, char: 'å­¸' },
                    { x: 4, y: 7, char: 'ç¿’' },
                    { x: 3, y: 7, char: 'çŸ¥' },
                    { x: 2, y: 7, char: 'è­˜' }
                ];
                this.direction = { x: 1, y: 0 };
                this.foods = []; // å¤šå€‹é£Ÿç‰©æ•¸çµ„
                this.gameLoop = null;
                
                this.bindEvents();
                this.initializeGameAsync(); // ç•°æ­¥åˆå§‹åŒ–
            }

            async initializeGameAsync() {
                // å…ˆåˆå§‹åŒ–è©åº«
                await this.wordDB.initialize();
                console.log('è©åº«åˆå§‹åŒ–å®Œæˆï¼Œè©èªæ•¸é‡:', this.wordDB.words.size);
                
                // ç„¶å¾Œåˆå§‹åŒ–éŠæˆ²
                this.initializeGame();
            }

            initializeGame() {
                this.setupBoard();
                this.generateFoods(); // åˆå§‹åŒ–æ™‚ç”Ÿæˆå¤šå€‹é£Ÿç‰©
                this.updateDragonDisplay();
                this.gameState.updateDisplay();
                this.render();
            }

            setupBoard() {
                const board = document.getElementById('game-board');
                // è¨ˆç®—å¯¦éš›éœ€è¦çš„å°ºå¯¸ï¼Œç¢ºä¿æ‰€æœ‰æ–¹å‘é‚Šè·ä¸€è‡´
                const margin = 8; // å¢åŠ é‚Šè·åˆ°8pxï¼Œç¢ºä¿ä¸Šä¸‹å·¦å³éƒ½æœ‰è¶³å¤ ç©ºé–“
                const actualWidth = (this.boardWidth * this.cellSize) + (margin * 2);
                const actualHeight = (this.boardHeight * this.cellSize) + (margin * 2);
                
                board.style.width = actualWidth + 'px';
                board.style.height = actualHeight + 'px';
                board.innerHTML = '';
                
                console.log(`éŠæˆ²æ¿è¨­ç½®: ${actualWidth}Ã—${actualHeight}, æ ¼å­: ${this.boardWidth}Ã—${this.boardHeight}, å–®å…ƒæ ¼: ${this.cellSize}px, é‚Šè·: ${margin}px`);
            }

            bindEvents() {
                // æ§åˆ¶æŒ‰éˆ•
                document.getElementById('start-btn').addEventListener('click', () => this.startGame());
                document.getElementById('pause-btn').addEventListener('click', () => this.pauseGame());
                document.getElementById('restart-btn').addEventListener('click', () => this.restartGame());
                
                // éµç›¤æ§åˆ¶
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // è§¸æ§æ§åˆ¶ï¼ˆç§»å‹•è¨­å‚™ï¼‰
                let touchStartX = 0;
                let touchStartY = 0;
                
                document.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                document.addEventListener('touchend', (e) => {
                    if (!this.gameState.isPlaying) return;
                    
                    const touchEndX = e.changedTouches[0].clientX;
                    const touchEndY = e.changedTouches[0].clientY;
                    
                    const deltaX = touchEndX - touchStartX;
                    const deltaY = touchEndY - touchStartY;
                    
                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        // æ°´å¹³æ»‘å‹•
                        if (deltaX > 30 && this.direction.x !== -1) {
                            this.direction = { x: 1, y: 0 };
                        } else if (deltaX < -30 && this.direction.x !== 1) {
                            this.direction = { x: -1, y: 0 };
                        }
                    } else {
                        // å‚ç›´æ»‘å‹•
                        if (deltaY > 30 && this.direction.y !== -1) {
                            this.direction = { x: 0, y: 1 };
                        } else if (deltaY < -30 && this.direction.y !== 1) {
                            this.direction = { x: 0, y: -1 };
                        }
                    }
                });
            }

            handleKeyPress(e) {
                if (!this.gameState.isPlaying) return;
                
                switch(e.key) {
                    case 'ArrowUp':
                        if (this.direction.y !== 1) this.direction = { x: 0, y: -1 };
                        break;
                    case 'ArrowDown':
                        if (this.direction.y !== -1) this.direction = { x: 0, y: 1 };
                        break;
                    case 'ArrowLeft':
                        if (this.direction.x !== 1) this.direction = { x: -1, y: 0 };
                        break;
                    case 'ArrowRight':
                        if (this.direction.x !== -1) this.direction = { x: 1, y: 0 };
                        break;
                    case ' ':
                        e.preventDefault();
                        this.pauseGame();
                        break;
                }
            }

            startGame() {
                if (this.gameState.isPlaying) return;
                
                this.gameState.isPlaying = true;
                this.gameState.isPaused = false;
                
                document.getElementById('start-btn').disabled = true;
                document.getElementById('pause-btn').disabled = false;
                
                this.gameLoop = setInterval(() => {
                    if (!this.gameState.isPaused) {
                        this.update();
                        this.render();
                    }
                }, this.gameSpeed);
            }

            pauseGame() {
                if (!this.gameState.isPlaying) return;
                
                this.gameState.isPaused = !this.gameState.isPaused;
                document.getElementById('pause-btn').textContent = this.gameState.isPaused ? 'ç¹¼çºŒ' : 'æš«åœ';
            }

            restartGame() {
                if (this.gameLoop) {
                    clearInterval(this.gameLoop);
                }
                
                this.gameState = new GameState();
                this.dragon = [
                    { x: 5, y: 7, char: 'å­¸' },
                    { x: 4, y: 7, char: 'ç¿’' },
                    { x: 3, y: 7, char: 'çŸ¥' },
                    { x: 2, y: 7, char: 'è­˜' }
                ];
                this.direction = { x: 1, y: 0 };
                this.generateFoods(); // é‡æ–°é–‹å§‹æ™‚ç”Ÿæˆå¤šå€‹é£Ÿç‰©
                
                document.getElementById('start-btn').disabled = false;
                document.getElementById('pause-btn').disabled = true;
                document.getElementById('pause-btn').textContent = 'æš«åœ';
                
                this.updateDragonDisplay();
                this.gameState.updateDisplay();
                this.render();
            }

            update() {
                // è¨ˆç®—é¾é ­æ–°ä½ç½®
                const head = this.dragon[0];
                const newX = head.x + this.direction.x;
                const newY = head.y + this.direction.y;
                
                // æª¢æŸ¥é‚Šç•Œç¢°æ’
                if (newX < 0 || newX >= this.boardWidth || 
                    newY < 0 || newY >= this.boardHeight) {
                    this.gameOver();
                    return;
                }
                
                // æª¢æŸ¥è‡ªèº«ç¢°æ’
                if (this.dragon.some(segment => segment.x === newX && segment.y === newY)) {
                    this.gameOver();
                    return;
                }
                
                // æª¢æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
                const eatenFood = this.foods.find(food => food.x === newX && food.y === newY);
                if (eatenFood) {
                    this.eatFood(eatenFood, { x: newX, y: newY });
                } else {
                    // æ­£å¸¸ç§»å‹•ï¼šä¿æŒé•·åº¦ä¸è®Šï¼Œæ¯å€‹éƒ¨åˆ†å‘å‰ç§»å‹•
                    console.log('æ­£å¸¸ç§»å‹•å‰é¾èº«:', this.dragon.map((s, i) => `${i}:${s.char}(${s.x},${s.y})`).join(' | '));
                    
                    // å¾é¾å°¾é–‹å§‹ï¼Œæ¯å€‹éƒ¨åˆ†ç§»å‹•åˆ°å‰ä¸€å€‹éƒ¨åˆ†çš„ä½ç½®
                    for (let i = this.dragon.length - 1; i > 0; i--) {
                        this.dragon[i].x = this.dragon[i - 1].x;
                        this.dragon[i].y = this.dragon[i - 1].y;
                        // å­—ç¬¦ä¿æŒä¸è®Šï¼šthis.dragon[i].char ä¸éœ€è¦ä¿®æ”¹
                    }
                    
                    // é¾é ­ç§»å‹•åˆ°æ–°ä½ç½®ï¼Œå­—ç¬¦ä¿æŒä¸è®Š
                    this.dragon[0].x = newX;
                    this.dragon[0].y = newY;
                    // this.dragon[0].char ä¿æŒä¸è®Š
                    
                    console.log('æ­£å¸¸ç§»å‹•å¾Œé¾èº«:', this.dragon.map((s, i) => `${i}:${s.char}(${s.x},${s.y})`).join(' | '));
                }
                
                // æ›´æ–°é¡¯ç¤º
                this.updateDragonDisplay();
            }

            eatFood(eatenFood, newHeadPosition) {
                const headChar = this.dragon[0].char;
                const foodChar = eatenFood.char;
                
                console.log(`åƒé£Ÿç‰©: é¾é ­å­—ç¬¦="${headChar}", é£Ÿç‰©å­—ç¬¦="${foodChar}"`);
                
                // æª¢æŸ¥é¾é ­å­—ç¬¦èˆ‡é£Ÿç‰©å­—ç¬¦æ˜¯å¦èƒ½çµ„è©
                const validWords = [];
                const word1 = headChar + foodChar;
                const word2 = foodChar + headChar;
                
                // ä½¿ç”¨æœ¬åœ°è©åº«æª¢æŸ¥è©èªï¼ˆç„¡å»¶é²ï¼‰
                const word1Result = this.wordDB.isValidWordSync(word1);
                const word2Result = this.wordDB.isValidWordSync(word2);
                
                if (word1Result.exists) {
                    validWords.push({
                        word: word1,
                        chars: [headChar, foodChar],
                        score: this.wordDB.calculateScore(word1),
                        definitions: word1Result.definitions || [],
                        pronunciation: word1Result.pronunciation || '',
                        source: word1Result.source || 'moedict'
                    });
                }
                if (word2Result.exists && word2 !== word1) {
                    validWords.push({
                        word: word2,
                        chars: [foodChar, headChar],
                        score: this.wordDB.calculateScore(word2),
                        definitions: word2Result.definitions || [],
                        pronunciation: word2Result.pronunciation || '',
                        source: word2Result.source || 'moedict'
                    });
                }
                
                if (validWords.length > 0) {
                    // æ‰¾åˆ°æœ€é«˜åˆ†çš„è©
                    const bestWord = validWords.reduce((best, current) => 
                        current.score > best.score ? current : best
                    );
                    
                    // çµ„è©æˆåŠŸ
                    this.gameState.addScore(bestWord.score, bestWord.word);
                    
                    // é¡¯ç¤ºæˆåŠŸä¿¡æ¯
                    let successMessage = `çµ„è©æˆåŠŸï¼š${bestWord.word} +${bestWord.score}åˆ†`;
                    this.gameState.showSuccessAnimation(successMessage);
                    
                    // ç§»é™¤çµ„è©çš„å­—ç¬¦ï¼Œé¾é ­è¢«æ¶ˆé™¤
                    this.removeUsedCharacters(bestWord.chars);
                    
                    // çµ„è©æˆåŠŸå¾Œé‡æ–°ç”Ÿæˆæ‰€æœ‰é£Ÿç‰©
                    this.generateFoods();
                } else {
                    // ç„¡æ³•çµ„è©ï¼Œé¾èº«è®Šé•·
                    console.log('ç„¡æ³•çµ„è©ï¼Œé¾èº«è®Šé•·');
                    console.log('åƒé£Ÿç‰©å‰é¾èº«:', this.dragon.map((s, i) => `${i}:${s.char}(${s.x},${s.y})`).join(' | '));
                    
                    // å…ˆä¿å­˜åŸé¾èº«æ•¸æ“šçš„æ·±æ‹·è²
                    const originalDragon = this.dragon.map(segment => ({
                        x: segment.x,
                        y: segment.y,
                        char: segment.char
                    }));
                    
                    // æ“´å±•é¾èº«æ•¸çµ„é•·åº¦
                    this.dragon = new Array(originalDragon.length + 1);
                    
                    // å‰µå»ºæ–°çš„é¾é ­ï¼ˆåƒåˆ°çš„é£Ÿç‰©å­—ç¬¦ï¼‰
                    this.dragon[0] = {
                        x: newHeadPosition.x,
                        y: newHeadPosition.y,
                        char: foodChar // æ–°åƒåˆ°çš„å­—ç¬¦æˆç‚ºé¾é ­
                    };
                    
                    // å°‡åŸé¾èº«æ•¸æ“šè¤‡è£½åˆ°æ–°ä½ç½®ï¼Œä¿æŒå­—ç¬¦ä¸è®Š
                    for (let i = 0; i < originalDragon.length; i++) {
                        this.dragon[i + 1] = {
                            x: originalDragon[i].x,
                            y: originalDragon[i].y,
                            char: originalDragon[i].char  // ä¿æŒåŸå­—ç¬¦ä¸è®Š
                        };
                    }
                    
                    console.log('æ’å…¥æ–°é¾é ­å¾Œ:', this.dragon.map((s, i) => `${i}:${s.char}(${s.x},${s.y})`).join(' | '));
                    
                    this.gameState.addScore(5); // åŸºç¤åˆ†æ•¸
                    
                    // é‡æ–°ç”Ÿæˆæ‰€æœ‰é£Ÿç‰©ï¼Œç¢ºä¿æœ‰å¯çµ„è©çš„å­—ç¬¦
                    this.generateFoods();
                }
            }

            removeUsedCharacters(usedChars) {
                // ç§»é™¤é¾é ­
                this.dragon.shift();
                
                // ç¢ºä¿é¾èº«å§‹çµ‚ä¿æŒè‡³å°‘3å€‹å­—ç¬¦
                while (this.dragon.length < 3) {
                    // åœ¨é¾å°¾æ·»åŠ æ–°çš„éš¨æ©Ÿå­—ç¬¦
                    const lastSegment = this.dragon[this.dragon.length - 1];
                    this.dragon.push({
                        x: lastSegment.x - 1, // ç°¡å–®çš„ä½ç½®å®‰æ’ï¼Œæœƒåœ¨ä¸‹æ¬¡ç§»å‹•æ™‚èª¿æ•´
                        y: lastSegment.y,
                        char: this.wordDB.getRandomChar()
                    });
                }
                
                // é¾é ­ä¸éœ€è¦æ›´æ–°å­—ç¬¦ï¼Œå› ç‚ºåŸæœ¬çš„ç¬¬äºŒå€‹å­—ç¬¦ç¾åœ¨æˆç‚ºé¾é ­
            }

            generateFoods() {
                this.foods = [];
                const numFoods = 6; // ç”Ÿæˆ6å€‹é£Ÿç‰©
                const headChar = this.dragon[0].char;
                
                // ä½¿ç”¨å„ªåŒ–çš„æ™ºèƒ½å­—ç¬¦é¸æ“‡
                const smartChars = this.getSmartComplementaryChars(headChar);
                
                // ç”Ÿæˆé£Ÿç‰©
                for (let i = 0; i < numFoods; i++) {
                    let newFood;
                    let attempts = 0;
                    do {
                        // å‰åŠæ•¸é£Ÿç‰©å„ªå…ˆä½¿ç”¨æ™ºèƒ½é¸æ“‡çš„å­—ç¬¦ï¼Œå¾ŒåŠæ•¸ä½¿ç”¨éš¨æ©Ÿå­—ç¬¦å¢åŠ æŒ‘æˆ°æ€§
                        const char = (i < Math.min(3, smartChars.length)) ? 
                            smartChars[i] : this.wordDB.getRandomChar();
                        
                        newFood = {
                            x: Math.floor(Math.random() * this.boardWidth),
                            y: Math.floor(Math.random() * this.boardHeight),
                            char: char
                        };
                        attempts++;
                        
                        // é˜²æ­¢ç„¡é™å¾ªç’°
                        if (attempts > 50) {
                            console.log('ç”Ÿæˆé£Ÿç‰©ä½ç½®å˜—è©¦æ¬¡æ•¸éå¤šï¼Œå¼·åˆ¶æ”¾ç½®');
                            break;
                        }
                    } while (this.isPositionOccupied(newFood.x, newFood.y));
                    
                    this.foods.push(newFood);
                }
            }

            // æ–°çš„æ™ºèƒ½äº’è£œå­—ç¬¦é¸æ“‡æ–¹æ³• - ä½¿ç”¨å„ªåŒ–çš„å­—å…¸æ•¸æ“š
            getSmartComplementaryChars(headChar) {
                const complementaryChars = new Set();
                
                // ä½¿ç”¨å„ªåŒ–çš„å­—å…¸æ•¸æ“šå¿«é€ŸæŸ¥æ‰¾
                const wordsWithHead = this.wordDB.getWordsByFirstChar(headChar);
                const wordsEndingWithHead = this.wordDB.getWordsByLastChar(headChar);
                
                // å¾ä»¥é¾é ­é–‹å§‹çš„è©èªä¸­æå–ç¬¬äºŒå€‹å­—ç¬¦
                wordsWithHead.forEach(word => {
                    if (word.length === 2 && word[1] !== headChar) {
                        complementaryChars.add(word[1]);
                    }
                });
                
                // å¾ä»¥é¾é ­çµå°¾çš„è©èªä¸­æå–ç¬¬ä¸€å€‹å­—ç¬¦
                wordsEndingWithHead.forEach(word => {
                    if (word.length === 2 && word[0] !== headChar) {
                        complementaryChars.add(word[0]);
                    }
                });
                
                // è½‰æ›ç‚ºæ•¸çµ„ä¸¦æ‰“äº‚é †åº
                const result = Array.from(complementaryChars).sort(() => Math.random() - 0.5);
                
                // å¦‚æœæ‰¾åˆ°çš„å­—ç¬¦è¼ƒå°‘ï¼Œè£œå……ä¸€äº›å¸¸ç”¨å­—ç¬¦
                if (result.length < 3) {
                    const fallbackChars = ['ç¿’', 'ç”Ÿ', 'å•', 'å®¶', 'äºº', 'å¿ƒ', 'æ„›', 'å¥½', 'ç¾', 'å¤§'];
                    for (let char of fallbackChars) {
                        if (!complementaryChars.has(char) && char !== headChar) {
                            result.push(char);
                            if (result.length >= 5) break;
                        }
                    }
                }
                
                return result.slice(0, 5); // æœ€å¤šè¿”å›5å€‹æ™ºèƒ½é¸æ“‡çš„å­—ç¬¦
            }

            generateSingleFood() {
                let newFood;
                do {
                    // ä½¿ç”¨æ™ºèƒ½å­—ç¬¦é¸æ“‡ï¼Œæé«˜çµ„è©æˆåŠŸç‡
                    const headChar = this.dragon[0].char;
                    const smartChar = this.wordDB.getSmartFoodChar(this.dragon[0]);
                    
                    newFood = {
                        x: Math.floor(Math.random() * this.boardWidth),
                        y: Math.floor(Math.random() * this.boardHeight),
                        char: smartChar
                    };
                } while (this.isPositionOccupied(newFood.x, newFood.y));
                
                this.foods.push(newFood);
            }

            isPositionOccupied(x, y) {
                // æª¢æŸ¥æ˜¯å¦èˆ‡é¾èº«ç¢°æ’
                if (this.dragon.some(segment => segment.x === x && segment.y === y)) {
                    return true;
                }
                // æª¢æŸ¥æ˜¯å¦èˆ‡å…¶ä»–é£Ÿç‰©ç¢°æ’
                if (this.foods.some(food => food.x === x && food.y === y)) {
                    return true;
                }
                return false;
            }

            updateDragonDisplay() {
                if (this.dragon.length > 0) {
                    document.getElementById('dragon-head').textContent = this.dragon[0].char;
                    
                    const bodyElement = document.getElementById('dragon-body');
                    bodyElement.innerHTML = this.dragon.slice(1).map(segment => 
                        `<div class="dragon-char">${segment.char}</div>`
                    ).join('');
                }
            }

            render() {
                const board = document.getElementById('game-board');
                board.innerHTML = '';
                
                const offset = 8; // èˆ‡setupBoardçš„marginä¿æŒä¸€è‡´ï¼Œç¢ºä¿æ‰€æœ‰æ–¹å‘é‚Šè·ç›¸åŒ
                
                // æ¸²æŸ“é¾èº«
                this.dragon.forEach((segment, index) => {
                    const element = document.createElement('div');
                    element.className = 'game-cell ' + (index === 0 ? 'snake-head' : 'snake-body');
                    element.style.left = (segment.x * this.cellSize + offset) + 'px';
                    element.style.top = (segment.y * this.cellSize + offset) + 'px';
                    element.textContent = segment.char;
                    board.appendChild(element);
                });
                
                // æ¸²æŸ“æ‰€æœ‰é£Ÿç‰©
                this.foods.forEach(food => {
                    const foodElement = document.createElement('div');
                    foodElement.className = 'game-cell food';
                    foodElement.style.left = (food.x * this.cellSize + offset) + 'px';
                    foodElement.style.top = (food.y * this.cellSize + offset) + 'px';
                    foodElement.textContent = food.char;
                    board.appendChild(foodElement);
                });
            }

            gameOver() {
                this.gameState.isPlaying = false;
                if (this.gameLoop) {
                    clearInterval(this.gameLoop);
                }
                
                // é¡¯ç¤ºéŠæˆ²çµæŸç•«é¢
                const gameOverDiv = document.createElement('div');
                gameOverDiv.className = 'game-over';
                gameOverDiv.innerHTML = `
                    <div class="game-over-content">
                        <h2>éŠæˆ²çµæŸ</h2>
                        <div class="final-stats">
                            <div>æœ€çµ‚åˆ†æ•¸: ${this.gameState.score}</div>
                            <div>çµ„è©æˆåŠŸ: ${this.gameState.wordsFormed}</div>
                            <div>é”åˆ°ç­‰ç´š: ${this.gameState.level}</div>
                            <div>é¾èº«é•·åº¦: ${this.dragon.length}</div>
                        </div>
                        <button class="control-btn" onclick="game.closeGameOver(); game.restartGame();">å†ç©ä¸€æ¬¡</button>
                    </div>
                `;
                
                document.querySelector('.game-container').appendChild(gameOverDiv);
            }

            closeGameOver() {
                const gameOverDiv = document.querySelector('.game-over');
                if (gameOverDiv) {
                    gameOverDiv.remove();
                }
            }
        }

        // åˆå§‹åŒ–éŠæˆ²
        let game;
        document.addEventListener('DOMContentLoaded', () => {
            game = new WordDragonGame();
        });
    </script>
</body>
</html>
