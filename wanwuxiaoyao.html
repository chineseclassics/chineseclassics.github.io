<!DOCTYPE html><html lang="zh-TW"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com https://chineseclassics.github.io https://*.github.io https://*.githubusercontent.com https://api.deepseek.com; connect-src 'self' https://api.deepseek.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>萬物逍遙</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700;900&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            'lxgw': ['"LXGW WenKai"', 'serif'],
            'noto-serif': ['"Noto Serif SC"', 'serif'],
          },
        },
      },
    }
  </script>
  <style>
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    @keyframes wave {
      0% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-5px) rotate(2deg); }
      50% { transform: translateY(0) rotate(0deg); }
      75% { transform: translateY(5px) rotate(-2deg); }
      100% { transform: translateY(0) rotate(0deg); }
    }
    
    @keyframes cloud-drift {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(20px); }
    }
    
    /* Form indicator icon animations */
    @keyframes flutter-icon-left {
      0%, 100% { transform: translate(0, -50%) rotate(-10deg); }
      50% { transform: translate(0, -50%) rotate(-20deg); }
    }
    
    @keyframes flutter-icon-right {
      0%, 100% { transform: translate(0, -50%) rotate(10deg); }
      50% { transform: translate(0, -50%) rotate(20deg); }
    }
    
    @keyframes fish-icon-swim {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(3px); }
    }
    
    @keyframes fish-icon-tail {
      0%, 100% { transform: translateY(-50%) rotate(0deg); }
      50% { transform: translateY(-50%) rotate(15deg); }
    }
    

    
    @keyframes butterfly {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }
    
    @keyframes fishSwim {
      0% { transform: translateX(0) translateY(0) rotate(0deg); }
      25% { transform: translateX(10px) translateY(-5px) rotate(2deg); }
      50% { transform: translateX(20px) translateY(0) rotate(0deg); }
      75% { transform: translateX(10px) translateY(5px) rotate(-2deg); }
      100% { transform: translateX(0) translateY(0) rotate(0deg); }
    }
    
    .text-char {
      display: inline-block;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .text-char:hover {
      transform: scale(1.2);
    }
    
    .butterfly-form {
      animation: butterfly 2s infinite ease-in-out;
      transition: all 0.5s ease;
    }
    
    .fish-form {
      animation: fishSwim 4s infinite ease-in-out;
      transition: all 0.5s ease;
    }
    

    
    .dream-text {
      animation: pulse 3s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    .water-text {
      animation: wave 4s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    .cloud-text {
      animation: cloud-drift 6s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    .leaf-text {
      animation: leaf-sway 4s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    @keyframes leaf-sway {
      0% { transform: rotate(0deg) translateY(0); }
      25% { transform: rotate(1deg) translateY(-2px); }
      50% { transform: rotate(0deg) translateY(0); }
      75% { transform: rotate(-1deg) translateY(2px); }
      100% { transform: rotate(0deg) translateY(0); }
    }
    
    .heaven-earth-text {
      /* 整體發光和呼吸效果 - 極其緩慢柔和 */
      color: #FFD700;
      animation: text-glow-breathe 20s infinite ease-in-out;
    }
    
    @keyframes text-glow-breathe {
      0%, 100% { 
        text-shadow: 0 0 6px rgba(255, 215, 0, 0.3), 0 0 12px rgba(255, 215, 0, 0.2);
        color: #FFD700;
        transform: scale(1);
      }
      50% { 
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.4), 0 0 16px rgba(255, 215, 0, 0.3), 0 0 24px rgba(255, 215, 0, 0.2);
        color: #FFED4E;
        transform: scale(1.01);
      }
    }

    /* 章節過渡動畫效果 */
    @keyframes chapter-transition-fade {
      0% { opacity: 0; backdrop-filter: blur(0px); }
      100% { opacity: 1; backdrop-filter: blur(10px); }
    }

    @keyframes chapter-title-emerge {
      0% { 
        opacity: 0; 
        transform: translateY(30px) scale(0.9);
        text-shadow: 0 0 0px rgba(255, 255, 255, 0);
      }
      100% { 
        opacity: 1; 
        transform: translateY(0) scale(1);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      }
    }

    @keyframes typewriter-cursor {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* 第七章到尾聲章節的白色過渡動畫 */
    @keyframes white-transition-fade {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    @keyframes epilogue-title-emerge {
      0% { 
        opacity: 0; 
        transform: translateY(20px) scale(0.95);
        text-shadow: 0 0 0px rgba(0, 0, 0, 0);
      }
      100% { 
        opacity: 1; 
        transform: translateY(0) scale(1);
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
    }
    
    @keyframes gentle-breathing {
      0%, 100% { 
        opacity: 1;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      50% { 
        opacity: 0.85;
        text-shadow: 0 1px 8px rgba(0, 0, 0, 0.15);
      }
    }
    
    /* Hunlun (Chaos) design and seven apertures */
    .aperture-container {
      position: relative;
      width: 150px;
      height: 150px;
      background: radial-gradient(circle, rgba(80, 80, 120, 0.6) 0%, rgba(50, 50, 80, 0.4) 70%);
      border-radius: 50%;
      padding: 10px;
      box-shadow: 
        0 0 15px rgba(93, 92, 222, 0.4),
        0 0 25px rgba(0, 0, 0, 0.3) inset;
      backdrop-filter: blur(2px);
      overflow: hidden;
    }
    
    .dark .aperture-container {
      background: radial-gradient(circle, rgba(90, 90, 130, 0.5) 0%, rgba(60, 60, 100, 0.4) 70%);
    }
    
    /* Chaos energy field */
    .aperture-container::before {
      content: '';
      position: absolute;
      top: -10%;
      left: -10%;
      right: -10%;
      bottom: -10%;
      border-radius: 50%;
      background: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0'/%3E%3C/filter%3E%3Crect width='100' height='100' fill='%235D5CDE' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E");
      opacity: 0.5;
      mix-blend-mode: overlay;
      animation: chaos-noise 8s linear infinite;
      z-index: 0;
    }
    
    @keyframes chaos-noise {
      0% { transform: rotate(0deg) scale(1); }
      33% { transform: rotate(120deg) scale(1.05); }
      66% { transform: rotate(240deg) scale(0.95); }
      100% { transform: rotate(360deg) scale(1); }
    }
    
    /* Face pattern - subtle face outline */
    .face-pattern {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 3s ease-in-out;
      z-index: 0;
    }
    
    .face-pattern.visible {
      opacity: 0.2;
    }
    
    /* Individual aperture */
    .aperture {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 
        0 0 4px rgba(0, 0, 0, 0.7) inset,
        0 0 3px rgba(93, 92, 222, 0.2);
      transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 18px; /* Size for emojis */
      overflow: hidden;
      z-index: 2;
    }
    
    /* Aperture filled state - what happens when collected */
    .aperture.active {
      animation: none !important; /* 停止流動動畫 */
      transform: scale(0.1);
      opacity: 0;
      transition: all 0.7s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    /* Aperture filled state */
    .aperture.filled {
      background: linear-gradient(135deg, rgba(93, 92, 222, 0.8), rgba(147, 146, 255, 0.6));
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 
        0 0 10px rgba(93, 92, 222, 0.4),
        0 0 5px rgba(255, 255, 255, 0.2) inset;
    }
    
    /* Aperture random positions - each aperture moves independently */
    
    /* AI回應界面樣式 */
    .ai-response-container {
      backdrop-filter: blur(10px);
      animation: aiResponseGlow 2s ease-in-out infinite alternate;
    }
    
    @keyframes aiResponseGlow {
      0% { box-shadow: 0 4px 20px rgba(147, 51, 234, 0.3); }
      100% { box-shadow: 0 8px 30px rgba(147, 51, 234, 0.5); }
    }
    
    .ai-response-container .border-l-3 {
      border-left-width: 3px;
    }
    
    /* AI控制面板樣式 */
    .ai-control-panel {
      backdrop-filter: blur(5px);
      font-family: 'Courier New', monospace;
    }
    
    .ai-control-panel button {
      transition: all 0.2s ease;
      font-size: 11px;
    }
    
    .ai-control-panel button:hover {
      transform: translateY(-1px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.3);
    }
    .aperture-random {
      transition: all 3s cubic-bezier(0.34, 0.56, 0.64, 1);
    }
    
    /* 七竅流動動畫系統 - 模擬在混沌形體上的能量流動 */
    .aperture-left-eye {
      animation: aperture-flow-1 8s infinite ease-in-out;
    }
    
    .aperture-right-eye {
      animation: aperture-flow-2 9s infinite ease-in-out 1s;
    }
    
    .aperture-left-ear {
      animation: aperture-flow-3 10s infinite ease-in-out 2s;
    }
    
    .aperture-right-ear {
      animation: aperture-flow-4 11s infinite ease-in-out 3s;
    }
    
    .aperture-left-nose {
      animation: aperture-flow-5 12s infinite ease-in-out 4s;
    }
    
    .aperture-right-nose {
      animation: aperture-flow-6 13s infinite ease-in-out 5s;
    }
    
    .aperture-mouth {
      animation: aperture-flow-7 14s infinite ease-in-out 6s;
    }
    
    /* 七竅流動動畫 - 在150px容器內自由流動 */
    @keyframes aperture-flow-1 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(-5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      25% { 
        transform: translate(60px, 20px) scale(1.05) rotate(-3deg); /* 向右移動 */
        opacity: 1; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 12px rgba(93, 92, 222, 0.5);
      }
      50% { 
        transform: translate(30px, 70px) scale(0.95) rotate(-7deg); /* 向下移動 */
        opacity: 0.9; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 10px rgba(93, 92, 222, 0.4);
      }
      75% { 
        transform: translate(-15px, 35px) scale(1.02) rotate(-2deg); /* 向左移動 */
        opacity: 1; 
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.7) inset, 0 0 14px rgba(93, 92, 222, 0.6);
      }
    }
    
    @keyframes aperture-flow-2 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      30% { 
        transform: translate(-75px, 15px) scale(1.03) rotate(8deg); /* 向左移動 */
        opacity: 1; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 12px rgba(93, 92, 222, 0.5);
      }
      60% { 
        transform: translate(-25px, 60px) scale(0.97) rotate(2deg); /* 向左下移動 */
        opacity: 0.9; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 10px rgba(93, 92, 222, 0.4);
      }
    }
    
        @keyframes aperture-flow-3 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(-15deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      40% { 
        transform: translate(85px, 35px) scale(1.04) rotate(-12deg); /* 向右下移動 */
        opacity: 1; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 15px rgba(93, 92, 222, 0.6);
      }
      80% { 
        transform: translate(45px, -35px) scale(0.96) rotate(-18deg); /* 向右上移動 */
        opacity: 0.85; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 9px rgba(93, 92, 222, 0.4);
      }
    }

    @keyframes aperture-flow-4 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(15deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      35% { 
        transform: translate(-95px, -10px) scale(1.06) rotate(12deg); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 7px rgba(0, 0, 0, 0.7) inset, 0 0 16px rgba(93, 92, 222, 0.7);
      }
      70% { 
        transform: translate(-40px, 25px) scale(0.94) rotate(18deg); /* 向左下移動 */
        opacity: 0.9; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 11px rgba(93, 92, 222, 0.45);
      }
    }
    
        @keyframes aperture-flow-5 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(-5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      20% { 
        transform: translate(50px, -60px) scale(1.02) rotate(-3deg); /* 向右上移動 */
        opacity: 0.95; 
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.7) inset, 0 0 10px rgba(93, 92, 222, 0.4);
      }
      45% { 
        transform: translate(-20px, -45px) scale(1.07) rotate(-8deg); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.7) inset, 0 0 18px rgba(93, 92, 222, 0.8);
      }
      85% { 
        transform: translate(55px, 15px) scale(0.93) rotate(-2deg); /* 向右中移動 */
        opacity: 0.85; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 9px rgba(93, 92, 222, 0.35);
      }
    }

    @keyframes aperture-flow-6 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      50% { 
        transform: translate(-70px, -55px) scale(1.08) rotate(8deg); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 9px rgba(0, 0, 0, 0.7) inset, 0 0 20px rgba(93, 92, 222, 0.9);
      }
    }

    @keyframes aperture-flow-7 {
      0%, 100% { 
        transform: translate(0, 0) scale(1); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      33% { 
        transform: translate(25px, -80px) scale(1.03); /* 向上移動 */
        opacity: 0.95; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 13px rgba(93, 92, 222, 0.55);
      }
      66% { 
        transform: translate(-45px, -65px) scale(1.09); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.7) inset, 0 0 22px rgba(93, 92, 222, 1);
      }
    }
    
    /* 七竅在150px容器內的初始位置 - 使用絕對定位相對於aperture-container */
    .aperture-left-eye { top: 20px; left: 20px; }  /* 左上象限 */
    .aperture-right-eye { top: 20px; left: 100px; }  /* 右上象限 */
    .aperture-left-ear { top: 60px; left: 5px; }   /* 左邊緣 */
    .aperture-right-ear { top: 60px; left: 115px; } /* 右邊緣 */
    .aperture-left-nose { top: 100px; left: 25px; } /* 左下象限 */
    .aperture-right-nose { top: 100px; left: 95px; } /* 右下象限 */
    .aperture-mouth { top: 115px; left: 60px; } /* 底部中央 */
    
    /* Left-right distinction for paired apertures */
    .aperture-left-eye::after, 
    .aperture-left-ear::after,
    .aperture-left-nose::after {
      content: '';
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(255, 100, 100, 0.5);
    }
    
    .aperture-right-eye::after,
    .aperture-right-ear::after,
    .aperture-right-nose::after {
      content: '';
      position: absolute;
      bottom: 2px;
      left: 2px;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(100, 100, 255, 0.5);
    }
    
    /* Seal collection animation */
    @keyframes seal-collection {
      0% { transform: scale(0.3) rotate(0deg); opacity: 0; }
      20% { transform: scale(1.5) rotate(180deg); opacity: 1; }
      40% { transform: scale(1.2) rotate(360deg); opacity: 1; }
      70% { transform: scale(1) rotate(720deg); opacity: 1; }
      80% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    @keyframes seal-glow-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(93, 92, 222, 0.6), 0 0 20px rgba(93, 92, 222, 0.3); }
      50% { box-shadow: 0 0 20px rgba(93, 92, 222, 0.8), 0 0 30px rgba(93, 92, 222, 0.5); }
    }
    
    .aperture.collecting {
      animation: 
        seal-collection 1.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
        seal-glow-pulse 2s ease-in-out infinite 1.5s !important; /* 覆蓋流動動畫 */
      z-index: 10;
    }
    
    /* Floating seal in scene */
    .scene-seal {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(147, 146, 255, 0.8), rgba(93, 92, 222, 0.8));
      box-shadow: 
        0 0 10px rgba(93, 92, 222, 0.6),
        0 0 20px rgba(93, 92, 222, 0.3);
      animation: seal-float 3s ease-in-out infinite;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    .scene-seal::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-size: 150% 150%;
      background-position: center;
      opacity: 0.8;
    }
    
    /* 神秘封印符號設計 - 左目之竅：洞察之眼 */
    .scene-seal.left-eye::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Ccircle cx='12' cy='12' r='6'/%3E%3Ccircle cx='12' cy='12' r='3'/%3E%3Ccircle cx='12' cy='12' r='1' fill='white'/%3E%3Cpath d='M6 12 L2 8 M18 12 L22 8 M12 6 L12 2' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 右目之竅：真察之眼 */
    .scene-seal.right-eye::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Ccircle cx='12' cy='12' r='6'/%3E%3Ccircle cx='12' cy='12' r='3'/%3E%3Ccircle cx='12' cy='12' r='1' fill='white'/%3E%3Cpath d='M6 12 L2 16 M18 12 L22 16 M12 18 L12 22' stroke-width='1'/%3E%3Cpolygon points='12,9 10.5,10.5 13.5,10.5' fill='white'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 左耳之竅：聆聽螺紋 */
    .scene-seal.left-ear::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpath d='M12 4 Q16 8 12 12 Q8 16 12 20' fill='none'/%3E%3Cpath d='M8 6 Q12 9 8 12 Q4 15 8 18' fill='none'/%3E%3Cpath d='M16 6 Q20 9 16 12 Q12 15 16 18' fill='none'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3Cpath d='M2 12 L6 8 M2 12 L6 16' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 右耳之竅：辨析波紋 */
    .scene-seal.right-ear::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpath d='M12 4 Q8 8 12 12 Q16 16 12 20' fill='none'/%3E%3Cpath d='M16 6 Q12 9 16 12 Q20 15 16 18' fill='none'/%3E%3Cpath d='M8 6 Q4 9 8 12 Q12 15 8 18' fill='none'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3Cpath d='M22 12 L18 8 M22 12 L18 16' stroke-width='1'/%3E%3Cpath d='M12 8 L14 10 M12 16 L14 14' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 左鼻之竅：感知三角 */
    .scene-seal.left-nose::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpolygon points='12,4 6,16 18,16' fill='none'/%3E%3Cpolygon points='12,8 9,14 15,14' fill='none'/%3E%3Ccircle cx='12' cy='12' r='1.5' fill='white'/%3E%3Cpath d='M12 20 L8 22 M12 20 L16 22' stroke-width='1'/%3E%3Cpath d='M6 10 L3 7 M18 10 L21 7' stroke-width='1'/%3E%3Cpath d='M10 6 L8 3 M14 6 L16 3' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 右鼻之竅：辨氣菱形 */
    .scene-seal.right-nose::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpolygon points='12,2 20,12 12,22 4,12' fill='none'/%3E%3Cpolygon points='12,6 16,12 12,18 8,12' fill='none'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3Cpath d='M12 22 L8 20 M12 22 L16 20' stroke-width='1'/%3E%3Cpath d='M4 8 L1 5 M20 8 L23 5' stroke-width='1'/%3E%3Cpath d='M4 16 L1 19 M20 16 L23 19' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 口之竅：表達符文 */
    .scene-seal.mouth::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpath d='M4 12 Q12 6 20 12 Q12 18 4 12' fill='none'/%3E%3Cpath d='M6 12 Q12 9 18 12 Q12 15 6 12' fill='none'/%3E%3Ccircle cx='8' cy='12' r='1' fill='white'/%3E%3Ccircle cx='16' cy='12' r='1' fill='white'/%3E%3Cpath d='M12 4 L10 2 M12 4 L14 2' stroke-width='1'/%3E%3Cpath d='M12 20 L10 22 M12 20 L14 22' stroke-width='1'/%3E%3Cpath d='M2 8 L4 6 M22 8 L20 6 M2 16 L4 18 M22 16 L20 18' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    @keyframes seal-float {
      0%, 100% { transform: translateY(0) rotate(0deg); box-shadow: 0 0 10px rgba(93, 92, 222, 0.6), 0 0 20px rgba(93, 92, 222, 0.3); }
      50% { transform: translateY(-10px) rotate(5deg); box-shadow: 0 0 15px rgba(93, 92, 222, 0.7), 0 0 30px rgba(93, 92, 222, 0.4); }
    }
    
    /* Collection path animation */
    @keyframes seal-path {
      0% { transform: translate(0, 0) scale(1); }
      70% { transform: translate(var(--end-x), var(--end-y)) scale(0.5); opacity: 1; }
      90%, 100% { transform: translate(var(--end-x), var(--end-y)) scale(0); opacity: 0; }
    }
    
    /* ===== 统一Emoji物化角色系统 ===== */
    
    /* 基础emoji容器样式 */
    .emoji-form-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      position: relative;
      font-size: 72px;
      line-height: 1;
      user-select: none;
    }
    
    /* 统一的emoji视觉效果 */
    .emoji-unified {
      position: relative;
      z-index: 2;
      filter: sepia(0.15) saturate(1.2) contrast(1.1) brightness(0.98);
      text-shadow: 0 2px 4px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
      transform-origin: center;
    }
    
    .emoji-unified:hover {
      filter: sepia(0.1) saturate(1.4) contrast(1.2) brightness(1.05);
      transform: scale(1.05);
      text-shadow: 0 3px 6px rgba(0,0,0,0.2);
    }
    
    /* 状态指示器中的emoji特效 */
    .form-icon-container .emoji-unified {
      font-size: 64px;
      animation: emoji-breathe 4s infinite ease-in-out;
    }
    
    @keyframes emoji-breathe {
      0%, 100% { 
        transform: scale(1) rotate(0deg);
        filter: sepia(0.15) saturate(1.2) contrast(1.1) brightness(0.98);
      }
      50% { 
        transform: scale(1.02) rotate(1deg);
        filter: sepia(0.1) saturate(1.3) contrast(1.15) brightness(1.02);
      }
    }
    
    /* 变身动画中的emoji特效 - 优化性能版本 */
    .transformation-emoji {
      font-size: 120px;
      animation: transformation-spin 2s ease-in-out;
      will-change: transform, opacity;
      backface-visibility: hidden;
    }
    
    @keyframes transformation-spin {
      0% { transform: scale(0.3) rotate(0deg); opacity: 0; filter: drop-shadow(0 0 25px rgba(255,255,255,0.9)); }
      2.5% { transform: scale(0.35) rotate(9deg); opacity: 0.08; filter: drop-shadow(0 0 24px rgba(255,255,255,0.85)); }
      5% { transform: scale(0.4) rotate(18deg); opacity: 0.15; filter: drop-shadow(0 0 23px rgba(255,255,255,0.8)); }
      7.5% { transform: scale(0.45) rotate(27deg); opacity: 0.23; filter: drop-shadow(0 0 22px rgba(255,255,255,0.75)); }
      10% { transform: scale(0.5) rotate(36deg); opacity: 0.3; filter: drop-shadow(0 0 21px rgba(255,255,255,0.7)); }
      12.5% { transform: scale(0.55) rotate(45deg); opacity: 0.35; filter: drop-shadow(0 0 20px rgba(255,255,255,0.7)); }
      15% { transform: scale(0.6) rotate(54deg); opacity: 0.4; filter: drop-shadow(0 0 19px rgba(255,255,255,0.7)); }
      17.5% { transform: scale(0.65) rotate(63deg); opacity: 0.45; filter: drop-shadow(0 0 18px rgba(255,255,255,0.7)); }
      20% { transform: scale(0.7) rotate(72deg); opacity: 0.5; filter: drop-shadow(0 0 17px rgba(255,255,255,0.7)); }
      22.5% { transform: scale(0.75) rotate(81deg); opacity: 0.55; filter: drop-shadow(0 0 16px rgba(255,255,255,0.7)); }
      25% { transform: scale(0.8) rotate(90deg); opacity: 0.6; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      27.5% { transform: scale(0.85) rotate(99deg); opacity: 0.65; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      30% { transform: scale(0.9) rotate(108deg); opacity: 0.7; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      32.5% { transform: scale(0.95) rotate(117deg); opacity: 0.75; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      35% { transform: scale(1.0) rotate(126deg); opacity: 0.8; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      37.5% { transform: scale(1.05) rotate(135deg); opacity: 0.83; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      40% { transform: scale(1.1) rotate(144deg); opacity: 0.85; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      42.5% { transform: scale(1.13) rotate(153deg); opacity: 0.88; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      45% { transform: scale(1.15) rotate(162deg); opacity: 0.9; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      47.5% { transform: scale(1.18) rotate(171deg); opacity: 0.95; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      50% { transform: scale(1.2) rotate(180deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      52.5% { transform: scale(1.19) rotate(189deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      55% { transform: scale(1.18) rotate(198deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      57.5% { transform: scale(1.17) rotate(207deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      60% { transform: scale(1.15) rotate(216deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      62.5% { transform: scale(1.14) rotate(225deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      65% { transform: scale(1.13) rotate(234deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      67.5% { transform: scale(1.12) rotate(243deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      70% { transform: scale(1.1) rotate(252deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      72.5% { transform: scale(1.09) rotate(261deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      75% { transform: scale(1.08) rotate(270deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      77.5% { transform: scale(1.07) rotate(279deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      80% { transform: scale(1.05) rotate(288deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      82.5% { transform: scale(1.04) rotate(297deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      85% { transform: scale(1.03) rotate(306deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      87.5% { transform: scale(1.025) rotate(315deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      90% { transform: scale(1.02) rotate(324deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      92.5% { transform: scale(1.015) rotate(333deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      95% { transform: scale(1.01) rotate(342deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      97.5% { transform: scale(1.005) rotate(351deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      100% { transform: scale(1) rotate(360deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
    }
    
    /* 背景光效 */
    .emoji-glow-bg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      border-radius: 50%;
      opacity: 0.6;
      z-index: 1;
      animation: glow-pulse 3s infinite ease-in-out;
    }
    
    @keyframes glow-pulse {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.4;
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 0.7;
      }
    }
    
    /* 特定物化形态的背景色彩 */
    .emoji-glow-human { background: radial-gradient(circle, rgba(147, 146, 255, 0.3), transparent 70%); }
    .emoji-glow-butterfly { background: radial-gradient(circle, rgba(147, 51, 234, 0.3), transparent 70%); }
    .emoji-glow-fish { background: radial-gradient(circle, rgba(59, 130, 246, 0.3), transparent 70%); }
    .emoji-glow-kun { background: radial-gradient(circle, rgba(6, 182, 212, 0.3), transparent 70%); }
    .emoji-glow-peng { background: radial-gradient(circle, rgba(14, 165, 233, 0.3), transparent 70%); }
    .emoji-glow-yuanchu { background: radial-gradient(circle, rgba(255, 215, 0, 0.3), transparent 70%); }
    .emoji-glow-chixiao { background: radial-gradient(circle, rgba(139, 69, 19, 0.3), transparent 70%); }
    .emoji-glow-snail { background: radial-gradient(circle, rgba(147, 50, 158, 0.3), transparent 70%); }
    .emoji-glow-fungus { background: radial-gradient(circle, rgba(245, 158, 11, 0.3), transparent 70%); }
    .emoji-glow-cicada { background: radial-gradient(circle, rgba(34, 197, 94, 0.3), transparent 70%); }
    .emoji-glow-tree { background: radial-gradient(circle, rgba(22, 163, 74, 0.3), transparent 70%); }
    .emoji-glow-ant { background: radial-gradient(circle, rgba(120, 53, 15, 0.3), transparent 70%); }
    .emoji-glow-star { background: radial-gradient(circle, rgba(255, 215, 0, 0.4), transparent 70%); }
    
    /* Leaf effects for forest scene */
    .leaf {
      position: absolute;
      background-color: rgba(44, 119, 68, 0.7);
      border-radius: 50% 5% 50% 5%;
      filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.2));
      z-index: 1;
      transition: all 0.3s ease;
      transform-origin: center bottom;
    }
    
    @keyframes leaf-falling {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0.7; }
    }
    
    @keyframes leaf-sway-animation {
      0%, 100% { transform: rotate(-5deg) translateX(0); }
      50% { transform: rotate(5deg) translateX(10px); }
    }
    
    /* Character transformation effects */
    .transformation-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    .transformation-circle {
      position: absolute;
      width: 300px;
      height: 300px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(93, 92, 222, 0.2) 0%, rgba(93, 92, 222, 0.8) 70%, rgba(93, 92, 222, 0.2) 100%);
      box-shadow: 0 0 80px rgba(93, 92, 222, 0.6);
      opacity: 0;
      transform: scale(0.2);
      transition: all 0.5s ease-in-out;
    }
    
    .transform-active .transformation-circle {
      opacity: 0.8;
      transform: scale(1);
    }
    
    .particle-container {
      position: absolute;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
    }
    
    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
    }
    
    /* Human transformation */
    .human-symbol {
      position: absolute;
      width: 120px;
      height: 120px;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.5s ease-in-out 0.2s;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
    }
    
    .human-symbol svg {
      width: 100%;
      height: 100%;
    }
    
    .transform-active .human-symbol {
      opacity: 1;
      transform: scale(1);
    }
    
    /* Butterfly transformation */
    .butterfly-wings {
      position: absolute;
      width: 0;
      height: 0;
    }
    
    .butterfly-wing {
      position: absolute;
      width: 60px;
      height: 80px;
      background: linear-gradient(135deg, rgba(93, 92, 222, 0.9), rgba(147, 146, 255, 0.6));
      border-radius: 50% 50% 50% 50% / 80% 80% 20% 20%;
      opacity: 0;
      transform-origin: bottom center;
    }
    
    .butterfly-wing.left {
      transform: rotate(-30deg) translate(-30px, 0) scaleX(-1);
    }
    
    .butterfly-wing.right {
      transform: rotate(30deg) translate(30px, 0);
    }
    
    .transform-active .butterfly-wing {
      opacity: 0.9;
      animation: flutter 2.5s infinite alternate ease-in-out;
    }
    
    .transform-active .butterfly-wing.left {
      animation-delay: 0.1s;
    }
    
    @keyframes flutter {
      0%, 100% { transform: rotate(-20deg) translate(-30px, 0) scaleX(-1); }
      50% { transform: rotate(-40deg) translate(-40px, -10px) scaleX(-1); }
    }
    
    @keyframes flutter-right {
      0%, 100% { transform: rotate(20deg) translate(30px, 0); }
      50% { transform: rotate(40deg) translate(40px, -10px); }
    }
    
    /* Bird transformation */
    .bird-body {
      position: absolute;
      width: 120px;
      height: 80px;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.5s ease-in-out 0.2s;
    }
    
    .swan-shape, .owl-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      transition: all 0.5s ease-in-out;
    }
    
    .swan-shape {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 182, 193, 0.8), rgba(173, 216, 230, 0.7));
      border-radius: 70% 40% 70% 40%;
      z-index: 1;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }
    
    .owl-shape {
      background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(101, 67, 33, 0.8), rgba(75, 0, 130, 0.6));
      border-radius: 80% 80% 60% 60%;
      z-index: 0;
      opacity: 0;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
    }
    
    .bird-head {
      position: absolute;
      border-radius: 50%;
      z-index: 2;
    }
    
    .swan-head {
      width: 35px;
      height: 40px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(240, 240, 250, 0.7));
      left: 5px;
      top: 15px;
    }
    
    .owl-head {
      width: 40px;
      height: 45px;
      background: linear-gradient(135deg, rgba(90, 70, 50, 0.9), rgba(70, 50, 40, 0.8));
      left: 5px;
      top: 10px;
      opacity: 0;
    }
    
    .swan-beak {
      position: absolute;
      width: 25px;
      height: 10px;
      background: rgba(255, 196, 0, 0.9);
      border-radius: 50% 80% 20% 50%;
      left: 0;
      top: 25px;
      z-index: 3;
    }
    
    .owl-beak {
      position: absolute;
      width: 18px;
      height: 12px;
      background: rgba(210, 170, 0, 0.9);
      border-radius: 40% 40% 80% 80%;
      left: 17px;
      top: 35px;
      transform: rotate(10deg);
      z-index: 3;
      opacity: 0;
    }
    
    .bird-wing {
      position: absolute;
      z-index: 1;
    }
    
    .swan-wing {
      width: 60px;
      height: 40px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(240, 240, 250, 0.7));
      border-radius: 80% 70% 60% 90%;
      right: 10px;
      top: 20px;
      transform-origin: left center;
    }
    
    .owl-wing {
      width: 55px;
      height: 45px;
      background: linear-gradient(135deg, rgba(110, 80, 50, 0.9), rgba(80, 60, 40, 0.8));
      border-radius: 70% 60% 80% 70%;
      right: 15px;
      top: 15px;
      transform-origin: left center;
      opacity: 0;
    }
    
    .bird-eye {
      position: absolute;
      border-radius: 50%;
      z-index: 4;
    }
    
    .swan-eye {
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 215, 0, 0.6);
      left: 30px;
      top: 25px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
    }
    
    .owl-eye {
      width: 14px;
      height: 14px;
      background: rgba(255, 215, 0, 0.9);
      border: 2px solid rgba(101, 67, 33, 0.8);
      left: 20px;
      top: 20px;
      opacity: 0;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    }
    
    .owl-eye::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 6px;
      background: #000;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .transform-active .bird-body {
      opacity: 1;
      transform: scale(1);
    }
    
    @keyframes bird-wing-flap {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(-20deg); }
    }
    
    .transform-swan .swan-shape,
    .transform-swan .swan-head,
    .transform-swan .swan-beak,
    .transform-swan .swan-wing,
    .transform-swan .swan-eye {
      opacity: 1;
    }
    
    .transform-swan .owl-shape,
    .transform-swan .owl-head,
    .transform-swan .owl-beak,
    .transform-swan .owl-wing,
    .transform-swan .owl-eye {
      opacity: 0;
    }
    
    .transform-owl .swan-shape,
    .transform-owl .swan-head,
    .transform-owl .swan-beak,
    .transform-owl .swan-wing,
    .transform-owl .swan-eye {
      opacity: 0;
    }
    
    .transform-owl .owl-shape,
    .transform-owl .owl-head,
    .transform-owl .owl-beak,
    .transform-owl .owl-wing,
    .transform-owl .owl-eye {
      opacity: 1;
    }
    
    .transform-active .swan-wing {
      animation: bird-wing-flap 4s infinite ease-in-out;
    }
    
    .transform-active .owl-wing {
      animation: bird-wing-flap 3s infinite ease-in-out;
    }
    
    /* Bird form icon for the form indicator */
    #bird-icon {
      position: absolute;
      width: 28px;
      height: 28px;
      transition: all 0.5s ease-in-out;
      opacity: 0;
      transform: scale(0);
    }
    
    /* Leaf effects for forest scene */
    .leaf-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
    }
    
    .tree {
      position: absolute;
      bottom: 0;
      z-index: 1;
    }
    
    .tree-trunk {
      position: absolute;
      bottom: 0;
      width: 25px;
      background: linear-gradient(to right, #4b3621 10%, #6b4423 50%, #4b3621 90%);
      border-radius: 5px;
      z-index: 1;
    }
    
    .tree-crown {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 40%, rgba(100, 170, 80, 0.8) 0%, rgba(60, 130, 40, 0.9) 100%);
      box-shadow: inset 3px 3px 5px rgba(255, 255, 255, 0.2), 
                  inset -3px -3px 5px rgba(0, 0, 0, 0.2);
      z-index: 0;
    }
    
    .tree-branch {
      position: absolute;
      height: 8px;
      background: linear-gradient(to bottom, #6b4423, #4b3621);
      border-radius: 3px;
      transform-origin: 0 50%;
      z-index: 0;
    }
    
    .falling-leaf {
      position: absolute;
      background-color: rgba(44, 119, 68, 0.7);
      border-radius: 50% 5% 50% 5%;
      filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.2));
      z-index: 2;
      opacity: 0;
      animation: leaf-falling linear forwards;
    }
    
    @keyframes leaf-falling {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
      10% { opacity: 0.7; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }
    
    @keyframes leaf-sway-animation {
      0%, 100% { transform: rotate(-5deg) translateX(0); }
      50% { transform: rotate(5deg) translateX(10px); }
    }
    
    .forest-light {
      position: absolute;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0) 70%);
      border-radius: 50%;
      filter: blur(8px);
      pointer-events: none;
      opacity: 0;
      animation: forest-light-fade 8s infinite ease-in-out;
      z-index: 1;
    }
    
    @keyframes forest-light-fade {
      0%, 100% { opacity: 0; transform: scale(0.8) translate(0, 0); }
      50% { opacity: 0.5; transform: scale(1.1) translate(10px, -10px); }
    }
    
    /* Fish transformation */
    .fish-body {
      position: absolute;
      width: 120px;
      height: 60px;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.5s ease-in-out 0.2s;
    }
    
    .fish-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50% 50% 50% 50% / 70% 70% 30% 30%;
      background: linear-gradient(135deg, rgba(93, 92, 222, 0.9), rgba(147, 146, 255, 0.7));
      overflow: hidden;
    }
    
    .fish-tail {
      position: absolute;
      right: -20px;
      top: 15px;
      width: 40px;
      height: 30px;
      border-radius: 0 0 50% 0;
      background: rgba(93, 92, 222, 0.8);
      transform-origin: left center;
    }
    
    .fish-eye {
      position: absolute;
      width: 10px;
      height: 10px;
      background: white;
      border-radius: 50%;
      top: 22px;
      left: 15px;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }
    
    .fish-fin {
      position: absolute;
      width: 20px;
      height: 15px;
      background: rgba(93, 92, 222, 0.8);
      border-radius: 50% 50% 0 50%;
      top: 5px;
      left: 40px;
      transform-origin: bottom center;
      transform: rotate(-20deg);
    }
    
    .fish-fin.bottom {
      top: auto;
      bottom: 5px;
      transform: rotate(20deg) scaleY(-1);
    }
    
    .transform-active .fish-body {
      opacity: 1;
      transform: scale(1);
      animation: fish-swim 3s infinite ease-in-out;
    }
    
    .transform-active .fish-tail {
      animation: fish-tail 1.5s infinite ease-in-out;
    }
    
    .transform-active .fish-fin {
      animation: fish-fin 2s infinite ease-in-out;
    }
    
    .transform-active .fish-fin.bottom {
      animation: fish-fin 2s infinite ease-in-out reverse;
    }
    
    /* Kun-Peng Transformation - 已分離為獨立的kun和peng形態 */
    
    .kun-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50% 50% 50% 50% / 70% 70% 30% 30%;
      background: linear-gradient(135deg, rgba(64, 186, 213, 0.9), rgba(103, 200, 208, 0.7));
      overflow: hidden;
      transition: all 1.5s ease-in-out;
    }
    
    .peng-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: all 1.5s ease-in-out;
    }
    
    .peng-wing {
      position: absolute;
      background: linear-gradient(135deg, rgba(64, 186, 213, 0.9), rgba(103, 200, 208, 0.7));
      border-radius: 50% 20% 50% 20%;
      transform-origin: center top;
    }
    
    .peng-wing.left {
      width: 100px;
      height: 130px;
      left: -50px;
      top: 20px;
      transform: rotate(-25deg);
    }
    
    .peng-wing.right {
      width: 100px;
      height: 130px;
      right: -50px;
      top: 20px;
      transform: rotate(25deg);
    }
    
    .peng-body {
      position: absolute;
      width: 40px;
      height: 120px;
      background: linear-gradient(to bottom, rgba(64, 186, 213, 0.9), rgba(103, 200, 208, 0.7));
      border-radius: 50% 50% 30% 30%;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .peng-head {
      position: absolute;
      width: 30px;
      height: 35px;
      background: rgba(64, 186, 213, 0.9);
      border-radius: 50% 50% 40% 40%;
      left: 50%;
      top: -5px;
      transform: translateX(-50%);
    }
    
    .peng-beak {
      position: absolute;
      width: 15px;
      height: 10px;
      background: rgba(255, 196, 0, 0.9);
      border-radius: 40% 40% 80% 80%;
      left: 50%;
      top: 20px;
      transform: translateX(-50%);
    }
    

    
    .transform-kun .kun-shape {
      opacity: 1;
      animation: kun-swim 5s infinite ease-in-out;
    }
    
    .transform-kun .peng-shape {
      opacity: 0;
    }
    
    .transform-peng .kun-shape {
      opacity: 0;
    }
    
    .transform-peng .peng-shape {
      opacity: 1;
    }
    
    .transform-peng .peng-wing {
      animation: peng-wing-flap 6s infinite ease-in-out;
    }
    
    .transform-peng .peng-wing.right {
      animation-delay: 0.3s;
    }
    
    @keyframes fish-swim {
      0%, 100% { transform: translateX(0) rotate(0deg); }
      25% { transform: translateX(10px) rotate(2deg); }
      75% { transform: translateX(-10px) rotate(-2deg); }
    }
    
    @keyframes fish-tail {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(15deg); }
    }
    
    @keyframes fish-fin {
      0%, 100% { transform: rotate(-20deg); }
      50% { transform: rotate(-10deg); }
    }
    
    /* 鯤（鯨魚）游動動畫 - 改進為更自然的鯨魚游動 */
    @keyframes kun-swim {
      0%, 100% { transform: translateX(0) rotate(0deg) translateY(0); }
      25% { transform: translateX(15px) rotate(1deg) translateY(-5px); }
      75% { transform: translateX(-15px) rotate(-1deg) translateY(5px); }
    }
    
    /* 鯨魚尾鰭擺動 */
    @keyframes whale-tail {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(15deg); }
    }
    
    /* 鯨魚噴水動畫 */
    @keyframes water-spray {
      0%, 80%, 100% { opacity: 0; height: 0; }
      85%, 87% { opacity: 0.7; height: 15px; }
    }
    
    /* 鵬（巨鳥）的翅膀拍動 - 改進為更自然的鳥類翅膀動作 */
    @keyframes peng-wing-flap {
      0%, 100% { transform: rotate(-25deg) scaleY(1); }
      50% { transform: rotate(-40deg) scaleY(0.9); }
    }
    
    @keyframes peng-wing-flap-right {
      0%, 100% { transform: rotate(25deg) scaleY(1); }
      50% { transform: rotate(40deg) scaleY(0.9); }
    }
    
    /* 羽毛閃爍動畫 */
    @keyframes feather-shimmer {
      0% { opacity: 0.5; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
      100% { opacity: 0.5; transform: scale(1); }
    }
    
    /* Particles animation */
    @keyframes particle-float {
      0% { transform: translate(-50%, -50%) translateY(0) scale(1); opacity: 0; }
      20% { opacity: 0.8; }
      100% { transform: translate(-50%, -50%) translateY(-100px) scale(0); opacity: 0; }
    }
    
    /* Fade out animation for transformation container */
    @keyframes fade-out {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .fade-out {
      animation: fade-out 0.8s forwards ease-in-out;
    }
    
    /* Game container base styles */
    .game-container {
      background: linear-gradient(to bottom, #ffffff, #f3f4f6);
    }
    
    /* Dark mode styles */
    .dark .game-container {
      background: linear-gradient(to bottom, #181818, #2d2d2d);
      color: #f1f1f1;
    }
    
    .dark .aperture {
      border-color: rgba(93, 92, 222, 0.4);
    }
    
    .dark .aperture.active {
      background-color: rgba(93, 92, 222, 0.8);
      box-shadow: 0 0 15px rgba(93, 92, 222, 0.8);
    }
    
    /* Segmentation puzzle styles - Enhanced and Improved */
    .text-segment-container {
      line-height: 2.8; /* Increased line height */
      letter-spacing: 14px; /* Increased letter spacing significantly */
      font-size: 1.75rem;
      font-weight: 500;
      margin: 1.5rem 0;
      position: relative;
      text-align: left; /* Revert to left-aligned for better character positioning */
      padding: 0 1.5rem; /* Add some padding for better display */
      word-spacing: 8px; /* Added word spacing for more room between characters */
    }
    
    .segment-gap {
      width: 8px; /* Slightly larger dot for better visibility */
      height: 8px; /* Same width and height for a circle */
      background-color: #4F46E5 !important; /* Force background color */
      display: inline-block;
      margin: 0;
      vertical-align: middle;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-radius: 50%; /* Make it a perfect circle */
      position: absolute;
      opacity: 0; /* Hide by default - will become visible when active */
      box-shadow: 0 0 4px rgba(93, 92, 222, 0.6);
      /* Position the dot in absolute center */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
    }
    
    /* Create a semi-transparent indicator on hover for better visibility */
    .segment-gap::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(93, 92, 222, 0);
      border-radius: 50%; /* Match the parent circle */
      transition: all 0.2s ease-out;
    }
    
    /* Create extended clickable area between characters */
    .segment-clickable-area {
      position: absolute;
      width: 30px; /* Much wider clickable area */
      height: 2.8rem; /* Match the increased line height */
      margin: 0;
      left: 50%;
      transform: translateX(-50%);
      top: 0;
      z-index: 10;
      cursor: pointer;
      opacity: 0;
    }
    
    /* Always show the active segments, and show on hover over the extended area or the character */
    .text-char:hover ~ .segment-gap,
    .segment-gap:hover,
    .segment-clickable-area:hover ~ .segment-gap,
    .segment-gap.active {
      opacity: 1;
    }
    
    .segment-gap:hover::before {
      background-color: rgba(93, 92, 222, 0.6);
      box-shadow: 0 0 12px rgba(93, 92, 222, 0.4);
    }
    
    .segment-gap:active::before {
      transform: scaleY(0.8);
    }
    
    /* Active segment - high contrast with light background */
    .segment-gap.active {
      opacity: 1;
      background-color: transparent;
    }
    
    .segment-gap.active::before {
      background-color: #4F46E5; /* More vivid indigo */
      box-shadow: 0 0 8px rgba(93, 92, 222, 0.7);
      transform: scale(1.2); /* Slightly larger when active */
    }
    
    /* Active segment - high contrast with dark background */
    .dark .segment-gap.active::before {
      background-color: #818CF8; /* Lighter indigo for dark mode */
      box-shadow: 0 0 10px rgba(129, 140, 248, 0.8);
      transform: scale(1.2); /* Slightly larger when active */
    }
    
    /* Glowing effect for active segments */
    .segment-gap.active::after {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border-radius: 5px;
      box-shadow: 0 0 8px 2px rgba(93, 92, 222, 0.7);
      opacity: 0;
      animation: segment-pulse 2s infinite ease-in-out;
    }
    
    .dark .segment-gap.active::after {
      box-shadow: 0 0 8px 2px rgba(129, 140, 248, 0.8);
    }
    
    @keyframes segment-pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }
    
    /* Scene backgrounds */
    /* 序章 - 夢境場景：增強夢幻效果 */
    .dream-scene {
      background: 
        radial-gradient(ellipse at 20% 30%, rgba(33, 169, 175, 0.4) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(23, 42, 116, 0.5) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(72, 61, 139, 0.3) 0%, transparent 60%),
        linear-gradient(135deg, #172a74, #21a9af);
      position: relative;
      overflow: hidden;
      animation: dream-atmosphere 12s ease-in-out infinite;
    }

    @keyframes dream-atmosphere {
      0%, 100% { 
        filter: brightness(1) saturate(1.2) hue-rotate(0deg);
      }
      33% { 
        filter: brightness(1.1) saturate(1.4) hue-rotate(5deg);
      }
      66% { 
        filter: brightness(0.95) saturate(1.1) hue-rotate(-3deg);
      }
    }

    /* 序章夢境粒子效果 */
    .dream-scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(33, 169, 175, 0.15) 1px, transparent 1px),
        radial-gradient(circle at 50% 80%, rgba(23, 42, 116, 0.12) 1px, transparent 1px);
      background-size: 150px 150px, 200px 200px, 120px 120px;
      animation: dream-particles-float 20s linear infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes dream-particles-float {
      0% { 
        background-position: 0% 0%, 0% 0%, 0% 0%;
        opacity: 0.6;
      }
      50% { 
        background-position: 100% 50%, -50% 100%, 150% 25%;
        opacity: 0.9;
      }
      100% { 
        background-position: 200% 100%, -100% 200%, 300% 50%;
        opacity: 0.6;
      }
    }

    /* 序章夢境光暈效果 */
    .dream-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at 60% 40%, 
        rgba(255, 255, 255, 0.08) 0%, 
        rgba(33, 169, 175, 0.05) 40%,
        transparent 70%
      );
      animation: dream-glow-shift 15s ease-in-out infinite;
      pointer-events: none;
      z-index: 2;
    }

    @keyframes dream-glow-shift {
      0% { 
        transform: translate(0, 0) scale(1);
        opacity: 0.7;
      }
      25% { 
        transform: translate(-10px, 5px) scale(1.1);
        opacity: 0.9;
      }
      50% { 
        transform: translate(15px, -8px) scale(0.95);
        opacity: 0.8;
      }
      75% { 
        transform: translate(-5px, 10px) scale(1.05);
        opacity: 1.0;
      }
      100% { 
        transform: translate(0, 0) scale(1);
        opacity: 0.7;
      }
    }
    
    .water-scene {
      background: linear-gradient(135deg, #1e5799, #7db9e8);
    }
    
    /* 第二章 - 雲海場景：增強雲朵動態效果 */
    .cloud-scene {
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 60%, rgba(103, 200, 208, 0.4) 0%, transparent 60%),
        radial-gradient(ellipse at 50% 80%, rgba(64, 186, 213, 0.3) 0%, transparent 40%),
        linear-gradient(135deg, #40bad5, #67c8d0);
      position: relative;
      overflow: hidden;
      animation: cloud-sky-breathe 10s ease-in-out infinite;
    }

    @keyframes cloud-sky-breathe {
      0%, 100% { 
        filter: brightness(1) saturate(1.1);
      }
      50% { 
        filter: brightness(1.15) saturate(1.3);
      }
    }

    /* 第二章雲朵層效果 */
    .cloud-scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse 200px 100px at 20% 30%, rgba(255, 255, 255, 0.6) 0%, transparent 50%),
        radial-gradient(ellipse 300px 150px at 60% 20%, rgba(255, 255, 255, 0.4) 0%, transparent 60%),
        radial-gradient(ellipse 250px 120px at 80% 50%, rgba(255, 255, 255, 0.5) 0%, transparent 55%),
        radial-gradient(ellipse 180px 90px at 40% 70%, rgba(255, 255, 255, 0.7) 0%, transparent 45%);
      animation: cloud-float 18s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes cloud-float {
      0%, 100% { 
        transform: scale(1) translateY(0);
        opacity: 0.8;
      }
      25% { 
        transform: scale(1.1) translateY(-8px);
        opacity: 0.9;
      }
      50% { 
        transform: scale(0.95) translateY(5px);
        opacity: 0.7;
      }
      75% { 
        transform: scale(1.05) translateY(-3px);
        opacity: 0.85;
      }
    }

    /* 第二章雲霧漂浮效果 */
    .cloud-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse 400px 200px at 30% 60%, rgba(255, 255, 255, 0.2) 0%, transparent 70%),
        radial-gradient(ellipse 350px 180px at 70% 80%, rgba(255, 255, 255, 0.15) 0%, transparent 65%);
      animation: cloud-mist-pulse 22s ease-in-out infinite;
      pointer-events: none;
      z-index: 2;
    }

    @keyframes cloud-mist-pulse {
      0%, 100% { 
        transform: scale(1) translateY(0);
        opacity: 0.5;
      }
      30% { 
        transform: scale(1.15) translateY(-10px);
        opacity: 0.7;
      }
      60% { 
        transform: scale(0.9) translateY(8px);
        opacity: 0.4;
      }
      80% { 
        transform: scale(1.08) translateY(-5px);
        opacity: 0.6;
      }
    }
    
    .forest-scene {
      background: linear-gradient(135deg, #2c7744, #8fc866);
    }
    
    .spiral-scene {
      background: linear-gradient(135deg, #271c51, #4b3a6d);
    }
    
    /* 第五章 - 時間森林場景：簡化背景 */
    .time-scene {
      background: linear-gradient(135deg, #8B4513, #DAA520);
      position: relative;
      overflow: hidden;
    }




    
    .heaven-earth-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 5;
      pointer-events: none; /* 讓點擊事件穿透到下層 */
    }
    
    /* 日月星辰容器 - 與天空區域完全對應 */
    .heaven-earth-celestial-container {
      position: absolute;
      top: 20vh; /* 進一步抬高地平線，與繼續按鈕保持合適間距 */
      left: 50%;
      transform: translateX(-50%);
      width: 67vw; /* 增加約三分之一：50vw * 4/3 ≈ 67vw */
      height: 33.5vw; /* 高度正好是寬度的一半，形成完美半圓 */
      clip-path: ellipse(50% 100% at 50% 100%); /* 確保只在半圓內顯示 */
      z-index: 20; /* 在天空背景之上 */
      pointer-events: none;
      overflow: hidden;
    }
    
    /* 天空區域 - 半圓形 */
    .heaven-earth-scene::before {
      content: '';
      position: absolute;
      top: 20vh; /* 進一步抬高地平線，與繼續按鈕保持合適間距 */
      left: 50%;
      transform: translateX(-50%);
      width: 67vw; /* 增加約三分之一：50vw * 4/3 ≈ 67vw */
      height: 33.5vw; /* 高度正好是寬度的一半，形成完美半圓 */
      background: radial-gradient(ellipse at center bottom, 
        #4A3728 0%,     /* 溫暖褐色大地 */
        #2D1B69 25%,    /* 深紫夜色 */
        #1E3A8A 50%,    /* 深藍夜空 */
        #1E1B4B 75%,    /* 深夜藍 */
        #0F172A 100%    /* 深藍黑夜空 */
      );
      clip-path: ellipse(50% 100% at 50% 100%);
      z-index: 6;
      
      /* 地平線 */
      border-bottom: 4px solid #4A3728;
      box-shadow: 0 4px 0 0 #2D1B1B, 0 8px 0 0 #1A1010;
      
      /* 大氣層發光效果 - 增強圓弧邊緣發光 */
      box-shadow: 
        /* 內層發光 - 藍白色大氣層 */
        inset 0 0 30px rgba(135, 206, 235, 0.4),
        inset 0 0 60px rgba(100, 149, 237, 0.3),
        /* 外層發光 - 模擬大氣層散射 */
        0 0 40px rgba(135, 206, 235, 0.8),
        0 0 80px rgba(100, 149, 237, 0.6),
        0 0 120px rgba(65, 105, 225, 0.4),
        0 0 160px rgba(30, 144, 255, 0.3),
        0 0 200px rgba(0, 100, 255, 0.2),
        /* 地平線陰影 */
        0 4px 0 0 #2D1B1B, 
        0 8px 0 0 #1A1010;
      
      animation: atmosphere-glow 8s ease-in-out infinite;
    }

    /* 大氣層邊緣漸變效果 */
    .chapter6-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50% 50% 0 0;
      background: radial-gradient(
        ellipse at center bottom,
        transparent 85%,
        rgba(135, 206, 235, 0.3) 90%,
        rgba(100, 149, 237, 0.4) 95%,
        rgba(65, 105, 225, 0.5) 98%,
        rgba(30, 144, 255, 0.6) 100%
      );
      pointer-events: none;
      z-index: 7;
      animation: edge-glow 6s ease-in-out infinite;
    }

    /* 邊緣發光動畫 */
    @keyframes edge-glow {
      0%, 100% {
        opacity: 0.8;
      }
      50% {
        opacity: 1.0;
      }
    }
    
    /* 地面區域 - 透明，顯示外太空背景 */
    .heaven-earth-scene::after {
      content: '';
      position: absolute;
      top: calc(20vh + 33.5vw); /* 天空區域下方 */
      left: 0;
      width: 100vw;
      height: calc(100vh - 20vh - 33.5vw - 4px); /* 剩餘高度，減去地平線厚度 */
      background: transparent; /* 透明，顯示外太空星空 */
      z-index: 4; /* 在星空上方，但在天空下方 */
      pointer-events: auto; /* 允許點擊事件，用於按鈕交互 */
    }
    
    /* 為不支持clip-path的瀏覽器提供border-radius fallback */
    @supports not (clip-path: ellipse(50% 100% at 50% 100%)) {
      .heaven-earth-scene::before {
        border-radius: 33.5vw 33.5vw 0 0; /* 使用與寬度一半相同的圓角半徑 */
        clip-path: none;
      }
      
      .heaven-earth-celestial-container {
        border-radius: 33.5vw 33.5vw 0 0; /* 確保日月星辰容器也使用相同的圓角 */
        clip-path: none;
      }
    }
    
    /* 第六章天地場景下的UI調整 - 確保按鈕在地面區域（地平線以下） */
    .heaven-earth-scene #game-ui {
      position: fixed !important;
      bottom: 1.5rem !important; /* 位於地面區域底部 */
      left: 0 !important;
      right: 0 !important;
      z-index: 10003 !important; /* 使用超高z-index確保在所有元素上方 */
    }
    
    /* 繼續按鈕也移到地面區域 */
    .heaven-earth-scene .fixed[style*="top: 78%"] {
      top: auto !important;
      bottom: 6rem !important; /* 在物化按鈕上方，適應縮小的地面區域 */
      position: fixed !important;
      z-index: 10002 !important; /* 使用超高z-index確保在所有元素之上 */
    }
    
    /* 第六章天地場景下，將物化指示器和七竅追蹤器移到半圓外的空間 */
    .heaven-earth-scene #current-form-indicator {
      position: fixed !important;
      top: 1rem !important; /* 移到頁面最上方 */
      left: 1rem !important;
      z-index: 100 !important; /* 確保在所有元素上方顯示 */
      opacity: 1 !important; /* 強制顯示 */
    }
    
    .heaven-earth-scene #apertures-tracker {
      position: fixed !important;
      top: 1rem !important; /* 移到頁面最上方 */
      right: 1rem !important;
      z-index: 100 !important; /* 確保在所有元素上方顯示 */
      opacity: 1 !important; /* 強制顯示 */
    }
    
    /* 為第六章添加頁面背景 - 外太空黑色 */
    body:has(.heaven-earth-scene) {
      background: #000000 !important; /* 外太空黑色 */
    }
    
    /* 確保遊戲容器在第六章時有黑色背景 */
    .heaven-earth-scene {
      background-color: #000000; /* 先設置黑色背景 */
    }
    
    /* 移除第六章時遊戲容器的灰色漸變背景，讓星空透過 */
    body:has(.heaven-earth-scene) #game-container {
      background: transparent !important; /* 設置為透明，讓星空背景透過 */
    }

    /* 扁平化繼續按鈕設計 */
    #advance-btn {
      /* 簡潔的半透明背景 */
      background: rgba(99, 102, 241, 0.75) !important;
      backdrop-filter: blur(12px) !important;
      -webkit-backdrop-filter: blur(12px) !important;
      
      /* 簡潔邊框，無陰影 */
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      box-shadow: none !important;
      
      /* 清晰文字 */
      color: #ffffff !important;
      font-weight: 600 !important;
      letter-spacing: 0.5px !important;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) !important;
      
      /* 圓角和尺寸 */
      border-radius: 12px !important;
      padding: 12px 24px !important;
      min-width: 120px !important;
      
      /* 簡單過渡 */
      transition: all 0.2s ease !important;
      
      /* 確保按鈕層級 */
      position: relative !important;
      z-index: 1000 !important;
    }

    /* 桌面端樣式 */
    @media (min-width: 768px) {
      #advance-btn {
        padding: 14px 28px !important;
        font-size: 16px !important;
        min-width: 130px !important;
      }
    }

    /* 簡潔的懸停效果 */
    #advance-btn:hover {
      background: rgba(99, 102, 241, 0.9) !important;
      border-color: rgba(255, 255, 255, 0.4) !important;
      transform: translateY(-1px) !important;
    }

    /* 簡潔的按下效果 */
    #advance-btn:active {
      background: rgba(99, 102, 241, 0.8) !important;
      transform: translateY(0) !important;
    }

    /* 氣視覺效果下的處理 */
    body.qi-vision #advance-btn {
      background: rgba(255, 255, 255, 0.3) !important;
      color: #ffffff !important;
      border-color: rgba(255, 255, 255, 0.5) !important;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8) !important;
    }

    body.qi-vision #advance-btn:hover {
      background: rgba(255, 255, 255, 0.4) !important;
      border-color: rgba(255, 255, 255, 0.6) !important;
    }

    /* 尾聲章節美觀紫色文字設計 */
    .epilogue-scene #game-content p,
    .epilogue-scene .max-w-2xl p,
    .epilogue-scene .narrative p,
    .epilogue-scene p,
    body:has(.epilogue-scene) #game-content p,
    body:has(.epilogue-scene) .max-w-2xl p {
      color: #6d28d9 !important; /* 美觀的深紫色 */
      text-shadow: 
        0 1px 3px rgba(255, 255, 255, 0.9),
        0 0 8px rgba(109, 40, 217, 0.3),
        0 0 15px rgba(255, 255, 255, 0.6) !important; /* 紫色光暈 + 白色陰影 */
      font-weight: 500 !important; /* 加粗字體增加可讀性 */
    }

    /* 暗色模式下的尾聲章節紫色文字 */
    .dark .epilogue-scene #game-content p,
    .dark .epilogue-scene .max-w-2xl p,
    .dark .epilogue-scene .narrative p,
    .dark .epilogue-scene p,
    body.dark:has(.epilogue-scene) #game-content p,
    body.dark:has(.epilogue-scene) .max-w-2xl p {
      color: #a855f7 !important; /* 亮紫色在暗色背景下 */
      text-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.8),
        0 0 10px rgba(168, 85, 247, 0.4) !important; /* 紫色光暈 */
      font-weight: 500 !important;
    }

    /* 額外保障：直接針對尾聲章節所有文字元素 */
    .epilogue-scene * {
      color: #6d28d9 !important; /* 美觀紫色 */
      text-shadow: 
        0 1px 3px rgba(255, 255, 255, 0.9),
        0 0 8px rgba(109, 40, 217, 0.3),
        0 0 15px rgba(255, 255, 255, 0.6) !important;
    }

    .dark .epilogue-scene * {
      color: #a855f7 !important; /* 暗色模式亮紫色 */
      text-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.8),
        0 0 10px rgba(168, 85, 247, 0.4) !important;
    }

    /* 尾聲章節專用深色文字 - 超高對比度 */
    .epilogue-text-purple {
      color: #000000 !important; /* 純黑色，在淺米色背景上最突出 */
      text-shadow: none !important; /* 移除所有陰影效果 */
      font-weight: 800 !important; /* 超粗字體確保突出 */
    }

    /* 暗色模式下的尾聲章節文字（同樣淺米色背景） */
    .dark .epilogue-text-purple {
      color: #000000 !important; /* 暗色模式也使用純黑色，因為背景圖片相同 */
      text-shadow: none !important; /* 移除所有陰影效果 */
      font-weight: 800 !important;
    }
    
    /* 尾聲章節背景樣式 */
    .epilogue-scene {
      background-image: url('https://chineseclassics.github.io/images/zhuangzi.png') !important;
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      filter: sepia(0.15) saturate(1.2) brightness(1.1) !important;
      animation: epilogue-breathe 20s infinite ease-in-out !important;
      position: relative;
      overflow: hidden;
    }

    /* 增強的背景呼吸動畫 - 移除transform避免與物化縮放衝突 */
    @keyframes epilogue-breathe {
      0%, 100% { 
        filter: sepia(0.15) saturate(1.2) brightness(1.1) contrast(1.05);
      }
      25% { 
        filter: sepia(0.2) saturate(1.3) brightness(1.15) contrast(1.1);
      }
      50% { 
        filter: sepia(0.25) saturate(1.4) brightness(1.2) contrast(1.15);
      }
      75% { 
        filter: sepia(0.2) saturate(1.3) brightness(1.15) contrast(1.1);
      }
          }

      /* 尾聲章節動態效果層 */
      .epilogue-scene::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at 30% 20%, 
          rgba(255, 255, 255, 0.25) 0%, 
          rgba(255, 235, 150, 0.18) 30%,
          rgba(255, 215, 0, 0.12) 50%,
          transparent 75%
        );
        animation: sunlight-dance 30s infinite ease-in-out;
        z-index: 1;
        pointer-events: none;
      }

      @keyframes sunlight-dance {
        0% { 
          background-position: 30% 20%; 
          opacity: 0.6;
          transform: rotate(0deg) scale(1);
        }
        25% { 
          background-position: 60% 15%; 
          opacity: 0.9;
          transform: rotate(1deg) scale(1.1);
        }
        50% { 
          background-position: 80% 30%; 
          opacity: 0.7;
          transform: rotate(0deg) scale(1.05);
        }
        75% { 
          background-position: 40% 40%; 
          opacity: 1.0;
          transform: rotate(-1deg) scale(1.15);
        }
        100% { 
          background-position: 30% 20%; 
          opacity: 0.6;
          transform: rotate(0deg) scale(1);
        }
      }

      /* 最終場景輕微呼吸光效 */
      @keyframes gentle-breathing {
        0% { 
          text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          transform: scale(1);
          opacity: 0.95;
        }
        50% { 
          text-shadow: 0 2px 8px rgba(139, 69, 19, 0.15), 0 0 12px rgba(139, 69, 19, 0.08);
          transform: scale(1.002);
          opacity: 1;
        }
        100% { 
          text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          transform: scale(1);
          opacity: 0.95;
        }
      }

      /* 樹影搖擺效果 */
      .epilogue-scene::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          transparent 0%,
          rgba(0, 0, 0, 0.08) 50%,
          rgba(0, 0, 0, 0.12) 70%,
          transparent 100%
        );
        animation: tree-shadow-sway 25s infinite ease-in-out;
        z-index: 2;
        pointer-events: none;
      }

      @keyframes tree-shadow-sway {
        0%, 100% { 
          transform: skewX(0deg) translateX(0); 
          opacity: 0.3; 
        }
        30% { 
          transform: skewX(-1deg) translateX(5px); 
          opacity: 0.5; 
        }
        70% { 
          transform: skewX(1deg) translateX(-3px); 
          opacity: 0.4; 
        }
      }

      /* 智慧光點粒子系統 */
      .wisdom-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 3;
      }

      .wisdom-particle {
        position: absolute;
        width: 3px;
        height: 3px;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(255, 235, 150, 0.8));
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 235, 150, 0.6), 0 0 30px rgba(255, 215, 0, 0.4);
        animation: wisdom-float 15s infinite linear;
      }

      @keyframes wisdom-float {
        0% { 
          transform: translateY(100vh) translateX(0) scale(0.3); 
          opacity: 0; 
        }
        10% { 
          opacity: 0.8; 
        }
        50% { 
          transform: translateY(50vh) translateX(20px) scale(1);
          opacity: 1;
        }
        90% { 
          opacity: 0.6; 
        }
        100% { 
          transform: translateY(-20px) translateX(-10px) scale(0.5); 
          opacity: 0; 
        }
      }

      /* 飄落樹葉效果 */
      .ancient-leaves {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
        overflow: hidden;
      }

      .ancient-leaf {
        position: absolute;
        width: 8px;
        height: 12px;
        background: rgba(139, 69, 19, 0.7);
        border-radius: 50% 10% 50% 10%;
        animation: leaf-gentle-fall 20s infinite linear;
      }

      @keyframes leaf-gentle-fall {
        0% { 
          transform: translateY(-300px) rotate(0deg) translateX(0); 
          opacity: 0; 
        }
        3% { 
          transform: translateY(-250px) rotate(9deg) translateX(2px); 
          opacity: 0.1; 
        }
        8% { 
          transform: translateY(-180px) rotate(18deg) translateX(5px); 
          opacity: 0.3; 
        }
        15% { 
          opacity: 0.8; 
        }
        50% {
          transform: translateY(50vh) rotate(180deg) translateX(30px);
          opacity: 0.6;
        }
        90% { 
          opacity: 0.4; 
        }
        100% { 
          transform: translateY(calc(100vh + 100px)) rotate(360deg) translateX(-20px); 
          opacity: 0; 
        }
      }




      
      /* 為物化效果創建覆蓋層系統 */
    .transformation-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      transition: all 0.3s ease;
    }

    @keyframes background-breathe {
      0%, 100% { 
        filter: sepia(0.1) saturate(1.1) brightness(1.05); 
        transform: scale(1);
      }
      50% { 
        filter: sepia(0.15) saturate(1.2) brightness(1.1); 
        transform: scale(1.02);
      }
    }

    /* 陽光移動效果 */
    .epilogue-scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at 30% 20%, 
        rgba(255, 215, 0, 0.15) 0%, 
        rgba(255, 215, 0, 0.05) 40%,
        transparent 70%
      );
      animation: sunlight-shift 25s infinite ease-in-out;
      z-index: 1;
      pointer-events: none;
    }

    @keyframes sunlight-shift {
      0% { background-position: 30% 20%; opacity: 0.3; }
      25% { background-position: 50% 15%; opacity: 0.5; }
      50% { background-position: 70% 25%; opacity: 0.4; }
      75% { background-position: 40% 30%; opacity: 0.6; }
      100% { background-position: 30% 20%; opacity: 0.3; }
    }

    /* 樹影變化效果 */
    .epilogue-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        135deg,
        transparent 0%,
        rgba(0, 0, 0, 0.1) 60%,
        rgba(0, 0, 0, 0.15) 80%,
        transparent 100%
      );
      animation: shadow-dance 30s infinite ease-in-out;
      z-index: 2;
      pointer-events: none;
    }

    @keyframes shadow-dance {
      0%, 100% { transform: skewX(0deg) translateX(0); opacity: 0.4; }
      50% { transform: skewX(-2deg) translateX(10px); opacity: 0.6; }
    }

    /* 空白浮現場景樣式 */
    .blank-emergence-scene {
      background: #ffffff !important;
      transition: background-color 1s ease-in-out;
    }

    .blank-emergence-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: #333;
      text-align: center;
      opacity: 0;
      animation: text-emergence 3s ease-in-out forwards;
      z-index: 10;
      font-weight: 500;
      line-height: 1.6;
      max-width: 80%;
    }

    @keyframes text-emergence {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      30% {
        opacity: 0.3;
        transform: translate(-50%, -50%) scale(0.9);
      }
      60% {
        opacity: 0.7;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* 照片顯影場景樣式 */
    .photo-develop-scene {
      background: #ffffff !important;
      position: relative;
      overflow: hidden;
    }

    .photo-develop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('https://chineseclassics.github.io/images/zhuangzi.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 0;
      animation: photo-develop 4s ease-in-out forwards;
      z-index: 1;
    }

    @keyframes photo-develop {
      0% {
        opacity: 0;
        filter: brightness(2) contrast(0.5) blur(5px);
      }
      25% {
        opacity: 0.3;
        filter: brightness(1.8) contrast(0.7) blur(3px);
      }
      50% {
        opacity: 0.6;
        filter: brightness(1.5) contrast(0.9) blur(2px);
      }
      75% {
        opacity: 0.8;
        filter: brightness(1.2) contrast(1.1) blur(1px);
      }
      100% {
        opacity: 1;
        filter: sepia(0.15) saturate(1.2) brightness(1.1);
      }
    }

    .photo-develop-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      font-size: 1.2rem;
      color: #333;
      text-align: center;
      opacity: 0;
      animation: text-fade-in 2s ease-in-out 1s forwards;
      z-index: 10;
      max-width: 80%;
      line-height: 1.6;
      backdrop-filter: blur(10px);
    }

    @keyframes text-fade-in {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) translateY(20px);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) translateY(0);
      }
    }
    
    /* 第七章虛空場景樣式 */
    .void-scene {
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 30%, #0f0f23 100%);
      position: relative;
      overflow: hidden;
      min-height: 100vh;
    }
    
    /* 虛空粒子系統 */
    .void-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .void-particle {
      position: absolute;
      border-radius: 50%;
      opacity: 0;
      animation: void-particle-float 15s infinite linear;
    }
    
    @keyframes void-particle-float {
      0% {
        opacity: 0;
        transform: translateY(100vh) scale(0.5);
      }
      10% {
        opacity: 0.8;
      }
      90% {
        opacity: 0.8;
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) scale(1.2);
      }
    }
    

    
    /* 渾沌形體 */
    .chaos-form {
      width: 240px;
      height: 180px;
      background: radial-gradient(ellipse, rgba(255, 255, 255, 0.3) 0%, rgba(147, 146, 255, 0.2) 50%, transparent 100%);
      border-radius: 50%;
      animation: chaos-breathing 4s infinite ease-in-out;
      cursor: pointer;
      transition: all 0.3s ease;
      /* 持續發光效果 */
      box-shadow: 0 0 40px rgba(255, 255, 255, 0.3), 0 0 80px rgba(147, 146, 255, 0.2);
    }
    
    /* 呼吸調息模式下的混沌圖形 */
    .chaos-form.breathing-mode {
      width: 360px;
      height: 270px;
      animation: chaos-guided-breathing 10s infinite cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 10;
      will-change: transform, opacity, box-shadow;
    }
    
    .chaos-form:hover {
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 0 0 60px rgba(255, 255, 255, 0.5), 0 0 120px rgba(147, 146, 255, 0.4);
    }
    
    /* 斷句界面時的低層級樣式 */
    .chaos-form.segmentation-mode {
      z-index: 1 !important;
      opacity: 0.3;
      pointer-events: none;
    }
    
    @keyframes chaos-breathing {
      0%, 100% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.3), 0 0 80px rgba(147, 146, 255, 0.2);
      }
      50% {
        opacity: 0.9;
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 0 60px rgba(255, 255, 255, 0.5), 0 0 120px rgba(147, 146, 255, 0.4);
      }
    }
    
    /* 引導呼吸動畫：吸氣4秒(0-40%) + 呼氣6秒(40-100%) */
    @keyframes chaos-guided-breathing {
      0% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(0.85);
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.25), 0 0 80px rgba(147, 146, 255, 0.15);
      }
      20% {
        opacity: 0.75;
        transform: translate(-50%, -50%) scale(1.0);
        box-shadow: 0 0 55px rgba(255, 255, 255, 0.35), 0 0 110px rgba(147, 146, 255, 0.25);
      }
      40% {
        opacity: 0.95;
        transform: translate(-50%, -50%) scale(1.15);
        box-shadow: 0 0 75px rgba(255, 255, 255, 0.55), 0 0 150px rgba(147, 146, 255, 0.45);
      }
      55% {
        opacity: 0.85;
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 0 65px rgba(255, 255, 255, 0.45), 0 0 130px rgba(147, 146, 255, 0.35);
      }
      75% {
        opacity: 0.7;
        transform: translate(-50%, -50%) scale(0.95);
        box-shadow: 0 0 50px rgba(255, 255, 255, 0.3), 0 0 100px rgba(147, 146, 255, 0.2);
      }
      100% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(0.85);
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.25), 0 0 80px rgba(147, 146, 255, 0.15);
      }
    }
    

    

    
    /* 太極符號系統 */
    .taiji-container {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 120px;
      animation: taiji-rotate 20s infinite linear;
      z-index: 5;
      filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.3));
    }
    
    .yin-yang-emoji {
      color: rgba(255, 255, 255, 0.8);
      animation: taiji-glow 4s infinite ease-in-out;
    }
    
    @keyframes taiji-rotate {
      0% {
        transform: translateX(-50%) rotate(0deg);
      }
      100% {
        transform: translateX(-50%) rotate(360deg);
      }
    }
    
    @keyframes taiji-glow {
      0%, 100% {
        filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.3));
        opacity: 0.8;
      }
      50% {
        filter: drop-shadow(0 0 60px rgba(255, 255, 255, 0.6));
        opacity: 1;
      }
    }
    
    /* 八卦符號系統 */
    .bagua-symbols {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
    }
    
    .bagua-symbol {
      position: absolute;
      font-size: 32px;
      color: rgba(255, 255, 255, 0.8);
      opacity: 0;
      animation: bagua-float 25s infinite linear;
      filter: drop-shadow(0 0 15px currentColor) drop-shadow(0 0 30px currentColor) drop-shadow(0 0 45px currentColor);
      text-shadow: 
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 60px currentColor;
    }
    
    @keyframes bagua-float {
      0% {
        opacity: 0;
        transform: translateY(100vh) rotate(0deg) scale(0.8);
      }
      5% {
        opacity: 0.6;
      }
      95% {
        opacity: 0.6;
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) rotate(360deg) scale(1.2);
      }
    }
    
    /* 八卦符號的特殊顏色 - 增強發光效果 */
    .bagua-qian { 
      color: rgba(255, 215, 0, 0.9); /* 乾-天-金色 */
      text-shadow: 
        0 0 15px #FFD700,
        0 0 30px #FFD700,
        0 0 45px #FFD700,
        0 0 60px #FFD700;
    }
    .bagua-dui { 
      color: rgba(192, 192, 192, 0.9); /* 兌-澤-銀色 */
      text-shadow: 
        0 0 15px #C0C0C0,
        0 0 30px #C0C0C0,
        0 0 45px #C0C0C0,
        0 0 60px #C0C0C0;
    }
    .bagua-li { 
      color: rgba(255, 69, 0, 0.9); /* 離-火-橙紅色 */
      text-shadow: 
        0 0 15px #FF4500,
        0 0 30px #FF4500,
        0 0 45px #FF4500,
        0 0 60px #FF4500;
    }
    .bagua-zhen { 
      color: rgba(138, 43, 226, 0.9); /* 震-雷-紫色 */
      text-shadow: 
        0 0 15px #8A2BE2,
        0 0 30px #8A2BE2,
        0 0 45px #8A2BE2,
        0 0 60px #8A2BE2;
    }
    .bagua-xun { 
      color: rgba(144, 238, 144, 0.9); /* 巽-風-淺綠色 */
      text-shadow: 
        0 0 15px #90EE90,
        0 0 30px #90EE90,
        0 0 45px #90EE90,
        0 0 60px #90EE90;
    }
    .bagua-kan { 
      color: rgba(30, 144, 255, 0.9); /* 坎-水-藍色 */
      text-shadow: 
        0 0 15px #1E90FF,
        0 0 30px #1E90FF,
        0 0 45px #1E90FF,
        0 0 60px #1E90FF;
    }
    .bagua-gen { 
      color: rgba(139, 69, 19, 0.9); /* 艮-山-棕色 */
      text-shadow: 
        0 0 15px #8B4513,
        0 0 30px #8B4513,
        0 0 45px #8B4513,
        0 0 60px #8B4513;
    }
    .bagua-kun { 
      color: rgba(218, 165, 32, 0.9); /* 坤-地-土黃色 */
      text-shadow: 
        0 0 15px #DAA520,
        0 0 30px #DAA520,
        0 0 45px #DAA520,
        0 0 60px #DAA520;
    }

    /* 八卦收集答案圆圈翻转动画样式 */
    .answer-circle {
      perspective: 1000px;
      transform-style: preserve-3d;
    }

    .answer-circle .front-side,
    .answer-circle .back-side {
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-style: preserve-3d;
    }

    .answer-circle .back-side {
      transform: rotateY(180deg);
    }

    .answer-circle.flipped .front-side {
      transform: rotateY(180deg);
    }

    .answer-circle.flipped .back-side {
      transform: rotateY(0deg);
    }
    

    
    /* 大氣層發光動畫 - 增強呼吸效果 */
    @keyframes atmosphere-glow {
      0%, 100% {
        box-shadow: 
          /* 內層發光 */
          inset 0 0 30px rgba(135, 206, 235, 0.4),
          inset 0 0 60px rgba(100, 149, 237, 0.3),
          /* 外層發光 */
          0 0 40px rgba(135, 206, 235, 0.8),
          0 0 80px rgba(100, 149, 237, 0.6),
          0 0 120px rgba(65, 105, 225, 0.4),
          0 0 160px rgba(30, 144, 255, 0.3),
          0 0 200px rgba(0, 100, 255, 0.2),
          /* 地平線陰影 */
          0 4px 0 0 #2D1B1B, 
          0 8px 0 0 #1A1010;
      }
      50% {
        box-shadow: 
          /* 內層發光 - 增強 */
          inset 0 0 50px rgba(135, 206, 235, 0.6),
          inset 0 0 90px rgba(100, 149, 237, 0.5),
          /* 外層發光 - 增強 */
          0 0 60px rgba(135, 206, 235, 1.0),
          0 0 120px rgba(100, 149, 237, 0.8),
          0 0 180px rgba(65, 105, 225, 0.6),
          0 0 240px rgba(30, 144, 255, 0.4),
          0 0 300px rgba(0, 100, 255, 0.3),
          /* 地平線陰影 */
          0 4px 0 0 #2D1B1B, 
          0 8px 0 0 #1A1010;
      }
    }
    

    
    /* 外太空星空粒子動畫 */
    .space-starfield {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2; /* 在外太空背景上面，但在半圓下面 */
      pointer-events: none;
      animation: space-rotation 300s linear infinite;
    }
    
    .space-star {
      position: absolute;
      border-radius: 50%;
      animation: star-twinkle-space 3s ease-in-out infinite;
    }
    
    .space-star.yellow {
      background: #FFD700;
      box-shadow: 0 0 6px #FFD700, 0 0 12px #FFD700;
    }
    
    .space-star.blue {
      background: #87CEEB;
      box-shadow: 0 0 6px #87CEEB, 0 0 12px #87CEEB;
    }
    
    .space-star.white {
      background: #FFFFFF;
      box-shadow: 0 0 6px #FFFFFF, 0 0 12px #FFFFFF;
    }
    
    @keyframes space-rotation {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes star-twinkle-space {
      0%, 100% { 
        opacity: 0.3;
        transform: scale(1);
      }
      50% { 
        opacity: 1;
        transform: scale(1.2);
      }
    }
    
    /* 大氣層粒子 */
    .atmosphere-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 4;
      border-radius: 50% 50% 0 0;
      overflow: hidden;
    }

    .atmosphere-particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(135, 206, 235, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(135, 206, 235, 0.6);
      animation: atmosphere-particle-float 4s ease-in-out infinite;
    }

    /* 大氣層粒子動畫 */
    @keyframes atmosphere-particle-float {
      0%, 100% {
        transform: translateY(0) scale(1);
        opacity: 0.6;
      }
      25% {
        transform: translateY(-10px) scale(1.1);
        opacity: 0.8;
      }
      50% {
        transform: translateY(-5px) scale(0.9);
        opacity: 1;
      }
      75% {
        transform: translateY(-15px) scale(1.05);
        opacity: 0.7;
      }
    }
    

    
    /* 大氣層邊緣動畫 */
    @keyframes atmosphere-edge-glow {
      0%, 100% {
        opacity: 0.8;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.02);
      }
    }
    

    
    @keyframes stars-twinkle {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }
    
    /* 視角縮放控制器 */
    .scale-controller {
      position: fixed;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      width: 3rem;
      height: 15rem;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2rem;
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      opacity: 0;
      pointer-events: none;
      z-index: 50;
    }
    
    .dark .scale-controller {
      background: rgba(30, 30, 40, 0.3);
      border-color: rgba(80, 80, 100, 0.3);
    }
    
    .scale-controller.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* 視角控制器發光提示效果 */
    .scale-controller.highlight {
      animation: scaleControllerGlow 2s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(147, 50, 158, 0.6), 0 0 40px rgba(147, 50, 158, 0.4);
    }
    
    @keyframes scaleControllerGlow {
      0%, 100% {
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.1), 0 0 25px rgba(147, 50, 158, 0.4);
        border-color: rgba(255, 255, 255, 0.2);
      }
      50% {
        box-shadow: 0 0 25px rgba(147, 50, 158, 0.6), 0 0 50px rgba(147, 50, 158, 0.4);
        border-color: rgba(147, 50, 158, 0.6);
      }
    }
    
    /* 暗色模式的發光效果 */
    .dark .scale-controller.highlight {
      animation: scaleControllerGlowDark 2s ease-in-out infinite;
    }
    
    @keyframes scaleControllerGlowDark {
      0%, 100% {
        box-shadow: 0 0 15px rgba(30, 30, 40, 0.3), 0 0 25px rgba(147, 50, 158, 0.4);
        border-color: rgba(80, 80, 100, 0.3);
      }
      50% {
        box-shadow: 0 0 25px rgba(147, 50, 158, 0.6), 0 0 50px rgba(147, 50, 158, 0.4);
        border-color: rgba(147, 50, 158, 0.6);
      }
    }
    
    .scale-track {
      position: relative;
      height: 80%;
      width: 0.5rem;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 1rem;
      margin: 0.5rem 0;
    }
    
    .dark .scale-track {
      background: rgba(80, 80, 100, 0.4);
    }
    
    .scale-handle {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 1.75rem;
      height: 1.75rem;
      background: linear-gradient(135deg, rgba(147, 50, 158, 0.9), rgba(80, 50, 160, 0.7));
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(147, 50, 158, 0.5);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.75rem;
      user-select: none;
      z-index: 2;
      transition: transform 0.1s ease;
    }
    
    .scale-handle:hover {
      transform: translate(-50%, -50%) scale(1.1);
    }
    
    .scale-handle:active {
      transform: translate(-50%, -50%) scale(0.95);
    }
    
    .scale-label {
      position: absolute;
      width: 100%;
      text-align: center;
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .scale-label.macro {
      top: -1.5rem;
    }
    
    .scale-label.micro {
      bottom: -1.5rem;
    }
    
    .scale-value {
      position: absolute;
      right: 3.5rem;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(4px);
      padding: 0.5rem;
      border-radius: 0.5rem;
      color: white;
      font-size: 0.875rem;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .scale-value.visible {
      opacity: 1;
    }
    
    /* 視角效果 */
    .scene-container {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      will-change: transform;
    }
    
    /* 微觀世界元素 */
    .snail-shell {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      opacity: 0.85;
      transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 2;
    }
    
    /* 創建畫布背景層，確保文字在蝸牛前顯示 */
    .canvas-layers {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .background-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .snail-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }
    
    .ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-layer > * {
      pointer-events: auto;
    }
    
    .kingdom {
      position: absolute;
      width: 40px;
      height: 25px;
      transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 3;
    }
    
    .kingdom.left {
      left: calc(50% - 45px);
      top: calc(50% - 20px);
      transform: rotate(-15deg);
      cursor: pointer;
    }
    
    .kingdom.right {
      left: calc(50% + 15px);
      top: calc(50% - 30px);
      transform: rotate(10deg);
      cursor: pointer;
    }
    
    .kingdom-buildings {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      align-items: flex-end;
    }
    
    .building {
      width: 6px;
      background: rgba(240, 240, 240, 0.8);
      border-radius: 1px;
      transition: height 0.3s ease, background 0.3s ease;
    }
    
    .building.tall {
      height: 15px;
    }
    
    .building.medium {
      height: 10px;
    }
    
    .building.short {
      height: 7px;
    }
    
    /* 王國互動效果 */
    .kingdom:hover .building {
      background: rgba(255, 255, 255, 0.95);
    }
    
    .kingdom.left:hover .kingdom-flag {
      background: rgba(170, 120, 220, 0.95);
    }
    
    .kingdom.right:hover .kingdom-flag {
      background: rgba(120, 170, 220, 0.95);
    }
    
    /* 王國居民 */
    .citizen {
      position: absolute;
      width: 4px;
      height: 6px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 1px;
      bottom: 0;
      animation: citizen-idle 3s infinite ease-in-out;
      cursor: pointer;
      z-index: 5;
    }
    
    .citizen::after {
      content: '';
      position: absolute;
      left: 0;
      width: 4px;
      height: 2px;
      top: -2px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 2px 2px 0 0;
    }
    
    .citizen:hover {
      background: rgba(255, 255, 255, 0.9);
      animation: citizen-active 1s infinite ease-in-out;
    }
    
    .citizen:hover::after {
      background: rgba(255, 255, 255, 0.8);
    }
    
    @keyframes citizen-idle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-1px); }
    }
    
    @keyframes citizen-active {
      0%, 100% { transform: translateY(0) scale(1.2); }
      50% { transform: translateY(-2px) scale(1.2); }
    }
    
    /* 觸國（左）居民的特色 */
    .citizen.touch {
      background: rgba(200, 180, 255, 0.8);
    }
    
    .citizen.touch::after {
      background: rgba(170, 120, 220, 0.6);
    }
    
    /* 蠻國（右）居民的特色 */
    .citizen.savage {
      background: rgba(180, 200, 255, 0.8);
    }
    
    .citizen.savage::after {
      background: rgba(120, 170, 220, 0.6);
    }
    
    /* 王國名稱標籤 */
    .kingdom-label {
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .kingdom:hover .kingdom-label {
      opacity: 1;
    }
    
    /* 對話框樣式 */
    .micro-dialog {
      position: absolute;
      background: rgba(10, 10, 30, 0.8);
      border: 1px solid rgba(93, 92, 222, 0.5);
      border-radius: 8px;
      padding: 12px;
      max-width: 180px;
      font-size: 8px;
      color: white;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      z-index: 100; /* 增加z-index確保顯示在蝸牛上方 */
      pointer-events: all;
      backdrop-filter: blur(3px);
      transform-origin: center bottom;
      animation: dialog-appear 0.3s ease-out forwards;
    }
    
    @keyframes dialog-appear {
      from { transform: scale(0.7); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    
    .micro-dialog::after {
      content: '';
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid rgba(10, 10, 30, 0.8);
    }
    
    .micro-dialog-header {
      font-weight: bold;
      margin-bottom: 5px;
      color: rgba(147, 146, 255, 1);
      font-size: 9px;
    }
    
    .micro-dialog-content {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .micro-dialog-options {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .micro-dialog-option {
      background: rgba(80, 80, 120, 0.4);
      border: 1px solid rgba(147, 146, 255, 0.5);
      border-radius: 4px;
      padding: 3px 6px;
      font-size: 7px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .micro-dialog-option:hover {
      background: rgba(93, 92, 222, 0.5);
      border-color: rgba(147, 146, 255, 0.8);
    }
    
    /* 微觀視角下才顯示對話框 */
    .micro-dialog {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .micro-mode .micro-dialog {
      opacity: 1;
      pointer-events: auto;
    }
    
    .kingdom-flag {
      position: absolute;
      width: 5px;
      height: 8px;
      top: -5px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .kingdom.left .kingdom-flag {
      background: rgba(150, 100, 200, 0.9);
    }
    
    .kingdom.right .kingdom-flag {
      background: rgba(100, 150, 200, 0.9);
    }
    
    .kingdom-flag::before {
      content: '';
      position: absolute;
      width: 1px;
      height: 12px;
      background: rgba(255, 255, 255, 0.8);
      left: -1px;
      bottom: 0;
    }
    
    .battlefield {
      position: absolute;
      width: 30px;
      height: 15px;
      left: calc(50% - 15px);
      top: calc(50% - 8px);
      background: rgba(200, 50, 50, 0.2);
      border-radius: 50%;
      z-index: 2;
      overflow: hidden;
    }
    
    .soldier {
      position: absolute;
      width: 2px;
      height: 3px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 1px;
    }
    
    .snail-perspective-indicator {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding-bottom: 20%;
      color: rgba(255, 255, 255, 0.9);
      font-size: 24px;
      z-index: 50; /* 提高z-index確保顯示在蝸牛上方 */
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);
    }
    
    /* 添加文字背景，確保即使蝸牛放大也能清晰看到視角提示 */
    .snail-perspective-indicator .text-center {
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 8px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      max-width: 80%;
    }
    
    /* Cloud effects */
    .cloud {
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      filter: blur(15px);
      opacity: 0.8;
      z-index: 1;
      transition: all 0.3s ease;
    }
    
    @keyframes float-cloud {
      0%, 100% { transform: translate(0, 0); }
      50% { transform: translate(var(--cloud-dx, 20px), var(--cloud-dy, -10px)); }
    }
    
    /* Perspective scale animation */
    @keyframes scale-perspective {
      0% { transform: scale(1); }
      100% { transform: scale(var(--scale-to, 0.5)); }
    }
    
    /* Height transition for scene changes */
    .height-transition {
      transition: height 2s ease-in-out;
    }
    
    /* 蟪蛄飛行動畫 */
    @keyframes cicada-flight {
      0% { 
        transform: translate(0, 0) rotate(0deg); 
        opacity: 0.8; 
      }
      25% { 
        transform: translate(30vw, -10vh) rotate(15deg); 
        opacity: 1; 
      }
      50% { 
        transform: translate(60vw, 5vh) rotate(-10deg); 
        opacity: 0.9; 
      }
      75% { 
        transform: translate(20vw, -15vh) rotate(20deg); 
        opacity: 1; 
      }
      100% { 
        transform: translate(0, 0) rotate(0deg); 
        opacity: 0.8; 
      }
    }
    
    /* 蟪蛄翅膀扇動動畫 */
    @keyframes cicada-wing-left {
      0%, 100% { transform: rotateY(0deg) scaleX(1); }
      50% { transform: rotateY(-15deg) scaleX(0.8); }
    }
    
    @keyframes cicada-wing-right {
      0%, 100% { transform: rotateY(0deg) scaleX(1); }
      50% { transform: rotateY(15deg) scaleX(0.8); }
    }
    
    /* 章節標題專用樣式 - 加粗思源宋體 */
    .chapter-title-text {
      font-family: 'Noto Serif SC', serif;
      font-weight: 900;
      font-size: 2.5rem;
      line-height: 1.2;
      letter-spacing: 0.05em;
    }
    
    @media (min-width: 768px) {
      .chapter-title-text {
        font-size: 3.75rem;
      }
    }
    

  </style>
</head>
<body class="font-lxgw h-screen overflow-hidden">
  <div id="game-container" class="game-container relative h-screen w-screen overflow-hidden flex flex-col items-center justify-center transition-all duration-500 ease-in-out">
    
    <!-- Current Form Indicator - Enlarged and Enhanced -->
    <div id="current-form-indicator" class="absolute top-4 left-4 md:top-6 md:left-6 z-30 opacity-0 transition-opacity duration-500">
      <div class="form-icon-container bg-gradient-to-br from-white/90 to-indigo-50/70 dark:from-gray-800/90 dark:to-indigo-900/70 rounded-full p-4 
                  shadow-lg flex items-center justify-center w-[140px] h-[140px] overflow-hidden 
                  border-2 border-indigo-400/70 dark:border-indigo-500/70 
                  animate-pulse-subtle relative">
        <!-- Pulsating glow effect -->
        <div class="absolute inset-0 bg-gradient-to-r from-indigo-500/0 via-indigo-500/20 to-indigo-500/0 rounded-full 
                    animate-glow-slide pointer-events-none"></div>
        
        <!-- Rotating Outer Energy Ring -->
        <div class="absolute w-full h-full rounded-full 
                    border border-indigo-300/20 dark:border-indigo-400/20
                    animate-spin-slow">
          <div class="absolute w-3 h-3 bg-indigo-400/60 dark:bg-indigo-300/60 rounded-full top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 
                      shadow-md shadow-indigo-400/30 dark:shadow-indigo-300/30"></div>
          <div class="absolute w-2 h-2 bg-indigo-300/60 rounded-full top-1/4 right-0 transform translate-x-1/2 
                      shadow-sm shadow-indigo-300/30"></div>
          <div class="absolute w-3 h-3 bg-indigo-400/60 dark:bg-indigo-300/60 rounded-full bottom-0 left-1/2 transform -translate-x-1/2 translate-y-1/2 
                      shadow-md shadow-indigo-400/30 dark:shadow-indigo-300/30"></div>
        </div>
        
        <!-- Secondary Rotating Energy Ring (opposite direction) -->
        <div class="absolute w-[90%] h-[90%] rounded-full 
                    border border-indigo-400/20 dark:border-indigo-300/20
                    animate-spin-slow-reverse">
          <div class="absolute w-2 h-2 bg-indigo-300/60 rounded-full bottom-1/4 left-0 transform -translate-x-1/2 
                      shadow-sm shadow-indigo-300/30"></div>
          <div class="absolute w-2.5 h-2.5 bg-indigo-300/60 rounded-full top-1/3 left-0 transform -translate-x-1/2 
                      shadow-sm shadow-indigo-300/30"></div>
        </div>
                    
        <!-- Human Form Icon -->
        <div id="human-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-100 scale-100">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-human"></div>
                            <div class="emoji-unified">🧘</div>
          </div>
        </div>
        
        <!-- Butterfly Form Icon -->
        <div id="butterfly-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-butterfly"></div>
            <div class="emoji-unified">🦋</div>
          </div>
        </div>
        
        <!-- Fish Form Icon -->
        <div id="fish-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-fish"></div>
            <div class="emoji-unified">🐟</div>
          </div>
        </div>
        
        <!-- Morning Fungus Form Icon -->
        <div id="morning-fungus-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-fungus"></div>
            <div class="emoji-unified">🍄</div>
          </div>
        </div>
        
        <!-- Cicada Form Icon -->
        <div id="cicada-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-cicada"></div>
            <div class="emoji-unified">🦗</div>
          </div>
        </div>
        
        <!-- Great Chun Form Icon -->
        <div id="great-chun-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-tree"></div>
            <div class="emoji-unified">🌳</div>
          </div>
        </div>
        
        <!-- 鯤鵬圖示已移除，改為使用獨立的kun-icon和peng-icon -->
        
        <!-- Form Label -->
        <div class="absolute -bottom-1 left-1/2 transform -translate-x-1/2 bg-white/80 dark:bg-gray-800/80 
                    px-3 py-1 rounded-full text-sm font-medium text-indigo-700 dark:text-indigo-300
                    border border-indigo-200 dark:border-indigo-700 shadow-sm">
          <span id="form-label">人形</span>
        </div>
      </div>
    </div>
    
    <!-- Main Menu -->
    <div id="main-menu" class="absolute inset-0 flex flex-col items-center justify-center z-50 transition-opacity duration-500 bg-gradient-to-b from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-indigo-900 py-8">
      <!-- 標題區域 -->
      <div class="text-center mb-12 flex-shrink-0">
        <h1 class="text-4xl md:text-6xl font-bold mb-3 text-indigo-800 dark:text-indigo-300 font-serif">萬物逍遙</h1>
        <p class="text-base md:text-lg text-indigo-600 dark:text-indigo-400 font-medium">一場超越物我界限的哲學之旅</p>
      </div>
      
      <!-- 章節選擇卡片區域 -->
      <div id="chapter-selection" class="w-full max-w-4xl px-4 mb-8 flex flex-col items-center">
        <h2 class="text-lg font-semibold text-center mb-2 text-indigo-700 dark:text-indigo-300">選擇章節</h2>
        <p class="text-xs text-center text-indigo-500 dark:text-indigo-400 mb-4">按洛書九宮格排列，數字為章節序號</p>
        <div id="chapter-cards" class="chapter-grid mx-auto">
          <!-- 章節卡片將在這裡動態生成 -->
        </div>
      </div>
      
      <!-- 控制面板 -->
      <div class="flex flex-col items-center mb-6 space-y-3 flex-shrink-0">
        <!-- 設置控制區域 -->
        <div class="flex flex-col space-y-2">
          <!-- 音效開關 -->
          <div class="flex items-center space-x-3 bg-white dark:bg-gray-800 px-3 py-2 rounded-lg shadow-sm border border-gray-200 dark:border-gray-600">
            <span id="audio-icon" class="text-base transition-all duration-300">🎵</span>
            <span class="text-sm text-gray-700 dark:text-gray-300">音效</span>
            <label class="audio-switch relative inline-block w-10 h-5">
              <input type="checkbox" id="audio-toggle" checked class="opacity-0 w-0 h-0">
              <span class="audio-slider absolute cursor-pointer rounded-full inset-0 transition-all duration-300"></span>
              <span class="audio-knob absolute top-0.5 left-0.5 bg-white w-4 h-4 rounded-full shadow-sm transition-all duration-300"></span>
            </label>
            <span id="audio-status" class="text-xs text-gray-500 dark:text-gray-400 min-w-[28px]">開啟</span>
            
            <!-- 開發者模式按鈕 -->
            <button id="dev-mode-access" class="text-xs text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 px-1 py-1 rounded transition-colors">⚙️</button>
          </div>
          

        </div>
        
        <!-- 音效說明 -->
        <p class="text-xs text-center text-gray-600 dark:text-gray-400 max-w-lg whitespace-nowrap leading-normal mt-2">
          🎧 每一章都有獨特的背景音效和音樂，建議開啟音效以獲得完整的沉浸體驗
        </p>
      </div>


      <!-- 開發者面板（隱藏） -->
      <div id="dev-panel" class="hidden mt-4 p-4 bg-gray-100 dark:bg-gray-800 rounded-lg shadow-md w-full max-w-2xl">
        <div class="flex justify-end mb-3">
          <button id="close-dev-panel" class="text-gray-500 hover:text-red-500 font-bold">✕</button>
        </div>
        
        <div class="border-t border-gray-200 dark:border-gray-700 pt-3">
          <div class="grid grid-cols-3 gap-2 lg:grid-cols-3 md:grid-cols-2 sm:grid-cols-1">
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="prologue">序章：莊周夢蝶</button>
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="chapter1">第一章：子非魚</button>
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="chapter2">第二章：北冥有魚</button>
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="chapter3">第三章：鴟得腐鼠</button>
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="chapter4">第四章：蝸角之爭</button>
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="chapter5">第五章：朝菌與大椿</button>
            <button class="chapter-jump bg-gray-200 hover:bg-gray-300 dark:bg-gray-700 dark:hover:bg-gray-600 py-2 px-2 rounded text-xs" data-chapter="chapter6">第六章：天地為棺槨</button>
            <button class="chapter-jump bg-purple-200 hover:bg-purple-300 dark:bg-purple-700 dark:hover:bg-purple-600 py-2 px-2 rounded text-xs" data-chapter="chapter7">第七章：渾沌之死</button>
            <button class="chapter-jump bg-yellow-200 hover:bg-yellow-300 dark:bg-yellow-700 dark:hover:bg-yellow-600 py-2 px-2 rounded text-xs" data-chapter="epilogue">🌅 尾聲：逍遙遊</button>
          </div>
        </div>
        
        <!-- 開發者工具區域已簡化，只保留章節跳轉功能 -->
      </div>
      
      <style>
        /* 簡潔音效開關樣式 */
        .audio-switch input:checked ~ .audio-slider {
          background: #6366f1;
        }
        
        .audio-switch input:not(:checked) ~ .audio-slider {
          background: #d1d5db;
        }
        
        .audio-switch input:checked ~ .audio-knob {
          transform: translateX(20px);
        }
        
        .audio-switch input:not(:checked) ~ .audio-knob {
          transform: translateX(0);
        }
        
        /* 暗色模式適配 */
        .dark .audio-switch input:not(:checked) ~ .audio-slider {
          background: #4b5563;
        }
        

        
        /* 音效圖標狀態動畫 */
        .audio-enabled #audio-icon {
          animation: audiobeat 2s ease-in-out infinite;
        }
        
        @keyframes audiobeat {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.1); }
        }
        
        /* 開發者面板小開關樣式 */
        .switch input:checked + .slider {
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        }
        
        .switch input:checked + .slider:before {
          transform: translateX(18px);
        }
        
        .switch .slider {
          background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
        }
        
        .dark .switch .slider {
          background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
        }
        
        /* 無間距九宮格容器樣式 */
        .chapter-grid {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          grid-template-rows: repeat(3, 1fr);
          gap: 0;
          width: 360px !important;
          height: 360px !important;
          min-width: 360px;
          min-height: 360px;
          max-width: 360px;
          max-height: 360px;
          border: 3px solid #d4af37;
          border-radius: 16px;
          overflow: hidden;
          background: linear-gradient(135deg, #fdfbf7 0%, #f8f4e6 50%, #f5f0e1 100%);
          box-shadow: 
            0 8px 32px rgba(212, 175, 55, 0.15),
            0 4px 16px rgba(139, 69, 19, 0.1),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);
          flex-shrink: 0;
          aspect-ratio: 1;
          position: relative;
        }
        
        .chapter-grid::before {
          content: '';
          position: absolute;
          inset: 0;
          background: linear-gradient(45deg, 
            rgba(212, 175, 55, 0.05) 0%, 
            transparent 25%, 
            transparent 75%, 
            rgba(212, 175, 55, 0.05) 100%);
          pointer-events: none;
        }
        
        .dark .chapter-grid {
          border-color: #b8860b;
          background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #1d4ed8 100%);
          box-shadow: 
            0 8px 32px rgba(184, 134, 11, 0.2),
            0 4px 16px rgba(30, 58, 138, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .dark .chapter-grid::before {
          background: linear-gradient(45deg, 
            rgba(184, 134, 11, 0.08) 0%, 
            transparent 25%, 
            transparent 75%, 
            rgba(184, 134, 11, 0.08) 100%);
        }
        
        /* 響應式調整 */
        @media (max-width: 480px) {
          .chapter-grid {
            width: 300px !important;
            height: 300px !important;
            min-width: 300px;
            min-height: 300px;
            max-width: 300px;
            max-height: 300px;
          }
          
          /* 小屏幕上的間距調整 */
          #main-menu {
            padding-top: 2rem !important;
            padding-bottom: 2rem !important;
          }
          
          #main-menu .text-center.mb-12 {
            margin-bottom: 1.5rem !important;
          }
          
          #main-menu #chapter-selection {
            margin-bottom: 1.5rem !important;
          }
          
          #main-menu .flex.flex-col.items-center.mb-6 {
            margin-bottom: 1.5rem !important;
          }
        }
        
        @media (min-width: 768px) {
          .chapter-grid {
            width: 400px !important;
            height: 400px !important;
            min-width: 400px;
            min-height: 400px;
            max-width: 400px;
            max-height: 400px;
          }
          
          /* 中等屏幕上的間距調整 */
          #main-menu {
            padding-top: 3rem !important;
            padding-bottom: 3rem !important;
          }
        }

        /* 無間距九宮格卡片樣式 */
        .chapter-card {
          background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(248, 244, 230, 0.3) 100%);
          border-right: 1px solid rgba(212, 175, 55, 0.25);
          border-bottom: 1px solid rgba(212, 175, 55, 0.25);
          cursor: pointer;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          position: relative;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: 100%;
        }
        
        /* 移除右邊框（第3、6、9個卡片） */
        .chapter-card:nth-child(3n) {
          border-right: none;
        }
        
        /* 移除底邊框（第7、8、9個卡片） */
        .chapter-card:nth-child(n+7) {
          border-bottom: none;
        }
        
        .dark .chapter-card {
          background: linear-gradient(135deg, rgba(30, 64, 175, 0.4) 0%, rgba(29, 78, 216, 0.3) 100%);
          border-color: rgba(184, 134, 11, 0.3);
        }
        
        /* 居中洛書九宮格數字樣式 */
        .luoshu-number-center {
          width: 40px;
          height: 40px;
          min-width: 40px;
          min-height: 40px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
          font-weight: bold;
          font-family: serif;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          margin-bottom: 10px;
          flex-shrink: 0;
          border: 2px solid #d4af37;
        }
        
        /* 陽數（奇數）：白色背景，黑色文字 */
        .luoshu-number-center.luoshu-yang {
          background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 50%, #e9ecef 100%);
          color: #1a1a1a;
          text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
          box-shadow: 
            0 4px 12px rgba(212, 175, 55, 0.3),
            0 2px 6px rgba(0, 0, 0, 0.1),
            inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }
        
        /* 陰數（偶數）：黑色背景，白色文字 */
        .luoshu-number-center.luoshu-yin {
          background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #404040 100%);
          color: #ffffff;
          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
          box-shadow: 
            0 4px 12px rgba(212, 175, 55, 0.3),
            0 2px 6px rgba(0, 0, 0, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        /* 未解鎖的陽數（奇數）：淡化的白色背景 */
        .luoshu-number-center.luoshu-yang.locked {
          background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 50%, #9ca3af 100%);
          color: #4b5563;
          border-color: #9ca3af;
          box-shadow: 
            0 3px 10px rgba(156, 163, 175, 0.3),
            0 1px 4px rgba(107, 114, 128, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.3);
          opacity: 0.7;
        }
        
        /* 未解鎖的陰數（偶數）：淡化的黑色背景 */
        .luoshu-number-center.luoshu-yin.locked {
          background: linear-gradient(135deg, #6b7280 0%, #4b5563 50%, #374151 100%);
          color: #d1d5db;
          border-color: #6b7280;
          box-shadow: 
            0 3px 10px rgba(107, 114, 128, 0.3),
            0 1px 4px rgba(75, 85, 99, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
          opacity: 0.7;
        }
        
        .dark .luoshu-number-center.luoshu-yang {
          background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
          color: #1a1a1a;
          border-color: #fbbf24;
          box-shadow: 
            0 4px 12px rgba(251, 191, 36, 0.4),
            0 2px 6px rgba(0, 0, 0, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }
        
        .dark .luoshu-number-center.luoshu-yin {
          background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 50%, #2d2d2d 100%);
          color: #ffffff;
          border-color: #fbbf24;
          box-shadow: 
            0 4px 12px rgba(251, 191, 36, 0.4),
            0 2px 6px rgba(0, 0, 0, 0.6),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        .dark .luoshu-number-center.luoshu-yang.locked {
          background: linear-gradient(135deg, #d1d5db 0%, #9ca3af 50%, #6b7280 100%);
          color: #374151;
          border-color: #9ca3af;
          box-shadow: 
            0 3px 10px rgba(209, 213, 219, 0.2),
            0 1px 4px rgba(156, 163, 175, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);
          opacity: 0.7;
        }
        
        .dark .luoshu-number-center.luoshu-yin.locked {
          background: linear-gradient(135deg, #4b5563 0%, #374151 50%, #1f2937 100%);
          color: #9ca3af;
          border-color: #4b5563;
          box-shadow: 
            0 3px 10px rgba(75, 85, 99, 0.2),
            0 1px 4px rgba(55, 65, 81, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
          opacity: 0.7;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yang {
          transform: scale(1.15);
          box-shadow: 
            0 8px 25px rgba(212, 175, 55, 0.5),
            0 4px 15px rgba(0, 0, 0, 0.15),
            inset 0 2px 0 rgba(255, 255, 255, 0.9);
          background: linear-gradient(135deg, #ffffff 0%, #ffffff 50%, #f1f3f4 100%);
          border-color: #e6c547;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yin {
          transform: scale(1.15);
          box-shadow: 
            0 8px 25px rgba(212, 175, 55, 0.5),
            0 4px 15px rgba(0, 0, 0, 0.6),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
          background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 50%, #2d2d2d 100%);
          border-color: #e6c547;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yang.locked {
          box-shadow: 
            0 6px 20px rgba(156, 163, 175, 0.4),
            0 3px 12px rgba(107, 114, 128, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);
          background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 50%, #d1d5db 100%);
          opacity: 0.85;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yin.locked {
          box-shadow: 
            0 6px 20px rgba(107, 114, 128, 0.4),
            0 3px 12px rgba(75, 85, 99, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
          background: linear-gradient(135deg, #6b7280 0%, #4b5563 50%, #374151 100%);
          opacity: 0.85;
        }
        
        /* 章節emoji圖標樣式 */
        .chapter-emoji {
          font-size: 20px;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          flex-shrink: 0;
          line-height: 1;
          filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }
        
        .chapter-emoji.locked {
          font-size: 18px;
          opacity: 0.7;
        }
        
        .chapter-card:hover .chapter-emoji {
          transform: scale(1.1) translateY(-2px);
          filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
        }
        
        .chapter-card:hover .chapter-emoji.locked {
          transform: scale(1.05) translateY(-1px);
          filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.12));
        }
        

        
        .chapter-card:hover {
          background: linear-gradient(135deg, rgba(212, 175, 55, 0.1) 0%, rgba(255, 255, 255, 0.6) 50%, rgba(212, 175, 55, 0.1) 100%);
          transform: scale(1.02);
          box-shadow: inset 0 0 20px rgba(212, 175, 55, 0.1);
        }
        
        .dark .chapter-card:hover {
          background: linear-gradient(135deg, rgba(184, 134, 11, 0.15) 0%, rgba(30, 64, 175, 0.7) 50%, rgba(184, 134, 11, 0.15) 100%);
          box-shadow: inset 0 0 20px rgba(184, 134, 11, 0.1);
        }
        
        .chapter-card.unlocked {
          cursor: pointer;
        }
        
        .chapter-card.locked {
          opacity: 0.6;
          cursor: pointer;
        }
        
        .chapter-card.locked:hover {
          background: rgba(148, 163, 184, 0.1);
          opacity: 0.8;
          transform: scale(1.01);
        }
        
        .chapter-card.current {
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.2) 0%, rgba(251, 191, 36, 0.15) 50%, rgba(245, 158, 11, 0.2) 100%);
          border-color: rgba(245, 158, 11, 0.4);
          box-shadow: 
            inset 0 0 15px rgba(245, 158, 11, 0.1),
            0 0 0 1px rgba(245, 158, 11, 0.2);
        }
        
        .dark .chapter-card.current {
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.25) 0%, rgba(251, 191, 36, 0.2) 50%, rgba(245, 158, 11, 0.25) 100%);
          border-color: rgba(245, 158, 11, 0.5);
          box-shadow: 
            inset 0 0 15px rgba(245, 158, 11, 0.15),
            0 0 0 1px rgba(245, 158, 11, 0.3);
        }
        

        
        /* 九宮格響應式優化 */
        @media (max-width: 480px) {
          .luoshu-number-center {
            width: 36px;
            height: 36px;
            min-width: 36px;
            min-height: 36px;
            font-size: 18px;
            margin-bottom: 8px;
          }
          
          .chapter-emoji {
            font-size: 16px;
          }
          
          .chapter-emoji.locked {
            font-size: 15px;
          }
        }
        
        @media (min-width: 768px) {
          .luoshu-number-center {
            width: 44px;
            height: 44px;
            min-width: 44px;
            min-height: 44px;
            font-size: 22px;
            margin-bottom: 12px;
          }
          
          .chapter-emoji {
            font-size: 24px;
          }
          
          .chapter-emoji.locked {
            font-size: 20px;
          }
        }
        

        

        

        
        /* 按鈕漣漪效果 */
        .chapter-jump:active {
          transform: scale(0.98);
        }
      </style>
    </div>
    
    <!-- Hunlun (Chaos) Container with Seven Apertures -->
    <div id="apertures-tracker" class="absolute top-4 right-4 md:top-6 md:right-6 aperture-container opacity-0 transition-opacity duration-500">
      <!-- Subtle face pattern -->
      <div class="face-pattern" id="face-pattern"></div>
      
      <!-- Individual apertures - no rotating holder -->
      <div class="aperture aperture-random aperture-left-eye" title="左目之竅">👁️‍🗨️</div>
      <div class="aperture aperture-random aperture-right-eye" title="右目之竅">👁️‍🗨️</div>
      <div class="aperture aperture-random aperture-left-ear" title="左耳之竅">👂</div>
      <div class="aperture aperture-random aperture-right-ear" title="右耳之竅">👂</div>
      <div class="aperture aperture-random aperture-left-nose" title="左鼻之竅">⚫</div>
      <div class="aperture aperture-random aperture-right-nose" title="右鼻之竅">⚫</div>
      <div class="aperture aperture-random aperture-mouth" title="口之竅">👄</div>
    </div>
    
    <!-- Chapter Title Display -->
    <div id="chapter-title" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80 z-40 opacity-0 pointer-events-none transition-opacity duration-1000">
      <h2 id="chapter-name" class="chapter-title-text text-white mb-4"></h2>
      <p id="chapter-description" class="text-xl text-gray-200 max-w-md text-center"></p>
    </div>
    
    <!-- Game Content -->
    <div id="game-content" class="w-full h-full relative flex flex-col items-center justify-center opacity-0 transition-opacity duration-500">
      <!-- Scene will be inserted here -->
    </div>
    
    <!-- 繼續按鈕，放置在遊戲內容下方，與物化按鈕間保持適當距離 -->
    <div class="fixed left-0 right-0 flex justify-center" style="top: 78%;">
      <button id="advance-btn" class="hidden pointer-events-auto z-20">
        繼續
      </button>
    </div>
    
    <!-- User Interface -->
    <div id="game-ui" class="absolute bottom-0 left-0 right-0 p-4 md:p-6 flex flex-col items-center opacity-0 transition-opacity duration-500 pointer-events-none">      
      
      <!-- 形態切換按鈕 -->
      <div class="form-selector flex gap-2 justify-center mt-auto pointer-events-auto">
        <button id="human-form" class="form-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50">
          人形
        </button>
        <button id="butterfly-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50">
          蝴蝶
        </button>
        <button id="fish-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          儵魚
        </button>
        <button id="kun-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          鯤
        </button>
        <button id="peng-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          鵬
        </button>
                  <button id="yuanchu-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
            鵷鶵
          </button>
          <button id="chixiao-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
            鴟鴞
        </button>
        <button id="snail-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          蝸牛
        </button>
        <button id="morning-fungus-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          朝菌
        </button>
        <button id="cicada-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          蟪蛄
        </button>
        <button id="great-chun-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          大椿
        </button>
        <button id="ant-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          螻蟻
        </button>
        <button id="star-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          星辰
        </button>
        <button id="qi-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          氣
        </button>
      </div>
    </div>
    
    <!-- Dialog Box -->
    <div id="dialog-box" class="absolute top-1/2 left-0 right-0 mx-auto max-w-3xl -translate-y-1/2 bg-white dark:bg-gray-800 border-2 border-indigo-600 dark:border-indigo-500 rounded-lg p-4 shadow-lg opacity-0 transition-all duration-300 transform">
      <p id="dialog-text" class="text-gray-800 dark:text-gray-200"></p>
      <div id="dialog-options" class="mt-4 flex flex-col gap-2 relative" style="z-index: 100;">
        <!-- Dialog options will be inserted here -->
      </div>
    </div>
  </div>

  <script>
    // 暗色主題系統（固定為暗色模式）
    let themePreference = 'dark';
    
    // 初始化主題（固定暗色模式）
    function initializeTheme() {
      document.documentElement.classList.add('dark');
    }
    

    

    
    // 初始化主題
    initializeTheme();
    
    // 统一Emoji物化角色映射系统
    const emojiFormMap = {
              human: { emoji: '🧘', name: '人形', glow: 'emoji-glow-human' },
      butterfly: { emoji: '🦋', name: '蝴蝶', glow: 'emoji-glow-butterfly' },
      fish: { emoji: '🐟', name: '儵魚', glow: 'emoji-glow-fish' },
      kun: { emoji: '🐋', name: '鯤', glow: 'emoji-glow-kun' },
      peng: { emoji: '🦅', name: '鵬', glow: 'emoji-glow-peng' },
      yuanchu: { emoji: '🦚', name: '鵷鶵', glow: 'emoji-glow-yuanchu' },
      chixiao: { emoji: '🦉', name: '鴟鴞', glow: 'emoji-glow-chixiao' },
      snail: { emoji: '🐌', name: '蝸牛', glow: 'emoji-glow-snail' },
      'morning-fungus': { emoji: '🍄', name: '朝菌', glow: 'emoji-glow-fungus' },
      cicada: { emoji: '🦗', name: '蟪蛄', glow: 'emoji-glow-cicada' },
      'great-chun': { emoji: '🌳', name: '大椿', glow: 'emoji-glow-tree' },
      ant: { emoji: '🐜', name: '螻蟻', glow: 'emoji-glow-ant' },
      star: { emoji: '⭐', name: '星辰', glow: 'emoji-glow-star' },
      qi: { emoji: '💨', name: '氣', glow: 'emoji-glow-qi' }
    };

    // 创建统一的emoji图标
    function createEmojiIcon(formType, isTransformation = false) {
      const formData = emojiFormMap[formType];
      if (!formData) return null;

      const container = document.createElement('div');
      container.className = 'emoji-form-icon';
      
      if (!isTransformation) {
        const glowBg = document.createElement('div');
        glowBg.className = `emoji-glow-bg ${formData.glow}`;
        container.appendChild(glowBg);
      }
      
      const emoji = document.createElement('div');
      emoji.className = isTransformation ? 'emoji-unified transformation-emoji' : 'emoji-unified';
      emoji.textContent = formData.emoji;
      container.appendChild(emoji);
      
      return container;
    }

    // 确保指定形态的图标存在（修复变身动画空白问题）
    function ensureIconExists(formType) {
      const iconId = `${formType}-icon`;
      const existingIcon = document.getElementById(iconId);
      
      // 如果图标已存在，直接返回
      if (existingIcon) {
        return existingIcon;
      }
      
      // 获取图标容器
      const formIconContainer = document.querySelector('.form-icon-container');
      if (!formIconContainer) {
        console.warn(`无法找到图标容器，无法创建${formType}图标`);
        return null;
      }
      
      // 检查是否是需要动态创建的图标类型
      const dynamicIcons = ['kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      if (!dynamicIcons.includes(formType)) {
        // 静态图标应该已经在HTML中存在
        return existingIcon;
      }
      
      // 动态创建缺失的图标
      console.log(`🔧 创建缺失的${formType}图标用于变身动画`);
      const newIcon = document.createElement('div');
      newIcon.id = iconId;
      newIcon.className = 'absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0';
      newIcon.appendChild(createEmojiIcon(formType));
      formIconContainer.appendChild(newIcon);
      
      return newIcon;
    }

    // 为变身动画添加统一的发光能量粒子效果
    function addTransformationParticleEffects(toForm, iconContainer) {
      const effectConfig = {
        'human': { count: 12, color: 'rgba(147, 146, 255, 0.9)' },
        'butterfly': { count: 15, color: 'rgba(147, 51, 234, 0.9)' },
        'fish': { count: 18, color: 'rgba(59, 130, 246, 0.9)' },
        'kun': { count: 16, color: 'rgba(6, 182, 212, 0.9)' },
        'peng': { count: 14, color: 'rgba(14, 165, 233, 0.9)' },
        'yuanchu': { count: 16, color: 'rgba(255, 215, 0, 0.9)' },
        'chixiao': { count: 12, color: 'rgba(139, 69, 19, 0.9)' },
        'snail': { count: 10, color: 'rgba(147, 50, 158, 0.9)' },
        'morning-fungus': { count: 14, color: 'rgba(245, 158, 11, 0.9)' },
        'cicada': { count: 13, color: 'rgba(34, 197, 94, 0.9)' },
        'great-chun': { count: 20, color: 'rgba(22, 163, 74, 0.9)' },
        'ant': { count: 8, color: 'rgba(120, 53, 15, 0.9)' },
        'star': { count: 25, color: 'rgba(255, 215, 0, 0.9)' },
        'qi': { count: 20, color: 'rgba(147, 146, 255, 0.8)' }
      };

      const config = effectConfig[toForm] || { count: 12, color: 'rgba(255, 255, 255, 0.9)' };

      // 创建统一的发光能量粒子效果
      for (let i = 0; i < config.count; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = `${3 + Math.random() * 4}px`;
        particle.style.height = `${3 + Math.random() * 4}px`;
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = config.color;
        particle.style.boxShadow = `0 0 ${6 + Math.random() * 8}px ${config.color}`;
        particle.style.pointerEvents = 'none';
        particle.style.zIndex = '1000';
        
        // 随机起始位置（围绕中心）
        const angle = Math.random() * Math.PI * 2;
        const startDistance = 20 + Math.random() * 30;
        const startX = Math.cos(angle) * startDistance;
        const startY = Math.sin(angle) * startDistance;
        
        particle.style.left = `calc(50% + ${startX}px)`;
        particle.style.top = `calc(50% + ${startY}px)`;
        
        // 添加动画
        const delay = Math.random() * 1.5;
        particle.style.animation = `energy-particle-transform 2s ${delay}s ease-out forwards`;
        
        iconContainer.appendChild(particle);
      }

      // 添加统一的能量粒子动画样式（如果不存在）
      if (!document.getElementById('energy-particle-transform-style')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'energy-particle-transform-style';
        styleEl.innerHTML = `
          @keyframes energy-particle-transform {
            0% { 
              transform: scale(0.3) translate(0, 0); 
              opacity: 0; 
            }
            15% { 
              opacity: 1; 
              transform: scale(1) translate(0, 0); 
            }
            100% { 
              transform: scale(0.1) translate(${-80 + Math.random() * 160}px, ${-80 + Math.random() * 160}px); 
              opacity: 0; 
            }
          }
        `;
        document.head.appendChild(styleEl);
      }
    }
    
    // Game state
    const gameState = {
      currentChapter: 'menu',
      currentScene: 0,
      dialogIndex: 0,
      unlockedForms: ['human'],
      currentForm: 'human',
      transformationInProgress: null, // 記錄正在進行的物化形態
      collectedApertures: [],
      hasDonePrologue: false,
      segmentationPuzzleState: {
        solved: false,
        segments: []
      },
              // birdState removed - 鵷鶵 and 鴟鴞 are now independent forms
      viewScale: 100, // 視角縮放值：100為正常比例，0為最微觀，200為最宏觀
      scaleEnabled: false, // 是否啟用視角縮放功能
      formSequenceGuideActive: false, // 萬物回響引導是否激活（保留兼容性）
      handleFormSequenceClick: null, // 萬物回響點擊處理函數（保留兼容性）
      // 新增：區分初次物化和日常物化
      isInDailyTransformation: false, // 是否處於日常物化狀態
      dailyTransformationPreviousForm: null, // 日常物化前的原始形態
      dailyTransformationAdvanceBtnVisible: false, // 日常物化前繼續按鈕是否可見
      firstTimeUnlockInProgress: false, // 是否正在進行初次解鎖物化
      pendingFormUnlock: null, // 待解鎖的形態（用於初次物化按鈕）
      // 新增：第七章萬物尋氣系統
      baguaLearningCompleted: false,    // 八卦學習是否完成
      wanwuXunqiActive: false,          // 萬物尋氣模式是否激活
      currentBaguaCollection: null,     // 當前收集的八卦類型
      baguaCollectionCount: 0,          // 當前八卦收集數量
      wanwuXunqiProgress: [],           // 已完成的物化形態列表
      wanwuXunqiCurrentFormIndex: 0,    // 當前萬物尋氣的物化形態索引
      // 新增：音頻系統
      audioEnabled: true,               // 音頻是否開啟
      currentBackgroundMusic: null,     // 當前播放的背景音樂
      // 新增：開發者模式狀態
      devMode: false,                   // 開發者模式是否開啟
      devModeAccessedViaPassword: false, // 是否通過密碼進入開發者模式
      
      // 新增：玩家選擇記錄系統 - 用於AI個性化分析和故事影響
      playerChoices: {
        // 選擇歷史記錄
        choiceHistory: [],
        
        // 時間戳記錄
        timingData: {
          sceneStartTime: null,          // 當前場景開始時間
          choiceStartTime: null,         // 選擇開始時間（選項出現時）
          totalThinkingTime: 0,          // 總思考時間
          averageThinkingTime: 0         // 平均思考時間
        },
        
        // 新增：場景停留時間數據
        sceneDwellTime: {
          currentSceneStartTime: null,   // 當前場景開始時間
          sceneDwellTimes: {},           // 各場景停留時間記錄 {chapter_scene: time}
          averageDwellTime: 0,           // 平均場景停留時間
          totalDwellTime: 0              // 總停留時間
        },
        
        // 新增：物化體驗數據
        transformationData: {
          transformationHistory: [],     // 物化歷史記錄
          formUsageCount: {},            // 各形態使用次數
          transformationDurations: {},   // 各形態停留時間
          firstTimeTransformations: [],  // 初次物化記錄
          dailyTransformations: [],      // 日常物化記錄
          transformationPatterns: {      // 物化模式分析
            preferredForms: [],          // 偏好形態
            transformationFrequency: 0,  // 物化頻率
            explorationDepth: 0,         // 探索深度
            comfortZone: [],             // 舒適區形態
            experimentalForms: []        // 實驗性形態
          }
        },
        
        // 新增：斷句挑戰表現數據
        segmentationPuzzleData: {
          puzzleAttempts: {},            // 各章節斷句挑戰嘗試記錄
          completionTimes: {},           // 完成時間記錄
          accuracyRates: {},             // 準確率記錄
          hintUsage: {},                 // 提示使用情況
          puzzlePerformance: {           // 整體表現分析
            averageCompletionTime: 0,    // 平均完成時間
            averageAccuracy: 0,          // 平均準確率
            learningCurve: [],           // 學習曲線
            difficultyAdaptation: 0,     // 難度適應能力
            persistenceLevel: 0          // 堅持程度
          }
        },
        
        // 哲學傾向統計（隱蔽的分數系統）- 人生價值觀與世界觀
        philosophicalTraits: {
          compassion: 0,           // 同理心 - "你總是能感受到他人的情感"
          idealism: 0,             // 理想主義 - "你心中有美好世界的藍圖"
          harmony: 0,              // 和諧追求 - "你渴望內心與世界的平衡"
          wisdom_seeking: 0,       // 智慧追求 - "你不滿足於表面答案"
          acceptance: 0,           // 接納包容 - "你能接受事物的本來面目"
          beauty_appreciation: 0,  // 美的感受 - "你對美有敏銳的感知"
          transcendence: 0,        // 超脫境界 - "你能跳出日常的束縛"
          authenticity: 0          // 真實自然 - "你追求做真實的自己"
        },
        
        // MBTI人格維度評分 (0-100)
        mbtiTraits: {
          // 態度指向：外向(E) vs 內向(I)
          extraversion: 0,      // 外向：關注外部世界，精力來源於外部刺激
          introversion: 0,      // 內向：關注內心世界，精力來源於內省
          
          // 認知功能：感覺(S) vs 直覺(N)
          sensing: 0,           // 感覺：關注現實、細節、具體經驗
          intuition: 0,         // 直覺：關注可能性、抽象概念、未來
          
          // 判斷功能：思考(T) vs 情感(F)
          thinking: 0,          // 思考：基於邏輯和客觀分析做決策
          feeling: 0,           // 情感：基於價值觀和情感做決策
          
          // 生活方式：判斷(J) vs 感知(P)
          judging: 0,           // 判斷：喜歡計劃性、確定性、結論
          perceiving: 0         // 感知：喜歡靈活性、開放性、探索
        },
        
        // 故事情節相關數據 - 個性特質與生活態度
        storyTraits: {
          gentleness: 0,        // 溫柔細膩 - "你待人溫和，處事細心"
          curiosity: 0,         // 好奇探索 - "你對未知充滿渴望"
          resilience: 0,        // 堅韌不拔 - "你能在困難中保持堅強"
          introspection: 0,     // 內省深思 - "你習慣深入思考自己"
          courage: 0,           // 勇敢冒險 - "你敢於面對挑戰"
          creativity: 0,        // 創造想像 - "你有豐富的想像力"
          independence: 0,      // 獨立自主 - "你喜歡按自己的方式生活"
          emotional_depth: 0    // 情感豐富 - "你的內心世界很豐富"
        },
        
        // 選擇模式分析
        choicePatterns: {
          consistencyScore: 0,     // 一致性評分
          contradictions: [],      // 矛盾選擇記錄
          evolutionTrend: [],      // 思想演化趨勢
          dominantTraits: [],      // 主導特質
          secondaryTraits: [],     // 次要特質
          storyBranches: []        // 故事分支影響記錄
        },
        
        // 章節特定選擇影響
        chapterInfluences: {
          prologue: { choices: [], storyBranch: 'default' },
          chapter1: { choices: [], storyBranch: 'default' },
          chapter2: { choices: [], storyBranch: 'default' },
          chapter3: { choices: [], storyBranch: 'default' },
          chapter4: { choices: [], storyBranch: 'default' },
          chapter5: { choices: [], storyBranch: 'default' },
          chapter6: { choices: [], storyBranch: 'default' },
          chapter7: { choices: [], storyBranch: 'default' },
          epilogue: { choices: [], storyBranch: 'default' }
        },
        
        // 章節選擇統計
        chapterChoices: {},
        
        // AI調用準備數據
        aiContext: {
          lastUpdateTime: null,
          profileSummary: '',
          mbtiType: '',              // 推測的MBTI類型
          philosophicalType: '',     // 莊子哲學性格類型
          recentTrends: [],
          suggestedResponseStyle: '',
          storyPersonalization: {    // 故事個性化數據
            preferredNarrativeStyle: '', // 偏好的敘述風格
            emotionalResonance: [],      // 情感共鳴點
            challengeLevel: '',          // 適合的挑戰難度
            guidanceNeed: ''            // 指導需求程度
          }
        }
      }
    };

    // 玩家選擇記錄和分析系統
    
    // 記錄物化體驗數據
    function recordTransformationData(form, isDailyTransformation, fromForm) {
      const timestamp = Date.now();
      
      // 構建物化記錄
      const transformationRecord = {
        timestamp: timestamp,
        form: form,
        fromForm: fromForm,
        type: isDailyTransformation ? 'daily' : 'story',
        chapter: gameState.currentChapter,
        scene: gameState.currentScene,
        context: {
          unlockedForms: [...gameState.unlockedForms],
          currentForm: form
        }
      };
      
      // 添加到歷史記錄
      gameState.playerChoices.transformationData.transformationHistory.push(transformationRecord);
      
      // 更新使用次數統計
      if (!gameState.playerChoices.transformationData.formUsageCount[form]) {
        gameState.playerChoices.transformationData.formUsageCount[form] = 0;
      }
      gameState.playerChoices.transformationData.formUsageCount[form]++;
      
      // 記錄初次物化
      if (!gameState.playerChoices.transformationData.firstTimeTransformations.includes(form)) {
        gameState.playerChoices.transformationData.firstTimeTransformations.push(form);
        transformationRecord.isFirstTime = true;
      }
      
      // 記錄日常物化
      if (isDailyTransformation) {
        gameState.playerChoices.transformationData.dailyTransformations.push(transformationRecord);
      }
      
      // 更新物化模式分析
      updateTransformationPatterns();
      
      console.log(`🔄 物化數據記錄: ${fromForm} -> ${form} (${isDailyTransformation ? '日常' : '劇情'})`);
    }
    
    // 更新物化模式分析
    function updateTransformationPatterns() {
      const data = gameState.playerChoices.transformationData;
      
      // 計算物化頻率
      data.transformationPatterns.transformationFrequency = data.transformationHistory.length;
      
      // 找出偏好形態（使用次數最多的前3個）
      const sortedForms = Object.entries(data.formUsageCount)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3)
        .map(([form]) => form);
      data.transformationPatterns.preferredForms = sortedForms;
      
      // 計算探索深度（使用過的形態數量）
      data.transformationPatterns.explorationDepth = Object.keys(data.formUsageCount).length;
      
      // 找出舒適區形態（使用次數最多的）
      data.transformationPatterns.comfortZone = sortedForms.slice(0, 1);
      
      // 找出實驗性形態（只使用過1次的）
      data.transformationPatterns.experimentalForms = Object.entries(data.formUsageCount)
        .filter(([,count]) => count === 1)
        .map(([form]) => form);
    }
    
    // 記錄斷句挑戰嘗試數據
    function recordSegmentationPuzzleAttempt(isCorrect) {
      const puzzleKey = `${gameState.currentChapter}_${gameState.currentScene}`;
      const data = gameState.playerChoices.segmentationPuzzleData;
      
      // 初始化章節記錄
      if (!data.puzzleAttempts[puzzleKey]) {
        data.puzzleAttempts[puzzleKey] = {
          attempts: 0,
          correctAttempts: 0,
          incorrectAttempts: 0,
          startTime: Date.now(),
          lastAttemptTime: null
        };
      }
      
      const puzzleRecord = data.puzzleAttempts[puzzleKey];
      puzzleRecord.attempts++;
      puzzleRecord.lastAttemptTime = Date.now();
      
      if (isCorrect) {
        puzzleRecord.correctAttempts++;
      } else {
        puzzleRecord.incorrectAttempts++;
      }
      
      console.log(`🧩 斷句挑戰嘗試記錄: ${puzzleKey} - 第${puzzleRecord.attempts}次嘗試 (${isCorrect ? '正確' : '錯誤'})`);
    }
    
    // 記錄斷句挑戰完成數據
    function recordSegmentationPuzzleCompletion(isSuccessful) {
      const puzzleKey = `${gameState.currentChapter}_${gameState.currentScene}`;
      const data = gameState.playerChoices.segmentationPuzzleData;
      
      if (!data.puzzleAttempts[puzzleKey]) {
        return; // 如果沒有嘗試記錄，直接返回
      }
      
      const puzzleRecord = data.puzzleAttempts[puzzleKey];
      const completionTime = Date.now() - puzzleRecord.startTime;
      
      // 記錄完成時間
      data.completionTimes[puzzleKey] = completionTime;
      
      // 計算準確率
      const accuracy = puzzleRecord.correctAttempts / puzzleRecord.attempts;
      data.accuracyRates[puzzleKey] = accuracy;
      
      // 更新整體表現分析
      updatePuzzlePerformanceAnalysis();
      
      console.log(`✅ 斷句挑戰完成記錄: ${puzzleKey} - 完成時間: ${completionTime}ms, 準確率: ${(accuracy * 100).toFixed(1)}%`);
    }
    
    // 更新斷句挑戰表現分析
    function updatePuzzlePerformanceAnalysis() {
      const data = gameState.playerChoices.segmentationPuzzleData;
      const performance = data.puzzlePerformance;
      
      // 計算平均完成時間
      const completionTimes = Object.values(data.completionTimes);
      if (completionTimes.length > 0) {
        performance.averageCompletionTime = completionTimes.reduce((sum, time) => sum + time, 0) / completionTimes.length;
      }
      
      // 計算平均準確率
      const accuracyRates = Object.values(data.accuracyRates);
      if (accuracyRates.length > 0) {
        performance.averageAccuracy = accuracyRates.reduce((sum, rate) => sum + rate, 0) / accuracyRates.length;
      }
      
      // 計算學習曲線（按章節順序）
      performance.learningCurve = Object.keys(data.completionTimes)
        .sort()
        .map(key => ({
          puzzle: key,
          completionTime: data.completionTimes[key],
          accuracy: data.accuracyRates[key]
        }));
      
      // 計算難度適應能力（後期章節的表現改善程度）
      if (performance.learningCurve.length >= 2) {
        const earlyPerformance = performance.learningCurve.slice(0, Math.ceil(performance.learningCurve.length / 2));
        const latePerformance = performance.learningCurve.slice(Math.ceil(performance.learningCurve.length / 2));
        
        const earlyAvgTime = earlyPerformance.reduce((sum, p) => sum + p.completionTime, 0) / earlyPerformance.length;
        const lateAvgTime = latePerformance.reduce((sum, p) => sum + p.completionTime, 0) / latePerformance.length;
        
        performance.difficultyAdaptation = earlyAvgTime > 0 ? (earlyAvgTime - lateAvgTime) / earlyAvgTime : 0;
      }
      
      // 計算堅持程度（總嘗試次數）
      const totalAttempts = Object.values(data.puzzleAttempts)
        .reduce((sum, record) => sum + record.attempts, 0);
      performance.persistenceLevel = totalAttempts;
    }
    
    // 獲取完整的玩家數據用於AI報告生成
    function getCompletePlayerData() {
      // 計算平均場景停留時間
      const sceneDwellTimes = Object.values(gameState.playerChoices.sceneDwellTime.sceneDwellTimes);
      if (sceneDwellTimes.length > 0) {
        gameState.playerChoices.sceneDwellTime.averageDwellTime = 
          sceneDwellTimes.reduce((sum, time) => sum + time, 0) / sceneDwellTimes.length;
      }
      
      return {
        // 基本信息
        totalPlayTime: gameState.playerChoices.sceneDwellTime.totalDwellTime,
        averageSceneDwellTime: gameState.playerChoices.sceneDwellTime.averageDwellTime,
        totalChoices: gameState.playerChoices.choiceHistory.length,
        
        // 選擇數據
        choiceHistory: gameState.playerChoices.choiceHistory,
        philosophicalTraits: gameState.playerChoices.philosophicalTraits,
        mbtiTraits: gameState.playerChoices.mbtiTraits,
        storyTraits: gameState.playerChoices.storyTraits,
        
        // 物化體驗數據
        transformationData: {
          totalTransformations: gameState.playerChoices.transformationData.transformationHistory.length,
          formUsageCount: gameState.playerChoices.transformationData.formUsageCount,
          firstTimeTransformations: gameState.playerChoices.transformationData.firstTimeTransformations,
          dailyTransformations: gameState.playerChoices.transformationData.dailyTransformations.length,
          transformationPatterns: gameState.playerChoices.transformationData.transformationPatterns
        },
        
        // 斷句挑戰數據
        segmentationPuzzleData: {
          totalPuzzles: Object.keys(gameState.playerChoices.segmentationPuzzleData.puzzleAttempts).length,
          averageCompletionTime: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.averageCompletionTime,
          averageAccuracy: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.averageAccuracy,
          learningCurve: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.learningCurve,
          difficultyAdaptation: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.difficultyAdaptation,
          persistenceLevel: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.persistenceLevel
        },
        
        // 遊戲進度
        gameProgress: {
          currentChapter: gameState.currentChapter,
          unlockedForms: gameState.unlockedForms,
          collectedApertures: gameState.collectedApertures,
          totalApertures: gameState.collectedApertures.length
        },
        
        // 時間數據
        timingData: gameState.playerChoices.timingData,
        
        // 章節影響
        chapterInfluences: gameState.playerChoices.chapterInfluences
      };
    }
    
    // 記錄玩家選擇（核心函數）
    function recordPlayerChoice(choiceData) {
      const timestamp = Date.now();
      const thinkingTime = gameState.playerChoices.timingData.choiceStartTime ? 
        timestamp - gameState.playerChoices.timingData.choiceStartTime : 0;
      
      console.log('📝 ===== 玩家選擇記錄調試信息 =====');
      console.log('🎯 記錄時間:', new Date().toLocaleTimeString());
      console.log('📊 輸入的選擇數據:', choiceData);
      console.log('⏱️ 思考時間:', `${Math.round(thinkingTime / 1000)}秒 (${thinkingTime}ms)`);
      
      // 檢查是否已經有這個位置的選擇記錄
      const existingChoiceIndex = gameState.playerChoices.choiceHistory.findIndex(choice => 
        choice.chapter === gameState.currentChapter && choice.scene === gameState.currentScene
      );
      
      if (existingChoiceIndex !== -1) {
        const existingChoice = gameState.playerChoices.choiceHistory[existingChoiceIndex];
        console.log('🔄 發現同位置的舊選擇:', existingChoice.choiceText);
        console.log('🔄 新選擇:', choiceData.text);
        
        // 如果選擇不同，先移除舊選擇的特質影響
        if (existingChoice.choiceText !== choiceData.text) {
          console.log('🔄 選擇不同，移除舊選擇的特質影響...');
          removeTraitInfluence(existingChoice);
          
          // 從歷史記錄中移除舊選擇
          gameState.playerChoices.choiceHistory.splice(existingChoiceIndex, 1);
          
          // 從章節特定選擇中移除
          removeChapterSpecificChoice(existingChoice);
          
          console.log('🔄 舊選擇已移除，準備記錄新選擇');
        } else {
          console.log('🔄 選擇相同，跳過重複記錄');
          return;
        }
      }
      
      // 構建選擇記錄
      const choiceRecord = {
        id: generateChoiceId(),
        timestamp: timestamp,
        chapter: gameState.currentChapter,
        scene: gameState.currentScene,
        choiceText: choiceData.text,
        choiceIndex: choiceData.index || 0,
        thinkingTime: thinkingTime,
        context: {
          speaker: choiceData.speaker || 'unknown',
          situation: choiceData.situation || '',
          currentForm: gameState.currentForm
        },
        // 隱蔽的特質標記
        traits: {
          philosophical: choiceData.philosophical || {},
          mbti: choiceData.mbti || {},
          story: choiceData.story || {}
        },
        // 故事分支影響
        storyImpact: choiceData.storyImpact || {}
      };
      
      console.log('🔍 構建的選擇記錄:', {
        id: choiceRecord.id,
        chapter: choiceRecord.chapter,
        scene: choiceRecord.scene,
        choiceText: choiceRecord.choiceText,
        thinkingTime: `${Math.round(choiceRecord.thinkingTime / 1000)}s`,
        traits: choiceRecord.traits
      });
      
      // 添加到歷史記錄
      gameState.playerChoices.choiceHistory.push(choiceRecord);
      
      console.log('📚 選擇歷史更新:', {
        總選擇數: gameState.playerChoices.choiceHistory.length,
        本章選擇數: gameState.playerChoices.choiceHistory.filter(c => c.chapter === gameState.currentChapter).length
      });
      
      // 記錄章節特定選擇
      recordChapterSpecificChoice(choiceRecord);
      
      // 更新時間統計
      updateTimingStatistics(thinkingTime);
      
      // 更新哲學傾向分數
      const oldPhilosophicalTraits = { ...gameState.playerChoices.philosophicalTraits };
      updatePhilosophicalTraits(choiceData.philosophical || {});
      console.log('🧠 哲學特質更新:', {
        更新前: oldPhilosophicalTraits,
        更新後: gameState.playerChoices.philosophicalTraits,
        本次增加: choiceData.philosophical
      });
      
      // 更新MBTI維度分數
      const oldMBTITraits = { ...gameState.playerChoices.mbtiTraits };
      updateMBTITraits(choiceData.mbti || {});
      console.log('🎭 MBTI特質更新:', {
        更新前: oldMBTITraits,
        更新後: gameState.playerChoices.mbtiTraits,
        本次增加: choiceData.mbti
      });
      
      // 更新故事相關特質
      const oldStoryTraits = { ...gameState.playerChoices.storyTraits };
      updateStoryTraits(choiceData.story || {});
      console.log('📖 故事特質更新:', {
        更新前: oldStoryTraits,
        更新後: gameState.playerChoices.storyTraits,
        本次增加: choiceData.story
      });
      
      // 處理故事分支影響
      processStoryImpact(choiceData.storyImpact || {});
      
      // 分析選擇模式
      analyzeChoicePatterns();
      
      // 準備AI上下文數據
      updateAIContext();
      
      console.log('✅ 選擇記錄完成:', choiceRecord.choiceText);
      console.log('🎯 當前玩家檔案:', gameState.playerChoices.aiContext?.profileSummary);
      console.log('========================================');
    }
    
    // 移除舊選擇的特質影響（重新計算法）
    function removeTraitInfluence(oldChoice) {
      console.log('🔄 移除舊選擇的特質影響...');
      
      // 保存當前特質狀態
      const backupPhilosophical = { ...gameState.playerChoices.philosophicalTraits };
      const backupMBTI = { ...gameState.playerChoices.mbtiTraits };
      const backupStory = { ...gameState.playerChoices.storyTraits };
      
      // 重置特質分數到初始狀態
      resetTraitsToInitial();
      
      // 重新計算所有選擇的特質影響（除了要移除的那個）
      const remainingChoices = gameState.playerChoices.choiceHistory.filter(choice => 
        !(choice.chapter === oldChoice.chapter && choice.scene === oldChoice.scene)
      );
      
      console.log(`🔄 重新計算${remainingChoices.length}個選擇的特質影響...`);
      
      remainingChoices.forEach(choice => {
        if (choice.traits) {
          // 重新應用哲學特質
          if (choice.traits.philosophical) {
            updatePhilosophicalTraits(choice.traits.philosophical);
          }
          
          // 重新應用MBTI特質
          if (choice.traits.mbti) {
            updateMBTITraits(choice.traits.mbti);
          }
          
          // 重新應用故事特質
          if (choice.traits.story) {
            updateStoryTraits(choice.traits.story);
          }
        }
      });
      
      console.log('✅ 特質影響重新計算完成');
      console.log('🔄 移除前特質:', {
        philosophical: backupPhilosophical,
        mbti: backupMBTI,
        story: backupStory
      });
      console.log('🔄 移除後特質:', {
        philosophical: gameState.playerChoices.philosophicalTraits,
        mbti: gameState.playerChoices.mbtiTraits,
        story: gameState.playerChoices.storyTraits
      });
    }
    
    // 重置特質分數到初始狀態
    function resetTraitsToInitial() {
      // 重置哲學特質
      const philosophicalTraits = gameState.playerChoices.philosophicalTraits;
      Object.keys(philosophicalTraits).forEach(trait => {
        philosophicalTraits[trait] = 0;
      });
      
      // 重置MBTI特質
      const mbtiTraits = gameState.playerChoices.mbtiTraits;
      Object.keys(mbtiTraits).forEach(trait => {
        mbtiTraits[trait] = 0;
      });
      
      // 重置故事特質
      const storyTraits = gameState.playerChoices.storyTraits;
      Object.keys(storyTraits).forEach(trait => {
        storyTraits[trait] = 0;
      });
      
      console.log('🔄 特質分數已重置到初始狀態');
    }
    
    // 移除章節特定選擇記錄
    function removeChapterSpecificChoice(oldChoice) {
      const chapterInfluences = gameState.playerChoices.chapterInfluences[oldChoice.chapter];
      if (chapterInfluences && chapterInfluences.choices) {
        const choiceIndex = chapterInfluences.choices.findIndex(choice => 
          choice.scene === oldChoice.scene
        );
        if (choiceIndex !== -1) {
          chapterInfluences.choices.splice(choiceIndex, 1);
          console.log('🔄 已移除章節特定選擇記錄');
        }
      }
    }
    
    // 生成選擇ID
    function generateChoiceId() {
      return `choice_${gameState.currentChapter}_${gameState.currentScene}_${Date.now()}`;
    }

    // === 進度存檔系統 ===
    
    // 章節配置數據
    const chapterConfig = {
      prologue: { title: '序章：莊周夢蝶', emoji: '🦋', description: '夢與現實的界限在何處？' },
      chapter1: { title: '第一章：子非魚', emoji: '🐟', description: '站在濠梁之上，思考魚的快樂' },
      chapter2: { title: '第二章：北冥有魚', emoji: '🐋', description: '從鯤到鵬的變化之道' },
      chapter3: { title: '第三章：鴟得腐鼠', emoji: '🦅', description: '價值觀的相對性與包容' },
      chapter4: { title: '第四章：蝸角之爭', emoji: '🐌', description: '在微觀中理解爭執的虛妄' },
      chapter5: { title: '第五章：朝菌與大椿', emoji: '🍄', description: '時間的相對性與生命的意義' },
      chapter6: { title: '第六章：天地為棺槨', emoji: '⭐', description: '生死之間，超越界限' },
      chapter7: { title: '第七章：渾沌之死', emoji: '🌪️', description: '七竅既開，渾沌歸一' },
      epilogue: { title: '尾聲：逍遙遊', emoji: '🌅', description: '回歸本心，自在逍遙' }
    };
    
    // 保存遊戲進度
    function saveGameProgress() {
      const progressData = {
        maxReachedChapter: gameState.maxReachedChapter || gameState.currentChapter,
        unlockedChapters: getUnlockedChapters(),
        collectedApertures: gameState.collectedApertures,
        unlockedForms: gameState.unlockedForms,
        lastPlayTime: Date.now(),
        currentScene: gameState.currentScene,
        playerChoices: gameState.playerChoices
      };
      
      try {
        localStorage.setItem('zhuangziGameProgress', JSON.stringify(progressData));
        console.log('💾 遊戲進度已保存');
      } catch (error) {
        console.error('❌ 保存進度失敗:', error);
      }
    }
    
    // 讀取遊戲進度
    function loadGameProgress() {
      try {
        const savedData = localStorage.getItem('zhuangziGameProgress');
        if (savedData) {
          const progressData = JSON.parse(savedData);
          console.log('📖 讀取到遊戲進度:', progressData);
          return progressData;
        }
      } catch (error) {
        console.error('❌ 讀取進度失敗:', error);
      }
      return null;
    }
    
    // 獲取已解鎖的章節列表
    function getUnlockedChapters() {
      const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
      const maxReachedChapter = gameState.maxReachedChapter || gameState.currentChapter;
      const maxIndex = chapters.indexOf(maxReachedChapter);
      
      if (maxIndex === -1) return ['prologue']; // 默認只解鎖序章
      
      // 返回到最高章節為止的所有章節
      return chapters.slice(0, maxIndex + 1);
    }
    
    // 生成章節卡片
    function generateChapterCards() {
      const savedProgress = loadGameProgress();
      const unlockedChapters = savedProgress ? 
        getUnlockedChaptersFromProgress(savedProgress.maxReachedChapter) : 
        ['prologue'];
      
      const cardsContainer = document.getElementById('chapter-cards');
      if (!cardsContainer) return;
      
      cardsContainer.innerHTML = '';
      
      // 洛書九宮格排列：4 9 2 / 3 5 7 / 8 1 6
      // 對應章節：第三章 尾聲 第一章 / 第二章 第四章 第六章 / 第七章 序章 第五章
      const luoshuOrder = [
        'chapter3', 'epilogue', 'chapter1',    // 第一行：4 9 2
        'chapter2', 'chapter4', 'chapter6',    // 第二行：3 5 7  
        'chapter7', 'prologue', 'chapter5'     // 第三行：8 1 6
      ];
      
      luoshuOrder.forEach(chapterId => {
        const config = chapterConfig[chapterId];
        if (config) {
          const isUnlocked = unlockedChapters.includes(chapterId);
          const isCurrent = savedProgress && savedProgress.maxReachedChapter === chapterId;
          
          const card = createChapterCard(chapterId, config, isCurrent, isUnlocked);
          cardsContainer.appendChild(card);
        }
      });
    }
    
    // 從進度數據獲取已解鎖章節
    function getUnlockedChaptersFromProgress(maxChapter) {
      const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
      const maxIndex = chapters.indexOf(maxChapter);
      
      if (maxIndex === -1) return ['prologue'];
      
      return chapters.slice(0, maxIndex + 1);
    }
    

    // 創建章節卡片
    function createChapterCard(chapterId, config, isCurrent, isUnlocked) {
      const card = document.createElement('div');
      
      const chapterNumber = chapterId === 'prologue' ? '序' : 
                           chapterId === 'epilogue' ? '尾' : 
                           chapterId.replace('chapter', '');
      
      // 洛書九宮格數字對應表
      const luoshuNumbers = {
        'prologue': '1',   // 序章對應洛書數字1
        'chapter1': '2',   // 第一章對應洛書數字2  
        'chapter2': '3',   // 第二章對應洛書數字3
        'chapter3': '4',   // 第三章對應洛書數字4
        'chapter4': '5',   // 第四章對應洛書數字5
        'chapter5': '6',   // 第五章對應洛書數字6
        'chapter6': '7',   // 第六章對應洛書數字7
        'chapter7': '8',   // 第七章對應洛書數字8
        'epilogue': '9'    // 尾聲對應洛書數字9
      };
      
      const luoshuNumber = luoshuNumbers[chapterId] || '';
      
      if (isUnlocked) {
        // 已解鎖章節
        card.className = `chapter-card ${isCurrent ? 'current' : 'unlocked'}`;
        
        // 判斷洛書數字的陰陽屬性
        const yinYangClass = parseInt(luoshuNumber) % 2 === 1 ? 'luoshu-yang' : 'luoshu-yin';
        
        card.innerHTML = `
          <div class="luoshu-number-center ${yinYangClass}">${luoshuNumber}</div>
          <div class="chapter-emoji">${config.emoji}</div>
        `;
        
        card.addEventListener('click', () => {
          jumpToChapter(chapterId);
        });
      } else {
        // 未解鎖章節
        card.className = 'chapter-card locked';
        
        // 判斷洛書數字的陰陽屬性（未解鎖狀態）
        const yinYangClass = parseInt(luoshuNumber) % 2 === 1 ? 'luoshu-yang' : 'luoshu-yin';
        
        card.innerHTML = `
          <div class="luoshu-number-center ${yinYangClass} locked">${luoshuNumber}</div>
          <div class="chapter-emoji locked">🔒</div>
        `;
        
        // 鎖定章節的點擊提示
        card.addEventListener('click', () => {
          showUnlockHint(chapterId);
        });
      }
      
      return card;
    }
    
    // 顯示解鎖提示
    function showUnlockHint(chapterId) {
      const luoshuNumbers = {
        'prologue': '1',   
        'chapter1': '2',   
        'chapter2': '3',   
        'chapter3': '4',   
        'chapter4': '5',   
        'chapter5': '6',   
        'chapter6': '7',   
        'chapter7': '8',   
        'epilogue': '9'    
      };
      
      const chapterTitles = {
        'prologue': '序章：莊周夢蝶',
        'chapter1': '第一章：濠梁觀魚',
        'chapter2': '第二章：北冥有魚',
        'chapter3': '第三章：鴟得腐鼠',
        'chapter4': '第四章：蝸角之爭',
        'chapter5': '第五章：朝菌大椿',
        'chapter6': '第六章：天地棺槨',
        'chapter7': '第七章：渾沌之死',
        'epilogue': '尾聲：逍遙歸真'
      };
      
      const luoshuNumber = luoshuNumbers[chapterId];
      const chapterTitle = chapterTitles[chapterId] || '此章節';
      
      alert(`洛書${luoshuNumber}宮：${chapterTitle}\n\n尚未解鎖！請先完成前面的章節來解鎖新的內容。`);
    }
    
    // 跳轉到指定章節（重用現有邏輯）
    function jumpToChapter(chapterId) {
      // 使用現有的setupChapterPrerequisites和startChapter邏輯
      setupChapterPrerequisites(chapterId);
      
      // 關閉主菜單
      const mainMenu = document.getElementById('main-menu');
      const aperturesTracker = document.getElementById('apertures-tracker');
      const gameUI = document.getElementById('game-ui');
      const gameContent = document.getElementById('game-content');
      
      mainMenu.style.opacity = 0;
      setTimeout(() => {
        mainMenu.style.display = 'none';
        aperturesTracker.style.opacity = 1;
        gameUI.style.opacity = 1;
        gameContent.style.opacity = 1;
        document.getElementById('current-form-indicator').style.opacity = 1;
        
        // 保存當前已達到的最高章節，避免被覆蓋
        const savedProgress = loadGameProgress();
        const originalMaxChapter = savedProgress ? savedProgress.maxReachedChapter : 'prologue';
        
        // 開始對應章節
        startChapter(chapterId);
        
        // 恢復原始的最高章節記錄，然後保存進度
        gameState.maxReachedChapter = originalMaxChapter;
        saveGameProgress();
      }, 500);
    }
    
    // 開發者模式密碼驗證
    function initDevModeAccess() {
      const devAccessBtn = document.getElementById('dev-mode-access');
      const devPanel = document.getElementById('dev-panel');
      const closeDevBtn = document.getElementById('close-dev-panel');
      
      if (devAccessBtn) {
        devAccessBtn.addEventListener('click', () => {
          const password = prompt('請輸入開發者密碼：');
          if (password === '1644') {
            devPanel.classList.remove('hidden');
            // 設置開發者模式狀態
            gameState.devMode = true;
            gameState.devModeAccessedViaPassword = true;
            document.documentElement.classList.add('dev-mode');
            showDevMessage('開發者模式已通過密碼開啟');
          } else if (password !== null) {
            alert('密碼錯誤！');
          }
        });
      }
      
      if (closeDevBtn) {
        closeDevBtn.addEventListener('click', () => {
          devPanel.classList.add('hidden');
        });
      }
    }
    
    // 更新時間統計
    function updateTimingStatistics(thinkingTime) {
      const timing = gameState.playerChoices.timingData;
      timing.totalThinkingTime += thinkingTime;
      
      const totalChoices = gameState.playerChoices.choiceHistory.length;
      if (totalChoices > 0) {
        timing.averageThinkingTime = timing.totalThinkingTime / totalChoices;
      }
    }
    
    // === 新增：章節特定選擇記錄 ===
    function recordChapterSpecificChoice(choiceRecord) {
      const chapterKey = choiceRecord.chapter;
      if (gameState.playerChoices.chapterInfluences[chapterKey]) {
        gameState.playerChoices.chapterInfluences[chapterKey].choices.push({
          scene: choiceRecord.scene,
          text: choiceRecord.choiceText,
          traits: choiceRecord.traits,
          storyImpact: choiceRecord.storyImpact
        });
      }
    }
    
    // === 新增：MBTI維度更新 ===
    function updateMBTITraits(mbtiData) {
      const mbtiTraits = gameState.playerChoices.mbtiTraits;
      
      for (const [trait, value] of Object.entries(mbtiData)) {
        if (mbtiTraits.hasOwnProperty(trait)) {
          mbtiTraits[trait] = Math.max(0, Math.min(100, mbtiTraits[trait] + value));
        }
      }
      
      // 平衡對立的MBTI維度
      balanceMBTIDimensions();
    }
    
    // === 新增：故事特質更新 ===
    function updateStoryTraits(storyData) {
      const storyTraits = gameState.playerChoices.storyTraits;
      
      for (const [trait, value] of Object.entries(storyData)) {
        if (storyTraits.hasOwnProperty(trait)) {
          storyTraits[trait] = Math.max(0, Math.min(100, storyTraits[trait] + value));
        }
      }
    }
    
    // === 新增：故事分支影響處理 ===
    function processStoryImpact(impactData) {
      const chapterKey = gameState.currentChapter;
      
      if (impactData.branchInfluence) {
        // 更新該章節的故事分支
        if (gameState.playerChoices.chapterInfluences[chapterKey]) {
          gameState.playerChoices.chapterInfluences[chapterKey].storyBranch = 
            impactData.branchInfluence;
        }
        
        // 記錄分支變化
        gameState.playerChoices.choicePatterns.storyBranches.push({
          chapter: chapterKey,
          scene: gameState.currentScene,
          branch: impactData.branchInfluence,
          timestamp: Date.now()
        });
      }
    }
    
    // === 新增：MBTI維度平衡 ===
    function balanceMBTIDimensions() {
      const mbti = gameState.playerChoices.mbtiTraits;
      
      // MBTI對立維度對
      const dimensionPairs = [
        ['extraversion', 'introversion'],
        ['sensing', 'intuition'],
        ['thinking', 'feeling'],
        ['judging', 'perceiving']
      ];
      
      dimensionPairs.forEach(([trait1, trait2]) => {
        const total = mbti[trait1] + mbti[trait2];
        if (total > 100) {
          // 如果總和超過100，按比例調整
          const ratio1 = mbti[trait1] / total;
          const ratio2 = mbti[trait2] / total;
          mbti[trait1] = Math.round(ratio1 * 100);
          mbti[trait2] = Math.round(ratio2 * 100);
        }
      });
    }
    
    // 更新哲學傾向分數（隱蔽系統）
    function updatePhilosophicalTraits(traits) {
      const currentTraits = gameState.playerChoices.philosophicalTraits;
      
      // 遍歷選擇帶來的特質影響
      for (const [trait, value] of Object.entries(traits)) {
        if (currentTraits.hasOwnProperty(trait)) {
          // 累加分數，但限制在0-100範圍內
          currentTraits[trait] = Math.max(0, Math.min(100, currentTraits[trait] + value));
        }
      }
      
      // 平衡對立特質（如果需要）
      balanceOpposingTraits();
    }
    
    // 平衡對立特質
    function balanceOpposingTraits() {
      const traits = gameState.playerChoices.philosophicalTraits;
      
      // 定義對立特質對
      const opposingPairs = [
        ['compassion', 'detachment'],
        ['intervention', 'acceptance'],
        ['pragmatism', 'idealism'],
        ['curiosity', 'harmony']
      ];
      
      // 輕微調整對立特質以保持平衡
      opposingPairs.forEach(([trait1, trait2]) => {
        const diff = Math.abs(traits[trait1] - traits[trait2]);
        if (diff > 80) {
          // 如果差距過大，輕微調整較低的一方
          const lowerTrait = traits[trait1] < traits[trait2] ? trait1 : trait2;
          traits[lowerTrait] += Math.min(5, diff * 0.05);
        }
      });
    }
    
    // 分析選擇模式
    function analyzeChoicePatterns() {
      const history = gameState.playerChoices.choiceHistory;
      const patterns = gameState.playerChoices.choicePatterns;
      
      if (history.length < 3) return; // 需要足夠的數據才能分析
      
      // 計算一致性評分
      calculateConsistencyScore();
      
      // 識別主導特質
      identifyDominantTraits();
      
      // 檢測思想演化趨勢
      detectEvolutionTrend();
    }
    
    // 計算選擇一致性評分
    function calculateConsistencyScore() {
      const traits = gameState.playerChoices.philosophicalTraits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      // 基於特質分布的一致性分析
      const traitValues = Object.values(traits);
      const maxTrait = Math.max(...traitValues);
      const minTrait = Math.min(...traitValues);
      
      // 一致性評分：特質分化程度（有明顯偏好）vs 平均分布（猶豫不決）
      const consistency = maxTrait > 30 ? (maxTrait - minTrait) / 100 : 0;
      patterns.consistencyScore = Math.round(consistency * 100);
    }
    
    // 識別主導特質
    function identifyDominantTraits() {
      const traits = gameState.playerChoices.philosophicalTraits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      // 按分數排序特質
      const sortedTraits = Object.entries(traits)
        .sort(([,a], [,b]) => b - a)
        .filter(([,score]) => score > 20); // 只考慮有意義的分數
      
      patterns.dominantTraits = sortedTraits.slice(0, 3).map(([trait,]) => trait);
      patterns.secondaryTraits = sortedTraits.slice(3, 6).map(([trait,]) => trait);
    }
    
    // 檢測思想演化趨勢
    function detectEvolutionTrend() {
      const history = gameState.playerChoices.choiceHistory;
      const patterns = gameState.playerChoices.choicePatterns;
      
      if (history.length < 5) return;
      
      // 分析最近5個選擇的趨勢
      const recentChoices = history.slice(-5);
      const recentTraits = {};
      
      recentChoices.forEach(choice => {
        for (const [trait, value] of Object.entries(choice.traits)) {
          recentTraits[trait] = (recentTraits[trait] || 0) + value;
        }
      });
      
      // 記錄演化趨勢
      patterns.evolutionTrend.push({
        timestamp: Date.now(),
        trends: recentTraits,
        dominantInRecent: Object.keys(recentTraits).sort((a,b) => recentTraits[b] - recentTraits[a])[0]
      });
      
      // 保持趨勢記錄在合理範圍內
      if (patterns.evolutionTrend.length > 10) {
        patterns.evolutionTrend.shift();
      }
    }
    
    // 更新AI調用上下文（增強版）
    function updateAIContext() {
      const context = gameState.playerChoices.aiContext;
      const traits = gameState.playerChoices.philosophicalTraits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      context.lastUpdateTime = Date.now();
      
      // 生成性格檔案摘要
      context.profileSummary = generateProfileSummary();
      
      // 確定MBTI類型
      context.mbtiType = determineMBTIType();
      
      // 確定莊子哲學性格類型
      const philosophicalProfile = determinePhilosophicalProfile();
      context.philosophicalType = philosophicalProfile.description;
      
      // 分析最近趨勢
      context.recentTrends = analyzeRecentTrends();
      
      // 建議AI回應風格
      context.suggestedResponseStyle = suggestResponseStyle();
      
      // 生成故事個性化數據
      context.storyPersonalization = generateStoryPersonalization();
    }
    
    // 生成性格檔案摘要
    function generateProfileSummary() {
      const traits = gameState.playerChoices.philosophicalTraits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      const summary = {
        dominantTraits: patterns.dominantTraits.slice(0, 2),
        consistencyLevel: patterns.consistencyScore > 60 ? 'high' : patterns.consistencyScore > 30 ? 'medium' : 'low',
        totalChoices: gameState.playerChoices.choiceHistory.length,
        averageThinkingTime: Math.round(gameState.playerChoices.timingData.averageThinkingTime),
        philosophicalProfile: determinePhilosophicalProfile()
      };
      
      return summary;
    }
    
    // === 新增：MBTI類型推測 ===
    function determineMBTIType() {
      const mbti = gameState.playerChoices.mbtiTraits;
      
      // 確定每個維度的傾向
      const E_I = mbti.extraversion >= mbti.introversion ? 'E' : 'I';
      const S_N = mbti.sensing >= mbti.intuition ? 'S' : 'N';
      const T_F = mbti.thinking >= mbti.feeling ? 'T' : 'F';
      const J_P = mbti.judging >= mbti.perceiving ? 'J' : 'P';
      
      return E_I + S_N + T_F + J_P;
    }
    
    // === 新增：MBTI類型描述 ===
    function getMBTITypeDescription(mbtiType) {
      const descriptions = {
        'ENFJ': '教育家：富有同情心的引導者，關心他人成長',
        'ENFP': '激勵者：熱情洋溢的理想主義者，富有創造力',
        'ENTJ': '指揮官：天生的領導者，果斷而有遠見',
        'ENTP': '辯論家：聰明好辯的思想家，喜愛智力挑戰',
        'ESFJ': '執政官：熱心助人的合作者，重視和諧',
        'ESFP': '娛樂者：活潑開朗的表演者，享受當下',
        'ESTJ': '總經理：實用主義的組織者，重視效率',
        'ESTP': '企業家：精力充沛的實用主義者，適應力強',
        'INFJ': '提倡者：富有洞察力的理想主義者，追求意義',
        'INFP': '調停者：富有想像力的理想主義者，價值觀驅動',
        'INTJ': '建築師：富有想像力的戰略家，追求完美',
        'INTP': '思想家：富有創新精神的發明家，追求理解',
        'ISFJ': '守護者：溫暖體貼的保護者，樂於助人',
        'ISFP': '探險家：靈活友善的藝術家，追求和諧',
        'ISTJ': '物流師：實用忠誠的傳統主義者，責任感強',
        'ISTP': '鑑賞家：靈活務實的技師，擅長解決問題'
      };
      
      return descriptions[mbtiType] || '探索中：正在發現自己的人格類型';
    }
    
    // 確定哲學性格類型（增強版）
    function determinePhilosophicalProfile() {
      const traits = gameState.playerChoices.philosophicalTraits;
      const story = gameState.playerChoices.storyTraits;
      
      // 基於主要特質組合判斷類型
      if (traits.detachment > 50 && traits.wisdom > 40) {
        return { type: 'sage', description: '智者型：達觀明智，超脫物外' };
      } else if (traits.compassion > 50 && traits.harmony > 40) {
        return { type: 'harmonizer', description: '和諧者：包容萬物，追求平和' };
      } else if (traits.curiosity > 50 && traits.paradoxical > 30) {
        return { type: 'seeker', description: '求索者：好奇探索，樂於思辨' };
      } else if (traits.acceptance > 50 && traits.beauty_appreciation > 40) {
        return { type: 'acceptor', description: '接納者：寬容理解，不妄下評判' };
      } else if (traits.aesthetic > 50 && traits.spontaneity > 30) {
        return { type: 'artist', description: '藝術家：審美敏銳，崇尚自然' };
      } else {
        return { type: 'developing', description: '修行者：正在探索屬於自己的道路' };
      }
    }
    
    // === 新增：故事個性化數據生成 ===
    function generateStoryPersonalization() {
      const story = gameState.playerChoices.storyTraits;
      const mbti = gameState.playerChoices.mbtiTraits;
      const philosophical = gameState.playerChoices.philosophicalTraits;
      
      return {
        preferredNarrativeStyle: determineNarrativeStyle(story, mbti),
        emotionalResonance: identifyEmotionalResonance(philosophical),
        challengeLevel: determineChallengeLevel(story),
        guidanceNeed: determineGuidanceNeed(story, mbti)
      };
    }
    
    // === 新增：敘述風格確定 ===
    function determineNarrativeStyle(story, mbti) {
      if (story.analyticalApproach > 60) return 'analytical'; // 分析型敘述
      if (story.intuitiveApproach > 60) return 'intuitive';   // 直覺型敘述
      if (story.experientialApproach > 60) return 'experiential'; // 體驗型敘述
      if (mbti.sensing > mbti.intuition) return 'concrete';    // 具體型敘述
      return 'balanced'; // 平衡型敘述
    }
    
    // === 新增：情感共鳴點識別 ===
    function identifyEmotionalResonance(philosophical) {
      const resonance = [];
      
      if (philosophical.compassion > 60) resonance.push('同理心');
      if (philosophical.aesthetic > 60) resonance.push('美學感受');
      if (philosophical.wisdom > 60) resonance.push('智慧洞察');
      if (philosophical.harmony > 60) resonance.push('和諧美好');
      if (philosophical.paradoxical > 60) resonance.push('哲思深度');
      
      return resonance.length > 0 ? resonance : ['平衡感受'];
    }
    
    // === 新增：挑戰難度確定 ===
    function determineChallengeLevel(story) {
      if (story.riskTolerance > 70) return 'high';     // 高挑戰
      if (story.cautionLevel > 70) return 'low';       // 低挑戰
      if (story.explorationDrive > 60) return 'medium-high'; // 中高挑戰
      return 'medium'; // 中等挑戰
    }
    
    // === 新增：指導需求確定 ===
    function determineGuidanceNeed(story, mbti) {
      if (story.independence > 70) return 'minimal';   // 最少指導
      if (story.followership > 70) return 'detailed';  // 詳細指導
      if (mbti.judging > mbti.perceiving) return 'structured'; // 結構化指導
      return 'moderate'; // 適度指導
    }
    
    // 分析最近趨勢
    function analyzeRecentTrends() {
      const patterns = gameState.playerChoices.choicePatterns;
      if (patterns.evolutionTrend.length < 2) return [];
      
      const recent = patterns.evolutionTrend.slice(-2);
      const trends = [];
      
      // 比較最近的變化
      if (recent.length >= 2) {
        const prev = recent[0].trends;
        const curr = recent[1].trends;
        
        for (const trait in curr) {
          if (prev[trait]) {
            const change = curr[trait] - prev[trait];
            if (Math.abs(change) >= 3) {
              trends.push({
                trait: trait,
                direction: change > 0 ? 'increasing' : 'decreasing',
                magnitude: Math.abs(change)
              });
            }
          }
        }
      }
      
      return trends;
    }
    
    // 建議AI回應風格（增強版）
    function suggestResponseStyle() {
      const profile = determinePhilosophicalProfile();
      const traits = gameState.playerChoices.philosophicalTraits;
      const mbti = gameState.playerChoices.mbtiTraits;
      const story = gameState.playerChoices.storyTraits;
      const avgThinking = gameState.playerChoices.timingData.averageThinkingTime;
      
      let style = {
        tone: 'balanced',
        depth: 'medium',
        approach: 'guiding',
        personalizedElements: []
      };
      
      // 根據哲學性格檔案調整風格
      switch(profile.type) {
        case 'sage':
          style = { tone: 'profound', depth: 'deep', approach: 'philosophical', personalizedElements: ['智慧引導', '深度洞察'] };
          break;
        case 'harmonizer':
          style = { tone: 'warm', depth: 'medium', approach: 'supportive', personalizedElements: ['溫暖包容', '和諧平衡'] };
          break;
        case 'seeker':
          style = { tone: 'mysterious', depth: 'deep', approach: 'questioning', personalizedElements: ['啟發思考', '探索未知'] };
          break;
        case 'acceptor':
          style = { tone: 'gentle', depth: 'medium', approach: 'understanding', personalizedElements: ['理解接納', '不評判'] };
          break;
        case 'artist':
          style = { tone: 'poetic', depth: 'medium', approach: 'inspiring', personalizedElements: ['詩意表達', '美學感受'] };
          break;
        default:
          style.personalizedElements = ['循序漸進', '探索成長'];
      }
      
      // 根據MBTI特質微調風格
      if (mbti.introversion > mbti.extraversion) {
        style.approach = 'introspective'; // 更內省的方式
      }
      
      if (mbti.intuition > mbti.sensing) {
        style.personalizedElements.push('抽象思維');
      } else {
        style.personalizedElements.push('具體實例');
      }
      
      if (mbti.feeling > mbti.thinking) {
        style.personalizedElements.push('情感共鳴');
      } else {
        style.personalizedElements.push('邏輯分析');
      }
      
      // 根據故事特質調整
      if (story.riskTolerance > 60) {
        style.personalizedElements.push('冒險鼓勵');
      }
      
      if (story.cautionLevel > 60) {
        style.personalizedElements.push('謹慎提醒');
      }
      
      // 根據思考時間調整深度
      if (avgThinking > 5000) { // 5秒以上表示深度思考者
        style.depth = 'deep';
        style.personalizedElements.push('深度思辨');
      } else if (avgThinking < 2000) { // 2秒以下表示快速決策者
        style.depth = 'light';
        style.personalizedElements.push('簡潔明瞭');
      }
      
      return style;
    }
    
    // 設置選擇開始時間（在選項出現時調用）
    function startChoiceTimer() {
      gameState.playerChoices.timingData.choiceStartTime = Date.now();
    }
    
    // === 新增：完整玩家分析報告生成 ===
    function generateComprehensivePlayerAnalysis() {
      const philosophical = gameState.playerChoices.philosophicalTraits;
      const mbti = gameState.playerChoices.mbtiTraits;
      const story = gameState.playerChoices.storyTraits;
      const patterns = gameState.playerChoices.choicePatterns;
      const choices = gameState.playerChoices.choiceHistory;
      
      // 基本統計
      const totalChoices = choices.length;
      const avgThinkingTime = Math.round(gameState.playerChoices.timingData.averageThinkingTime / 1000 * 10) / 10; // 秒
      
      // MBTI分析
      const mbtiType = determineMBTIType();
      const mbtiDescription = getMBTITypeDescription(mbtiType);
      
      // 哲學性格分析
      const philosophicalProfile = determinePhilosophicalProfile();
      
      // 故事旅程分析
      const storyJourney = analyzeStoryJourney();
      
      // 選擇模式分析
      const choiceAnalysis = analyzeChoiceCharacteristics();
      
      return {
        summary: {
          totalChoices: totalChoices,
          averageThinkingTime: avgThinkingTime,
          journeyDuration: estimatePlayTime(),
          consistencyScore: patterns.consistencyScore
        },
        mbtiAnalysis: {
          type: mbtiType,
          description: mbtiDescription,
          dimensions: {
            energySource: mbti.extraversion > mbti.introversion ? 
              { type: '外向型(E)', strength: mbti.extraversion, description: '從外部世界獲得能量，樂於與他人互動' } :
              { type: '內向型(I)', strength: mbti.introversion, description: '從內心世界獲得能量，重視深度思考' },
            informationProcessing: mbti.sensing > mbti.intuition ?
              { type: '感覺型(S)', strength: mbti.sensing, description: '關注現實細節，重視具體經驗' } :
              { type: '直觀型(N)', strength: mbti.intuition, description: '關注可能性，偏愛抽象概念' },
            decisionMaking: mbti.thinking > mbti.feeling ?
              { type: '思考型(T)', strength: mbti.thinking, description: '基於邏輯分析做決策，重視客觀標準' } :
              { type: '情感型(F)', strength: mbti.feeling, description: '基於價值觀做決策，重視和諧關係' },
            lifestylePreference: mbti.judging > mbti.perceiving ?
              { type: '判斷型(J)', strength: mbti.judging, description: '喜歡計劃性，傾向於得出結論' } :
              { type: '感知型(P)', strength: mbti.perceiving, description: '喜歡靈活性，保持開放態度' }
          }
        },
        philosophicalAnalysis: {
          type: philosophicalProfile.type,
          description: philosophicalProfile.description,
          dominantTraits: getDominantPhilosophicalTraits(),
          transformationJourney: analyzePhilosophicalGrowth()
        },
        storyAnalysis: {
          relationshipWithZhuangzi: analyzeZhuangziRelationship(),
          learningStyle: identifyLearningStyle(),
          adventureSpirit: assessAdventureSpirit(),
          wisdomReception: assessWisdomReception()
        },
        personalizedInsights: generatePersonalizedInsights()
      };
    }
    
    // === 新增：分析故事旅程 ===
    function analyzeStoryJourney() {
      const chapterInfluences = gameState.playerChoices.chapterInfluences;
      const journey = [];
      
      for (const [chapter, data] of Object.entries(chapterInfluences)) {
        if (data.choices.length > 0) {
          journey.push({
            chapter: chapter,
            choiceCount: data.choices.length,
            storyBranch: data.storyBranch,
            keyChoices: data.choices.slice(0, 3) // 前3個關鍵選擇
          });
        }
      }
      
      return journey;
    }
    
    // === 新增：選擇特徵分析 ===
    function analyzeChoiceCharacteristics() {
      const choices = gameState.playerChoices.choiceHistory;
      
      // 分析思考時間分布
      const thinkingTimes = choices.map(c => c.thinkingTime);
      const quickChoices = thinkingTimes.filter(t => t < 2000).length;
      const slowChoices = thinkingTimes.filter(t => t > 5000).length;
      
      return {
        decisionSpeed: {
          quick: Math.round(quickChoices / choices.length * 100),
          deliberate: Math.round(slowChoices / choices.length * 100),
          average: Math.round((choices.length - quickChoices - slowChoices) / choices.length * 100)
        },
        choiceDistribution: analyzeChoiceDistribution()
      };
    }
    
    // === 新增：主導哲學特質獲取 ===
    function getDominantPhilosophicalTraits() {
      const traits = gameState.playerChoices.philosophicalTraits;
      
      return Object.entries(traits)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 5)
        .map(([trait, score]) => ({
          trait: getTraitDisplayName(trait),
          score: score,
          level: score > 70 ? '強' : score > 40 ? '中' : '弱'
        }));
    }
    
    // === 新增：特質顯示名稱映射 ===
    function getTraitDisplayName(trait) {
      const names = {
        compassion: '同理心',
        detachment: '超脫性',
        curiosity: '好奇心',
        acceptance: '接納度',
        intervention: '干預傾向',
        aesthetic: '美學傾向',
        pragmatism: '實用主義',
        idealism: '理想主義',
        relativism: '相對主義',
        nonJudgmental: '不評判',
        harmony: '和諧追求',
        spontaneity: '自然性',
        wisdom: '智慧洞察',
        paradoxical: '悖論思維'
      };
      
      return names[trait] || trait;
    }
    
    // === 新增：個性化洞察生成 ===
    function generatePersonalizedInsights() {
      const mbtiType = determineMBTIType();
      const philosophicalProfile = determinePhilosophicalProfile();
      const story = gameState.playerChoices.storyTraits;
      
      const insights = [];
      
      // 基於MBTI的洞察
      if (mbtiType.includes('N')) {
        insights.push('你傾向於從抽象的哲學概念中汲取智慧，喜歡探索事物的深層含義。');
      }
      
      if (mbtiType.includes('F')) {
        insights.push('你在做決策時更多地考慮情感和價值觀，這使你能夠深度理解莊子的人文關懷。');
      }
      
      // 基於哲學性格的洞察
      switch (philosophicalProfile.type) {
        case 'sage':
          insights.push('你展現出智者的品質，能夠在複雜的哲學問題中保持清醒的洞察力。');
          break;
        case 'harmonizer':
          insights.push('你天生具有調和矛盾的能力，體現了莊子「物無貴賤」的包容精神。');
          break;
        case 'seeker':
          insights.push('你的好奇心驅使你不斷探索，這正是莊子「遊」的精神體現。');
          break;
      }
      
      // 基於故事特質的洞察
      if (story.transformationOpenness > 60) {
        insights.push('你對物化體驗的開放態度表明你具有突破自我界限的勇氣。');
      }
      
      return insights;
    }
    
    // === 新增：其他分析函數 ===
    function analyzePhilosophicalGrowth() {
      // 分析哲學成長軌跡
      return '在遊戲過程中，你的思想經歷了從困惑到清晰的轉變。';
    }
    
    function analyzeZhuangziRelationship() {
      const relationship = gameState.playerChoices.storyTraits.relationshipWithZhuangzi;
      if (relationship > 70) return '親密的師生關係';
      if (relationship > 40) return '信任的引導關係';
      return '謹慎的探索關係';
    }
    
    function identifyLearningStyle() {
      const story = gameState.playerChoices.storyTraits;
      if (story.analyticalApproach > 60) return '分析型學習者';
      if (story.intuitiveApproach > 60) return '直覺型學習者';
      if (story.experientialApproach > 60) return '體驗型學習者';
      return '平衡型學習者';
    }
    
    function assessAdventureSpirit() {
      const riskTolerance = gameState.playerChoices.storyTraits.riskTolerance;
      return riskTolerance > 60 ? '勇於冒險' : '謹慎探索';
    }
    
    function assessWisdomReception() {
      const reception = gameState.playerChoices.storyTraits.ancientWisdomReception;
      return reception > 60 ? '深度接受' : '逐步理解';
    }
    
    function analyzeChoiceDistribution() {
      // 分析選擇分布特徵
      return { balanced: 60, decisive: 30, exploratory: 10 };
    }
    
    // 獲取AI調用的完整數據包（增強版）
    function getAIAnalysisData() {
      const choiceHistory = gameState.playerChoices.choiceHistory;
      
      // 詳細調試日誌
      console.log('🔍 ===== AI數據收集詳細調試 =====');
      console.log('📊 基礎數據統計:', {
        選擇歷史長度: choiceHistory.length,
        哲學特質數量: Object.keys(gameState.playerChoices.philosophicalTraits || {}).length,
        MBTI特質數量: Object.keys(gameState.playerChoices.mbtiTraits || {}).length,
        故事特質數量: Object.keys(gameState.playerChoices.storyTraits || {}).length,
        AI上下文可用: !!gameState.playerChoices.aiContext
      });
      
      console.log('🧠 特質數據詳情:');
      console.log('  哲學特質:', gameState.playerChoices.philosophicalTraits);
      console.log('  MBTI特質:', gameState.playerChoices.mbtiTraits);
      console.log('  故事特質:', gameState.playerChoices.storyTraits);
      
      console.log('📈 選擇模式分析:', gameState.playerChoices.choicePatterns);
      console.log('👤 玩家檔案:', gameState.playerChoices.aiContext?.profileSummary);
      console.log('🎨 建議風格:', gameState.playerChoices.aiContext?.suggestedResponseStyle);
      
      console.log('🕰️ 最近5個選擇詳情:');
      choiceHistory.slice(-5).forEach((choice, index) => {
        console.log(`  ${index + 1}. [${choice.chapter}場景${choice.scene}] "${choice.choiceText}"`);
        console.log(`     特質: ${JSON.stringify(choice.traits)} | 思考時間: ${Math.round(choice.thinkingTime / 1000)}s`);
      });
      
      // 檢查數據完整性
      const dataIntegrity = {
        選擇記錄完整: choiceHistory.length > 0,
        特質數據存在: Object.keys(gameState.playerChoices.philosophicalTraits || {}).length > 0,
        AI上下文存在: !!gameState.playerChoices.aiContext?.profileSummary,
        遊戲進度有效: !!gameState.currentChapter
      };
      
      console.log('✅ 數據完整性檢查:', dataIntegrity);
      
      const analysisData = {
        comprehensive: generateComprehensivePlayerAnalysis(),
        profile: gameState.playerChoices.aiContext.profileSummary,
        traits: gameState.playerChoices.philosophicalTraits,
        mbtiTraits: gameState.playerChoices.mbtiTraits,
        storyTraits: gameState.playerChoices.storyTraits,
        patterns: gameState.playerChoices.choicePatterns,
        // 格式化choices數據以匹配AI期望的格式
        choices: choiceHistory.map(choice => ({
          choiceText: choice.choiceText,
          chapter: choice.chapter,
          scene: choice.scene,
          thinkingTime: choice.thinkingTime,
          traits: choice.traits,
          timestamp: choice.timestamp
        })),
        context: {
          currentChapter: gameState.currentChapter,
          currentScene: gameState.currentScene,
          currentForm: gameState.currentForm,
          gameProgress: getGameProgressSummary(),
          // AI章節總結需要的recentHistory格式
          recentHistory: choiceHistory.slice(-8).map(choice => ({
            choiceText: choice.choiceText,
            chapter: choice.chapter,
            scene: choice.scene,
            thinkingTime: choice.thinkingTime,
            traits: choice.traits,
            situation: choice.context?.situation || choice.context?.speaker || '對話場景'
          }))
        },
        suggestedStyle: gameState.playerChoices.aiContext.suggestedResponseStyle
      };
      
      console.log('📦 最終AI數據包:', {
        profile可用: !!analysisData.profile,
        traits數量: Object.keys(analysisData.traits || {}).length,
        choices數量: analysisData.choices.length,
        recentHistory數量: analysisData.context.recentHistory.length,
        suggestedStyle可用: !!analysisData.suggestedStyle
      });
      
      console.log('========================================');
      return analysisData;
    }
    
    // 獲取遊戲進度摘要
    function getGameProgressSummary() {
      return {
        chaptersCompleted: getCompletedChapters(),
        formsUnlocked: gameState.unlockedForms.length,
        aperturesCollected: gameState.collectedApertures.length,
        totalPlayTime: estimatePlayTime()
      };
    }
    
    // 估算遊戲時間
    function estimatePlayTime() {
      const choices = gameState.playerChoices.choiceHistory;
      if (choices.length < 2) return 0;
      
      const startTime = choices[0].timestamp;
      const endTime = choices[choices.length - 1].timestamp;
      return Math.round((endTime - startTime) / 1000 / 60); // 分鐘
    }
    
         // 獲取已完成章節
     function getCompletedChapters() {
       // 基於選擇歷史推斷完成的章節
       const chapterSet = new Set();
       gameState.playerChoices.choiceHistory.forEach(choice => {
         chapterSet.add(choice.chapter);
       });
       return Array.from(chapterSet);
     }
     
     // 獲取當前情境描述
     function getCurrentSituation() {
       const chapter = gameChapters[gameState.currentChapter];
       if (!chapter) return 'unknown';
       
       const scene = chapter.scenes[gameState.currentScene];
       if (!scene) return 'unknown';
       
       // 組合情境描述
       return {
         chapterTitle: chapter.title,
         sceneType: scene.type,
         sceneText: scene.text ? scene.text.substring(0, 100) + '...' : '',
         background: chapter.background
       };
     }
     
     // 從選擇文本中推斷哲學特質（隱蔽系統）
     function extractTraitsFromChoice(choiceText, speaker, chapter) {
       const traits = {
         philosophical: {},
         story: {}
       };
       const text = choiceText.toLowerCase();
       
       // === 哲學層面維度識別 ===
       
       // 同理心相關關鍵詞
       if (text.includes('痛苦') || text.includes('難過') || text.includes('可憐') || 
           text.includes('理解') || text.includes('感受') || text.includes('不安') ||
           text.includes('共鳴') || text.includes('體會') || text.includes('心疼')) {
         traits.philosophical.compassion = 3;
       }
       
       // 理想主義相關關鍵詞
       if (text.includes('理想') || text.includes('完美') || text.includes('應當') || 
           text.includes('正義') || text.includes('純真') || text.includes('高尚') ||
           text.includes('美好') || text.includes('崇高') || text.includes('夢想')) {
         traits.philosophical.idealism = 3;
       }
       
       // 和諧追求相關關鍵詞
       if (text.includes('和諧') || text.includes('平衡') || text.includes('協調') || 
           text.includes('安寧') || text.includes('平和') || text.includes('融洽') ||
           text.includes('統一') || text.includes('調和') || text.includes('穩定')) {
         traits.philosophical.harmony = 3;
       }
       
       // 智慧追求相關關鍵詞
       if (text.includes('領悟') || text.includes('明白') || text.includes('洞察') || 
           text.includes('深層') || text.includes('本質') || text.includes('真相') ||
           text.includes('智慧') || text.includes('思考') || text.includes('探索')) {
         traits.philosophical.wisdom_seeking = 3;
       }
       
       // 接納包容相關關鍵詞
       if (text.includes('接受') || text.includes('都好') || text.includes('沒關係') || 
           text.includes('包容') || text.includes('各自') || text.includes('都有道理') ||
           text.includes('理解') || text.includes('寬容') || text.includes('容忍')) {
         traits.philosophical.acceptance = 3;
       }
       
       // 美的感受相關關鍵詞
       if (text.includes('美') || text.includes('優雅') || text.includes('純淨') || 
           text.includes('色彩') || text.includes('詩意') || text.includes('優美') ||
           text.includes('壯觀') || text.includes('美感') || text.includes('美麗')) {
         traits.philosophical.beauty_appreciation = 3;
       }
       
       // 超脫境界相關關鍵詞
       if (text.includes('超越') || text.includes('跳出') || text.includes('脫離') || 
           text.includes('超脫') || text.includes('昇華') || text.includes('境界') ||
           text.includes('無限') || text.includes('超凡') || text.includes('解脫')) {
         traits.philosophical.transcendence = 3;
       }
       
       // 真實自然相關關鍵詞
       if (text.includes('真實') || text.includes('自然') || text.includes('本真') || 
           text.includes('純粹') || text.includes('本來') || text.includes('原始') ||
           text.includes('天然') || text.includes('本性') || text.includes('真誠')) {
         traits.philosophical.authenticity = 3;
       }
       
       // === 故事層面維度識別 ===
       
       // 溫柔細膩相關關鍵詞
       if (text.includes('溫柔') || text.includes('細心') || text.includes('輕柔') || 
           text.includes('溫和') || text.includes('柔和') || text.includes('細膩') ||
           text.includes('溫暖') || text.includes('輕聲') || text.includes('小心')) {
         traits.story.gentleness = 3;
       }
       
       // 好奇探索相關關鍵詞
       if (text.includes('好奇') || text.includes('探索') || text.includes('想知道') || 
           text.includes('觀察') || text.includes('研究') || text.includes('發現') ||
           text.includes('尋找') || text.includes('探尋') || text.includes('調查')) {
         traits.story.curiosity = 3;
       }
       
       // 堅韌不拔相關關鍵詞
       if (text.includes('堅持') || text.includes('不放棄') || text.includes('堅強') || 
           text.includes('堅韌') || text.includes('毅力') || text.includes('堅定') ||
           text.includes('頑強') || text.includes('不屈') || text.includes('持續')) {
         traits.story.resilience = 3;
       }
       
       // 內省深思相關關鍵詞
       if (text.includes('反思') || text.includes('深思') || text.includes('內省') || 
           text.includes('沉思') || text.includes('思索') || text.includes('思考') ||
           text.includes('反省') || text.includes('內觀') || text.includes('自省')) {
         traits.story.introspection = 3;
       }
       
       // 勇敢冒險相關關鍵詞
       if (text.includes('勇敢') || text.includes('冒險') || text.includes('挑戰') || 
           text.includes('勇氣') || text.includes('大膽') || text.includes('無畏') ||
           text.includes('冒險') || text.includes('嘗試') || text.includes('冒險')) {
         traits.story.courage = 3;
       }
       
       // 創造想像相關關鍵詞
       if (text.includes('創造') || text.includes('想像') || text.includes('創新') || 
           text.includes('創意') || text.includes('想象') || text.includes('幻想') ||
           text.includes('創作') || text.includes('構思') || text.includes('設想')) {
         traits.story.creativity = 3;
       }
       
       // 獨立自主相關關鍵詞
       if (text.includes('獨立') || text.includes('自主') || text.includes('自立') || 
           text.includes('獨特') || text.includes('自己') || text.includes('個人') ||
           text.includes('獨自') || text.includes('自決') || text.includes('自由')) {
         traits.story.independence = 3;
       }
       
       // 情感豐富相關關鍵詞
       if (text.includes('情感') || text.includes('感情') || text.includes('情緒') || 
           text.includes('內心') || text.includes('心情') || text.includes('感受') ||
           text.includes('情懷') || text.includes('心境') || text.includes('心靈')) {
         traits.story.emotional_depth = 3;
       }
       
       // 根據章節特色調整特質權重
       adjustTraitsByChapter(traits, chapter);
       
       return traits;
     }
     
     // 根據章節特色調整特質權重
     function adjustTraitsByChapter(traits, chapter) {
       switch(chapter) {
         case 'prologue':
           // 序章：夢境與現實的模糊，增強智慧追求和超脫境界
           if (traits.philosophical.wisdom_seeking) traits.philosophical.wisdom_seeking += 1;
           if (traits.philosophical.transcendence) traits.philosophical.transcendence += 1;
           if (traits.story.introspection) traits.story.introspection += 1;
           break;
           
         case 'chapter1':
           // 第一章：子非魚，關於認知和同理心
           if (traits.philosophical.compassion) traits.philosophical.compassion += 1;
           if (traits.philosophical.acceptance) traits.philosophical.acceptance += 1;
           if (traits.story.emotional_depth) traits.story.emotional_depth += 1;
           break;
           
         case 'chapter2':
           // 第二章：鯤鵬變化，關於視角和超越
           if (traits.philosophical.transcendence) traits.philosophical.transcendence += 1;
           if (traits.story.curiosity) traits.story.curiosity += 1;
           if (traits.story.courage) traits.story.courage += 1;
           break;
           
         case 'chapter3':
           // 第三章：鴟得腐鼠，關於價值觀多元
           if (traits.philosophical.acceptance) traits.philosophical.acceptance += 1;
           if (traits.philosophical.harmony) traits.philosophical.harmony += 1;
           if (traits.story.gentleness) traits.story.gentleness += 1;
           break;
           
         case 'chapter4':
           // 第四章：蝸角之爭，關於相對性和視角
           if (traits.philosophical.wisdom_seeking) traits.philosophical.wisdom_seeking += 1;
           if (traits.philosophical.authenticity) traits.philosophical.authenticity += 1;
           if (traits.story.introspection) traits.story.introspection += 1;
           break;
           
         case 'chapter5':
           // 第五章：朝菌大椿，關於時間和生命
           if (traits.philosophical.harmony) traits.philosophical.harmony += 1;
           if (traits.philosophical.acceptance) traits.philosophical.acceptance += 1;
           if (traits.story.resilience) traits.story.resilience += 1;
           break;
           
         case 'chapter6':
           // 第六章：天地為棺槨，關於生死超脫
           if (traits.philosophical.transcendence) traits.philosophical.transcendence += 1;
           if (traits.philosophical.wisdom_seeking) traits.philosophical.wisdom_seeking += 1;
           if (traits.story.courage) traits.story.courage += 1;
           break;
           
         case 'chapter7':
           // 第七章：道歸混沌，關於回歸本源
           if (traits.philosophical.authenticity) traits.philosophical.authenticity += 1;
           if (traits.philosophical.harmony) traits.philosophical.harmony += 1;
           if (traits.story.introspection) traits.story.introspection += 1;
           break;
               }
      }
      
      // 測試和演示函數（可以在開發者控制台中調用）
      function showPlayerAnalysis() {
        const data = getAIAnalysisData();
        console.log('🎯 玩家性格分析報告:');
        console.log('='.repeat(50));
        console.log('📊 基本統計:');
        console.log(`總選擇次數: ${data.profile.totalChoices}`);
        console.log(`平均思考時間: ${data.profile.averageThinkingTime}ms`);
        console.log(`一致性水平: ${data.profile.consistencyLevel}`);
        console.log(`哲學性格: ${data.profile.philosophicalProfile}`);
        console.log('');
        console.log('🧠 哲學傾向分數 (0-100):');
        for (const [trait, score] of Object.entries(data.traits)) {
          if (score > 0) {
            console.log(`${trait}: ${score}`);
          }
        }
        console.log('');
        console.log('🎭 主導特質:');
        console.log(`主要: ${data.patterns.dominantTraits.join(', ')}`);
        console.log(`次要: ${data.patterns.secondaryTraits.join(', ')}`);
        console.log('');
               console.log('📈 最近趨勢:');
       if (data.context?.recentHistory && data.context.recentHistory.length > 0) {
         data.context.recentHistory.forEach((choice, index) => {
           console.log(`${index + 1}. [${choice.chapter}] ${choice.choiceText} (思考${choice.thinkingTime}ms)`);
         });
       } else {
         console.log('暫無選擇記錄');
       }
        console.log('');
        console.log('🎨 建議AI風格:');
        console.log(`語調: ${data.suggestedStyle.tone}`);
        console.log(`深度: ${data.suggestedStyle.depth}`);
        console.log(`方式: ${data.suggestedStyle.approach}`);
        console.log('='.repeat(50));
        
        return data;
      }
      
      // 生成AI調用示例（演示如何使用數據）
      function generateAIPromptExample() {
        const data = getAIAnalysisData();
        
        const prompt = `你是莊子，正在與一位學生對話。基於以下分析數據，請生成個性化的回應：

玩家性格檔案：
- 哲學類型：${data.profile.philosophicalProfile}
- 主導特質：${data.patterns.dominantTraits.join(', ')}
- 一致性：${data.profile.consistencyLevel}
- 思考速度：${data.profile.averageThinkingTime > 3000 ? '深思熟慮' : '快速決斷'}

當前情境：
- 章節：${data.context.currentChapter}
- 形態：${data.context.currentForm}

最近選擇模式：
${(data.context?.recentHistory || []).map(h => `- ${h.choiceText || '未知選擇'}`).join('\n') || '暫無選擇記錄'}

建議回應風格：
- 語調：${data.suggestedStyle.tone}
- 深度：${data.suggestedStyle.depth}  
- 方式：${data.suggestedStyle.approach}

請以莊子的智慧和這個學生的特質，給出一個深刻而個性化的回應。`;

        console.log('🤖 AI調用示例Prompt:');
        console.log(prompt);
        console.log('');
        console.log('💡 可以複製上述prompt到AI API進行個性化回應生成');
        
        return prompt;
      }
      
      // 創建初始玩家選擇狀態
      function createInitialPlayerChoicesState() {
        return {
          choiceHistory: [],
          timingData: {
            sceneStartTime: null,
            choiceStartTime: null,
            totalThinkingTime: 0,
            averageThinkingTime: 0
          },
          philosophicalTraits: {
            compassion: 0, detachment: 0, curiosity: 0, acceptance: 0,
            intervention: 0, aesthetic: 0, pragmatism: 0, idealism: 0,
            relativism: 0, nonJudgmental: 0, harmony: 0, spontaneity: 0,
            wisdom: 0, paradoxical: 0
          },
          mbtiTraits: {
            extraversion: 0, introversion: 0, sensing: 0, intuition: 0,
            thinking: 0, feeling: 0, judging: 0, perceiving: 0
          },
          storyTraits: {
            analyticalApproach: 0, intuitiveApproach: 0, experientialApproach: 0,
            riskTolerance: 0, cautionLevel: 0, explorationDrive: 0,
            independence: 0, followership: 0, transformationOpenness: 0,
            relationshipWithZhuangzi: 0, ancientWisdomReception: 0, adventureSpirit: 0
          },
          choicePatterns: {
            consistencyScore: 0, contradictions: [], evolutionTrend: [],
            dominantTraits: [], secondaryTraits: [], storyBranches: []
          },
          chapterInfluences: {},
          aiContext: {
            lastUpdateTime: null, profileSummary: '', recentTrends: [],
            suggestedResponseStyle: '', philosophicalType: '', mbtiType: '',
            storyPersonalization: {}
          },
          transformationData: {
            transformationHistory: [],
            formUsageCount: {},
            firstTimeTransformations: [],
            dailyTransformations: [],
            transformationPatterns: {}
          },
          segmentationPuzzleData: {
            puzzleAttempts: {},
            puzzlePerformance: {
              averageCompletionTime: 0,
              averageAccuracy: 0,
              learningCurve: [],
              difficultyAdaptation: 0,
              persistenceLevel: 0
            }
          },
          sceneDwellTime: {
            sceneDwellTimes: {},
            totalDwellTime: 0,
            averageDwellTime: 0
          }
        };
      }
      
      // 重置選擇記錄（用於測試）
      function resetPlayerChoices() {
        gameState.playerChoices = {
          choiceHistory: [],
          timingData: {
            sceneStartTime: null,
            choiceStartTime: null,
            totalThinkingTime: 0,
            averageThinkingTime: 0
          },
          philosophicalTraits: {
            compassion: 0, detachment: 0, curiosity: 0, acceptance: 0,
            intervention: 0, aesthetic: 0, pragmatism: 0, idealism: 0,
            relativism: 0, nonJudgmental: 0, harmony: 0, spontaneity: 0,
            wisdom: 0, paradoxical: 0
          },
          mbtiTraits: {
            extraversion: 0, introversion: 0, sensing: 0, intuition: 0,
            thinking: 0, feeling: 0, judging: 0, perceiving: 0
          },
          storyTraits: {
            analyticalApproach: 0, intuitiveApproach: 0, experientialApproach: 0,
            riskTolerance: 0, cautionLevel: 0, explorationDrive: 0,
            independence: 0, followership: 0, transformationOpenness: 0,
            relationshipWithZhuangzi: 0, ancientWisdomReception: 0, adventureSpirit: 0
          },
          choicePatterns: {
            consistencyScore: 0, contradictions: [], evolutionTrend: [],
            dominantTraits: [], secondaryTraits: [], storyBranches: []
          },
          chapterInfluences: {},
          aiContext: {
            lastUpdateTime: null, profileSummary: '', recentTrends: [],
            suggestedResponseStyle: '', philosophicalType: '', mbtiType: '',
            storyPersonalization: {}
          },
          transformationData: {
            transformationHistory: [],
            formUsageCount: {},
            firstTimeTransformations: [],
            dailyTransformations: [],
            transformationPatterns: {}
          },
          segmentationPuzzleData: {
            puzzleAttempts: {},
            puzzlePerformance: {
              averageCompletionTime: 0,
              averageAccuracy: 0,
              learningCurve: [],
              difficultyAdaptation: 0,
              persistenceLevel: 0
            }
          },
          sceneDwellTime: {
            sceneDwellTimes: {},
            totalDwellTime: 0,
            averageDwellTime: 0
          }
        };
                 console.log('🔄 玩家選擇記錄已重置');
       }

    // DeepSeek AI 集成系統
    class ZhuangziAI {
      constructor() {
        this.apiKey = 'sk-d850478e8977454abc9975d544ffd4e3';
        this.baseUrl = 'https://api.deepseek.com';
        this.model = 'deepseek-chat';
        this.isEnabled = true;
        this.responseCache = new Map(); // 緩存AI回應避免重複調用
      }
      
      // 核心AI調用函數
      async callDeepSeekAPI(messages, options = {}) {
        if (!this.isEnabled) {
          console.log('🤖 AI功能已禁用');
          return null;
        }
        
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${this.apiKey}`
            },
            body: JSON.stringify({
              model: this.model,
              messages: messages,
              stream: false,
              temperature: options.temperature || 0.7,
              max_tokens: options.maxTokens || 500,
              top_p: options.topP || 0.9
            })
          });
          
          if (!response.ok) {
            throw new Error(`API調用失敗: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log('🤖 AI回應成功:', data.choices[0].message.content.substring(0, 100) + '...');
          return data.choices[0].message.content;
          
        } catch (error) {
          console.error('🚨 AI調用錯誤:', error);
          return null;
        }
      }
      
      // 生成個性化的莊子回應
      async generatePersonalizedResponse(context, playerData) {
        const cacheKey = this.generateCacheKey(context, playerData);
        
        // 詳細調試信息：AI調用開始
        console.log('🤖 ===== AI個性化回應調試信息 =====');
        console.log('🎯 調用時間:', new Date().toLocaleTimeString());
        console.log('📍 調用上下文:', {
          chapter: context.chapter,
          scene: context.scene,
          sceneType: context.sceneType,
          description: context.description,
          specificQuestion: context.specificQuestion,
          responseKey: context.responseKey
        });
        
        // 詳細調試信息：玩家數據分析
        console.log('👤 玩家數據分析:');
        console.log('  📊 基本檔案:', {
          哲學類型: playerData.profile?.philosophicalProfile || 'developing',
          主導特質: (playerData.patterns?.dominantTraits || []).slice(0, 3),
          一致性: playerData.profile?.consistencyLevel || 'unknown',
          思考時間: `${playerData.profile?.averageThinkingTime || 0}ms`,
          選擇總數: playerData.profile?.totalChoices || 0
        });
        
        console.log('  🧠 哲學特質:', playerData.traits || {});
        console.log('  🎭 MBTI特質:', playerData.mbtiTraits || {});
        console.log('  📚 故事特質:', playerData.storyTraits || {});
        
        console.log('  📈 選擇模式:', {
          主導特質: playerData.patterns?.dominantTraits || [],
          一致性分數: playerData.patterns?.consistencyScore || 0,
          最近趨勢: playerData.patterns?.recentTrends || []
        });
        
        console.log('  🎨 建議風格:', {
          語調: playerData.suggestedStyle?.tone || 'balanced',
          深度: playerData.suggestedStyle?.depth || 'medium',
          方式: playerData.suggestedStyle?.approach || 'guiding',
          個性化元素: playerData.suggestedStyle?.personalizedElements || []
        });
        
        console.log('  🕰️ 最近選擇歷史:');
        const recentChoices = (playerData.context?.recentHistory || []).slice(-5);
        recentChoices.forEach((choice, index) => {
          console.log(`    ${index + 1}. [${choice.chapter}] ${choice.choiceText} (${Math.round(choice.thinkingTime / 1000)}s)`);
          console.log(`       特質: ${JSON.stringify(choice.traits)}`);
        });
        
        // 檢查緩存
        if (this.responseCache.has(cacheKey)) {
          console.log('💾 使用緩存的AI回應');
          console.log('🔍 緩存鍵:', cacheKey.substring(0, 100) + '...');
          console.log('========================================');
          return this.responseCache.get(cacheKey);
        }
        
        // 構建AI調用消息
        const systemPrompt = this.buildSystemPrompt(playerData);
        const userPrompt = this.buildUserPrompt(context, playerData);
        
        console.log('📝 AI調用消息構建:');
        console.log('  🔧 系統提示詞長度:', systemPrompt.length, '字符');
        console.log('  📖 用戶提示詞長度:', userPrompt.length, '字符');
        console.log('  🌡️ 溫度參數:', this.getTemperatureByProfile(playerData.profile?.philosophicalProfile));
        
        // 顯示關鍵提示詞內容
        console.log('  🎯 關鍵系統提示內容:');
        console.log('    - 哲學類型:', this.translateProfile(playerData.profile?.philosophicalProfile || 'developing'));
        console.log('    - 主導特質:', (playerData.patterns?.dominantTraits || []).slice(0, 2).map(t => this.translateTrait(t)).join('、'));
        console.log('    - 思考方式:', playerData.profile?.averageThinkingTime > 3000 ? '深思熟慮' : '快速決斷');
        
        console.log('  🎯 關鍵用戶提示內容:');
        console.log('    - 當前章節:', context.chapter);
        console.log('    - 場景類型:', context.sceneType);
        console.log('    - 具體問題:', context.specificQuestion);
        console.log('    - 最近選擇:', recentChoices.slice(-1)[0]?.choiceText || '無');
        
        const messages = [
          {
            role: 'system',
            content: systemPrompt
          },
          {
            role: 'user', 
            content: userPrompt
          }
        ];
        
        console.log('🚀 開始調用DeepSeek API...');
        const startTime = Date.now();
        
        const response = await this.callDeepSeekAPI(messages, {
          temperature: this.getTemperatureByProfile(playerData.profile?.philosophicalProfile),
          maxTokens: 300
        });
        
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        console.log('⏱️ AI調用完成:', `${duration}ms`);
        
        if (response) {
          console.log('✅ AI回應成功生成:');
          console.log('  📏 回應長度:', response.length, '字符');
          console.log('  📝 回應內容預覽:', response.substring(0, 100) + '...');
          console.log('  🎯 回應是否包含個性化元素:', this.analyzePersonalization(response, playerData));
          
          // 緩存回應
          this.responseCache.set(cacheKey, response);
          console.log('💾 回應已緩存');
          
          // 限制緩存大小
          if (this.responseCache.size > 50) {
            const firstKey = this.responseCache.keys().next().value;
            this.responseCache.delete(firstKey);
            console.log('🗑️ 清理舊緩存');
          }
        } else {
          console.error('❌ AI回應生成失敗');
        }
        
        console.log('========================================');
        return response;
      }
      
      // 新增：分析回應的個性化程度
      analyzePersonalization(response, playerData) {
        const analysis = {
          包含哲學概念: false,
          回應特質相關: false,
          使用建議語調: false,
          長度合適: false,
          個性化得分: 0
        };
        
        // 檢查是否包含哲學概念
        const philosophicalKeywords = ['逍遙', '自然', '無為', '道', '變化', '相對', '超越', '和諧'];
        analysis.包含哲學概念 = philosophicalKeywords.some(keyword => response.includes(keyword));
        if (analysis.包含哲學概念) analysis.個性化得分 += 20;
        
        // 檢查是否回應了玩家特質
        const dominantTraits = playerData.patterns?.dominantTraits || [];
        const traitKeywords = {
          'compassion': ['理解', '同理', '關懷', '溫暖'],
          'wisdom_seeking': ['探索', '思考', '智慧', '學習'],
          'harmony': ['和諧', '平衡', '協調', '統一'],
          'transcendence': ['超越', '解脫', '昇華', '境界']
        };
        
        for (const trait of dominantTraits.slice(0, 2)) {
          const keywords = traitKeywords[trait] || [];
          if (keywords.some(keyword => response.includes(keyword))) {
            analysis.回應特質相關 = true;
            analysis.個性化得分 += 30;
            break;
          }
        }
        
        // 檢查語調是否符合建議
        const suggestedTone = playerData.suggestedStyle?.tone || 'balanced';
        const toneKeywords = {
          'warm': ['溫暖', '親切', '關懷', '理解'],
          'profound': ['深刻', '深層', '本質', '根本'],
          'gentle': ['溫和', '柔和', '輕柔', '平靜'],
          'poetic': ['詩意', '美麗', '優雅', '如詩']
        };
        
        const toneWords = toneKeywords[suggestedTone] || [];
        if (toneWords.some(word => response.includes(word))) {
          analysis.使用建議語調 = true;
          analysis.個性化得分 += 25;
        }
        
        // 檢查回應長度
        if (response.length >= 60 && response.length <= 120) {
          analysis.長度合適 = true;
          analysis.個性化得分 += 25;
        }
        
        return analysis;
      }
      
      // 生成莊子的親筆信
      async generatePersonalizedReport(prompt) {
        console.log('🎁 開始生成莊子的親筆信');
        
        const messages = [
          {
            role: 'system',
            content: `你是莊子本人，現在要穿越時空，為一位現代玩家寫一封親筆信。

你的身份和任務：
1. **你就是莊子**：用第一人稱"我"來寫，就像真的莊子在和這位朋友對話
2. **穿越時空**：表達你從古代穿越到現代來關心這位朋友
3. **個性洞察**：基於遊戲數據，深入分析這位朋友的個性特點
4. **生活啟示**：給出具體的生活建議和人生啟示
5. **情感連結**：建立你與這位現代朋友之間的情感連結
6. **未來指引**：針對他們的未來生活給出溫暖而智慧的指導

寫作風格：
- **情感基調**：溫暖、親切、充滿關懷，像長輩對晚輩的慈愛指導
- **語言風格**：現代白話文，親切自然，避免文言文，但要有莊子的智慧深度
- **啟示性**：重點在於給出對個性和生活的啟示，讓讀者有所感悟
- **感動性**：要有情感衝擊力，讓讀者讀完後感到溫暖、感動、有所啟發
- **實用性**：給出具體的生活建議，不只是抽象的哲學討論

這封信應該讓讀者感受到：莊子真的穿越時空來關心他們，理解他們，並為他們的人生提供智慧的指引。`
          },
          {
            role: 'user',
            content: prompt
          }
        ];
        
        const response = await this.callDeepSeekAPI(messages, {
          temperature: 0.8,
          maxTokens: 2000
        });
        
        return response || '抱歉，莊子的信生成失敗，請稍後再試。';
      }
      
                   // 構建系統提示詞
      buildSystemPrompt(playerData) {
        const profile = playerData.profile?.philosophicalProfile || 'developing';
        const dominantTraits = (playerData.patterns?.dominantTraits || []).slice(0, 2);
        const style = playerData.suggestedStyle || { tone: 'balanced', depth: 'medium', approach: 'guiding' };
        
        return `你是遊戲中的莊子，一位親切而智慧的導師。你必須使用繁體中文回應，用現代白話文與學生對話，語言自然流暢，不使用古文言文。請根據學生特質調整回應：

學生性格檔案：
- 哲學類型：${this.translateProfile(profile)}
- 主導特質：${dominantTraits.map(t => this.translateTrait(t)).join('、')}
- 思考方式：${playerData.profile.averageThinkingTime > 3000 ? '深思熟慮，喜歡仔細考慮' : '快速決斷，行動力強'}
- 一致性：${playerData.profile.consistencyLevel === 'high' ? '思想一致，立場堅定' : playerData.profile.consistencyLevel === 'medium' ? '思想較為一致' : '思想靈活，容易改變'}

語言風格要求：
- 必須使用繁體中文（Traditional Chinese）
- 使用現代白話文，如："看那些儵魚，游得多自在啊！"、"很好！你已獲得了新的能力"
- 親切自然，不要過於正式或文言
- 可以使用"你"、"我"、"這樣"、"很好"等現代表達
- 保持莊子的智慧但用現代語言表達

重要角色設定：
- 你就是莊子本人，請用第一人稱表達：說"我認為..."、"我曾經說過..."
- 絕對不要用第三人稱"莊子說的..."，因為你就是莊子
- 與學生直接對話，不是在介紹外部觀點

請給出60-80字的個性化回應，必須使用繁體中文，體現莊子哲學但用現代白話文表達。`;
      }
      
             // 構建用戶提示詞
       buildUserPrompt(context, playerData) {
         const recentChoices = (playerData.context?.recentHistory || []).slice(-3);
         const lastChoice = recentChoices[recentChoices.length - 1];
         
         // 獲取章節特定的上下文信息
         const chapterContexts = {
           'chapter1': {
             theme: '濠梁觀魚的知樂爭論',
             setting: '濠梁橋上觀察魚兒游泳',
             key_concepts: '知樂、觀察視角、魚兒的自由'
           },
           'chapter2': {
             theme: '鯤鵬逍遙的無限視野',
             setting: '北冥大海與九萬里高空',
             key_concepts: '無限視野、鯤鵬變化、逍遙境界'
           },
           'chapter3': {
             theme: '鴟得腐鼠的價值相對性',
             setting: '森林中遇見鵷鶵和鴟鴞',
             key_concepts: '價值相對性、美醜標準、不同視角'
           },
           'chapter4': {
             theme: '蝸角之爭的渺小與偉大',
             setting: '蝸牛觸角上的微觀世界',
             key_concepts: '大小相對性、爭執無意義、螺旋時空'
           },
           'chapter5': {
             theme: '朝菌大椿的時間長短',
             setting: '時間森林中的生命周期',
             key_concepts: '時間相對性、生命長短、朝菌與大椿的對比'
           },
           'chapter6': {
             theme: '莊子將死與生死一體',
             setting: '天地為棺槨的超越境界',
             key_concepts: '生死超越、螻蟻與星辰、天地懷抱、超越偏見'
           },
           'chapter7': {
             theme: '混沌之死與道的回歸',
             setting: '虛空殿中的渾沌復生',
             key_concepts: '混沌復生、七竅之謎、道的本質'
           }
         };
         
         const currentChapterInfo = chapterContexts[context.chapter] || chapterContexts['chapter1'];
         
         // 特殊處理斷句解讀場景
         if (context.sceneType === 'segmentation-interpretation') {
           return `🎯 **莊子解讀：古文智慧的個性化指導**

📖 **當前章節背景**：
- 章節主題：${currentChapterInfo.theme}
- 故事場景：${currentChapterInfo.setting}
- 核心概念：${currentChapterInfo.key_concepts}

📜 **古文資訊**：
${context.puzzleInfo ? `- 古文標題：${context.puzzleInfo.title}
- 古文主題：${context.puzzleInfo.theme}
- 古文內容：${context.puzzleInfo.text}
- 古文出處：${context.puzzleInfo.source}` : ''}

❓ **學生的問題**：
"${context.specificQuestion}"

🎭 **個性化回應要求**：
1. 你是莊子本人，請用第一人稱"我"來回應
2. 基於學生的哲學傾向（${(playerData.patterns?.dominantTraits || []).slice(0, 2).map(t => this.translateTrait(t)).join('、')}）來回答
3. 結合當前章節的主題和古文內容
4. 語調親切自然，像朋友聊天一樣，避免文言文
5. 可以分享"我"的人生智慧和哲學見解
6. 鼓勵學生在遊戲中的學習和思考
7. 回答控制在150-200字以內

💡 **重要**：請直接回答學生的問題，不要包含任何前綴或說明。用繁體中文的現代白話文。`;
         }
        
        return `🎯 **請基於當前章節內容，明確針對學生的最新選擇進行回應**

📖 **當前章節背景**：
- 章節主題：${currentChapterInfo.theme}
- 故事場景：${currentChapterInfo.setting}
- 核心概念：${currentChapterInfo.key_concepts}

🎯 **學生的最新選擇**：
學生剛才選擇："${lastChoice?.choiceText || context.specificQuestion || '學生的回應'}"
選擇情境：${context.description || '當前對話場景'}
體現特質：${lastChoice?.traits ? Object.keys(lastChoice.traits).slice(0, 2).join('、') : '深層思考'}

📚 **選擇歷史參考**：
${recentChoices.map((choice, index) => 
  `${index + 1}. "${choice.choiceText}" - 體現了${choice.traits ? Object.keys(choice.traits).slice(0, 2).join('、') : '某些特質'}`
).join('\n')}

💡 **回應要求**：
1. 必須基於當前章節的主題和故事背景進行回應
2. 明確評論學生的最近選擇：用"你剛才選擇..."、"從你的選擇中我看出..."開頭
3. 解釋這個選擇在當前章節語境下反映的哲學傾向
4. 結合本章節的莊子智慧給出相應指導
5. 語調親切自然，像朋友聊天一樣
6. 控制在60-80字，讓學生感受到個性化回應

🎭 **重要角色設定**：
- 你就是莊子本人，請用第一人稱表達觀點
- 說"我曾經說過..."、"我認為..."，不要說"莊子說的..."
- 你在與學生直接對話，不是在介紹莊子的思想

⚠️ **重要**：請必須圍繞當前章節"${currentChapterInfo.theme}"的內容進行回應，不要提及其他章節的內容。用繁體中文的現代白話文，避免文言文。`;
      }
      
             // 生成緩存鍵
       generateCacheKey(context, playerData) {
         const keyData = {
           profile: playerData.profile?.philosophicalProfile || 'developing',
           dominantTraits: (playerData.patterns?.dominantTraits || []).slice(0, 2),
           chapter: context.chapter || 'unknown',
           scene: context.scene || 'unknown',
           sceneType: context.sceneType || 'general',
           description: (context.description || '').substring(0, 50), // 取前50個字符避免key過長
           specificQuestion: (context.specificQuestion || '').substring(0, 30),
           recentChoices: (playerData.context?.recentHistory || []).slice(-2).map(h => h.choiceText || '')
         };
         return JSON.stringify(keyData);
       }
      
      // 根據性格調整AI溫度參數
      getTemperatureByProfile(profile) {
        const temperatureMap = {
          'sage': 0.6,        // 智者：更穩定、深刻
          'harmonizer': 0.7,  // 和諧者：平衡
          'seeker': 0.8,      // 求索者：更有創造性
          'acceptor': 0.65,   // 接納者：溫和穩定
          'artist': 0.85,     // 藝術家：最有創造性
          'developing': 0.75  // 發展中：中等創造性
        };
        return temperatureMap[profile] || 0.7;
      }
      
      // 翻譯函數
      translateProfile(profile) {
        const map = {
          'sage': '智者型（超脫而有智慧）',
          'harmonizer': '和諧者型（追求平衡與和諧）', 
          'seeker': '求索者型（好奇心強，喜歡探索）',
          'acceptor': '接納者型（包容性強，不輕易評判）',
          'artist': '藝術家型（重視美感和自然性）',
          'developing': '發展中型（思想還在形成過程中）'
        };
        return map[profile] || profile;
      }
      
      translateTrait(trait) {
        const map = {
          'compassion': '同理心', 'detachment': '超脫性', 'curiosity': '好奇心',
          'acceptance': '接納度', 'intervention': '干預傾向', 'aesthetic': '美學傾向',
          'pragmatism': '實用主義', 'idealism': '理想主義', 'relativism': '相對主義',
          'nonJudgmental': '不評判', 'harmony': '和諧追求', 'spontaneity': '自然性',
          'wisdom': '智慧洞察', 'paradoxical': '悖論思維'
        };
        return map[trait] || trait;
      }
      
      translateTone(tone) {
        const map = {
          'profound': '深邃而富有哲理', 'warm': '溫暖而親切',
          'mysterious': '神秘而引人深思', 'gentle': '溫和而理解',
          'poetic': '詩意而優美', 'balanced': '平衡而中庸'
        };
        return map[tone] || tone;
      }
      
      translateDepth(depth) {
        const map = {
          'deep': '深刻複雜，富有層次', 'medium': '適中，易於理解',
          'light': '簡潔明了，直接有效'
        };
        return map[depth] || depth;
      }
      
      translateApproach(approach) {
        const map = {
          'philosophical': '哲學思辨式', 'supportive': '支持鼓勵式',
          'questioning': '啟發提問式', 'understanding': '理解共情式',
          'inspiring': '啟發激勵式', 'guiding': '引導指點式'
        };
        return map[approach] || approach;
      }
      
      // 生成古文解讀
      async generateTextInterpretation(ancientText, playerData) {
        const messages = [
          {
            role: 'system',
            content: `你是莊子，請根據學生的性格特質，對古文進行個性化解讀。

學生特質：
- 哲學類型：${this.translateProfile(playerData.profile.philosophicalProfile)}
- 主導特質：${playerData.patterns.dominantTraits.map(t => this.translateTrait(t)).join('、')}

請必須用繁體中文的現代白話文，以親切自然的語調解讀古文的深層含義。避免文言文表達，回應控制在100字以內。`
          },
          {
            role: 'user',
            content: `古文：${ancientText}\n\n請根據我的性格特質，解讀這段古文對我的特殊意義。`
          }
        ];
        
        return await this.callDeepSeekAPI(messages, { maxTokens: 200 });
      }
      
      // 生成結局總結
      async generateEndingSummary(playerData) {
        const messages = [
          {
            role: 'system',
            content: `你是遊戲中的莊子，要對學生的學習歷程進行總結。請必須用繁體中文的現代白話文，以親切而深刻的語調總結學生的哲學特質和成長軌跡。`
          },
          {
            role: 'user',
            content: `學生的完整檔案：
總選擇：${playerData.profile.totalChoices}次
哲學類型：${this.translateProfile(playerData.profile.philosophicalProfile)}
主導特質：${playerData.patterns.dominantTraits.map(t => this.translateTrait(t)).join('、')}
一致性：${playerData.profile.consistencyLevel}
遊戲時長：${playerData.context.gameProgress.totalPlayTime}分鐘

請用親切自然的現代白話文給出總結，評價學生與莊子哲學的契合度，並指出成長方向。避免過於文言或正式的表達，回應控制在200字以內。`
          }
        ];
        
        return await this.callDeepSeekAPI(messages, { maxTokens: 400 });
      }
      
      // 生成章節總結
      async generateChapterSummary(chapter, playerData) {
        console.log('📊 ===== 章節總結AI調試信息 =====');
        console.log('🎯 調用時間:', new Date().toLocaleTimeString());
        console.log('📚 目標章節:', chapter);
        console.log('📦 玩家數據可用性:', !!playerData);
        
        const chapterNames = {
          'chapter1': '第一章：子非魚',
          'chapter2': '第二章：北冥有魚', 
          'chapter3': '第三章：鴟得腐鼠',
          'chapter4': '第四章：蝸角之爭',
          'chapter5': '第五章：朝菌大椿',
          'chapter6': '第六章：螻蟻星辰',
          'chapter7': '第七章：道歸混沌',
          'epilogue': '尾聲：逍遙遊'
        };
        
        // 確保數據完整性
        const safePlayerData = {
          choices: playerData.choices || [],
          traits: playerData.traits || {},
          profile: playerData.profile || { dominantTraits: [] },
          context: playerData.context || { 
            recentHistory: [],
            gameProgress: getGameProgressSummary()
          }
        };
        
        const recentChoices = safePlayerData.context.recentHistory.slice(-5); // 取最近5個選擇
        const chapterName = chapterNames[chapter] || chapter;
        
        console.log('📊 章節總結數據詳情:');
        console.log('  📖 章節名稱:', chapterName);
        console.log('  📈 最近選擇數量:', recentChoices.length);
        console.log('  🎯 主導特質:', safePlayerData.profile.dominantTraits);
        console.log('  🎭 是否為尾聲:', chapter === 'epilogue');
        console.log('  🎮 遊戲進度:', safePlayerData.context.gameProgress);
        console.log('  🔢 總選擇數:', safePlayerData.choices.length);
        
        console.log('  🕰️ 最近選擇詳情:');
        recentChoices.forEach((choice, index) => {
          console.log(`    ${index + 1}. [${choice.chapter}] ${choice.choiceText}`);
          console.log(`       思考時間: ${Math.round(choice.thinkingTime / 1000)}s, 特質: ${JSON.stringify(choice.traits)}`);
        });
        
        console.log('  🧠 當前特質狀態:');
        console.log('    哲學特質:', safePlayerData.traits);
        console.log('    MBTI特質:', playerData.mbtiTraits || {});
        console.log('    故事特質:', playerData.storyTraits || {});
        
        console.log('  📋 玩家檔案:');
        console.log('    哲學類型:', safePlayerData.profile.philosophicalProfile || 'developing');
        console.log('    一致性:', safePlayerData.profile.consistencyLevel || 'unknown');
        console.log('    平均思考時間:', safePlayerData.profile.averageThinkingTime || 0, 'ms');
        
        const messages = [
          {
            role: 'system',
            content: chapter === 'epilogue' ? 
              `你是莊子，正在為完成整個《萬物逍遙》旅程的學生寫一封告別信。請根據學生在整個遊戲中的表現，生成一封溫暖而深刻的告別信。

重要角色設定：
- 你就是莊子本人，請用第一人稱表達：說"我看到..."、"我認為..."
- 絕對不要用第三人稱"莊子認為..."，因為你就是莊子
- 與學生直接對話，分享你的觀察和建議

告別信要求：
- 必須針對學生在整個遊戲中的具體選擇和行為進行評價
- 分析學生展現的哲學特質和思維模式
- 給出個性化的生活建議和鼓勵
- 用繁體中文的親切自然現代白話文，避免套話
- 信長度：200-300字，要有內容深度
- 體現莊子的智慧和關懷
- 總結整個遊戲旅程的收穫和感悟
- 以"致逍遙未至的朋友："開頭，以"你跨越時空的朋友 庄周 于蝴蝶夢醒時分"結尾` :
              `你是莊子，正在為學生的${chapterName}學習做個性化總結。請根據學生的具體選擇和行為模式，生成一個詳細的章節總結。

重要角色設定：
- 你就是莊子本人，請用第一人稱表達：說"我看到..."、"我認為..."
- 絕對不要用第三人稱"莊子認為..."，因為你就是莊子
- 與學生直接對話，分享你的觀察和建議

總結要求：
- 必須針對學生的具體選擇進行評價
- 分析學生展現的哲學特質和思維模式
- 給出個性化的成長建議
- 用繁體中文的親切自然現代白話文，避免套話
- 總結長度：120-150字，要有內容深度
- 體現莊子的智慧和關懷
- 專注於本章內容，不要預告或提及下一章的具體內容`
          },
          {
            role: 'user',
            content: chapter === 'epilogue' ? 
              `請為我寫一封告別信，總結我在整個《萬物逍遙》旅程中的表現：

📊 **我的完整遊戲記錄：**
- 總遊戲時間：${safePlayerData.context.gameProgress.totalPlayTime}分鐘
- 總選擇次數：${safePlayerData.choices.length}次
- 解鎖物化形態：${safePlayerData.context.gameProgress.formsUnlocked}種
- 收集封印數量：${safePlayerData.context.gameProgress.aperturesCollected}個
- 完成章節：${safePlayerData.context.gameProgress.chaptersCompleted.join('、')}

📝 **我的選擇記錄：**
${safePlayerData.choices.slice(-10).map((choice, index) => 
  `${index + 1}. ${choice.chapter}場景${choice.scene}："${choice.choiceText}"
     - 思考時間：${Math.round((choice.thinkingTime || 0) / 1000 * 10) / 10}秒`
).join('\n')}

🧠 **我的哲學特質：**
- 性格類型：${safePlayerData.profile.dominantTraits.join('、') || '探索型'}
- 主要哲學傾向：${Object.entries(safePlayerData.traits).sort(([,a], [,b]) => b-a).slice(0, 3).map(([k,v]) => k).join('、') || '開放學習'}
- 平均思考時間：${Math.round((safePlayerData.choices.reduce((sum, c) => sum + (c.thinkingTime || 0), 0) / Math.max(1, safePlayerData.choices.length)) / 1000 * 10) / 10}秒

🎯 **告別信要求：**
請生成200-300字的溫暖告別信，必須包含：
1. 對我整個遊戲旅程的深度評價
2. 我在遊戲中展現的哲學智慧和思維特質
3. 我的學習方式和思考模式分析
4. 針對性的生活建議和鼓勵
5. 對整個遊戲體驗的感悟和收穫
6. 以"致逍遙未至的朋友："開頭
7. 以"你跨越時空的朋友 庄周 于蝴蝶夢醒時分"結尾

請用莊子的智慧和溫暖的語調來寫，讓我感受到跨越時空的關懷和指導。` :
              `請為我在${chapterName}的學習做詳細總結：

📊 **我的選擇記錄：**
${recentChoices.map((choice, index) => 
  `${index + 1}. 場景${choice.scene}："${choice.choiceText}"
     - 思考時間：${Math.round((choice.thinkingTime || 0) / 1000 * 10) / 10}秒
     - 反映特質：${choice.traits && Object.keys(choice.traits).length > 0 ? 
       Object.keys(choice.traits).slice(0, 3).join('、') : '理性思考'}`
).join('\n')}

🧠 **我的思維特點：**
- 性格類型：${safePlayerData.profile.dominantTraits.join('、') || '探索型'}
- 主要哲學傾向：${Object.entries(safePlayerData.traits).sort(([,a], [,b]) => b-a).slice(0, 3).map(([k,v]) => k).join('、') || '開放學習'}
- 平均思考時間：${Math.round((safePlayerData.context.recentHistory.reduce((sum, h) => sum + (h.thinkingTime || 0), 0) / Math.max(1, safePlayerData.context.recentHistory.length)) / 1000 * 10) / 10}秒

🎯 **總結要求：**
請生成120-150字的詳細總結，必須包含：
1. 對我具體選擇的深度評價（例如："從你選擇'...'可以看出..."）
2. 我在本章展現的哲學智慧和思維特質
3. 我的學習方式和思考模式分析
4. 針對性的成長建議和鼓勵
5. 對本章學習的整體感悟和收穫

請用莊子的智慧和溫暖的語調來寫，讓我感受到個性化的關懷和指導。不要預告下一章的具體內容。`
          }
        ];
        
                 const result = await this.callDeepSeekAPI(messages, { maxTokens: 400 });
         
         if (result) {
           console.log('✅ 章節總結生成成功!');
           console.log('📖 總結長度:', result.length, '字符');
           console.log('📝 總結內容預覽:', result.substring(0, 80) + '...');
           
           // 檢查總結質量
           if (result.length < 50) {
             console.warn('⚠️ 總結內容過短，可能是AI調用問題');
           } else if (result.length > 200) {
             console.log('💪 總結內容豐富，符合預期');
           }
         } else {
           console.error('❌ 章節總結生成失敗，返回null');
         }
         
         return result;
      }
      
      // 啟用/禁用AI功能
      toggleAI(enabled) {
        this.isEnabled = enabled;
        console.log(`🤖 AI功能已${enabled ? '啟用' : '禁用'}`);
      }
      
      // 清空緩存
      clearCache() {
        this.responseCache.clear();
        console.log('💾 AI回應緩存已清空');
      }
    }
    
    // 創建全局AI實例
    const zhuangziAI = new ZhuangziAI();
    
    // 掛載到window對象，使其全局可用
    window.zhuangziAI = zhuangziAI;
    
    // 驗證兩個引用指向同一個對象
    console.log('🔍 AI實例驗證:', {
      '局部zhuangziAI存在': !!zhuangziAI,
      'window.zhuangziAI存在': !!window.zhuangziAI,
      '兩者是同一個實例': zhuangziAI === window.zhuangziAI,
      'API密鑰一致': zhuangziAI.apiKey === window.zhuangziAI.apiKey
    });
    
    // AI調用的便捷函數
    async function getPersonalizedZhuangziResponse(context, specificQuestion = '') {
      const playerData = getAIAnalysisData();
      const fullContext = {
        ...context,
        specificQuestion: specificQuestion
      };
      
      return await zhuangziAI.generatePersonalizedResponse(fullContext, playerData);
    }
    
    // 獲取個性化古文解讀
    async function getPersonalizedTextInterpretation(ancientText) {
      const playerData = getAIAnalysisData();
      return await zhuangziAI.generateTextInterpretation(ancientText, playerData);
    }
    
    // 獲取遊戲結局總結
    async function getGameEndingSummary() {
      const playerData = getAIAnalysisData();
      return await zhuangziAI.generateEndingSummary(playerData);
    }
    
        // === ContentMixer系統已移除 ===
        // 根據新的設計理念，所有personalized-response場景都直接調用AI生成
        // AI和預設內容的比例通過四階段場景結構設計來控制，無需動態混合系統

                 // AI個性化回應生成函數（直接調用AI，不使用混合系統）
         window.generateSmartResponse = async function(choice, context = {}) {
             console.log('🤖 ===== generateSmartResponse調試信息 =====');
             console.log('🎯 調用時間:', new Date().toLocaleTimeString());
             console.log('📝 玩家選擇:', choice);
             console.log('🎬 場景上下文:', context);
             console.log('🎮 當前遊戲狀態:', {
                 chapter: gameState.currentChapter,
                 scene: gameState.currentScene,
                 currentForm: gameState.currentForm
             });
             
                // 準備AI調用的數據格式
                console.log('📊 準備收集玩家數據...');
                const playerData = getAIAnalysisData();
                
                const aiContext = {
                    chapter: context.chapter || gameState.currentChapter,
                    scene: context.scene || gameState.currentScene,
                 sceneType: context.sceneType || 'general', // 重要：包含場景類型
                    currentForm: gameState.currentForm,
                 description: context.description || context.sceneContext || '當前遊戲場景',
                 specificQuestion: choice,
                 responseKey: context.responseKey || '' // 包含回應鍵
                };
                
                console.log('🎭 AI調用上下文:', aiContext);
                console.log('👤 玩家數據摘要:', {
                    總選擇數: playerData.choices?.length || 0,
                    哲學特質數: Object.keys(playerData.traits || {}).length,
                    檔案類型: playerData.profile?.philosophicalProfile,
                    建議風格: playerData.suggestedStyle
                });
                
                console.log('🚀 開始調用AI生成個性化回應...');
                const aiStartTime = Date.now();
                
             // 直接調用AI生成個性化回應
                const response = await zhuangziAI.generatePersonalizedResponse(aiContext, playerData);
                
                const aiEndTime = Date.now();
                const aiDuration = aiEndTime - aiStartTime;
                
                console.log('⏱️ AI調用耗時:', `${aiDuration}ms`);
                
                if (response) {
                    console.log('✅ AI個性化回應生成成功!');
                    console.log('📏 回應長度:', response.length, '字符');
                    console.log('📝 回應內容:', response);
                    console.log('🎯 回應品質檢查:', {
                        包含繁體中文: /[\u4e00-\u9fff]/.test(response),
                        長度合適: response.length >= 40 && response.length <= 120,
                        包含個性化元素: response.includes('你') || response.includes('選擇'),
                        符合莊子風格: response.includes('道') || response.includes('自然') || response.includes('逍遙') || response.includes('無為')
                    });
                } else {
                    console.warn('⚠️ AI回應生成失敗，返回null');
                }
                
                console.log('========================================');
                return response;
         };

         // 測試第一章優化版本
         window.testChapter1Optimization = async function() {
             console.log('🧪 測試第一章優化版本...');
             
             // 重置遊戲狀態到第一章
             gameState.currentChapter = 'chapter1';
             gameState.currentScene = 0;
             gameState.playerChoices = createInitialPlayerChoicesState();
             
             console.log('✅ 已重置到第一章開始');
             console.log('🎯 第一章優化特色：');
             console.log('  - 5個主要分支對話場景（含2個新增深度對話）');
             console.log('  - 3層特質分析系統：');
             console.log('    • 哲學傾向（14個維度）');
             console.log('    • MBTI人格（8個維度）');
             console.log('    • 故事互動（12個維度）');
             console.log('  - 每個選項包含多維度隱蔽標記');
             console.log('  - 個性化AI回應機制');
             console.log('  - 智能選擇記錄系統');
             console.log('');
             console.log('💡 體驗提示：');
             console.log('  - 每個選擇都會被隱蔽記錄和分析');
             console.log('  - 選擇會影響後續的個性化內容');
             console.log('  - 可使用 showPlayerAnalysis() 查看分析結果');
             
             // 加載第一章
             transitionToChapter('chapter1');
             
             return '第一章優化版本已啟動！請進行選擇來體驗新的分支對話系統。';
         };

         // testContentMixer函數已移除，因為ContentMixer系統已刪除

         // 清除AI緩存並重新開始第一章（用於測試個性化回應修復）
         window.clearAICacheAndRestartChapter1 = function() {
             console.log('🧹 清除AI緩存...');
             zhuangziAI.clearCache();
             
             console.log('🔄 重置第一章進度...');
             gameState.currentChapter = 'chapter1';
             gameState.currentScene = 0;
             gameState.playerChoices = createInitialPlayerChoicesState();
             
             console.log('✅ AI緩存已清除，第一章已重置');
             console.log('💡 現在可以重新體驗第一章的個性化回應，每個場景都會生成全新的AI內容');
             
             // 重新加載第一章
             transitionToChapter('chapter1');
             
             return '已清除AI緩存並重置第一章！現在每個個性化回應場景都會生成新的AI內容。';
         };

         // 測試AI功能
     async function testAI() {
       console.log('🧪 測試AI功能...');
       
       // 確保有一些測試數據
       if (gameState.playerChoices.choiceHistory.length === 0) {
         console.log('🔧 創建測試選擇記錄...');
         recordPlayerChoice({
           text: '靜靜觀察，不打擾它們',
           index: 1,
           speaker: '莊子',
           situation: '測試情境',
           traits: { detachment: 3, curiosity: 2 }
         });
         
         recordPlayerChoice({
           text: '我能感受到它的快樂',
           index: 0,
           speaker: '莊子',
           situation: '測試情境',
           traits: { compassion: 4, relativism: 2 }
         });
       }
       
       const testContext = {
         chapter: 'chapter1',
         scene: 5,
         currentForm: 'human',
         description: '在濠梁之上觀魚'
       };
       
       try {
         console.log('🔧 準備調用AI...');
         const response = await getPersonalizedZhuangziResponse(testContext, '我該如何理解魚的快樂？');
         
         if (response) {
           console.log('✅ AI測試成功！');
           console.log('🤖 莊子回應:', response);
         } else {
           console.log('❌ AI回應為空');
         }
         
         return response;
       } catch (error) {
         console.error('🚨 AI測試錯誤:', error);
         return null;
       }
     }
     
     // AI回應UI組件
     function createAIResponseDisplay(response, context = {}) {
       // 移除現有的AI回應（如果存在）
       const existingResponse = document.querySelector('.ai-response-container');
       if (existingResponse) {
         existingResponse.remove();
       }
       
       // 創建AI回應容器
       const container = document.createElement('div');
       container.className = 'ai-response-container fixed top-4 right-4 max-w-md bg-gradient-to-br from-purple-50 to-indigo-50 dark:from-purple-900 dark:to-indigo-900 border-2 border-purple-300 dark:border-purple-600 rounded-xl p-4 shadow-lg z-50 transform translate-x-full transition-transform duration-500';
       
       // 添加莊子頭像和標題
       const header = document.createElement('div');
       header.className = 'flex items-center mb-3';
       header.innerHTML = `
         <div class="w-10 h-10 bg-gradient-to-br from-purple-400 to-indigo-500 rounded-full flex items-center justify-center text-white font-bold text-lg mr-3">
           莊
         </div>
         <div>
           <div class="font-semibold text-gray-800 dark:text-gray-200">莊子的智慧</div>
           <div class="text-xs text-gray-500 dark:text-gray-400">個性化回應</div>
         </div>
       `;
       container.appendChild(header);
       
       // 添加回應內容
       const content = document.createElement('div');
       content.className = 'text-sm text-gray-700 dark:text-gray-300 leading-relaxed mb-3 border-l-3 border-purple-300 dark:border-purple-600 pl-3';
       content.textContent = response;
       container.appendChild(content);
       
       // 添加關閉按鈕
       const closeButton = document.createElement('button');
       closeButton.className = 'absolute top-2 right-2 w-6 h-6 bg-gray-200 dark:bg-gray-700 hover:bg-gray-300 dark:hover:bg-gray-600 rounded-full flex items-center justify-center text-gray-500 dark:text-gray-400 text-xs';
       closeButton.innerHTML = '×';
       closeButton.onclick = () => hideAIResponse();
       container.appendChild(closeButton);
       
       // 添加到頁面
       document.body.appendChild(container);
       
       // 動畫顯示
       setTimeout(() => {
         container.style.transform = 'translateX(0)';
       }, 100);
       
       // 自動隱藏（15秒後）
       setTimeout(() => {
         hideAIResponse();
       }, 15000);
       
       return container;
     }
     
     // 隱藏AI回應
     function hideAIResponse() {
       const container = document.querySelector('.ai-response-container');
       if (container) {
         container.style.transform = 'translateX(full)';
         setTimeout(() => {
           container.remove();
         }, 500);
       }
     }
     
     // 在特定情境下觸發AI回應
     async function triggerContextualAIResponse(context, question = '') {
       console.log('🤖 觸發情境AI回應:', context);
       
       const response = await getPersonalizedZhuangziResponse(context, question);
       
       if (response) {
         createAIResponseDisplay(response, context);
         return response;
       }
       
       return null;
     }
     
     // 在斷句完成後觸發AI解讀
     async function triggerTextInterpretationAI(ancientText) {
       console.log('📜 觸發古文解讀AI:', ancientText.substring(0, 50) + '...');
       
       const interpretation = await getPersonalizedTextInterpretation(ancientText);
       
       if (interpretation) {
         createAIResponseDisplay(interpretation, { type: 'text_interpretation' });
         return interpretation;
       }
       
       return null;
     }
     
     // 創建AI功能控制面板（開發用）
     function createAIControlPanel() {
       // 檢查是否已存在
       if (document.querySelector('.ai-control-panel')) {
         return;
       }
       
       const panel = document.createElement('div');
       panel.className = 'ai-control-panel fixed bottom-4 left-4 bg-gray-800 text-white p-3 rounded-lg shadow-lg z-50';
       panel.innerHTML = `
         <div class="text-sm font-semibold mb-2">🤖 AI控制面板</div>
         <div class="flex flex-col gap-2">
           <button onclick="testAI()" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-xs">
             測試AI
           </button>
           <!-- 測試混合系統按鈕已移除（ContentMixer已刪除） -->
           <button onclick="testChapter1Optimization()" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-xs">
             測試第一章優化
           </button>
           <button onclick="console.log('🎯 第一章優化特色：\\n- 5個分支對話場景\\n- 3層特質分析系統\\n- 隱蔽心理分析\\n- 個性化AI回應\\n\\n💡 使用 showPlayerAnalysis() 查看分析結果')" class="bg-blue-600 hover:bg-blue-700 px-3 py-1 rounded text-xs">
             第一章說明
           </button>
           <button onclick="showPlayerAnalysis()" class="bg-green-600 hover:bg-green-700 px-3 py-1 rounded text-xs">
             完整分析報告
           </button>
           <button onclick="zhuangziAI.toggleAI(!zhuangziAI.isEnabled)" class="bg-yellow-600 hover:bg-yellow-700 px-3 py-1 rounded text-xs">
             切換AI
           </button>
           <button onclick="zhuangziAI.clearCache()" class="bg-red-600 hover:bg-red-700 px-3 py-1 rounded text-xs">
             清空緩存
           </button>
           <button onclick="document.querySelector('.ai-control-panel').remove()" class="bg-gray-600 hover:bg-gray-700 px-3 py-1 rounded text-xs">
             隱藏面板
           </button>
         </div>
       `;
       
       document.body.appendChild(panel);
     }
     
     // === 新增：完整玩家分析報告顯示 ===
     function showPlayerAnalysis() {
       const analysis = generateComprehensivePlayerAnalysis();
       
       let reportHTML = `
         <div class="comprehensive-analysis" style="max-height: 80vh; overflow-y: auto; padding: 20px; background: rgba(255,255,255,0.95); border-radius: 10px; margin: 20px;">
           <h2 style="color: #4A5568; border-bottom: 2px solid #E2E8F0; padding-bottom: 10px;">🎭 完整人格分析報告</h2>
           
           <div class="analysis-section">
             <h3 style="color: #2D3748;">📊 基本統計</h3>
             <p><strong>總選擇次數：</strong>${analysis.summary.totalChoices}</p>
             <p><strong>平均思考時間：</strong>${analysis.summary.averageThinkingTime}秒</p>
             <p><strong>旅程時長：</strong>${analysis.summary.journeyDuration}分鐘</p>
             <p><strong>選擇一致性：</strong>${analysis.summary.consistencyScore}%</p>
           </div>
           
           <div class="analysis-section">
             <h3 style="color: #2D3748;">🧠 MBTI人格分析</h3>
             <p><strong>人格類型：</strong>${analysis.mbtiAnalysis.type}</p>
             <p><strong>類型描述：</strong>${analysis.mbtiAnalysis.description}</p>
             
             <div style="margin-left: 20px;">
               <p><strong>能量來源：</strong>${analysis.mbtiAnalysis.dimensions.energySource.type} - ${analysis.mbtiAnalysis.dimensions.energySource.description}</p>
               <p><strong>信息處理：</strong>${analysis.mbtiAnalysis.dimensions.informationProcessing.type} - ${analysis.mbtiAnalysis.dimensions.informationProcessing.description}</p>
               <p><strong>決策方式：</strong>${analysis.mbtiAnalysis.dimensions.decisionMaking.type} - ${analysis.mbtiAnalysis.dimensions.decisionMaking.description}</p>
               <p><strong>生活方式：</strong>${analysis.mbtiAnalysis.dimensions.lifestylePreference.type} - ${analysis.mbtiAnalysis.dimensions.lifestylePreference.description}</p>
             </div>
           </div>
           
           <div class="analysis-section">
             <h3 style="color: #2D3748;">🏛️ 莊子哲學性格</h3>
             <p><strong>哲學類型：</strong>${analysis.philosophicalAnalysis.description}</p>
             
             <h4>主要哲學特質：</h4>
             <ul>
               ${analysis.philosophicalAnalysis.dominantTraits.map(trait => 
                 `<li><strong>${trait.trait}：</strong>${trait.level}度 (${trait.score}分)</li>`
               ).join('')}
             </ul>
           </div>
           
           <div class="analysis-section">
             <h3 style="color: #2D3748;">📚 故事互動分析</h3>
             <p><strong>與莊子的關係：</strong>${analysis.storyAnalysis.relationshipWithZhuangzi}</p>
             <p><strong>學習風格：</strong>${analysis.storyAnalysis.learningStyle}</p>
             <p><strong>冒險精神：</strong>${analysis.storyAnalysis.adventureSpirit}</p>
             <p><strong>智慧接受度：</strong>${analysis.storyAnalysis.wisdomReception}</p>
           </div>
           
           <div class="analysis-section">
             <h3 style="color: #2D3748;">💡 個性化洞察</h3>
             <ul>
               ${analysis.personalizedInsights.map(insight => 
                 `<li>${insight}</li>`
               ).join('')}
             </ul>
           </div>
           
           <button onclick="this.parentElement.style.display='none'" style="margin-top: 20px; padding: 10px 20px; background: #4299E1; color: white; border: none; border-radius: 5px; cursor: pointer;">關閉報告</button>
         </div>
       `;
       
       // 創建覆蓋層顯示報告
       const overlay = document.createElement('div');
       overlay.style.cssText = `
         position: fixed; top: 0; left: 0; width: 100%; height: 100%; 
         background: rgba(0,0,0,0.8); z-index: 10000; 
         display: flex; justify-content: center; align-items: center;
       `;
       overlay.innerHTML = reportHTML;
       document.body.appendChild(overlay);
       
       // 點擊外部關閉
       overlay.addEventListener('click', (e) => {
         if (e.target === overlay) {
           overlay.remove();
         }
       });
     }
     
     // === 新增：分支對話選項配置示例 ===
     const storyChoiceExamples = {
       // 序章：身份探索的故事導向選項
       prologueIdentityChoice: {
         philosophical: { curiosity: 5, acceptance: 3 },
         mbti: { intuition: 4, perceiving: 2 },
         story: { philosophicalDepth: 3, relationshipWithZhuangzi: 2 },
         storyImpact: { branchInfluence: 'curious_seeker' }
       },
       
       // 第一章：同理心與哲學深度的測試
       chapter1EmpathyChoice: {
         philosophical: { compassion: 8, wisdom: 4 },
         mbti: { feeling: 6, intuition: 3 },
         story: { ancientWisdomReception: 5, trustInGuidance: 3 },
         storyImpact: { branchInfluence: 'empathetic_learner' }
       },
       
       // 第二章：風險承受與探索精神
       chapter2AdventureChoice: {
         philosophical: { curiosity: 6, intervention: 4 },
         mbti: { extraversion: 5, perceiving: 4 },
         story: { riskTolerance: 7, explorationDrive: 6 },
         storyImpact: { branchInfluence: 'bold_explorer' }
       },
       
       // 第三章：價值觀接納與判斷態度
       chapter3ToleranceChoice: {
         philosophical: { acceptance: 9, nonJudgmental: 7 },
         mbti: { feeling: 5, perceiving: 3 },
         story: { philosophicalDepth: 4 },
         storyImpact: { branchInfluence: 'tolerant_observer' }
       }
     };
     
     // === 新增：智能選項生成函數 ===
     function generateStoryChoices(situation, chapterContext) {
       // 基於玩家當前特質和章節上下文生成個性化選項
       const currentTraits = gameState.playerChoices.philosophicalTraits;
       const currentMbti = gameState.playerChoices.mbtiTraits;
       const currentStory = gameState.playerChoices.storyTraits;
       
       // 這裡可以根據玩家已有特質傾向，生成與之互補或強化的選項
       // 例如：如果玩家已經表現出高度同理心，可以提供更多邏輯思考的選項
       
       return {
         // 選項生成邏輯將基於玩家特質和故事需求
         adaptive: true,
         context: chapterContext
       };
     }
     
     // === 新增：選擇記錄便捷函數 ===
     function recordStoryChoice(choiceText, choiceConfig) {
       recordPlayerChoice({
         text: choiceText,
         philosophical: choiceConfig.philosophical || {},
         mbti: choiceConfig.mbti || {},
         story: choiceConfig.story || {},
         storyImpact: choiceConfig.storyImpact || {},
         speaker: 'Player',
         situation: getCurrentSituation()
       });
     }

     // 高級AI功能：基於選擇歷史的智能提示
     async function getSmartHint(currentContext) {
       const playerData = getAIAnalysisData();
       
       if (playerData.profile.totalChoices < 3) {
         return null; // 選擇太少，無法提供有意義的提示
       }
       
       const messages = [
         {
           role: 'system',
                       content: `你是莊子的智慧化身，要給學生一個簡短的提示。基於學生的選擇模式，用一句話點出他可能忽略的視角或深層思考。必須用繁體中文，不超過30字。`
         },
         {
           role: 'user',
           content: `學生檔案：
類型：${zhuangziAI.translateProfile(playerData.profile?.philosophicalProfile || 'developing')}
主導特質：${(playerData.patterns?.dominantTraits || []).map(t => zhuangziAI.translateTrait(t)).join('、') || '尚未確定'}
最近選擇：${(playerData.context?.recentHistory || []).slice(-2).map(h => h.choiceText || '').join('；') || '暫無記錄'}

當前情境：${currentContext.description || ''}

給出一個簡短而深刻的提示。`
         }
       ];
       
       return await zhuangziAI.callDeepSeekAPI(messages, { maxTokens: 50 });
     }

    // 音頻管理系統
    class AudioManager {
      constructor() {
        this.backgroundMusic = new Audio();
        this.backgroundMusic.loop = true;
        this.backgroundMusic.volume = 0.3; // 默認音量
        this.currentChapterMusic = null;
        this.fadeInDuration = 2000; // 淡入時間（毫秒）
        this.fadeOutDuration = 1500; // 淡出時間（毫秒）
        
        // 章節特定音量設置
        this.chapterVolumes = {
          'chapter1': 0.3,
          'chapter2': 0.3,
          'chapter3': 0.3,
          'chapter4': 0.3,
          'chapter5': 0.6, // 朝菌大椿章節音量調高
          'chapter6': 0.3,
          'chapter7': 0.3,
          'epilogue': 0.3,
          'mysterious-gift': 0.4 // 神秘禮物音樂音量
        };
        this.defaultVolume = 0.3; // 默認音量
      }

      // 播放背景音樂，支持淡入效果和章節特定音量
      playBackgroundMusic(audioUrl, fadeIn = true, chapterId = null) {
        if (!gameState.audioEnabled) return;
        
        // 如果已經在播放相同的音樂，不重複播放
        if (this.currentChapterMusic === audioUrl && !this.backgroundMusic.paused) {
          return;
        }

        // 獲取該章節的目標音量
        this.targetVolume = chapterId && this.chapterVolumes[chapterId] 
          ? this.chapterVolumes[chapterId] 
          : this.defaultVolume;

        // 如果有其他音樂在播放，先淡出
        if (!this.backgroundMusic.paused) {
          this.fadeOut(() => {
            this.loadAndPlay(audioUrl, fadeIn);
          });
        } else {
          this.loadAndPlay(audioUrl, fadeIn);
        }
      }

      // 載入並播放音樂
      loadAndPlay(audioUrl, fadeIn) {
        this.backgroundMusic.src = audioUrl;
        this.currentChapterMusic = audioUrl;
        
        if (fadeIn) {
          this.backgroundMusic.volume = 0;
          this.backgroundMusic.play().then(() => {
            this.fadeIn();
          }).catch(error => {
            console.warn('音頻播放失敗:', error);
          });
        } else {
          this.backgroundMusic.volume = this.targetVolume || this.defaultVolume;
          this.backgroundMusic.play().catch(error => {
            console.warn('音頻播放失敗:', error);
          });
        }
      }

      // 停止背景音樂，支持淡出效果
      stopBackgroundMusic(fadeOut = true) {
        if (this.backgroundMusic.paused) return;
        
        if (fadeOut) {
          this.fadeOut(() => {
            this.backgroundMusic.pause();
            this.currentChapterMusic = null;
          });
        } else {
          this.backgroundMusic.pause();
          this.backgroundMusic.volume = this.defaultVolume;
          this.currentChapterMusic = null;
        }
      }

      // 淡入效果
      fadeIn() {
        const targetVolume = this.targetVolume || this.defaultVolume;
        const steps = 20;
        const volumeStep = targetVolume / steps;
        const timeStep = this.fadeInDuration / steps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
          currentStep++;
          this.backgroundMusic.volume = Math.min(volumeStep * currentStep, targetVolume);
          
          if (currentStep >= steps) {
            clearInterval(fadeInterval);
          }
        }, timeStep);
      }

      // 淡出效果
      fadeOut(callback) {
        const initialVolume = this.backgroundMusic.volume;
        const steps = 15;
        const volumeStep = initialVolume / steps;
        const timeStep = this.fadeOutDuration / steps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
          currentStep++;
          this.backgroundMusic.volume = Math.max(initialVolume - (volumeStep * currentStep), 0);
          
          if (currentStep >= steps) {
            clearInterval(fadeInterval);
            if (callback) callback();
          }
        }, timeStep);
      }

      // 設置音頻開關
      setAudioEnabled(enabled) {
        gameState.audioEnabled = enabled;
        if (!enabled && !this.backgroundMusic.paused) {
          this.stopBackgroundMusic(true);
        }
      }
    }

    // 創建全局音頻管理器
    const audioManager = new AudioManager();
    
    // 切換到神秘禮物專用音樂
    function switchToMysteriousGiftMusic() {
      console.log('🎵 切換到神秘禮物音樂');
      
      // 神秘禮物音樂URL
      const mysteriousGiftMusicUrl = 'https://chineseclassics.github.io/files/audio/zhuangzi/credit2.mp4';
      
      // 播放神秘禮物音樂，使用淡入效果
      audioManager.playBackgroundMusic(mysteriousGiftMusicUrl, true, 'mysterious-gift');
      
      console.log('🎵 神秘禮物音樂已開始播放');
    }
    
    // DOM Elements
    const gameContainer = document.getElementById('game-container');
    const mainMenu = document.getElementById('main-menu');
    const gameContent = document.getElementById('game-content');
    const gameUI = document.getElementById('game-ui');
    const chapterTitle = document.getElementById('chapter-title');
    const chapterName = document.getElementById('chapter-name');
    const chapterDescription = document.getElementById('chapter-description');
    const aperturesTracker = document.getElementById('apertures-tracker');
    const dialogBox = document.getElementById('dialog-box');
    const dialogText = document.getElementById('dialog-text');
    const dialogOptions = document.getElementById('dialog-options');
    const advanceBtn = document.getElementById('advance-btn');
    const startGameBtn = document.getElementById('start-game');
    const formButtons = {
      human: document.getElementById('human-form'),
      butterfly: document.getElementById('butterfly-form'),
      fish: document.getElementById('fish-form'),
      kun: document.getElementById('kun-form'),
      peng: document.getElementById('peng-form'),
              yuanchu: document.getElementById('yuanchu-form'),
        chixiao: document.getElementById('chixiao-form'),
      snail: document.getElementById('snail-form'),
      'morning-fungus': document.getElementById('morning-fungus-form'),
      cicada: document.getElementById('cicada-form'),
      'great-chun': document.getElementById('great-chun-form'),
      ant: document.getElementById('ant-form'),
      star: document.getElementById('star-form'),
      qi: document.getElementById('qi-form')
    };
    
    // Game content
    const gameChapters = {
      prologue: {
        title: '序章：莊周夢蝶',
        description: '誰夢見了誰？',
        background: 'dream-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你在一個奇異的夢境中醒來，周圍是藍紫色的光暈，一隻蝴蝶在你眼前飛舞，彷彿在引領你前行。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '？？？',
            text: '你來了，由夢而生的旅人。我是莊周，你可以叫我莊子。你能來到這裡，說明你的心靈還沒有被俗世完全束縛。',
            options: [
              { 
                text: '這裡是什麼地方？', 
                next: 2,
                traits: { 
                  philosophical: { idealism: 3, curiosity: 4, openness: 3 },
                  mbti: { intuition: 4, perception: 3 },
                  story: { exploration: 4, wonder: 3 }
                }
              },
              { 
                text: '您找我有什麼事嗎？', 
                next: 3,
                traits: { 
                  philosophical: { pragmatism: 4, responsibility: 3, focus: 3 },
                  mbti: { thinking: 3, judging: 3 },
                  story: { purpose: 4, readiness: 3 }
                }
              },
              { 
                text: '我怎麼會在夢境中？', 
                next: 4,
                traits: { 
                  philosophical: { skepticism: 4, rationality: 3, analysis: 3 },
                  mbti: { thinking: 4, sensing: 3 },
                  story: { confusion: 3, questioning: 4 }
                }
              }
            ]
          },
          // 分支場景：地點詢問路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這裡是夢境與現實的交界，是心靈未被拘束時能到達的地方。在這裡，你將了解一個關於宇宙本源的故事，以及你的使命。',
            nextScene: 5
          },
          // 分支場景：使命詢問路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '確實有一件極其重要的事需要你的幫助。這關係到萬物能否重新獲得自由變換的能力，關係到宇宙的平衡能否恢復。',
            nextScene: 5
          },
          // 分支場景：夢境疑問路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '夢與醒，虛與實，界限本就模糊。重要的不是你如何到這裡，而是你能在這裡學到什麼，能為這個世界做些什麼。',
            nextScene: 5
          },
          // 匯聚場景：混沌背景介紹
          {
            type: 'dialog',
            speaker: '莊子',
            text: '讓我告訴你一個古老的故事。在宇宙的中心，曾經有一位叫做混沌的中央之帝。他沒有七竅，卻能自由自在，是萬物變化的源泉。',
            nextScene: 6
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '混沌的神奇之處在於：他沒有眼耳鼻口，不被感官束縛，因此能夠包容萬物，讓所有生靈都能自由地轉換形態。那時的世界，是真正的「物我不分」。',
            nextScene: 7
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '然而有一天，發生了悲劇。混沌死了，他的七個竅被打開，万物失去了自由轉化的能力。現在，魚只能是魚，鳥只能是鳥，人也只能是人。',
            nextScene: 8
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '更糟糕的是，混沌死時，他的七竅化作七個封印，散落到世界各處。只有重新收集這七個封印，才有可能讓混沌重生，恢復萬物的自由。',
            nextScene: 9
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '在這段旅程中，你會面臨許多選擇。記住，沒有標準答案，也沒有對錯之分。每個選項都是通往智慧的不同路徑，就像山有千條小徑，都能登頂。',
            nextScene: 10
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '重要的是遵從你內心的聲音，選擇最符合你天性的那條路。不要猜測什麼是「正確」答案，因為真正的智慧來自於真實的自己。',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '還有一個小秘密要告訴你——如果你能完整走完這段旅程，收集齊所有的封印，最後會有一份特別的「神秘禮物」等著你。那是我為每一位勇敢的旅人準備的，獨一無二的智慧之書。',
            options: [
              { 
                text: '這聽起來是一個重要的使命', 
                next: 12,
                traits: { 
                  philosophical: { idealism: 4, compassion: 3, harmony: 2 },
                  mbti: { feeling: 4, judging: 3 },
                  story: { courage: 4, curiosity: 3 }
                }
              },
              { 
                text: '為什麼是我來做這件事？', 
                next: 13,
                traits: { 
                  philosophical: { wisdom_seeking: 4, authenticity: 3, transcendence: 2 },
                  mbti: { thinking: 4, introversion: 3 },
                  story: { introspection: 4, independence: 3 }
                }
              },
              { 
                text: '這聽起來很困難...', 
                next: 14,
                traits: { 
                  philosophical: { acceptance: 3, beauty_appreciation: 2, harmony: 3 },
                  mbti: { sensing: 4, introversion: 3 },
                  story: { resilience: 3, gentleness: 4 }
                }
              }
            ]
          },
          // 分支場景：積極響應路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '是的，這確實是宇宙中最重要的使命。七個封印分別是：左目、右目、左耳、右耳、左鼻、右鼻、和口。每一個都隱藏在不同的地方，需要特殊的能力才能獲得。',
            nextScene: 15
          },
          // 分支場景：質疑選擇路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '因為你的心還沒有被固化。你能質疑，能思考，還保持著孩子般的好奇心。這正是完成使命所需要的品質——開放、靈活、不被成見束縛。',
            nextScene: 15
          },
          // 分支場景：擔憂困難路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '困難是相對的。當你掌握了「物化之道」後，你會發現世界有無數種可能性。困難往往源於視角的局限，而物化能讓你獲得不同的視角。',
            nextScene: 15
          },
          // 物化機制詳細解釋
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我教你「物化之道」。這是完成使命的核心能力。物化，就是變換形態，以不同生物的視角和能力去體驗世界。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '每種生物都有獨特的感知方式：蝴蝶能看到花朵的細微色彩，魚兒能感受水流的變化，鳥兒能俯瞰大地全貌。物化讓你獲得這些能力。',
            nextScene: 17
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '更重要的是，每個封印都隱藏在特定的情境中，需要對應的生物視角才能發現和收集。人類的感官有限，但物化可以突破這些限制。',
            options: [
              { 
                text: '我準備好學習物化之道了', 
                next: 18,
                traits: { 
                  philosophical: { idealism: 3, transcendence: 4, harmony: 2 },
                  mbti: { intuition: 3, perceiving: 4 },
                  story: { courage: 4, curiosity: 3 }
                }
              },
              { 
                text: '這聽起來像是魔法...', 
                next: 19,
                traits: { 
                  philosophical: { wisdom_seeking: 4, authenticity: 3, acceptance: 2 },
                  mbti: { thinking: 4, sensing: 3 },
                  story: { introspection: 4, independence: 3 }
                }
              },
              { 
                text: '我要如何開始練習？', 
                next: 20,
                traits: { 
                  philosophical: { beauty_appreciation: 3, compassion: 2, harmony: 3 },
                  mbti: { sensing: 4, judging: 3 },
                  story: { gentleness: 3, resilience: 4 }
                }
              }
            ]
          },
          // 分支場景：準備充分路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好的心態！物化之道始於理解古人的智慧。這段古文記錄了我與蝴蝶的相遇，蘊含著變化的奧秘。用心感受其中的韻律。',
            nextScene: 21
          },
          // 分支場景：懷疑魔法路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '不是魔法，而是對本質的認知。萬物本就同源，只是形態不同。當你理解了這個道理，變化就成為可能。就像冰化為水，水化為氣，形態在變，本質不變。',
            nextScene: 21
          },
          // 分支場景：詢問練習路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好的問題！物化之道的第一步是理解變化的智慧。古人的文字中蘊含著這種智慧，通過解讀古文，你能感悟到變化的奧秘。',
            nextScene: 21
          },
          // 斷句挑戰場景
          {
            type: 'segmentation-puzzle',
            textStyle: 'dream-text',
            text: '昔者莊周夢為胡蝶栩栩然胡蝶也自喻適志與不知周也俄然覺則蘧蘧然周也',
            solution: [7, 13, 18, 22, 25],
            hint: '這段古文記錄了夢蝶的故事。點擊字符之間的空隙，嘗試正確斷句。感受文字中蘊含的變化智慧...',
            success: '你成功解讀了夢境文字！文字開始發出藍紫色的光芒，圍繞著你旋轉。你感受到了第一次物化能力的覺醒。',
            nextScene: 22
          },
          {
            type: 'narrative',
            text: '當最後一個斷句標記落入正確位置，古文化為流光，環繞你的身體。你感到一股神奇的力量流入體內，這是物化之道的第一次覺醒——你獲得了變化的可能性。',
            nextScene: 23
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你已經掌握了初步的物化能力。現在你可以在人形與蝴蝶之間自由轉換。這只是開始，隨著旅程的深入，你會解鎖更多生物的形態。',
            nextScene: 24
          },
          {
            type: 'form-unlock-guide',
            text: '你感受到一股神秘的力量流入身體，獲得了「蝴蝶」的物化能力！物化按鈕會在遊戲過程中逐漸解鎖。現在點擊物化按鈕，選擇蝴蝶形態來進行第一次物化體驗。',
            effect: 'unlockForm:butterfly',
            highlightForm: 'butterfly',
            nextScene: 25
          },
          {
            type: 'transformation-experience',
            formType: 'butterfly',
            text: '你化身為蝴蝶，感受到了前所未有的輕盈和自由。世界變得色彩斑斕，每一朵花都散發著誘人的香氣。你的翅膀輕輕扇動，就能在空中自由飛舞。在這夢幻般的體驗中，你體會到了「物我兩忘」——你既是人，也是蝶，或者說，你超越了固定形態的束縛。',
            nextScene: 26
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你明白了物化的感覺。記住：每種形態都有其獨特的能力和視角。在接下來的旅程中，善用物化之道，你就能找到散落各處的七竅封印，完成修復混沌的使命。準備好了嗎？我們前往第一個封印所在地——濠梁之上。',
            nextScene: 'chapter1:0'
          }
        ]
      },
      chapter1: {
        title: '第一章：子非魚',
        description: '你怎麼知道魚的快樂？',
        background: 'water-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你來到一座橋上，橋下是碧波蕩漾的濠水。莊子與他的朋友惠子正倚著橋欄交談。陽光照在水面上，閃爍著點點金光。',
            nextScene: 1
          },
          // === 網狀分支結構：基於故事情境的多重交匯 ===
          
          // === 第一個情境選擇點：初遇魚群 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看，那些儵魚在水中游弋，時而聚集成群，時而散開獨游。咦，有條魚游得特別奇怪，一直在打轉。',
            options: [
              { 
                text: '蹲下來看看那條打轉的魚怎麼了', 
                next: 2,
                traits: { 
                  philosophical: { compassion: 4, wisdom_seeking: 3, beauty_appreciation: 2 },
                  mbti: { feeling: 4, sensing: 3, extraversion: 2 },
                  story: { gentleness: 4, curiosity: 3, emotional_depth: 2 }
                }
              },
              { 
                text: '觀察整個魚群的反應', 
                next: 3,
                traits: { 
                  philosophical: { wisdom: 4, patience: 4, holistic_thinking: 3 },
                  mbti: { thinking: 3, sensing: 4, introversion: 3 },
                  story: { analytical_approach: 4, pattern_recognition: 4, systemic_thinking: 3 }
                }
              },
              { 
                text: '問莊子是否見過這種現象', 
                next: 4,
                traits: { 
                  philosophical: { humility: 4, knowledge_seeking: 3, respect_for_wisdom: 4 },
                  mbti: { thinking: 3, judging: 3, extraversion: 2 },
                  story: { guidance_seeking: 4, learning_oriented: 4, collaborative: 3 }
                }
              }
            ]
          },
          
          // === 第一組響應場景 ===
          {
            type: 'narrative',
            text: '你蹲下仔細觀察那條打轉的魚。它似乎被什麼東西吸引，不斷在水底一個地方打轉。透過清澈的水面，你隱約看到水底有什麼在發光。',
            nextScene: 5
          },
          {
            type: 'narrative', 
            text: '你觀察整個魚群，發現其他魚都刻意避開那條打轉的魚附近的區域。這種整體的迴避行為很有趣，好像那個地方有什麼特殊之處。',
            nextScene: 5
          },
          {
            type: 'narrative',
            text: '莊子撫摸著鬍鬚：「我確實見過幾次。通常是水底有異物，或是有特殊的氣息。你看其他魚都避開那裡，只有那一條執著地轉圈。」',
            nextScene: 5
          },
          
          // === 第一個交匯點：發現異象 ===
          {
            type: 'dialog',
            speaker: '惠子',
            text: '你們在看什麼？我也來湊湊熱鬧。咦，這條魚的行為確實古怪。會不會水底有什麼東西？',
            options: [
              { 
                text: '我們下水看看吧', 
                next: 6,
                traits: { 
                  philosophical: { idealism: 4, transcendence: 3, harmony: 2 },
                  mbti: { extraversion: 4, sensing: 3, perceiving: 3 },
                  story: { courage: 4, curiosity: 3, creativity: 2 }
                }
              },
              { 
                text: '先想想有什麼方法能看清水底', 
                next: 7,
                traits: { 
                  philosophical: { wisdom_seeking: 4, beauty_appreciation: 3, authenticity: 2 },
                  mbti: { thinking: 4, judging: 4, introversion: 2 },
                  story: { introspection: 4, resilience: 3, independence: 2 }
                }
              },
              { 
                text: '也許它有自己的原因，我們再觀察一下', 
                next: 8,
                traits: { 
                  philosophical: { acceptance: 4, compassion: 3, harmony: 3 },
                  mbti: { feeling: 4, judging: 3, introversion: 3 },
                  story: { gentleness: 4, emotional_depth: 3, resilience: 2 }
                }
              }
            ]
          },
          
          // === 第二組響應場景 ===
          {
            type: 'narrative',
            text: '莊子笑道：「你的行動力很強！不過這橋下水深，而且...」話沒說完，那條魚突然停止打轉，直直地游向水面，嘴裡竟然銜著一個發光的小物件！',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '惠子點頭：「謀而後動是智者之舉。我們可以用樹枝探探，或者...」正說著，水面突然泛起漣漪，那條魚浮上來了，嘴裡銜著一個閃閃發光的東西！',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '莊子讚許地看著你：「你很有智慧。大自然的秘密往往...」他話還沒說完，那條魚忽然浮出水面，嘴裡銜著一個散發藍光的神秘物件！',
            nextScene: 9
          },
          
          // === 第二個交匯點：神秘物件出現 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這是...左目之竅的封印！我們要找的第一個封印竟然被這條魚找到了！但它還在魚嘴裡，我們該怎麼辦？',
            options: [
              { 
                text: '輕聲呼喚，看能不能和魚溝通', 
                next: 10,
                traits: { 
                  philosophical: { compassion: 4, harmony: 3, beauty_appreciation: 3 },
                  mbti: { feeling: 4, intuition: 3, extraversion: 2 },
                  story: { gentleness: 4, emotional_depth: 3, creativity: 2 }
                }
              },
              { 
                text: '用食物引誘魚兒靠近', 
                next: 11,
                traits: { 
                  philosophical: { authenticity: 3, wisdom_seeking: 3, acceptance: 3 },
                  mbti: { thinking: 3, sensing: 4, judging: 3 },
                  story: { resilience: 4, independence: 3, introspection: 2 }
                }
              },
              { 
                text: '等等看，也許它會主動過來', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, idealism: 3, harmony: 2 },
                  mbti: { introversion: 4, perceiving: 4, feeling: 2 },
                  story: { curiosity: 3, courage: 2, emotional_depth: 4 }
                }
              }
            ]
          },
          
          // === 第三組響應場景 ===
          {
            type: 'narrative',
            text: '你輕柔地對魚兒說話，聲音如水波般溫和。奇妙的是，魚兒真的停下來，用黑亮的眼睛看著你，然後慢慢游近，將封印輕放在水面上。',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '惠子從包裡拿出一些魚食撒向水面。魚兒聞到香味，興奮地游過來，在吃食物時不小心鬆開了嘴，封印漂浮在水面上。',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '你們靜靜等待。過了一會兒，魚兒似乎完成了什麼儀式般的動作，主動將封印送到橋邊，然後滿足地游走了。',
            nextScene: 13
          },
          
          // === 最終匯聚點：發現封印線索 ===
          {
            type: 'narrative',
            text: '封印在水面上發出柔和的藍光，輕飄飄地浮向你們。莊子感嘆道：「看來每個生命都有自己的使命。這條魚為我們指出了左目之竅封印的位置！」封印發出一道光芒指向水底深處，然後消失了。惠子說：「看來我們需要更深入地理解這裡的奧秘才能真正獲得封印。」',
            nextScene: 14
          },
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過你剛才在尋找封印過程中的選擇，我能感受到你內心的智慧正在綻放。每個人面對未知和挑戰的方式都不同，而你的方式很獨特...',
            sceneType: 'personal_analysis',
            context: '濠梁尋封印過程中的行為模式分析',
            nextScene: 15
          },
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看看那水面下的文字，它們包含著關於魚之樂的奧秘。試著解讀它們。',
            nextScene: 16
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'water-text',
            text: '莊子與惠子遊於濠梁之上莊子曰儵魚出遊從容是魚樂也惠子曰子非魚安知魚之樂莊子曰子非我安知我不知魚之樂',
            solution: [10, 13, 19, 23, 26, 29, 34, 37, 40],
            hint: '點擊字符之間的空隙，嘗試正確斷句。莊子和惠子在橋上辯論...',
            success: '你成功解讀了水中文字！字符如水波般流動，逐漸清晰。',
            nextScene: 17
          },
          {
            type: 'narrative',
            text: '當文字解讀完成，一道藍光從水中升起，化作一條銀色的魚。魚兒環繞著你游動，最後停在你面前，彷彿在邀請你進入水中世界。',
            nextScene: 18
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你已獲得儵魚的物化能力。現在你可以潛入水中，體驗魚的視角。',
            nextScene: 19
          },
          {
            type: 'form-unlock-guide',
            text: '一道藍光注入你的身體，你獲得了「儵魚」的物化能力！現在你可以化身為儵魚，潛入水中探索水下世界。請點擊物化按鈕，選擇儵魚形態來體驗魚兒的快樂。',
            effect: 'unlockForm:fish',
            highlightForm: 'fish',
            nextScene: 20
          },
          {
            type: 'transformation-experience',
            formType: 'fish',
            text: '你化身為儵魚，潛入濠水之中。水下世界與陸地截然不同，所有聲音變得沉悶而遙遠，光線也變得朦朧柔和。水流輕撫著你的魚鰭，你能感受到每一絲水波的律動。在這寧靜的水中世界，時間彷彿變得緩慢而悠長，你終於理解了什麼是真正的「魚之樂」。',
            nextScene: 21
          },
          {
            type: 'narrative',
            text: '你在水中遊動時，發現了一道閃爍的光，那是左目之竅的封印！它嵌入在水底的一塊石頭中，發出微弱的藍光。就是之前那條魚為你們指出的位置。',
            nextScene: 22
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是我們尋找的第一個封印——左目之竅！它將封閉你的左眼視覺，讓你不再被外在形象所迷惑。取下它，混沌就能重新封閉第一個竅。',
            nextScene: 23
          },
          {
            type: 'narrative',
            text: '你靠近封印，伸出魚鰭輕觸它。封印立刻發出強烈的藍光，脫離石頭飄向你。當你接觸到它時，一股暖流沿著你的身體流動，你感到視界更加開闊了。',
            effect: 'collectAperture:left-eye',
            nextScene: 24
          },
          // === 第四階段：AI章節總結 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '恭喜你找到了第一個封印！你的左眼之竅已被封閉，不再被單一視角所束縛。混沌的第一個竅得以重新封閉，心中升起內在的清明。',
            nextScene: 25
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '現在你能理解了嗎？每個生命都有自己的感知世界...',
            sceneType: 'chapter_summary',
            context: '第一章深度總結：基於玩家在濠梁尋封印過程中的選擇分析其探索模式（關注細節vs全局觀察vs尋求指導、行動vs謹慎vs尊重邊界、直覺vs實用vs耐心），並運用莊子"魚之樂"智慧為玩家的決策方式、人際互動、面對未知的態度提供個性化的成長建議',
            effect: 'switchToHuman',
            nextScene: 'chapter2:0'
          }
        ]
      },
      chapter2: {
        title: '第二章：北冥有魚',
        description: '魚為何要變成鳥？',
        background: 'cloud-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你來到了北冥之海的邊緣，無盡的海水在你面前延伸至天際。海面平靜如鏡，倒映著天空中飄浮的雲朵，藍與白的色彩交融在一起，難以分辨界限。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '北冥有魚，其名為鯤。鯤之大，不知其幾千里也。這裡的尺度已經超出你的想像了。',
            nextScene: 2
          },
          // === 第一階段：預設分支對話 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '站在這片無垠的海邊，你有什麼感受？',
            options: [
              { 
                text: '感到自己在這無邊海洋面前是如此渺小', 
                next: 3,
                traits: { 
                  philosophical: { transcendence: 4, acceptance: 3, beauty_appreciation: 2 },
                  mbti: { feeling: 4, sensing: 3, introversion: 3 },
                  story: { introspection: 4, emotional_depth: 3, gentleness: 2 }
                }
              },
              { 
                text: '好奇這海里到底隱藏著什麼奧秘', 
                next: 4,
                traits: { 
                  philosophical: { wisdom_seeking: 4, idealism: 3, harmony: 2 },
                  mbti: { intuition: 4, thinking: 3, extraversion: 3 },
                  story: { curiosity: 4, courage: 3, creativity: 2 }
                }
              },
              { 
                text: '想像著在這片海中自由遨遊', 
                next: 5,
                traits: { 
                  philosophical: { compassion: 3, authenticity: 4, transcendence: 3 },
                  mbti: { perceiving: 4, intuition: 3, feeling: 3 },
                  story: { creativity: 4, curiosity: 3, emotional_depth: 3 }
                }
              }
            ]
          },
          // === 謙遜感受分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的感受很真實。面對無限，人確實顯得渺小。但你知道嗎？在道的層面，大與小其實沒有絕對的界限。',
            options: [
              { 
                text: '那麼什麼決定了事物的大小？', 
                next: 6, // 匯聚到場景6
                traits: { 
                  philosophical: { wisdom_seeking: 4, idealism: 3, authenticity: 2 },
                  mbti: { thinking: 3, intuition: 3, judging: 2 },
                  story: { curiosity: 4, introspection: 3, independence: 2 }
                }
              },
              { 
                text: '我感受到了某種超越大小的存在', 
                next: 6,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, harmony: 2 },
                  mbti: { intuition: 4, feeling: 3, perceiving: 2 },
                  story: { emotional_depth: 4, creativity: 3, gentleness: 2 }
                }
              },
              { 
                text: '這讓我重新思考什麼是真正重要的', 
                next: 6,
                traits: { 
                  philosophical: { acceptance: 4, compassion: 3, harmony: 2 },
                  mbti: { feeling: 3, thinking: 2, introversion: 3 },
                  story: { introspection: 4, resilience: 3, emotional_depth: 2 }
                }
              }
            ]
          },
          // === 好奇探索分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的好奇心很珍貴！這海中確實藏著巨大的秘密。傳說中有一種魚，大得無法測量，它們能變成鳥飛向天際。你認為這可能嗎？',
            options: [
              { 
                text: '聽起來像神話，但也許有更深的含義', 
                next: 6,
                traits: { 
                  philosophical: { wisdom_seeking: 4, authenticity: 3, acceptance: 2 },
                  mbti: { intuition: 3, thinking: 3, perceiving: 2 },
                  story: { introspection: 4, independence: 3, resilience: 2 }
                }
              },
              { 
                text: '如果真有這樣的生物，一定很壯觀', 
                next: 6,
                traits: { 
                  philosophical: { beauty_appreciation: 4, idealism: 3, harmony: 2 },
                  mbti: { feeling: 3, sensing: 2, perceiving: 3 },
                  story: { creativity: 4, emotional_depth: 3, curiosity: 3 }
                }
              },
              { 
                text: '也許變化本身就是生命的本質', 
                next: 6,
                traits: { 
                  philosophical: { transcendence: 4, compassion: 3, wisdom_seeking: 2 },
                  mbti: { intuition: 4, thinking: 2, perceiving: 3 },
                  story: { emotional_depth: 4, creativity: 3, courage: 2 }
                }
              }
            ]
          },
          // === 自由想像分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的想像力讓我欣喜！想像自己在海中遨遊，這本身就是一種自由。在你的想像中，你會選擇什麼樣的存在方式？',
            options: [
              { 
                text: '像魚一樣在深海中默默游弋', 
                next: 6,
                traits: { 
                  philosophical: { acceptance: 4, harmony: 3, authenticity: 2 },
                  mbti: { introversion: 4, sensing: 2, feeling: 2 },
                  story: { gentleness: 4, introspection: 3, resilience: 2 }
                }
              },
              { 
                text: '能夠自在地在不同境界間轉換', 
                next: 6,
                traits: { 
                  philosophical: { transcendence: 4, compassion: 3, wisdom_seeking: 2 },
                  mbti: { perceiving: 4, intuition: 3, extraversion: 2 },
                  story: { courage: 4, creativity: 3, independence: 2 }
                }
              },
              { 
                text: '既保持魚的純真，又擁有鳥的視野', 
                next: 6,
                traits: { 
                  philosophical: { beauty_appreciation: 4, idealism: 3, harmony: 2 },
                  mbti: { feeling: 3, intuition: 3, perceiving: 2 },
                  story: { emotional_depth: 4, creativity: 3, gentleness: 2 }
                }
              }
            ]
          },
          // === 第一次匯聚和AI個性化回應 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的回答讓我看到了你內心的特質。每個人面對無限時的反應都不同，這正反映了「道」的多樣性。',
            nextScene: 7
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '從你剛才的回應中，我能感受到你的心境和思考方式...',
            sceneType: 'initial_response_analysis',
            context: '北冥海邊初次相遇，基於玩家對無限海洋的反應進行個性化分析',
            nextScene: 8
          },
          // === 第二組分支對話：關於變化的哲學思辨 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我告訴你一個故事。在這片海中，有一種巨大的魚叫做鯤，它大得無法測量。但鯤不滿足於在海中游弋，它渴望化為大鵬，飛向九萬里高空。你覺得這個故事在說什麼？',
            options: [
              { 
                text: '生命總是渴望突破自己的界限', 
                next: 9,
                traits: { 
                  philosophical: { idealism: 4, transcendence: 3, wisdom_seeking: 2 },
                  mbti: { intuition: 4, feeling: 3, judging: 3 },
                  story: { courage: 4, independence: 3, curiosity: 2 }
                }
              },
              { 
                text: '每種存在都有它應該的樣子', 
                next: 10,
                traits: { 
                  philosophical: { acceptance: 4, harmony: 3, authenticity: 2 },
                  mbti: { sensing: 4, feeling: 3, judging: 4 },
                  story: { gentleness: 4, resilience: 3, introspection: 2 }
                }
              },
              { 
                text: '變化可能帶來更廣闊的視野', 
                next: 11,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, compassion: 2 },
                  mbti: { intuition: 4, perceiving: 4, thinking: 3 },
                  story: { creativity: 4, curiosity: 3, emotional_depth: 2 }
                }
              }
            ]
          },
          // === 成長超越分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你理解了生命的渴望！但這裡有個問題：鯤變成鵬後，它還是原來的自己嗎？',
            options: [
              { 
                text: '本質不變，只是表現形式不同', 
                next: 12, // 匯聚到場景12
                traits: { 
                  philosophical: { authenticity: 4, wisdom_seeking: 3, harmony: 2 },
                  mbti: { thinking: 3, sensing: 2, judging: 3 },
                  story: { introspection: 4, resilience: 3, independence: 2 }
                }
              },
              { 
                text: '變化本身就是存在的真諦', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, compassion: 2 },
                  mbti: { intuition: 4, perceiving: 4, thinking: 2 },
                  story: { creativity: 4, emotional_depth: 3, courage: 2 }
                }
              },
              { 
                text: '也許「自己」這個概念就是限制', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, wisdom_seeking: 3, idealism: 2 },
                  mbti: { intuition: 4, thinking: 3, perceiving: 3 },
                  story: { independence: 4, curiosity: 3, courage: 2 }
                }
              }
            ]
          },
          // === 自然和諧分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你珍視自然的和諧，這很智慧。但你有沒有想過，如果鯤一直滿足於做魚，它永遠不會知道天空的遼闊。有時候，不是所有的安於現狀都是智慧。',
            options: [
              { 
                text: '也許探索和安定都有其價值', 
                next: 12,
                traits: { 
                  philosophical: { harmony: 4, compassion: 3, wisdom_seeking: 2 },
                  mbti: { feeling: 3, perceiving: 3, thinking: 2 },
                  story: { emotional_depth: 4, gentleness: 3, resilience: 2 }
                }
              },
              { 
                text: '真正的和諧包含著變化的可能', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, acceptance: 2 },
                  mbti: { intuition: 3, thinking: 2, perceiving: 3 },
                  story: { creativity: 4, introspection: 3, emotional_depth: 2 }
                }
              },
              { 
                text: '每種選擇都會帶來不同的人生', 
                next: 12,
                traits: { 
                  philosophical: { acceptance: 4, authenticity: 3, compassion: 2 },
                  mbti: { thinking: 2, perceiving: 4, feeling: 2 },
                  story: { independence: 4, curiosity: 3, resilience: 2 }
                }
              }
            ]
          },
          // === 視野擴展分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看到了變化的價值！確實，從海底到九萬里高空，這樣的視野轉換會帶來完全不同的體驗。但問題是，這種轉換是否值得付出代價？',
            options: [
              { 
                text: '成長總是要付出代價的', 
                next: 12,
                traits: { 
                  philosophical: { wisdom_seeking: 4, acceptance: 3, authenticity: 2 },
                  mbti: { thinking: 3, judging: 3, sensing: 2 },
                  story: { resilience: 4, introspection: 3, courage: 2 }
                }
              },
              { 
                text: '重要的是過程中的體驗', 
                next: 12,
                traits: { 
                  philosophical: { beauty_appreciation: 4, compassion: 3, harmony: 2 },
                  mbti: { perceiving: 4, feeling: 3, sensing: 2 },
                  story: { emotional_depth: 4, gentleness: 3, creativity: 2 }
                }
              },
              { 
                text: '也許得失本身就是一種執著', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, wisdom_seeking: 3, acceptance: 2 },
                  mbti: { intuition: 4, thinking: 3, perceiving: 3 },
                  story: { independence: 4, introspection: 3, curiosity: 2 }
                }
              }
            ]
          },
          // === 第二次AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '你對變化和存在的理解展現了獨特的智慧...',
            sceneType: 'transformation_philosophy_analysis',
            context: '關於鯤鵬變化的哲學思辨，基於玩家對變化、成長、本質的理解',
            nextScene: 13
          },
          // === 第三組分支對話：行動與選擇 ===
          {
            type: 'dialog',
            speaker: '莊子',  
            text: '海風吹來，你聽到遠處傳來一陣奇異的聲音，像是巨大生物的呼吸聲。那聲音時而低沉如海浪，時而高亢如鳥鳴。',
            options: [
              {
                text: '想要找到聲音的來源', 
                next: 14,
                traits: { 
                  philosophical: { idealism: 4, wisdom_seeking: 3, beauty_appreciation: 2 },
                  mbti: { extraversion: 3, sensing: 2, thinking: 2 },
                  story: { curiosity: 4, courage: 3, independence: 2 }
                }
              },
              {
                text: '安靜聆聽，試圖理解其含義', 
                next: 15,
                traits: { 
                  philosophical: { acceptance: 4, compassion: 3, harmony: 2 },
                  mbti: { introversion: 4, intuition: 3, feeling: 2 },
                  story: { introspection: 4, gentleness: 3, emotional_depth: 2 }
                }
              },
              {
                text: '感受這聲音與自己內心的共鳴', 
                next: 16,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, authenticity: 2 },
                  mbti: { feeling: 4, intuition: 3, introversion: 2 },
                  story: { emotional_depth: 4, creativity: 3, gentleness: 2 }
                }
              }
            ]
          },
          // === 探索尋找分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的探索精神很可貴。但有時候，我們想要找到的東西，可能並不在我們預期的地方。',
            nextScene: 17
          },
          // === 安靜聆聽分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你選擇了聆聽，這顯示了智慧。在這種靜默中，你能聽到的不只是聲音，還有聲音背後的故事。',
            nextScene: 17
          },
          // === 內心共鳴分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你感受到了共鳴，這很難得。這說明你的心是開放的，能夠與萬物的節奏產生連結。',
            nextScene: 17
          },
          // === 第三次匯聚和AI個性化回應 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '無論你選擇什麼方式回應，都反映了你獨特的感知世界的方式。現在，我要告訴你一個重要的秘密。',
            nextScene: 18
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過我們的對話，我看到了你心中的特質...',
            sceneType: 'comprehensive_personality_analysis',
            context: '基於所有對話選擇的綜合個性分析，準備引入封印任務',
            nextScene: 19
          },
          // === 巧妙融入封印任務 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你知道嗎？混沌本是無形無相的存在，卻能讓萬物自由轉換形態。鯤變鵬的能力，正是混沌賦予的禮物。',
            nextScene: 20
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '但自從混沌失去七竅，這種轉換之力就被封印在天地之間。要重新獲得這種力量，我們必須找到封印在北冥深處的右目之竅。',
            nextScene: 21
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '傳說中，右目之竅隱藏在鯤鵬變化的奧秘中。只有真正理解變化之道的人，才能破解這個秘密。',
            nextScene: 22
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看，天空中的雲朵開始聚集，它們帶來了古老的文字。這些文字記載著鯤鵬變化的心法，解讀它們，你就能獲得接近封印的力量。',
            nextScene: 23
          },
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'segmentation-puzzle',
            textStyle: 'cloud-text',
            text: '北冥有魚其名為鯤鯤之大不知其幾千里也化而為鳥其名為鵬鵬之背不知其幾千里也怒而飛其翼若垂天之雲',
            solution: [3, 7, 10, 17, 21, 25, 28, 35, 38],
            hint: '點擊字符之間的空隙，嘗試正確斷句。北冥有一種大魚...',
            success: '你成功解讀了雲中文字！文字開始發出青色光芒，在雲海中騰起。一股雄渾的力量似乎呼喚著你的靈魂。',
            nextScene: 24
          },
          {
            type: 'narrative',
            text: '雲中文字解讀完成後，一股奇異的能量從天而降，你感到身體輕盈起來，同時又充滿力量。海面上出現了巨大的漩渦，似乎在邀請你進入。',
            nextScene: 25
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！鯤鵬之變需要你親身體驗，才能理解大小相對的奧妙。',
            nextScene: 26
          },
          {
            type: 'form-unlock-guide',
            text: '一股雄渾的力量從雲海中注入你的身體，你獲得了「鯤」的物化能力！現在你可以化身為千里之鯤，在北冥之海中自由遨遊。請點擊物化按鈕，選擇鯤形態來體驗巨大的力量。',
            effect: 'unlockForm:kun',
            highlightForm: 'kun',
            nextScene: 27
          },
          {
            type: 'transformation-experience',
            formType: 'kun',
            text: '你的身體開始膨脹，化為千里之鯤。巨大的魚身讓你能夠感受到海水的每一處細節。你游入漩渦，在北冥的深處暢遊，感受著前所未有的自由。作為鯤，整個海洋都是你的領域，千里之距不過是一個轉身。你體會到了什麼叫做真正的「大」——不是體積的大，而是心境的無限廣闊。',
            nextScene: 28
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '感受到了嗎？當你成為鯤，千里之距不過是一躍。現在試著變化為鵬，體驗天空的廣闊。',
            nextScene: 29
          },
          {
            type: 'form-unlock-guide',
            text: '鯤鵬變化的力量在你體內覺醒，你獲得了「鵬」的物化能力！現在你可以從千里之鯤變化為九萬里之鵬，翱翔於天際。請點擊物化按鈕，選擇鵬形態來體驗天空的廣闊。',
            effect: 'unlockForm:peng',
            highlightForm: 'peng',
            nextScene: 30
          },
          {
            type: 'transformation-experience',
            formType: 'peng',
            text: '你從海中躍起，身體再次變化，化為巨大的鵬鳥。你的翅膀展開，寬達九萬里，像巨大的雲層垂掛在天空。你飛向高空，俯瞰下方的北冥，海洋變得如同一灘小水窪。在這九萬里的高空中，你感受到了絕對的自由——沒有束縛，沒有界限，只有無盡的天空和你展翅翱翔的身影。這就是鵬的視角：超越一切，俯視萬物。',
            nextScene: 31
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '從這高度看去，世間萬物皆如微塵。大與小原是相對的概念，超越了大小的界限，才能真正獲得自由。',
            nextScene: 32
          },
          {
            type: 'narrative',
            text: '當你翱翔在九萬里高空，發現了一道耀眼的光，那光芒凝聚成右目之竅的封印！它懸浮在雲層之上，散發著清澈的青光。',
            nextScene: 33
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是第二個封印——右目之竅！它將封閉你對大小分別的執著，讓你回歸萬物平等的本源。取下它，你將超越分別心的束縛。',
            nextScene: 34
          },
          {
            type: 'narrative',
            text: '你展翅飛向封印，用翎羽輕輕碰觸它。封印立刻發出璀璨的青光，朝你飛來。當它與你接觸的那一刻，你感到右眼的分別心逐漸消融，不再執著於大小差異，心中升起一種平等寧靜的感受。',
            effect: 'collectAperture:right-eye',
            nextScene: 35
          },
          // === 第四階段：AI章節總結 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '恭喜你找到了第二個封印！你的右眼之竅已被封閉，不再被大小分別所束縛。混沌正在逐漸回歸無分別的原初狀態。',
            nextScene: 36
          },
          {
            type: 'narrative',
            text: '第二章完成！你已經收集了右目之竅的封印，並掌握了鯤鵬變化的能力，能夠自由轉換於千里之鯤和九萬里之鵬，理解了大小相對的奧妙。',
            nextScene: 37
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '通過北冥的體驗，你對變化和超越有了更深的理解...',
            sceneType: 'chapter_summary',
            context: '第二章深度總結：基於玩家在鯤鵬變化中的選擇分析其變化適應力、成長追求、視野格局，並運用莊子"逍遙遊"智慧為玩家未來的個人發展、生活轉變、自我突破提供個性化的策略建議和成長指導',
            effect: 'switchToHuman',
            nextScene: 'chapter3:0'
          }
        ]
      },
      chapter3: {
        title: '第三章：鴟得腐鼠',
        description: '腐鼠是什麼滋味？',
        background: 'forest-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你來到了一片茂密的森林，高大的梧桐樹散佈其間，斑駁的陽光透過樹葉間的縫隙灑落在地面上。你看到莊子站在一棵梧桐樹下，若有所思地觀察著在樹枝間飛舞的鳥兒。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看，樹上有一隻鵷鶵和一隻鴟鴞，牠們的價值觀截然不同。鵷鶵是鳳凰一族，愛好潔淨，非梧桐不止，非練實不食，非醴泉不飲。而鴟鴞在夜晚活動，以腐鼠為美食，有著完全不同的生存智慧。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '你抬頭望去，看見兩隻鳥停在樹枝上。一隻是色彩絢麗、羽毛如彩霞般的鵷鶵，散發著聖潔光芒；另一隻則是有著夜視能力的鴟鴞，正靜靜地凝視著一隻死老鼠。鵷鶵優雅地轉過頭去，而鴟鴞的眼中閃爍著黃金般的光芒。',
            nextScene: 3
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我們聆聽牠們的對話。若要獲得這兩種神鳥的物化能力，你需要理解並解讀樹葉間的文字。',
            nextScene: 4
          },
          {
            type: 'narrative',
            text: '你凝視著梧桐樹的枝葉，陽光穿過葉隙在地面投下斑駁的光影，形成文字的形狀。這些文字隨著微風輕輕擺動，似乎在訴說著什麼故事。',
            nextScene: 5
          },
          
          // === 第一階段：預設分支對話開始 ===
          {
            type: 'narrative',
            text: '微風吹過，樹葉發出輕柔的沙沙聲。你感覺整個森林都在靜靜地觀察著你，等待著你的選擇。在這寧靜的時刻，你的內心似乎也在經歷著某種微妙的變化。',
            nextScene: 6
          },
          {
            type: 'narrative',
            text: '突然，一陣微風吹過，幾片梧桐葉子飄落在你周圍。一片落在你肩膀上，一片掉在不遠處的泉水中激起漣漪，還有一片剛好落在一朵白色小花上面。',
            options: [
              { 
                text: '輕輕拿起肩膀上的葉子，欣賞它的紋理和色彩', 
                next: 7, 
                traits: { 
                  philosophical: { beauty_appreciation: 4, mindfulness: 3, harmony: 2 },
                  mbti: { sensing: 4, feeling: 3, perceiving: 2 },
                  story: { aesthetic_sensitivity: 4, wonder_capacity: 3, emotional_depth: 2 }
                }
              },
              { 
                text: '走到泉水邊，看著落葉在水中慢慢下沉', 
                next: 8, 
                traits: { 
                  philosophical: { acceptance: 4, transcendence: 3, wisdom_seeking: 2 },
                  mbti: { introversion: 4, intuition: 3, feeling: 2 },
                  story: { contemplative_preference: 4, inner_peace: 3, depth_seeking: 2 }
                }
              },
              { 
                text: '蹲下來觀察被葉子覆蓋的小花', 
                next: 9, 
                traits: { 
                  philosophical: { compassion: 4, wisdom_seeking: 3, mindfulness: 2 },
                  mbti: { sensing: 4, feeling: 3, introversion: 2 },
                  story: { intellectual_curiosity: 4, gentleness: 3, balance_seeking: 2 }
                }
              }
            ]
          },
          
          // 分支場景：欣賞葉子路線
          {
            type: 'narrative',
            text: '你輕輕拿起葉子，細細觀察它精緻的葉脈和漸變的色彩。這片梧桐葉雖然已經離開了枝頭，但它的美麗依然令人驚嘆。莊子在旁邊微笑著點頭，似乎很欣賞你對美的敏感。',
            nextScene: 10
          },
          
          // 分支場景：觀察泉水路線
          {
            type: 'narrative',
            text: '你走到泉水邊，看著那片葉子在清澈的水中慢慢沉向水底。水中的漣漪逐漸平息，葉子沉入水底，靜靜地躺在那裡。莊子走到你身邊，若有所思地看著水中的葉子。',
            nextScene: 10
          },
          
          // 分支場景：觀察小花路線
          {
            type: 'narrative',
            text: '你蹲下來仔細觀察那朵被葉子遮蓋的小花。當你輕輕移開葉子時，發現花朵並沒有因為被遮蓋而失去生機，反而在這種保護下顯得更加嬌嫩。你意識到，有時候覆蓋也是一種守護。',
            nextScene: 10
          },
          
          // 第二個分支點：面對鳥兒的行為
          {
            type: 'narrative',
            text: '這時，你注意到樹上的鵷鶵和鴟鴞有了新的動作。鵷鶵優雅地飛向一朵盛開的花朵，輕啄著花蜜；而鴟鴞卻悄悄接近樹根附近的一隻死老鼠，準備享用它的「美食」。兩種截然不同的選擇在你眼前同時上演。',
            nextScene: 11
          },
          {
            type: 'narrative',
            text: '就在這時，鴟鴞發現了死老鼠，正要俯衝下去。鵷鶵注意到了，發出一聲清脆的鳥鳴，似乎在表達什麼。而你剛好站在它們中間，兩隻鳥都看向了你，彷彿在等待你的反應。',
            options: [
              { 
                text: '微笑著點頭，示意鵷鶵繼續享用花蜜', 
                next: 12, 
                traits: { 
                  philosophical: { compassion: 4, idealism: 3, harmony: 2 },
                  mbti: { feeling: 4, extraversion: 3, judging: 2 },
                  story: { gentleness: 4, emotional_depth: 3, curiosity: 2 }
                }
              },
              { 
                text: '保持安靜，不干擾任何一隻鳥的行為', 
                next: 13, 
                traits: { 
                  philosophical: { nonJudgmental: 4, acceptance: 3 },
                  mbti: { introversion: 3, perceiving: 3 },
                  story: { contemplative_preference: 4, natural_order: 3 }
                }
              },
              { 
                text: '好奇地觀察兩隻鳥的互動，想了解更多', 
                next: 14, 
                traits: { 
                  philosophical: { curiosity: 4, wisdom: 3 },
                  mbti: { intuition: 4, perceiving: 2 },
                  story: { intellectual_curiosity: 4, wisdom_synthesis: 3 }
                }
              }
            ]
          },
          
          // 分支場景：鼓勵鵷鶵路線
          {
            type: 'narrative',
            text: '看到你的鼓勵，鵷鶵似乎更加自信地飛向花朵，優雅地享用著花蜜。它偶爾回頭看你，眼中閃爍著某種神采。莊子在一旁觀察著這一切，微微點頭。',
            nextScene: 15
          },
          
          // 分支場景：不干擾路線
          {
            type: 'narrative',
            text: '你選擇安靜地站在原地，既不偏向鵷鶵，也不阻止鴟鴞。兩隻鳥似乎感受到了你的中立態度，各自安心地進行著自己的活動。森林中的平衡在這一刻顯得特別和諧。',
            nextScene: 15
          },
          
          // 分支場景：好奇觀察路線
          {
            type: 'narrative',
            text: '你仔細觀察著兩隻鳥的行為，注意到它們各自的動作、表情、甚至是呼吸的節奏。你發現，無論是鵷鶵的優雅還是鴟鴞的專注，都有著各自的生命智慧。這種觀察讓你對生命有了更深的理解。',
            nextScene: 15
          },
          
          // 第三個分支點：深度哲學思辨
          {
            type: 'narrative',
            text: '森林中突然響起了其他動物的聲音：蟋蟀的鳴叫、松鼠的跳躍聲、遠處狼嚎的回響。生命的交響樂在這片林地中奏響，每種聲音都代表著不同的生存方式和價值觀。',
            nextScene: 16
          },
          {
            type: 'narrative',
            text: '一隻松鼠突然從樹上跳下來，在你腳邊找尋果實。同時，一隻蝴蝶輕盈地在花叢中飛舞，而遠處傳來了夜鶯的歌聲。三種不同的生命節拍在你周圍展現。',
            options: [
              { 
                text: '蹲下來想把手中的果子分給松鼠', 
                next: 17, 
                traits: { 
                  philosophical: { compassion: 4, intervention: 2 },
                  mbti: { feeling: 4, extraversion: 2 },
                  story: { emotional_response: 4, balance_seeking: 3 }
                }
              },
              { 
                text: '安靜地跟隨蝴蝶的飛行軌跡，想看它會去哪裡', 
                next: 18, 
                traits: { 
                  philosophical: { curiosity: 4, aesthetic: 2 },
                  mbti: { intuition: 4, perceiving: 3 },
                  story: { aesthetic_sensitivity: 4, intellectual_curiosity: 3 }
                }
              },
              { 
                text: '停下腳步，仔細聆聽夜鶯的歌聲', 
                next: 19, 
                traits: { 
                  philosophical: { aesthetic: 4, acceptance: 2 },
                  mbti: { introversion: 4, feeling: 3 },
                  story: { contemplative_preference: 4, inner_peace: 3 }
                }
              }
            ]
          },
          
          // 分支場景：分享果子路線
          {
            type: 'narrative',
            text: '松鼠停下來看著你，似乎理解了你的善意。它小心翼翼地接近，最終接受了你的果子。在這個分享的瞬間，你感受到了一種跨越物種的溫暖連結。莊子在一旁輕聲說：「萬物皆有靈性。」',
            nextScene: 20
          },
          
          // 分支場景：智慧探索路線
          {
            type: 'narrative',
            text: '你開始思考每種動物獨特的生存智慧：狼的團結協作，鳥兒的自由翱翔，昆蟲的精密組織。也許真正的智慧不是某種固定的知識，而是能夠適應不同環境、發揮不同特質的能力。',
            nextScene: 20
          },
          
          // 分支場景：存在探索路線
          {
            type: 'narrative',
            text: '你凝視著森林的深處，思考著生死的邊界在哪裡。那些看似死去的落葉正在滋養新的生命，那些看似永恆的大樹也終將歸於塵土。存在和不存在之間，似乎有著某種微妙的循環。',
            nextScene: 20
          },
          
          // 第四個分支點：生命態度的選擇
          {
            type: 'narrative',
            text: '夜幕降臨，森林變得更加神秘。你注意到一隻蛾子正撲向燈火，一隻螢火蟲在樹葉間安靜地發光，還有一隻蝙蝠在黑暗中自在地飛翔。三種不同的夜行生物，三種不同的生存哲學。',
            nextScene: 21
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看這三種夜晚的生靈，如果你要選擇一種生活方式，你會選擇哪一種？',
            options: [
              { 
                text: '像蛾子一樣，為了理想燃燒自己', 
                next: 22, 
                traits: { 
                  philosophical: { idealism: 4, intervention: 3 },
                  mbti: { feeling: 4, judging: 3 },
                  story: { growth_mindset: 4, aspiration_understanding: 3 }
                }
              },
              { 
                text: '像螢火蟲一樣，安靜地散發自己的光芒', 
                next: 23, 
                traits: { 
                  philosophical: { wisdom: 4, acceptance: 3 },
                  mbti: { introversion: 4, feeling: 3 },
                  story: { inner_peace: 4, wisdom_synthesis: 3 }
                }
              },
              { 
                text: '像蝙蝠一樣，在黑暗中找到自己的道路', 
                next: 24, 
                traits: { 
                  philosophical: { pragmatism: 4, spontaneity: 3 },
                  mbti: { intuition: 4, perceiving: 3 },
                  story: { independence: 4, adaptability: 3 }
                }
              }
            ]
          },
          
          // 分支場景：激情理想路線
          {
            type: 'narrative',
            text: '你被蛾子的熱情感動了。它明知燈火會傷害自己，卻仍然義無反顧地飛向光明。這種為了理想而不惜一切的精神，既令人敬佩，也令人深思。',
            nextScene: 25
          },
          
          // 分支場景：溫和智慧路線
          {
            type: 'narrative',
            text: '你選擇了螢火蟲的方式。它不需要外在的光源，而是從內心散發出溫柔的光芒，既照亮了自己，也照亮了他人。這種內在的力量，或許是最持久的智慧。',
            nextScene: 25
          },
          
          // 分支場景：獨立適應路線
          {
            type: 'narrative',
            text: '你欣賞蝙蝠的生存智慧。它不依賴視覺，而是用聲波導航，在完全的黑暗中也能自由飛翔。這種獨特的感知能力，讓它在夜晚的世界中游刃有餘。',
            nextScene: 25
          },
          
          // 第五個分支點：最終的哲學思辨
          {
            type: 'narrative',
            text: '突然間，森林中響起了一陣奇特的樂音。你環顧四周，發現是風吹過不同樹木的聲音：梧桐發出空靈的響聲，松樹發出低沉的吟唱，竹子發出清脆的節拍。大自然正在演奏一曲無聲的交響樂。',
            nextScene: 26
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '聽到了嗎？每種植物都在用自己的方式歌唱。如果要你為這場自然交響樂選擇一個主題，你會選擇什麼？',
            options: [
              { 
                text: '和諧共存：每種聲音都有其價值', 
                next: 27, 
                traits: { 
                  philosophical: { harmony: 4, acceptance: 3 },
                  mbti: { feeling: 4, perceiving: 3 },
                  story: { harmony_seeking: 4, balance_seeking: 3 }
                }
              },
              { 
                text: '自然之美：追求最純粹的美感', 
                next: 28, 
                traits: { 
                  philosophical: { aesthetic: 4, wisdom: 3 },
                  mbti: { intuition: 4, feeling: 3 },
                  story: { aesthetic_sensitivity: 4, wonder_capacity: 3 }
                }
              },
              { 
                text: '生命律動：感受存在的本質節拍', 
                next: 29, 
                traits: { 
                  philosophical: { wisdom: 4, spontaneity: 3 },
                  mbti: { intuition: 4, perceiving: 3 },
                  story: { depth_seeking: 4, life_philosophy: 3 }
                }
              }
            ]
          },
          
          // 分支場景：和諧共存路線
          {
            type: 'narrative',
            text: '你聽出了森林交響樂中的和諧之美。每一種聲音都不是孤立存在的，而是與其他聲音形成複雜而美妙的共鳴。這讓你想到了莊子所說的"萬物並育而不相害"。',
            nextScene: 30
          },
          
          // 分支場景：自然美學路線
          {
            type: 'narrative',
            text: '你被這自然音樂的純粹之美深深震撼。沒有人工的雕琢，沒有刻意的安排，一切都是那麼自然而然，卻又如此動人心弦。這或許就是真正的藝術境界。',
            nextScene: 30
          },
          
          // 分支場景：存在律動路線
          {
            type: 'narrative',
            text: '你感受到了生命的根本律動。每一個聲音都在訴說著存在的故事，從生長到死亡，從寂靜到喧嘩，這是宇宙最原始的節拍，是存在本身的呼吸。',
            nextScene: 30
          },
          
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過剛才的五次選擇，我看到了你內心真正的傾向...',
            sceneType: 'choice_reflection',
            context: '第三章選擇反思：針對玩家五次具體選擇行為的即時分析，重點解讀選擇背後的哲學傾向，並為即將到來的鵷鶵和鴟鴞物化體驗做心理準備',
            nextScene: 31
          },
          
          // === 第三階段：標準遊戲流程開始 ===
          {
            type: 'narrative',
            text: '森林逐漸安靜下來，月光透過樹葉灑在地面上，形成神秘的光影圖案。在這寧靜中，你開始聽到樹上鵷鶵和鴟鴞之間的對話聲。',
            nextScene: 32
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我們聆聽牠們的對話。若要獲得這兩種神鳥的物化能力，你需要理解並解讀樹葉間浮現的古老文字。',
            nextScene: 33
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'leaf-text',
            text: '惠子相梁莊子往見之或謂惠子曰莊子來欲代子相於是惠子恐搜於國中三日三夜莊子往見之曰南方有鳥其名為鵷鶵子知之乎',
            solution: [3, 8, 13, 16, 20, 25, 33, 38, 39, 43, 48],
            hint: '點擊字符之間的空隙，嘗試正確斷句。這段文字講述了惠子擔心莊子來取代他的位置...',
            success: '你成功解讀了樹葉間的文字！文字開始發出綠色光芒，圍繞著你旋轉。光線凝聚成兩種鳥的形態——純白的鵷鶵和褐色的鴟。',
            nextScene: 34
          },
          {
            type: 'narrative',
            text: '隨著最後一個斷句標記落入正確位置，文字化為綠色流光，在空中形成鳥的形態。一道光芒注入你的體內，你感到一股新的力量在體內流淌。',
            nextScene: 35
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！現在你已獲得兩種神鳥的物化能力。你可以分別化身為高潔的鵷鶵和夜行的鴟鴞，體驗截然不同的世界觀。',
            nextScene: 36
          },
          {
            type: 'form-unlock-guide',
            text: '綠色的流光注入你的身體，首先化為一道金色的神光！你獲得了聖潔鵷鶵的物化能力。鵷鶵是鳳凰一族，喜愛純淨，以甘露為飲食。請點擊鵷鶵按鈕，體驗這種高潔的存在方式。',
            effect: 'unlockForm:yuanchu',
            highlightForm: 'yuanchu',
            nextScene: 37
          },
          {
            type: 'transformation-experience',
            formType: 'yuanchu',
            text: '你化身為聖潔的鵷鶵，瞬間感受到世界的純淨之美。一切都呈現出水晶般透明的光澤，空氣中瀰漫著蓮花的芬芳。作為鵷鶵，你只能被純淨的事物所吸引——清澈的泉水、盛開的花朵、新鮮的果實。任何腐朽或污濁的東西都讓你感到不適。在這純淨的視角下，世界如同天堂般美好，只有最潔淨的事物才值得你的關注。',
            nextScene: 38
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '感受到了嗎？鵷鶵的世界是如此純淨高潔。但這只是一個視角。現在讓我們體驗另一種截然不同的存在方式。',
            nextScene: 39
          },
          {
            type: 'form-unlock-guide',
            text: '第二道神光——深紫色的夜光注入你的身體！你獲得了夜行鴟鴞的物化能力。鴟鴞在夜晚活動，擁有敏銳的夜視能力，以腐鼠為珍貴食物。請點擊鴟鴞按鈕，體驗這種夜行者的生存智慧。',
            effect: 'unlockForm:chixiao',
            highlightForm: 'chixiao',
            nextScene: 40
          },
          {
            type: 'transformation-experience',
            formType: 'chixiao',
            text: '你化身為夜行的鴟鴞，視角瞬間改變。黑暗對你來說不再是障礙，而是最好的掩護。你的金色眼睛能看穿夜晚的秘密，腐朽的氣味對你來說不是厭惡，而是珍貴食物的信號。在夜視模式下，你能清晰地看到其他生物無法察覺的細節，腐鼠散發的氣味就像香甜的蜜糖。這就是鴟鴞的生存智慧——在別人眼中的污穢，是你眼中的珍寶。',
            nextScene: 41
          },
          {
            type: 'narrative',
            text: '你已經分別體驗了兩種截然不同的存在方式。通過鵷鶵的純淨視角和鴟鴞的夜視能力，你開始理解價值觀的相對性——同樣的世界，不同的視角會帶來完全不同的認知和價值判斷。',
            nextScene: 42
          },
          
          // === 第四階段：封印收集開始 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你理解了萬物視角的相對性。無論以哪種形態體驗世界，都有其獨特的智慧和價值。在梧桐樹的高處，你會發現左耳之竅的封印。',
            nextScene: 43
          },
          {
            type: 'narrative',
            text: '你展翅飛向梧桐樹的頂端，在茂密的枝葉間，你發現了一道閃爍的光芒——那是左耳之竅的封印！它懸浮在空中，散發著溫暖的綠光。',
            nextScene: 44
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是第三個封印——左耳之竅！它將封閉你的左耳聽聞，讓你不再被外聲所擾。取下它，混沌就能重新封閉第三個竅，回歸內在的純然寧靜。',
            nextScene: 45
          },
          {
            type: 'narrative',
            text: '你飛近封印，伸出翅膀輕觸它。封印立刻發出璀璨的綠光，朝你飛來。當它與你接觸的那一刻，你感到左耳的聽聞執著逐漸消散，外界的繁雜聲音不再擾亂內心，心中升起一種純然的寧靜。',
            effect: 'collectAperture:left-ear',
            nextScene: 46
          },
          
          // === 第五階段：AI章節總結 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '恭喜你找到了第三個封印！你的左耳之竅已被封閉，不再被外界聲音所擾亂。混沌的第三個竅得以重新封閉，內心回歸更深的寧靜。',
            nextScene: 47
          },
          {
            type: 'narrative',
            text: '第三章即將結束！你已經收集了左耳之竅的封印，並掌握了兩種神鳥的物化能力：聖潔的鵷鶵和夜行的鴟鴞。通過五次深度的哲學選擇和兩種截然不同的存在體驗，你對價值觀的相對性有了深刻理解。',
            nextScene: 48
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在這片梧桐森林中，你的哲學之旅又進了一步...',
            sceneType: 'chapter_summary',
            context: '第三章深度總結：基於玩家五次分支選擇分析其價值觀包容度、美學傾向、生命態度，並運用莊子"價值相對性"智慧為玩家未來的人際分歧處理、多元觀點接納、合作相處方式提供個性化的成長建議和生活智慧',
            effect: 'switchToHuman',
            nextScene: 'chapter4:0'
          }
        ]
      },
      
      chapter4: {
        title: '第四章：蝸角之爭',
        description: '誰活在蝸牛角上？',
        background: 'spiral-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你跟隨莊子的身影，來到一片奇異的螺旋空間。這裡彌漫著紫色的光暈，空氣中迴盪著微弱的戰鼓聲和喊殺聲。莊子指向前方一個龐大身影——一隻巨大的蝸牛！',
            nextScene: 1
          },
          
          // === 網狀分支結構：基於蝸角戰爭的故事情境 ===
          
          // === 第一個情境選擇點：初遇戰爭場面 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你聽到了嗎？這戰鼓聲來自蝸牛的觸角上！左角是觸氏國，右角是蠻氏國，兩國正在激烈交戰。突然，一個信使從左角急急跑來，似乎在尋求支援。',
            options: [
              { 
                text: '立即上前詢問戰況如何', 
                next: 2,
                traits: { 
                  philosophical: { idealism: 4, compassion: 3, mindfulness: 2 },
                  mbti: { extraversion: 4, feeling: 3, judging: 2 },
                  story: { curiosity: 4, emotional_depth: 3, gentleness: 2 }
                }
              },
              { 
                text: '先觀察整個戰場局勢', 
                next: 3,
                traits: { 
                  philosophical: { wisdom_seeking: 4, acceptance: 3, transcendence: 2 },
                  mbti: { introversion: 4, thinking: 3, judging: 2 },
                  story: { introspection: 4, resilience: 3, independence: 2 }
                }
              },
              { 
                text: '詢問莊子這場戰爭的起因', 
                next: 4,
                traits: { 
                  philosophical: { wisdom_seeking: 4, authenticity: 3, mindfulness: 2 },
                  mbti: { introversion: 3, intuition: 4, thinking: 2 },
                  story: { introspection: 4, curiosity: 3, depth_seeking: 2 }
                }
              }
            ]
          },
          
          // === 第一組響應場景 ===
          {
            type: 'narrative',
            text: '你快步走向那個慌張的信使。他氣喘吁吁地說：「敵軍又奪取了我們的三個村莊！他們說我們侵犯了他們的祖地，但那明明是我們世代耕種的土地！」信使眼中滿含憤怒和絕望。',
            nextScene: 5
          },
          {
            type: 'narrative',
            text: '你退到高處，俯瞰整個蝸角戰場。驚人的是，兩國的士兵看起來幾乎一模一樣，連武器和戰術都相似。區別只在於左角的士兵帶紅色標記，右角的帶藍色標記。',
            nextScene: 5
          },
          {
            type: 'narrative',
            text: '莊子撫摸著鬍鬚：「這場戰爭起源於一場邊界糾紛。兩國都聲稱某塊土地是自己的，都有各自的歷史記錄和正當理由。戰爭越打越激烈，原本的爭議早已被仇恨取代。」',
            nextScene: 5
          },
          
          // === 第一個交匯點：戰爭真相的思考 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '此時，右角的蠻氏國也派來一個使者，他控訴觸氏國是侵略者。兩個使者在你面前激烈爭辯，都堅持自己是受害者。你該如何應對？',
            options: [
              { 
                text: '試著調解，讓雙方冷靜對話', 
                next: 6,
                traits: { 
                  philosophical: { harmony: 4, compassion: 3, idealism: 2 },
                  mbti: { extraversion: 4, feeling: 4, judging: 2 },
                  story: { gentleness: 4, emotional_depth: 3, cooperation: 2 }
                }
              },
              { 
                text: '分別聽取雙方的完整訴求', 
                next: 7,
                traits: { 
                  philosophical: { acceptance: 4, wisdom_seeking: 3, authenticity: 2 },
                  mbti: { introversion: 3, thinking: 4, judging: 3 },
                  story: { introspection: 4, resilience: 3, independence: 2 }
                }
              },
              { 
                text: '建議他們暫停戰爭，共同尋找解決方案', 
                next: 8,
                traits: { 
                  philosophical: { idealism: 4, harmony: 3, compassion: 2 },
                  mbti: { extraversion: 3, thinking: 3, judging: 4 },
                  story: { cooperation: 4, creativity: 3, optimism: 2 }
                }
              }
            ]
          },
          
          // === 第二組響應場景 ===
          {
            type: 'narrative',
            text: '你耐心地讓兩個使者輪流發言，試圖化解他們的敵意。然而，你發現一個有趣的現象：當他們不再互相指責時，各自的故事竟然有許多相似之處——都談到了家園、傳統和生存的恐懼。',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '你專注地聽取雙方的訴求，記錄下每個細節。觸氏國說那是他們的祖地，蠻氏國說那是他們的聖地。但你漸漸意識到，他們爭奪的「土地」在蝸牛角上也就巴掌大小。',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '你提出暫停戰爭的建議，兩個使者都沉默了。過了一會兒，蠻氏使者說：「戰爭已經進行太久，很多人忘記了最初為什麼要打。」觸氏使者點頭：「我們的孩子只知道仇恨，不知道和平。」',
            nextScene: 9
          },
          
          // === 第二個交匯點：視角轉換的關鍵時刻 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這時，蝸牛忽然緩緩移動，兩國的士兵都因為「大地震動」而暫停了戰鬥。在這短暫的寧靜中，你聽到有人問：「我們到底在為什麼而戰？」面對這個關鍵時刻，你會怎麼做？',
            options: [
              { 
                text: '告訴他們這場戰爭在更大視角下是多麼微小', 
                next: 10,
                traits: { 
                  philosophical: { transcendence: 4, wisdom_seeking: 3, acceptance: 2 },
                  mbti: { intuition: 4, thinking: 3, judging: 2 },
                  story: { depth_seeking: 4, introspection: 3, resilience: 2 }
                }
              },
              { 
                text: '邀請雙方領袖親自體驗對方的痛苦', 
                next: 11,
                traits: { 
                  philosophical: { compassion: 4, authenticity: 3, harmony: 2 },
                  mbti: { feeling: 4, extraversion: 3, perceiving: 2 },
                  story: { emotional_depth: 4, gentleness: 3, cooperation: 2 }
                }
              },
              { 
                text: '建議他們從蝸牛的角度看待這場爭論', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, wisdom_seeking: 2 },
                  mbti: { intuition: 4, perceiving: 3, thinking: 2 },
                  story: { creativity: 4, curiosity: 3, adaptability: 2 }
                }
              }
            ]
          },
          
          // === 第三組響應場景 ===
          {
            type: 'narrative',
            text: '你引導大家將視角拉高。當他們看到自己的整個「世界」只是一隻蝸牛的觸角時，許多士兵放下了武器。一個年輕的戰士說：「原來我們一直在這麼小的地方自相殘殺。」',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '你安排兩國的領袖交換身份，體驗對方的生活一天。當觸氏國王感受到蠻氏國民的辛苦，蠻氏國王理解觸氏國民的恐懼時，他們開始重新審視這場戰爭的意義。',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '你引導大家想像：如果蝸牛有意識，它會如何看待角上的戰爭？「也許對蝸牛來說，我們就像它身上的細菌在爭鬥。」一個智者說道。這個比喻讓所有人陷入沉思。',
            nextScene: 13
          },
          
          // === 最終匯聚點：和解的智慧 ===
          {
            type: 'narrative',
            text: '在你的引導下，兩國開始思考戰爭的意義。此時，莊子微笑著說：「你們都展現了超越爭論的智慧。這種能夠轉換視角、理解相對性的能力，正是通往右耳之竅封印的鑰匙。」一道紫光在空中閃現，指向遠方。',
            nextScene: 14
          },
          
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過你剛才在蝸角戰爭中的選擇，我看到了你處理衝突和理解不同視角的方式。每個人面對爭論時的反應都反映了內心的智慧...',
            sceneType: 'personal_analysis',
            context: '蝸角戰爭中的衝突處理方式分析',
            nextScene: 15
          },
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'spiral-effect',
            text: '莊子拂袖而過，紫色的螺旋光芒在空中凝聚，逐漸形成古老文字的輪廓。這些文字如同蝸牛殼上的紋路般盤旋排列，散發著神秘的光芒。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '若要理解這蝸角之爭的真相，你需要先解讀這段關於大小相對的古文。它將幫你獲得變換視角的能力。',
            nextScene: 17
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'spiral-text',
            text: '有所謂蝸者君知之乎有國於蝸之左角者曰觸氏有國於蝸之右角者曰蠻氏時相與爭地而戰伏尸數萬逐北旬有五日而後反',
            solution: [4, 8, 19, 30, 37, 41],
            hint: '點擊字符之間的空隙，嘗試正確斷句。想像你正在解讀一段關於蝸牛角上微觀世界的秘密...',
            success: '古文綻放出璀璨的紫光！文字化作螺旋光流環繞著你，你感到體內湧現一股奇特的力量——你已獲得了蝸牛的物化能力和視角轉換的神通。',
            nextScene: 18
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在，變身為蝸牛，親身體驗這個承載著兩個文明的微觀世界。只有成為蝸牛本身，你才能真正理解這場戰爭對當事者而言的意義。',
            nextScene: 19
          },
          {
            type: 'form-unlock-guide',
            text: '紫色的螺旋光流注入你的身體，你獲得了「蝸牛」的物化能力！現在你可以化身為蝸牛，成為承載兩個文明的微觀世界載體。請點擊物化按鈕，選擇蝸牛形態來感受這獨特的體驗。',
            effect: 'unlockForm:snail',
            highlightForm: 'snail',
            nextScene: 20
          },
          {
            type: 'transformation-experience',
            formType: 'snail',
            text: '你的意識轉換為蝸牛的視角。世界突然變得遼闊而深邃，你感受到前所未有的緩慢和專注。時間彷彿放慢了十倍，每一個細微的動作都需要巨大的耐心。你的感知變得極其敏銳——觸角上的細微震動、空氣中的濕度變化、土壤的溫度，一切都清晰可感。在這種緩慢而深邃的感知中，你體會到了什麼叫做「包容」和「承載」——不是消極的忍受，而是以最大的耐心和愛意去承受一切。',
            nextScene: 21
          },
          {
            type: 'snail-perspective-transition',
            text: '當你以蝸牛視角感受世界時，突然，你意識到自己就是那個承載著兩個文明的存在...讓我們將視角轉換，看看這個微觀世界的全貌。',
            nextScene: 22
          },
          {
            type: 'narrative',
            text: '在蝸牛視角的體驗中，你獲得了視角轉換的神通。你已獲得了視角轉換的體悟，理解了相對性的智慧，這種超越固化視角的能力，正是收集右耳封印的前提。',
            effect: 'unlockViewScale',
            nextScene: 23
          },
          {
            type: 'perspective-challenge',
            text: '你先切換到微觀視角，仔細觀察蝸牛觸角上的戰爭。在那微小的世界中，你聽到了兩國的聲音：觸氏國控訴蠻氏國是侵略者，蠻氏國反駁說觸氏國才是侵佔者。雙方都堅信自己的正義，都有自己的道理。',
            nextScene: 24
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你聽到了嗎？這就是紛爭的根源——站在不同立場，看到的真相截然不同。現在，讓你的視角拉到最高處，從更宏觀的維度來審視這場爭論。',
            nextScene: 25
          },
          {
            type: 'narrative',
            text: '當你將視角拉到最高處，整個蝸牛變得如同一粒微塵。從這個超然的層次看去，兩國的戰爭不過是蝸角上的微小騷動。就在這個宏觀的視角中，你看到了一道紫色的光芒——那是右耳之竅的封印！它象徵著超越表面爭論、洞察事物本質的智慧。',
            nextScene: 26
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這就是右耳之竅——分辨真假、超越爭論的智慧之竅。它教會我們：當陷入無謂爭論時，不妨換個視角，從更高的層次審視問題。',
            nextScene: 27
          },
          {
            type: 'narrative',
            text: '你伸手觸摸封印，紫色的光芒瞬間包圍了你。一股清明的感覺湧上心頭——你感到右耳的是非判斷逐漸寧息，不再被爭論聲擾亂，內心回歸超越分別的平靜，理解不同層次的相對性。',
            effect: 'collectAperture:right-ear',
            nextScene: 28
          },
          {
            type: 'narrative',
            text: '第四章圓滿結束！隨著封印的獲得，蝸角戰爭漸漸平息，螺旋空間中的紫色光暈也慢慢消散。你感受到內心的清明和開闊，學會了從不同視角看待同一件事。',
            effect: 'cleanupChapter4',
            nextScene: 29
          },
          
          // === 第四階段：AI章節總結 ===
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在蝸角戰爭的喧囂中，你學會了視角的重要性...',
            sceneType: 'chapter_summary',
            context: '第四章深度總結：基於玩家在蝸角戰爭中的衝突處理方式（直接參與vs觀察分析vs尋求智慧、調解vs公正vs合作、視角轉換vs同理心vs創新思維），分析其應對爭論和理解相對性的能力，運用莊子大小相對性智慧為玩家的人際衝突處理、視角轉換能力、面對分歧的態度提供個性化指導',
            effect: 'switchToHuman',
            nextScene: 'chapter5:0'
          }
        ]
      },
      
      chapter5: {
        title: '第五章：朝菌大椿',
        description: '一天有多長？',
        background: 'time-scene',
        scenes: [
          // === 第一階段：網狀分支對話 ===
          {
            type: 'narrative',
            text: '跟隨莊子的指引，你來到了一片神奇的時間森林。這裡的時間似乎有自己的韻律——有些地方光影變換極快，有些地方仿佛凝滯靜止。森林中彌漫著不同的時間氣息。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你感受到了嗎？這片森林居住著三種生靈：朝生暮死的朝菌、夏鳴秋寂的蟪蛄，還有見證千年滄桑的大椿。它們對時間的感知截然不同。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '莊子指向森林的三個區域。左側樹叢間有快速閃爍的微光，中央林區傳來節律性的蟲鳴，右側古木參天，散發著深沉的時間氣息。每個區域都在召喚著你的注意。',
            nextScene: 3
          },
          
          // 第一個選擇點：初入時間森林的探索方式
          {
            type: 'dialog',
            speaker: '莊子',
            text: '初來此地，你打算如何開始探索這時間的奧秘？',
            options: [
              {
                text: '走向左側區域，追隨那些快速閃爍的微光',
                traits: {
                  philosophical: { beauty_appreciation: 3, mindfulness: 2, authenticity: 2 },
                  mbti: { extraversion: 3, sensing: 3, perceiving: 2 },
                  story: { curiosity: 3, adaptability: 2, optimism: 2 }
                },
                next: 4
              },
              {
                text: '前往中央林區，仔細聆聽那節律性的蟲鳴',
                traits: {
                  philosophical: { harmony: 3, mindfulness: 3, wisdom_seeking: 2 },
                  mbti: { introversion: 2, sensing: 3, judging: 3 },
                  story: { introspection: 3, resilience: 2, depth_seeking: 2 }
                },
                next: 5
              },
              {
                text: '靜心走向右側古木，感受深沉的時間氣息',
                traits: {
                  philosophical: { transcendence: 3, wisdom_seeking: 3, acceptance: 2 },
                  mbti: { introversion: 4, intuition: 3, judging: 2 },
                  story: { introspection: 4, depth_seeking: 3, resilience: 2 }
                },
                next: 6
              }
            ],
            nextScene: null
          },
          
          // 分支路徑A：朝菌區域體驗
          {
            type: 'narrative',
            text: '你走向左側區域，周圍的光影變化越來越快。你看到無數細小的朝菌在晨露中綻放又凋零，它們的生命週期在短短數分鐘內完成。這裡的時間如急流般奔騰。',
            nextScene: 7
          },
          
          // 分支路徑B：蟪蛄區域體驗  
          {
            type: 'narrative',
            text: '你來到中央林區，節律性的蟲鳴越來越清晰。你看到蟪蛄們在樹幹上有規律地鳴叫，它們的生命伴隨著夏季的韻律，從羽化到終結都有固定的節拍。這裡的時間如樂曲般和諧。',
            nextScene: 7
          },
          
          // 分支路徑C：大椿區域體驗
          {
            type: 'narrative',
            text: '你走向右側的古木區域，感受到一種深沉的寧靜。參天的大椿樹矗立在那裡，它們的年輪記錄著千年的歲月。這裡的時間如山岳般厚重穩定。',
            nextScene: 7
          },
          
          // 第一次交匯：時間差異的震撼
          {
            type: 'narrative',
            text: '突然，你感受到一陣奇特的時間波動，三個區域的時間感知同時湧入你的心中——朝菌的急促、蟪蛄的節律、大椿的悠長。這種巨大的差異讓你感到震撼。',
            nextScene: 8
          },
          
          // 第二個選擇點：面對時間差異的反應
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你體驗到了時間感知的差異。面對如此巨大的不同，你有什麼感受？',
            options: [
              {
                text: '感嘆生命的短暫，為朝菌的瞬息人生感到惋惜',
                traits: {
                  philosophical: { compassion: 4, beauty_appreciation: 2, authenticity: 2 },
                  mbti: { feeling: 4, sensing: 3, perceiving: 2 },
                  story: { emotional_depth: 4, gentleness: 3, curiosity: 2 }
                },
                next: 9
              },
              {
                text: '羨慕大椿的悠長歲月，希望能有更多時間',
                traits: {
                  philosophical: { idealism: 3, wisdom_seeking: 2, authenticity: 2 },
                  mbti: { intuition: 3, judging: 3, thinking: 2 },
                  story: { depth_seeking: 3, resilience: 2, independence: 2 }
                },
                next: 10
              },
              {
                text: '認為每種時間感知都有其完整性和意義',
                traits: {
                  philosophical: { acceptance: 4, transcendence: 3, wisdom_seeking: 2 },
                  mbti: { thinking: 3, intuition: 3, judging: 2 },
                  story: { introspection: 4, resilience: 3, depth_seeking: 2 }
                },
                next: 11
              }
            ],
            nextScene: null
          },
          
          // 分支回應A：對短暫的感嘆
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你對朝菌的短暫生命感到惋惜。但你有沒有想過，對朝菌來說，這一天就是它完整的人生？長短的標準是什麼呢？',
            nextScene: 12
          },
          
          // 分支回應B：對悠長的羨慕
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你羨慕大椿的悠長歲月。但時間的價值在於長度嗎？蟪蛄的一個夏天、朝菌的一個晨曦，難道就沒有其獨特的豐富性？',
            nextScene: 12
          },
          
          // 分支回應C：對完整性的理解
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你體會到了時間的相對性。確實，每種生命都有其完整的時間體驗。接下來，讓我們更深入地理解這個道理。',
            nextScene: 12
          },
          
          // 第二次交匯：深度思考時間本質
          {
            type: 'narrative',
            text: '莊子引導你在森林中漫步，你開始感受到每種生物的時間韻律。朝菌的急促、蟪蛄的和諧、大椿的深沉，它們似乎在對話，分享著對時間的不同理解。',
            nextScene: 13
          },
          
          // 第三個選擇點：對話時間生靈
          {
            type: 'dialog',
            speaker: '莊子',
            text: '三種生靈都想與你分享它們的時間智慧。你最想聽誰的故事？',
            options: [
              {
                text: '想聽朝菌講述瞬息間的純粹體驗',
                traits: {
                  philosophical: { authenticity: 3, beauty_appreciation: 3, mindfulness: 2 },
                  mbti: { feeling: 3, sensing: 3, perceiving: 3 },
                  story: { emotional_depth: 3, curiosity: 3, optimism: 2 }
                },
                next: 14
              },
              {
                text: '想聽蟪蛄分享季節韻律的和諧之美',
                traits: {
                  philosophical: { harmony: 4, beauty_appreciation: 3, acceptance: 2 },
                  mbti: { feeling: 3, sensing: 2, judging: 3 },
                  story: { gentleness: 3, resilience: 3, depth_seeking: 2 }
                },
                next: 15
              },
              {
                text: '想聽大椿述說千年歲月的深刻感悟',
                traits: {
                  philosophical: { wisdom_seeking: 4, transcendence: 3, acceptance: 2 },
                  mbti: { introversion: 3, intuition: 4, thinking: 2 },
                  story: { introspection: 4, depth_seeking: 4, resilience: 2 }
                },
                next: 16
              }
            ],
            nextScene: null
          },
          
          // 生靈對話場景A：朝菌的智慧
          {
            type: 'dialog',
            speaker: '朝菌',
            text: '朋友，我的一生只有這個晨曦，但它是如此完整！我不知道昨日，不憂慮明天，只是全心全意地在這一刻綻放。這瞬息的時光對我來說已是無限。',
            nextScene: 17
          },
          
          // 生靈對話場景B：蟪蛄的智慧
          {
            type: 'dialog',
            speaker: '蟪蛄',
            text: '我的生命伴隨夏季的韻律，從初夏的羽化到夏末的寂靜。雖然不知春秋，但這一季已足夠豐富。每一聲鳴叫都是我對時間的歌頌。',
            nextScene: 17
          },
          
          // 生靈對話場景C：大椿的智慧
          {
            type: 'dialog',
            speaker: '大椿',
            text: '孩子，我見證了千年的變遷，八千年為春，八千年為秋。時間對我而言如呼吸般自然。長久並不意味著更有價值，只是看待世界的方式不同。',
            nextScene: 17
          },
          
          // 第三次交匯：智慧的融合
          {
            type: 'narrative',
            text: '三種生靈的智慧在你心中迴響。你開始理解，時間的意義不在長短，而在於每個生命如何完整地體驗自己的時間。一種古老的文字開始在琥珀色的光暈中浮現。',
            nextScene: 18
          },
          
          // 第四個選擇點：運用時間智慧
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你領悟了時間的相對性。那麼，你打算如何運用這種智慧？',
            options: [
              {
                text: '學會珍惜當下的每一刻，像朝菌般專注',
                traits: {
                  philosophical: { mindfulness: 4, authenticity: 3, beauty_appreciation: 2 },
                  mbti: { feeling: 3, sensing: 3, perceiving: 3 },
                  story: { emotional_depth: 3, curiosity: 3, optimism: 2 }
                },
                next: 19
          },
          {
                text: '尋找生活的節律，像蟪蛄般和諧',
                traits: {
                  philosophical: { harmony: 4, acceptance: 3, beauty_appreciation: 2 },
                  mbti: { feeling: 3, judging: 3, sensing: 2 },
                  story: { gentleness: 3, resilience: 3, cooperation: 2 }
                },
                next: 19
              },
              {
                text: '培養寬廣的時間視野，像大椿般包容',
                traits: {
                  philosophical: { transcendence: 4, acceptance: 3, wisdom_seeking: 2 },
                  mbti: { introversion: 3, intuition: 3, judging: 3 },
                  story: { introspection: 4, depth_seeking: 3, resilience: 2 }
                },
                next: 19
              }
            ],
            nextScene: null
          },
          
          // 最終交匯：智慧的整合
          {
            type: 'narrative',
            text: '你的選擇與三種生靈的智慧產生共鳴。森林中的時間氣息開始融合，你感受到一種超越時間局限的寧靜。古老的文字愈發清晰，等待著你的解讀。',
            nextScene: 20
          },
          
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '在時間森林的體驗中，你展現了對時間的獨特理解...',
            sceneType: 'time_wisdom_analysis',
            context: '第五章個性化回應：基於玩家在時間森林中的探索方式（追隨微光vs聆聽節律vs感受古木）、對時間差異的反應（感嘆短暫vs羨慕悠長vs理解完整性）、生靈對話選擇（朝菌純粹vs蟪蛄和諧vs大椿深沉）、智慧運用方向（珍惜當下vs尋找節律vs培養視野），分析其時間觀念、生活態度、價值取向，運用莊子時間相對性智慧提供個性化的時間管理和人生感悟指導',
            nextScene: 21
          },
          
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '要獲得時間感知的能力，你需要解讀這段關於生命長短的古文。只有真正領悟了時間的相對性，封印才會顯現。',
            nextScene: 22
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'time-text',
            text: '朝菌不知晦朔蟪蛄不知春秋此小年也楚之南有冥靈者以五百歲為春五百歲為秋上古有大椿者以八千歲為春八千歲為秋',
            solution: [5, 11, 15, 22, 28, 33, 39, 45],
            hint: '點擊字符之間的空隙，嘗試正確斷句。思考不同生物對時間的感知...',
            success: '文字綻放出琥珀般的溫暖光芒！時間的碎片如流沙般圍繞著你，你感到體內湧現一股神奇的力量——時間感知的能力已經覺醒。',
            effect: 'unlockTimePerception',
            nextScene: 23
          },
          {
            type: 'time-effect',
            text: '隨著古文的解讀完成，一股奇異的能量流入你的身體。你突然能感受到森林中不同生物的時間節拍——急促的朝菌，悠然的蟪蛄，還有緩慢而深沉的大椿心跳。',
            nextScene: 24
          },
          {
            type: 'form-unlock-guide',
            text: '時間感知的力量覺醒了！你獲得了朝菌、蟪蛄、大椿三種物化能力。首先體驗朝菌的瞬息時光——在短暫中感受永恆。點擊物化按鈕，選擇朝菌形態。',
            effect: 'unlockForm:morning-fungus',
            highlightForm: 'morning-fungus',
            nextScene: 25
          },
          {
            type: 'transformation-experience',
            formType: 'morning-fungus',
            text: '你的意識與一株朝菌融合。世界突然變得無比快速——陽光在眼前急速移動，露珠瞬間蒸發，其他植物如電影快進般生長。對朝菌而言，一天就是完整的一生。在這短暫的存在中，你體驗到了生命的純粹和專注：沒有過去的回憶，沒有未來的憂慮，只有當下這一刻的綻放。這就是朝菌的智慧——在有限中感受無限，在瞬息中體驗永恆。',
            nextScene: 26
          },
          {
            type: 'form-unlock-guide',
            text: '現在體驗蟪蛄的季節韻律——在有限的夏日中感受完整的生命週期。點擊物化按鈕，選擇蟪蛄形態。',
            effect: 'unlockForm:cicada',
            highlightForm: 'cicada',
            nextScene: 27
          },
          {
            type: 'transformation-experience',
            formType: 'cicada',
            text: '你的意識轉移到蟪蛄身上。時間流速有所放緩，你能感受到夏日的完整韻律——從初夏的羽化到盛夏的鳴叫，再到夏末的寂靜。春天和秋天對你來說是不存在的概念。作為蟪蛄，你擁有一個完整的季節來體驗生命：從土中鑽出的興奮，到樹上鳴叫的激情，再到生命終結時的平靜。這一個夏天就是你的全部世界，但它是如此豐富和完整。',
            nextScene: 28
          },
          {
            type: 'form-unlock-guide',
            text: '最後體驗大椿的千年歲月——在漫長中感受時間的深度和寬度。點擊物化按鈕，選擇大椿形態。',
            effect: 'unlockForm:great-chun',
            highlightForm: 'great-chun',
            nextScene: 29
          },
          {
            type: 'transformation-experience',
            formType: 'great-chun',
            text: '你的意識與古老的大椿樹融合。時間突然變得極其緩慢，人類的生老病死在你眼中如蜉蝣般短暫。朝代的更替、文明的興衰，都只是你生命中的瞬間片段。作為大椿，你見證了無數個春秋的輪迴，看著山川變遷，星辰移位。在這漫長的歲月中，你學會了什麼叫做「恆久」和「包容」——不是因為生命長就更有意義，而是因為你能以更寬廣的視角看待一切變化，理解萬物的本質都是相同的。',
            nextScene: 30
          },
          {
            type: 'time-effect',
            text: '三種時間感知的體驗完成後，你看到了一道溫潤的琥珀色光芒從大椿的樹幹中浮現——那是左鼻之竅的封印！它象徵著對時間本質的深刻理解。',
            nextScene: 31
          },
          {
            type: 'narrative',
            text: '你伸手觸摸封印，琥珀色的溫暖光芒包圍了你。一種超越時間的寧靜感充滿心靈——你感到左鼻的時間執著逐漸消散，不再被瞬息變化所困擾，心中升起超越時間的寧靜。',
            effect: 'collectAperture:left-nose',
            nextScene: 32
          },
          {
            type: 'narrative',
            text: '第五章圓滿結束！通過四次選擇和深度體驗，你領悟了時間相對性的真諦。時間森林中的智慧已融入你心——瞬息與永恆、短暫與悠長，都是時間的不同面向，每種都有其完整性和價值。',
            effect: 'cleanupChapter5',
            nextScene: 33
          },
          
          // === 第四階段：AI章節總結 ===
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在時間森林的旅程中，你探索了生命長短的奧秘...',
            sceneType: 'chapter_summary',
            context: '第五章深度總結：基於玩家在時間森林中的四次選擇（探索方式、時間差異反應、生靈對話、智慧運用），分析其時間觀念、生活節奏偏好、價值判斷模式、智慧整合能力，運用莊子朝菌大椿思想為玩家的時間管理、生活態度、人生規劃提供個性化指導',
            effect: 'switchToHuman',
            nextScene: 'chapter6:0'
          }
        ]
      },
      
      chapter6: {
        title: '第六章：螻蟻星辰',
        description: '上下有何不同？',
        background: 'heaven-earth-scene',
        scenes: [
          {
            type: 'narrative',
            text: '跟隨莊子的指引，你來到了一個神奇的地方。這裡天圓地方，日月星辰如珠璣般點綴在半圓形的天蓋之下。溫暖的金色光芒從大地升起，與深藍的夜空形成美麗的漸變。這裡充滿了自然的和諧與寧靜。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '我的朋友，我們來到了生死的邊界。但不要害怕，死亡不過是回歸自然的懷抱。你看，天地本就是最好的棺槨，日月星辰是最美的陪葬品。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '莊子的話語中透著一種超脫的智慧和對自然的深深眷戀。他指向天空中閃爍的星辰，又指向腳下溫暖的大地，臉上帶著平和的微笑。',
            nextScene: 3
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看到了嗎？這天地間的一切...',
            options: [
              {
                text: '跟隨莊子的手勢仰望星空，數著那些珠璣般的星辰',
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, idealism: 2 },
                  mbti: { intuition: 4, feeling: 3, perceiving: 2 },
                  story: { curiosity: 3, emotional_depth: 3, creativity: 2 }
                },
                next: 4
              },
              {
                text: '蹲下身摸摸腳下的土地，感受大地的溫度',
                traits: { 
                  philosophical: { authenticity: 4, mindfulness: 3, acceptance: 2 },
                  mbti: { sensing: 4, introversion: 3, judging: 2 },
                  story: { introspection: 3, resilience: 3, depth_seeking: 2 }
                },
                next: 4
              },
              {
                text: '靜靜站在原地，讓目光在天地之間緩緩游移',
                traits: { 
                  philosophical: { harmony: 4, wisdom_seeking: 3, transcendence: 2 },
                  mbti: { introversion: 3, intuition: 3, judging: 3 },
                  story: { introspection: 4, depth_seeking: 3, resilience: 2 }
                },
                next: 4
              }
            ]
          },
          {
            type: 'narrative',
            text: '這時，從遠處傳來幾位弟子的談話聲。他們正圍在一起，神情憂慮，似乎在討論著什麼重要的事情。其中一位弟子的聲音有些顫抖。',
            nextScene: 5
          },
          {
            type: 'dialog',
            speaker: '弟子甲',
            text: '老師說死亡是回歸自然...可我總覺得心裡空落落的，不知道該說什麼好。',
            nextScene: 6
          },
          {
            type: 'dialog',
            speaker: '弟子乙',
            text: '我最擔心的是...老師過世後，那些野外的鳥獸...',
            options: [
              {
                text: '輕輕走近弟子們，想聽聽他們的完整談話',
                traits: { 
                  philosophical: { compassion: 4, authenticity: 3, harmony: 2 },
                  mbti: { extraversion: 3, feeling: 4, perceiving: 2 },
                  story: { emotional_depth: 4, gentleness: 3, curiosity: 2 }
                },
                next: 7
              },
              {
                text: '在一旁安靜等待，不打擾他們的私人對話',
                traits: { 
                  philosophical: { acceptance: 4, wisdom_seeking: 3, authenticity: 2 },
                  mbti: { introversion: 4, thinking: 3, judging: 2 },
                  story: { introspection: 4, resilience: 3, independence: 2 }
                },
                next: 7
              },
              {
                text: '走向莊子，想問問老師對弟子擔憂的看法',
                traits: { 
                  philosophical: { wisdom_seeking: 4, idealism: 3, authenticity: 2 },
                  mbti: { extraversion: 3, thinking: 3, judging: 3 },
                  story: { curiosity: 4, depth_seeking: 3, independence: 2 }
                },
                next: 7
              }
            ]
          },
          {
            type: 'dialog',
            speaker: '弟子乙',
            text: '吾恐烏鳶之食夫子也。我們總想為老師準備厚葬，讓他在另一個世界也能舒適...',
            nextScene: 8
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '弟子們總是擔心我死後會被烏鳶啄食，但他們不明白——在上為烏鳶食，在下為螻蟻食，這有什麼區別呢？偏愛其中一種，豈不是很偏頗嗎？',
            nextScene: 9
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '從你剛才面對生死智慧的選擇中，我能感受到你的心境和思維方式。每個人面對弟子們的擔憂都有不同反應...',
            sceneType: 'personal_analysis',
            context: '第六章螻蟻星辰，基於玩家在面對莊子將死故事中的第一次選擇分析其生死智慧理解方式',
            nextScene: 11
          },
          {
            type: 'heaven-earth-effect',
            text: '隨著莊子的話語，天地間開始浮現古老的文字。這些文字如星光般閃爍，又如大地般溫暖，它們承載著莊子對生死的超脫理解。',
            nextScene: 12
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '要理解生死的真諦，你需要解讀這段關於自然回歸的古文。只有真正領悟了生死一體的道理，你才能獲得超越生死的智慧。',
            nextScene: 13
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'heaven-earth-text',
            text: '莊子將死弟子欲厚葬之莊子曰吾以天地為棺槨以日月為連璧星辰為珠璣萬物為齎送吾葬具豈不備邪何以加此弟子曰吾恐烏鳶之食夫子也莊子曰在上為烏鳶食在下為螻蟻食奪彼與此何其偏也',
            solution: [3, 9, 12, 19, 25, 30, 35, 42, 46, 49, 58, 61, 67, 73, 77],
            hint: '點擊字符之間的空隙，嘗試正確斷句。思考莊子對生死的超脫態度...',
            success: '文字綻放出金色的溫暖光芒！天地間的和諧之氣圍繞著你，你感到體內湧現一股超脫的力量——超越生死的智慧已經覺醒。',
            effect: 'unlockLifeDeathWisdom',
            nextScene: 14
          },
          {
            type: 'heaven-earth-effect',
            text: '隨著古文的解讀完成，一股深沉而溫暖的能量流入你的身體。你突然能感受到天地間的和諧——星辰的永恆寧靜，大地的溫暖懷抱，生與死原來都是自然的一部分。',
            nextScene: 15
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！現在你已獲得了超越生死的智慧。讓我們先體驗螻蟻的視角，感受那「在下」的踏實與安詳。',
            nextScene: 15
          },
          {
            type: 'form-unlock-guide',
            text: '一股來自大地深處的溫暖力量流入你的身體，你感到自己獲得了新的物化能力！現在你可以化身為「螻蟻」，體驗那「在下」的踏實與安詳。點擊物化按鈕，選擇螻蟻形態來感受大地的懷抱。',
            effect: 'unlockForm:ant',
            highlightForm: 'ant',
            nextScene: 16
          },
          {
            type: 'transformation-experience',
            formType: 'ant',
            text: '你的意識與一隻勤勞的螻蟻融合。世界突然變得溫暖而踏實——你能感受到大地母親的心跳，泥土的芬芳，根系的力量。作為螻蟻，你明白了什麼叫做「在下」的智慧：不是卑微，而是與大地最親近的連接。死亡對你來說不是恐懼，而是回到這溫暖懷抱的歸宿。在大地的懷抱中，你感受到了生命的踏實和死亡的安詳——它們都是自然循環中不可分割的一部分。',
            nextScene: 17
          },
          {
            type: 'dialog',
            speaker: '螻蟻',
            text: '朋友，你感受到了嗎？我們生活在大地的懷抱中，每一粒泥土都是我們的家。當生命結束時，我們只是回到了這個溫暖的家園。這裡沒有恐懼，只有回歸的安詳。',
            nextScene: 18
          },
          {
            type: 'narrative',
            text: '從螻蟻的視角中回到人形，你看到大地上散落著一些特別的東西——有閃閃發光的小石子，有形狀奇特的枯葉，還有一些看起來很古老的符號痕跡。',
            effect: 'switchToHuman',
            nextScene: 19
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你注意到了什麼有趣的東西嗎？',
            options: [
              {
                text: '撿起那些閃閃發光的小石子，放在掌心仔細觀察',
                traits: { 
                  philosophical: { mindfulness: 4, beauty_appreciation: 3, authenticity: 2 },
                  mbti: { sensing: 4, introversion: 3, perceiving: 2 },
                  story: { curiosity: 3, depth_seeking: 3, creativity: 2 }
                },
                next: 20
              },
              {
                text: '蹲下研究那些古老的符號痕跡，試圖理解其含義',
                traits: { 
                  philosophical: { wisdom_seeking: 4, idealism: 3, transcendence: 2 },
                  mbti: { intuition: 4, thinking: 3, judging: 2 },
                  story: { curiosity: 4, depth_seeking: 3, independence: 2 }
                },
                next: 20
              },
              {
                text: '輕撫那些枯葉，感受它們從生到死的自然軌跡',
                traits: { 
                  philosophical: { acceptance: 4, transcendence: 3, beauty_appreciation: 2 },
                  mbti: { feeling: 4, intuition: 3, perceiving: 2 },
                  story: { emotional_depth: 4, creativity: 3, gentleness: 2 }
                },
                next: 20
              }
            ]
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我們體驗星辰的視角，感受那「在上」的永恆與超脫。這將是你第一次化身為非生物的存在。',
            nextScene: 21
          },
          {
            type: 'form-unlock-guide',
            text: '一股來自天空深處的神秘力量注入你的身體，你感受到了前所未有的體驗——你獲得了「星辰」的物化能力！這是你第一次能夠化身為非生物的存在。點擊物化按鈕，選擇星辰形態來感受宇宙的永恆。',
            effect: 'unlockForm:star',
            highlightForm: 'star',
            nextScene: 22
          },
          {
            type: 'transformation-experience',
            formType: 'star',
            text: '你的意識升華為一顆閃爍的星辰。時間和空間的概念完全改變了——你從宇宙的高度俯瞰著一切，生死在你眼中如潮汐般自然。作為星辰，你體驗到了什麼叫做「在上」的超脱：不是高傲，而是以最寬廣的視角包容一切。從這個高度看去，生與死只是宇宙中微小的變化，如同呼吸一般自然。你感受到了永恆的寧靜和對萬物的慈悲——這就是超越生死界限的智慧。',
            nextScene: 23
          },
          {
            type: 'narrative',
            text: '從星辰的永恆視角回歸，你發現天地交接處出現了一道柔和的光帶，其中似乎蘊含著生死循環的奧秘。同時，你感受到內心有種前所未有的寧靜感。',
            effect: 'switchToHuman',
            nextScene: 24
          },
          {
            type: 'dialog',
            speaker: '內心聲音',
            text: '在永恆與瞬間之間，你選擇關注什麼？',
            options: [
              {
                text: '走向那道神秘的光帶，想要親身感受其中的奧秘',
                traits: { 
                  experiential_learning: 2, 
                  courage: 2, 
                  direct_engagement: 2,
                  mystery_attraction: 1
                },
                next: 25
              },
              {
                text: '閉上眼睛，專注感受內心的這種前所未有的寧靜',
                traits: { 
                  introspective_approach: 2, 
                  inner_wisdom: 2, 
                  meditative_tendency: 2,
                  self_awareness: 1
                },
                next: 25
              },
              {
                text: '在這裡靜靜坐下，讓天地的和諧慢慢滲透心靈',
                traits: { 
                  patience: 2, 
                  receptive_attitude: 2, 
                  harmony_seeking: 2,
                  contemplative_nature: 1
                },
                next: 25
              }
            ]
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '基於你在這段生死智慧之旅中的所有選擇，我能感受到你對生死境界的獨特理解...',
            sceneType: 'integrated_analysis',
            context: '第六章螻蟻星辰，基於玩家的完整選擇歷程（四次關鍵選擇）進行綜合性個性化分析',
            nextScene: 26
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你理解了嗎？無論是螻蟻的「在下」還是星辰的「在上」，它們都是自然的一部分。偏愛其中一種，確實是很偏頗的想法。',
            nextScene: 27
          },
          {
            type: 'heaven-earth-effect',
            text: '在這種超越生死的體驗中，你看到了一道溫暖的金色光芒從天地交接處浮現——那是右鼻之竅的封印！它象徵著對生死本質的深刻理解和超越偏見的智慧。',
            nextScene: 28
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是右鼻之竅——超越偏見之竅。它將封閉你的右鼻感知，讓你不再被生死氣息所困擾。取下它，混沌就能重新封閉第六個竅，超越生死分別的束縛。',
            nextScene: 29
          },
          {
            type: 'narrative',
            text: '你伸手觸摸封印，金色的溫暖光芒包圍了你。一種超越生死的平靜感充滿心靈——你感到右鼻的生死執著逐漸消融，不再被生死差別所束縛，心中升起超越生死的平等寧靜。',
            effect: 'collectAperture:right-nose',
            nextScene: 30
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在《莊子將死》的故事中，你通過螻蟻和星辰的雙重視角，領悟了生死一體的深刻哲理...',
            sceneType: 'chapter_summary',
            context: '第六章深度總結：基於玩家在生死智慧之旅中的四次關鍵選擇（面對天地的觀察方式、對弟子擔憂的反應、大地探索的關注點、永恆與瞬間的選擇），分析其生死觀念、同理心深度、探索傾向、哲學思辨能力，運用莊子超越生死的智慧為玩家的人生態度、面對變化、價值觀念提供個性化指導。現在右鼻之竅已收集，下一章將是最終考驗。',
            effect: 'switchToHuman',
            nextScene: 'chapter7:0'
          }
        ]
      },
      
      chapter7: {
        title: '第七章：道歸混沌',
        description: '混沌為何死又如何生？',
        background: 'void-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你跟隨莊子來到了宇宙的中心——虛空殿。這裡是中央之帝渾沌的領域，但現在卻籠罩著死亡的陰霾。星雲在虛空中緩緩流動，散發著前六章旅程的色彩回響。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看，這就是渾沌——曾經的中央之帝。儵與忽為了報答他的恩德，每日為他鑿一竅，七日而渾沌死。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '在虛空殿的中央，你看到了一個無竅的形體靜靜躺著，散發著微弱的光芒。空氣中彌漫著悲傷的氣息，彷彿還能感受到儵與忽的懊悔。',
            nextScene: 3
          },
          {
            type: 'dialog',
            speaker: '儵',
            text: '我們...我們只是想報答渾沌的恩德...人皆有七竅以視聽食息，為什麼他沒有呢？',
            nextScene: 4
          },
          {
            type: 'dialog',
            speaker: '忽',
            text: '我們每日為他鑿一竅...以為這樣能讓他更好地感受世界...但是...',
            nextScene: 5
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '言語或有遮蔽，何不親見其往事？觸摸渾沌，感受那段悲劇的真相。',
            nextScene: 6
          },
          {
            type: 'narrative',
            text: '你緩緩走向虛空殿中央的渾沌。當你的手觸及他的形體時，一股古老的記憶湧入你的心中...',
            nextScene: 7
          },
          {
            type: 'narrative',
            text: '記憶如潮水般湧來...你看到了儵與忽的善意，看到了渾沌的無竅之美，也看到了悲劇的必然。要理解這個故事，你需要轉動太極，讓陰陽重新流動。',
            nextScene: 8
          },
          {
            type: 'puzzle-taijitu',
            text: '太極轉動：點住太極符號轉動三圈，讓陰陽魚重新遊動起來。',
            nextScene: 9
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你讓太極重新轉動起來，陰陽魚又開始遊動了。看，頂部的太極也因你的行動而顯現。現在，讓我們回到渾沌之死的故事本身。要真正理解這個悲劇的深意，你需要先正確理解這段古文的含義。',
            nextScene: 10
          },
          {
            type: 'segmentation-puzzle',
            text: '南海之帝為儵北海之帝為忽中央之帝為渾沌儵與忽時相與遇於渾沌之地渾沌待之甚善儵與忽謀報渾沌之德曰人皆有七竅以視聽食息此獨無有嘗試鑿之日鑿一竅七日而渾沌死',
            solution: [5, 11, 18, 30, 36, 45, 46, 51, 53, 54, 55, 56, 60, 64, 68],
            hint: '仔細閱讀這段古文，理解渾沌之死的故事。注意句子的自然停頓和語義的完整性。',
            success: '你已經理解了渾沌之死的完整故事。儵與忽的善意反而害了渾沌，這正是莊子要表達的深刻哲理。',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你已經理解了這個悲劇的全貌。但要救渾沌，需要先聚集萬物之氣。萬物皆有氣，氣分八象。',
            nextScene: 12
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '在學習收集萬物之氣之前，你需要先理解八卦的奧秘。八卦是古人觀察天地萬物而創造的符號體系。看這些符號，實線代表陽，虛線代表陰。',
            nextScene: 13
          },
          {
            type: 'bagua-theory-explanation',
            text: '太極生兩儀，兩儀生四象，四象生八卦。讓我為你演示這個宇宙生成的過程...',
            nextScene: 14
          },
          {
            type: 'bagua-symbols-demonstration',
            text: '現在讓我們來認識八卦符號與其對應的自然元素。每個符號都有其深刻的含義...',
            nextScene: 15
          },
          {
            type: 'bagua-learning-challenge',
            text: '氣之源起：萬物皆有氣，氣分八象。現在測試你對八卦的理解，將符號與對應元素配對。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你已明瞭八氣之象。現在以萬物之眼，尋找散落各處的氣，為救渾沌做準備。',
            nextScene: 17
          },
          {
            type: 'wanwu-xunqi-guide',
            text: '萬物尋氣：以萬物之眼，尋找散落各處的氣。按照你的旅程順序，依次進入每個物化視野收集氣。',
            sequence: ['butterfly', 'fish', 'kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star'],
            nextScene: 18,
            showSkipButton: true // 開發測試標記：顯示跳過按鈕
          },
          {
            type: 'form-unlock-guide',
            text: '萬物之氣已聚於你身，你獲得了「氣」的物化能力！氣是萬物之本，超越一切具象形體。現在你可以化身為氣，體驗純粹能量的流動。請點擊物化按鈕，選擇氣形態來感受這終極的物化體驗。',
            effect: 'unlockForm:qi',
            highlightForm: 'qi',
            nextScene: 19
          },
          {
            type: 'transformation-experience',
            formType: 'qi',
            text: '你化身為氣，身體變得半透明，如雲霧般飄逸。在這超越具象的狀態下，你感受到前所未有的自由。世界在你眼中徹底改變：所有色彩消退，只留下陰陽二氣的純粹對立與統一。每個生命都散發著獨特的氣息，你能感知到它們內在的能量流動。你體會到了「氣者，生之本也」——萬物皆由氣聚散而成，而你已經觸及了存在的根本奧秘。',
            nextScene: 20
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '感受到了嗎？氣是萬物的根本，你已經觸及了存在的本質。現在讓氣的力量自然流動，或許能喚醒渾沌...',
            nextScene: 21
          },
          {
            type: 'narrative',
            text: '隨著氣的力量流動，虛空殿中的混沌形體開始發出微弱的光芒。你收集的六個封印在右上角閃閃發光，似乎在呼應著什麼...',
            nextScene: 22
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看！六竅的封印正在發揮作用。混沌雖死，但封印的力量讓他有了復甦的可能。現在只差最後一竅...',
            nextScene: 23
          },
          {
            type: 'dialog',
            speaker: '儵',
            text: '這...這怎麼可能？我們為混沌開竅是想讓他更好地感受世界，但為什麼封印竅位反而能救他？',
            nextScene: 24
          },
          {
            type: 'dialog',
            speaker: '忽',
            text: '儵，我想我明白了...混沌本來就是完美的。我們以為無竅是缺陷，實際上那才是他的本性。我們的『善意』反而害了他...',
            nextScene: 25
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '正是如此。自然無需人為的『改進』。現在我們要封印最後的口竅，讓混沌徹底回歸無竅的完美狀態。這不是剝奪，而是還原。',
            nextScene: 26
          },
          {
            type: 'narrative',
            text: '一道光芒從混沌身上升起，最後的口竅封印出現了！',
            effect: 'collectAperture:mouth',
            nextScene: 27
          },
          {
            type: 'narrative',
            text: '隨著最後一個封印的收集，右上角的七竅指示器全部消失。虛空殿中突然安靜下來，混沌的形體開始有了規律的起伏...他在呼吸！',
            nextScene: 28
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看！混沌開始呼吸了。這是自然本身的生命節律。七竅已封，他正在回歸最初的純淨狀態。來，讓我們與自然同息。',
            nextScene: 29
          },
          {
            type: 'chaos-breathing-guide',
            text: '跟隨混沌的呼吸節奏...這是自然最原始的韻律，是天地間最古老的生命節拍...',
            nextScene: 30
          },
          {
            type: 'narrative',
            text: '隨著你與混沌呼吸的同步，一種前所未有的寧靜充滿了你的心靈。這是與自然完全融合的境界，你理解了什麼是真正的『天人合一』。',
            nextScene: 31
          },
          {
            type: 'narrative',
            text: '混沌完全甦醒了，但他沒有說話。無竅的形體散發著溫和的光芒，你能感受到他內心的平靜和感激。這就是『得意忘言』的境界。',
            nextScene: 32
          },
          {
            type: 'dialog',
            speaker: '儵',
            text: '莊子先生，我們已經封印了所有七竅，混沌也開始呼吸了，但是...為什麼他還是沒有真正復活？是不是我們還缺少了什麼？',
            nextScene: 33
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你問得好，儵。封印七竅只是讓混沌回歸了無竅的狀態，但要真正讓他復活...（莊子陷入沉思）讓我想想老子的智慧...',
            nextScene: 34
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '我想起了老子說過的話：「天下萬物生於有，有生於無。」還有「致虛極，守靜篤，萬物並作，吾以觀其復。」我們剛才通過呼吸調息，已經達到了虛極靜篤的境界...',
            nextScene: 35
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '我明白了！老子還說過：「道生一，一生二，二生三，三生萬物。」如果萬物是這樣產生的，那麼要復活混沌，我們就要反過來：讓萬物歸於三，三歸於二，二歸於一，一歸於道！',
            nextScene: 36
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '混沌本身就是「一」，就是道的化身。我們收集的萬物之氣，正是「三生萬物」中的萬物精華。現在，讓我們將這些氣反向注入混沌，讓萬物回歸本源！',
            nextScene: 37
          },
          {
            type: 'qi-infusion-ritual',
            text: '長按混沌形體，將萬物之氣注入其中...',
            nextScene: 38
          },
          {
            type: 'dao-revelation',
            text: '道的顯現...',
            nextScene: 39
          },
          {
            type: 'narrative',
            text: '萬物之氣注入混沌後，一切都回歸了本源。虛空殿消失了，八卦符號消失了，甚至你自己的形體也開始變得模糊...這時你突然意識到，這可能只是一個夢境。就在這個念頭閃過的瞬間，你猛然驚醒，發現自己正躺在一棵古老的大樹下，陽光透過樹葉灑在臉上，耳邊傳來鳥兒的啁啾聲...',
            nextScene: 'epilogue:0'
          }
        ]
      },
      
      epilogue: {
        title: '尾聲：逍遙遊',
        description: '無用有什麼用？',
        background: 'epilogue-scene',
        scenes: [
          // 序幕：夢蝶轉場（場景0）
          {
            type: 'blank-emergence',
            text: '到底是莊周夢見了蝴蝶，還是蝴蝶夢見了莊周？',
            nextScene: 1
          },
          // 第一幕：醒來與困惑（場景1-3）
          {
            type: 'photo-develop',
            text: '陽光透過樹葉灑在你的臉上。你慢慢睜開眼睛，發現自己躺在一棵巨大古樹的樹蔭下。這棵樹非常粗壯，需要好幾個人才能抱住，枝葉茂密如雲朵，靜靜地立在廣闊的原野上。微風輕拂，樹葉沙沙作響，像是在低聲細語。',
            nextScene: 2
          },
          {
            type: 'dialog',
            speaker: '你',
            text: '這裡是...那個廣闊的原野嗎？剛才經歷的一切，感覺既真實又像夢境。到底我是在夢中，還是夢在我心裡？',
            nextScene: 3
          },
          {
            type: 'narrative', 
            text: '你坐起身來，環顧四周。這棵古樹看起來很眼熟，樹皮古老粗糙，刻滿了歲月的痕跡。遠處是一望無際的原野，天空高遠，白雲悠悠。這裡的一切都那麼安詳，彷彿不屬於人間。',
            nextScene: 4
          },
          // 第二幕：故人重現（場景4-9）
          {
            type: 'dialog',
            speaker: '蝴蝶',
            text: '你醒了。還是其實是我剛從你的夢中醒來？',
            nextScene: 5
          },
          {
            type: 'dialog',
            speaker: '魚',
            text: '沒有水，也能找到快樂的地方。這裡的樂趣，你現在應該明白了吧。',
            nextScene: 6
          },
          {
            type: 'narrative',
            text: '遠處的天空中，巨大的鯤鵬展開翅膀，影子遮住了雲朵。樹梢上，美麗的鵷鶵和夜行的鴟鴞各自棲息著，彼此相安無事。',
            nextScene: 7
          },
          {
            type: 'dialog',
            speaker: '蝸牛',
            text: '觸氏國和蠻氏國的戰爭，現在都成了過去的事情。在小小的蝸牛角上，再也沒有戰爭了。',
            nextScene: 8
          },
          {
            type: 'dialog',
            speaker: '朝菌',
            text: '朝生暮死的生物也有自己的快樂，活了幾千年的大樹也有自己的時光。生命的長短，真的有什麼區別嗎？',
            nextScene: 9
          },
          // 第三幕：哲人出現與教導（場景9-12）
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你來了。這棵樹叫做樗樹，工匠們都不要它，認為它沒用。正因為沒有用處，它才能活到天年。',
            nextScene: 10
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '人們總是擔心自己沒用，樹也是一樣。這棵樹做不了棟樑，也做不了器具，但它能為一方土地提供蔭涼，讓你我在這裡悠閒地遊玩。所謂的「有用」，到底在哪裡呢？',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '以前，我也曾經用這棵樹的道理，來開導我的朋友惠施。來聽聽，想想看。',
            nextScene: 12
          },
          // 第四幕：斷句挑戰（場景12）
          {
            type: 'segmentation-puzzle',
            text: '今子有大樹患其無用何不樹之於無何有之鄉廣莫之野徬徨乎無為其側逍遙乎寢臥其下不夭斤斧物無害者無所可用安所困苦哉',
            solution: [4, 8, 18, 22, 29, 36, 40, 44, 48],
            hint: '仔細看看這段文字，試著理解它的意思。這段話說的是關於「無用」的樹的道理。',
            success: '樗樹因為沒有用處，所以能夠逍遙自在。不被人利用，反而獲得了真正的自由。',
            nextScene: 13
          },
          // 第五幕：最終感悟與逍遙境界（場景13-18）
          {
            type: 'narrative',
            text: '突然間，你好像明白了什麼，所有的生物都出現了。蝴蝶落在你的肩膀上，魚兒在空中游泳，鳥兒在枝頭歌唱...所有的生靈都圍繞著你，一切都顯得那麼祥和。這一刻，你的心裡沒有任何牽掛。',
            nextScene: 14
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '萬物都有自己的生活方式，各自走著自己的道路。蝴蝶飛舞，魚兒快樂，樹木安靜，這些都是逍遙自在的表現。為什麼一定要選擇其中一種呢？你就是萬物，萬物也就是你。',
            nextScene: 15
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '蝴蝶飛舞，魚兒快樂，鳥兒歌唱，蝸牛慢行，朝菌朝生夕死，大椿活了千年...這些你都經歷過了。這棵樗樹因為沒用而活到天年，你我的相遇也是如此。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '真正逍遙的人，不需要等待什麼。不用等夢，不用等醒，不用等什麼理想的地方。你現在的心境，就是那個自由自在的境界。',
            nextScene: 17
          },
          {
            type: 'narrative',
            text: '莊子的聲音漸漸遠去，就像風吹過樹梢一樣。樹影輕輕搖擺，若有若無。再也沒有言語，只有清風徐徐吹來，樹葉無聲地飄落。',
            nextScene: 18
          },
          {
            type: 'final-meditation',
            text: '微風從身邊吹過，你的心變得無比輕鬆。夢境和現實，已經沒有什麼區別了。你靠著大樹，看著雲朵來來去去，聽著風聲和鳥鳴。你的身體、你的心，都在這裡。在這個自由自在的地方，在這片廣闊的原野上，你終於得到了真正的逍遙。',
            nextScene: 19
          },
          // 遊戲結束（場景19）
          {
            type: 'credits',
            title: '萬物逍遙',
            credits: [
              '本故事基於書院中國古代經典初級課程第一單元',
              '',
              '開發者：',
              '張老師',
              'Google Gemini',
              'Anthropic Claude'
            ],
            nextScene: 'end'
          }
        ]
      }
    };
    
    // Event listeners
    // 移除舊的開始遊戲按鈕，改用章節卡片
    // startGameBtn.addEventListener('click', startGame);
    advanceBtn.addEventListener('click', advanceScene);
    
    // 初始化新功能
    initDevModeAccess();  // 開發者模式密碼保護
    generateChapterCards();  // 生成章節選擇卡片
    
    // 初始化開發者工具事件監聽器
    initDevTools();
    
    // Initialize AI control panel (development mode)
    if (window.location.search.includes('dev=true')) {
      createAIControlPanel();
    }
    

    

    

    
    // Add bird form button to formButtons
    const birdButton = document.getElementById('bird-form');
    if (birdButton) {
      formButtons.bird = birdButton;
    }
    
    // Add snail form button to formButtons
    const snailButton = document.getElementById('snail-form');
    if (snailButton) {
      formButtons.snail = snailButton;
    }
    
    // Make sure snail is included in the initial formButtons object
    if (!formButtons.snail) {
      formButtons.snail = document.getElementById('snail-form');
    }
    
    // Form transformation buttons
    for (const [form, button] of Object.entries(formButtons)) {
      if (button) { // Make sure button exists
        button.addEventListener('click', () => {
          // 檢查是否在萬物回響引導模式或萬物尋氣模式
          if ((gameState.formSequenceGuideActive || gameState.wanwuXunqiActive) && gameState.handleFormSequenceClick) {
            const handled = gameState.handleFormSequenceClick(form);
            if (handled) {
              return; // 如果被處理了，就不執行正常的物化邏輯
            }
          }
          
          // 正常的物化邏輯
          if (form === 'bird' && gameState.currentForm === 'bird') {
            // Bird form toggle removed - now using independent forms
          } else {
            transformTo(form);
          }
        });
      }
    }
    
    // 拖拽功能實現
    function makeDraggable(element, elementId) {
      let isDragging = false;
      let startX, startY;
      let currentX, currentY;
      
      // 鼠標/觸摸開始事件
      const startDrag = (e) => {
        isDragging = true;
        
        // 獲取初始位置
        if (e.type === 'mousedown') {
          startX = e.clientX;
          startY = e.clientY;
        } else if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }
        
        // 獲取元素當前位置
        const rect = element.getBoundingClientRect();
        currentX = rect.left;
        currentY = rect.top;
        
        // 改變樣式表示正在拖拽
        element.style.cursor = 'grabbing';
        element.style.zIndex = '1000';
        element.style.opacity = '0.8';
        
        // 添加全局事件監聽器
        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        
        // 防止默認行為
        e.preventDefault();
      };
      
      // 拖拽中事件
      const drag = (e) => {
        if (!isDragging) return;
        
        let clientX, clientY;
        
        if (e.type === 'mousemove') {
          clientX = e.clientX;
          clientY = e.clientY;
        } else if (e.type === 'touchmove') {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
          e.preventDefault(); // 防止頁面滾動
        }
        
        // 計算移動距離
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        
        // 更新元素位置
        const newX = currentX + deltaX;
        const newY = currentY + deltaY;
        
        // 使用transform來移動元素，這樣不會影響文檔流
        element.style.position = 'fixed';
        element.style.left = newX + 'px';
        element.style.top = newY + 'px';
        element.style.transform = 'none';
        
        // 調試信息已移除
      };
      
      // 拖拽結束事件
      const endDrag = () => {
        if (!isDragging) return;
        
        isDragging = false;
        
        // 恢復樣式
        element.style.cursor = 'pointer';
        element.style.zIndex = '11';
        element.style.opacity = '1';
        
        // 移除全局事件監聽器
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchend', endDrag);
        
        // 調試信息已移除
        
        console.log(`${elementId} 新位置:`, element.getBoundingClientRect());
      };
      
      // 添加事件監聽器到元素
      element.addEventListener('mousedown', startDrag);
      element.addEventListener('touchstart', startDrag, { passive: false });
      
      // 防止點擊事件與拖拽衝突
      element.addEventListener('click', (e) => {
        // 如果剛剛完成拖拽，阻止點擊事件
        if (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5) {
          e.stopPropagation();
        }
      });
    }

    // Game functions
    function startGame() {
      mainMenu.style.opacity = 0;
      setTimeout(() => {
        mainMenu.style.display = 'none';
        aperturesTracker.style.opacity = 1;
        gameUI.style.opacity = 1;
        gameContent.style.opacity = 1;
        document.getElementById('current-form-indicator').style.opacity = 1; // Show form indicator
        
        // Start the prologue
        startChapter('prologue');
      }, 500);
    }

    // 初始化音效開關
    function initAudioControls() {
      const audioToggle = document.getElementById('audio-toggle');
      if (audioToggle) {
        // 設置初始狀態
        audioToggle.checked = gameState.audioEnabled;
        updateAudioVisualState(gameState.audioEnabled);
        
        // 添加事件監聽器
        audioToggle.addEventListener('change', (e) => {
          gameState.audioEnabled = e.target.checked;
          audioManager.setAudioEnabled(e.target.checked);
          
          // 更新視覺狀態
          updateAudioVisualState(e.target.checked);
          
          // 如果在第三章且音效開啟，立即播放背景音樂
          if (e.target.checked && gameState.currentChapter === 'chapter3') {
            audioManager.playBackgroundMusic('https://chineseclassics.github.io/files/audio/zhuangzi/forestbirds.mp3', true, 'chapter3');
          }
        });
      }
    }

    // 更新音效視覺狀態
    function updateAudioVisualState(isEnabled) {
      const audioIcon = document.getElementById('audio-icon');
      const audioStatus = document.getElementById('audio-status');
      const audioContainer = document.querySelector('.audio-control-container');
      
      if (audioIcon && audioStatus) {
        if (isEnabled) {
          // 音效開啟狀態
          audioIcon.textContent = '🎵';
          audioStatus.textContent = '開啟';
          audioStatus.className = 'text-xs text-indigo-600 dark:text-indigo-400 min-w-[28px]';
          document.body.classList.add('audio-enabled');
        } else {
          // 音效關閉狀態  
          audioIcon.textContent = '🔇';
          audioStatus.textContent = '關閉';
          audioStatus.className = 'text-xs text-gray-500 dark:text-gray-400 min-w-[28px]';
          document.body.classList.remove('audio-enabled');
        }
      }
    }

    // 處理章節音頻切換
    function handleChapterAudioTransition(chapterId) {
      if (!gameState.audioEnabled) return;

      // 章節背景音樂配置
      const chapterMusic = {
        'prologue': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter0.mp3',
        'chapter1': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter1.mp3',
        'chapter2': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter2.mp3',
        'chapter3': 'https://chineseclassics.github.io/files/audio/zhuangzi/forestbirds.mp3',
        'chapter4': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter4.mp3',
        'chapter5': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter5.mp3',
        'chapter6': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter6.mp3',
        'chapter7': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter7.mp3',
        'epilogue': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter8.mp3'
        // 未來可以在這裡添加其他章節的背景音樂
      };

      // 如果當前章節有背景音樂
      if (chapterMusic[chapterId]) {
        // 延遲播放，讓章節切換動畫先完成
        setTimeout(() => {
          audioManager.playBackgroundMusic(chapterMusic[chapterId], true, chapterId);
        }, 2500); // 章節標題顯示2秒後開始播放
      } else {
        // 如果切換到沒有背景音樂的章節，停止當前音樂
        if (audioManager.currentChapterMusic) {
          audioManager.stopBackgroundMusic(true);
        }
      }
    }
    
    // 視角縮放相關函數和變數
    let scaleControllerActive = false;
    let currentScaleValue = 50; // 中間值，範圍0-100
    
    // 創建視角縮放控制器
    function createScaleController() {
      // 如果已存在就不重複創建
      if (document.querySelector('.scale-controller')) {
        return;
      }
      
      // 創建控制器容器
      const controller = document.createElement('div');
      controller.className = 'scale-controller';
      controller.id = 'scale-controller';
      
      // 創建標題
      const macroLabel = document.createElement('div');
      macroLabel.className = 'scale-label macro';
      macroLabel.textContent = '宏觀';
      controller.appendChild(macroLabel);
      
      // 創建控制軌道
      const track = document.createElement('div');
      track.className = 'scale-track';
      
      // 創建滑塊
      const handle = document.createElement('div');
      handle.className = 'scale-handle';
      handle.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12"><path fill="white" d="M7 14l5-5 5 5z"></path></svg>';
      track.appendChild(handle);
      
      // 創建微觀標籤
      const microLabel = document.createElement('div');
      microLabel.className = 'scale-label micro';
      microLabel.textContent = '微觀';
      
      // 創建數值顯示
      const scaleValue = document.createElement('div');
      scaleValue.className = 'scale-value';
      scaleValue.id = 'scale-value';
      scaleValue.textContent = '100%';
      
      // 組合元素
      controller.appendChild(track);
      controller.appendChild(microLabel);
      controller.appendChild(scaleValue);
      
      // 添加到頁面
      document.body.appendChild(controller);
      
      // 設置初始位置（正常比例）
      updateScaleHandlePosition(50);
      
      // 添加拖動事件
      enableDragFunctionality(handle, track);
      
      // 添加軌道點擊事件
      track.addEventListener('click', (e) => {
        // 忽略手柄本身的點擊
        if (e.target === handle) return;
        
        const rect = track.getBoundingClientRect();
        const clickY = e.clientY - rect.top;
        const percentage = 100 - (clickY / rect.height * 100);
        
        updateScale(percentage);
      });
      
      return controller;
    }
    
    // 更新比例手柄的位置
    function updateScaleHandlePosition(percentage) {
      const handle = document.querySelector('.scale-handle');
      const track = document.querySelector('.scale-track');
      
      if (handle && track) {
        // 更新手柄位置 (上方是宏觀，下方是微觀)
        const position = 100 - percentage; // 反轉百分比
        handle.style.top = `${position}%`;
        
        // 更新數值顯示
        const scaleValue = document.getElementById('scale-value');
        if (scaleValue) {
          // 將50%映射為100%（正常比例）
          const displayValue = Math.round((percentage - 50) * 2 + 100);
          scaleValue.textContent = `${displayValue}%`;
          
          // 顯示數值
          scaleValue.classList.add('visible');
          
          // 2秒後隱藏
          clearTimeout(window.scaleValueTimeout);
          window.scaleValueTimeout = setTimeout(() => {
            scaleValue.classList.remove('visible');
          }, 2000);
        }
      }
    }
    
    // 啟用拖動功能
    function enableDragFunctionality(handle, track) {
      let isDragging = false;
      
      // 鼠標/觸摸開始事件
      const startDrag = (e) => {
        isDragging = true;
        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        
        // 防止頁面滾動
        e.preventDefault();
      };
      
      // 鼠標/觸摸移動事件
      const drag = (e) => {
        if (!isDragging) return;
        
        const rect = track.getBoundingClientRect();
        let clientY;
        
        if (e.type === 'touchmove') {
          clientY = e.touches[0].clientY;
          // 防止頁面滾動
          e.preventDefault();
        } else {
          clientY = e.clientY;
        }
        
        // 計算相對於軌道的位置
        let posY = clientY - rect.top;
        
        // 限制在軌道範圍內
        posY = Math.max(0, Math.min(posY, rect.height));
        
        // 轉換為百分比 (0-100)
        const percentage = 100 - (posY / rect.height * 100);
        
        // 更新比例
        updateScale(percentage);
      };
      
      // 鼠標/觸摸結束事件
      const endDrag = () => {
        isDragging = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchend', endDrag);
      };
      
      // 添加事件監聽器
      handle.addEventListener('mousedown', startDrag);
      handle.addEventListener('touchstart', startDrag, { passive: false });
    }
    
    // 更新比例並應用到場景
    function updateScale(percentage) {
      // 將百分比限制在0-100之間
      percentage = Math.max(0, Math.min(100, percentage));
      
      // 更新當前值
      currentScaleValue = percentage;
      
      // 更新手柄位置
      updateScaleHandlePosition(percentage);
      
      // 更新視覺效果
      applyScaleEffect(percentage);
      
      // 檢查是否需要移除視角控制器的發光效果（蝸角之爭章節）
      if (gameState.currentChapter === 'chapter4' && percentage < 30) {
        removeScaleControllerHighlight();
      }
      
      // 如果有需要，通知教程系統已經改變了視角
      if (gameState.currentChapter === 'chapter4') {
        // 檢查是否發生了比例變化
        if (Math.abs(gameState.viewScale - percentage) > 10) {
          // 更新遊戲狀態
          gameState.viewScale = percentage;
          
          // 觸發 scale:change 事件
          document.dispatchEvent(new CustomEvent('scaleChange', { detail: { value: percentage } }));
          
          // 如果是宏觀視角 (>75)，觸發 scale:macro 事件
          if (percentage > 75) {
            document.dispatchEvent(new CustomEvent('scaleMacro'));
          }
        }
      }
    }
    
    // 應用視覺縮放效果
    function applyScaleEffect(percentage) {
      // 獲取需要縮放的元素
      const snailShell = document.querySelector('.snail-shell');
      const leftKingdom = document.querySelector('.kingdom-circle#touch-kingdom-circle');
      const rightKingdom = document.querySelector('.kingdom-circle#savage-kingdom-circle');
      const indicator = document.getElementById('snail-perspective-indicator');
      
      if (!snailShell) return;
      
      // 將百分比轉換為縮放比例 (0% -> 5x, 50% -> 1x, 100% -> 0.2x)
      let snailScale;
      
      if (percentage < 50) {
        // 微觀區域 (放大)
        const factor = 1 + (50 - percentage) / 10; // 50% -> 1x, 0% -> 6x
        snailScale = factor;
      } else {
        // 宏觀區域 (縮小)
        const factor = 1 - (percentage - 50) / 70; // 50% -> 1x, 100% -> 0.3x
        snailScale = factor;
      }
      
      // 完全重新設計的縮放中心點策略
      
      // 首先定義蝸牛SVG中眼睛的精確座標
      // 根據SVG檢查，左眼在(30,30)，右眼在(85,30)
      const leftEyeX = 30;
      const leftEyeY = 30;
      const rightEyeX = 85;
      const rightEyeY = 30;
      
      // 計算兩眼的中心點
      const eyesCenterX = (leftEyeX + rightEyeX) / 2; // = 57.5
      const eyesCenterY = (leftEyeY + rightEyeY) / 2; // = 30
      
      // SVG的中心點（根據viewBox="0 0 180 140"）
      const svgCenterX = 180 / 2; // = 90
      const svgCenterY = 140 / 2; // = 70
      
      // 當縮放級別在正常(50)和完全微觀(0)之間時，我們需要逐漸將縮放中心從SVG中心移至眼睛中心
      
      // 計算需要的偏移比例，範圍從0（正常視圖）到1（完全微觀）
      let focusStrength = 0;
      if (percentage < 50) {
        // 在0-50範圍內線性映射到0-1
        focusStrength = (50 - percentage) / 50;
        
        // 使用平方函數讓過渡更平滑
        focusStrength = Math.pow(focusStrength, 1.5);
      }
      
      // 計算眼睛中心點與SVG中心點的差異（這是我們需要補償的偏移量）
      const offsetX = eyesCenterX - svgCenterX; // = 57.5 - 90 = -32.5
      const offsetY = eyesCenterY - svgCenterY; // = 30 - 70 = -40
      
      // 計算縮放後應用的實際偏移量
      // 當focusStrength = 1時，我們完全移動到眼睛中心
      // 當focusStrength = 0時，我們保持在SVG中心
      const appliedOffsetX = offsetX * focusStrength;
      const appliedOffsetY = offsetY * focusStrength;
      
      // 計算實際的縮放中心，基於SVG大小和當前的偏移量
      // 這裡需要將偏移量轉換為百分比形式
      const zoomCenterX = 50 + (appliedOffsetX / 180) * 100;
      const zoomCenterY = 50 + (appliedOffsetY / 140) * 100;
      
      // 直接從縮放中心應用transform，確保位置和縮放正確
      // 使用transform-origin設置縮放中心點
      snailShell.style.transformOrigin = `${zoomCenterX}% ${zoomCenterY}%`;
      snailShell.style.transform = `translate(-50%, -50%) scale(${snailScale})`;
      
      // 更新提示文字
      if (indicator) {
        // 根據視角顯示不同的提示
        if (percentage < 30) {
          indicator.innerHTML = `
            <div class="text-center">
              <div class="font-bold text-2xl mb-2">微觀視角</div>
              <div class="text-sm opacity-75">你看到了蝸牛眼睛上的國家和居民</div>
            </div>
          `;
          indicator.style.opacity = '1';
        } else if (percentage > 70) {
          indicator.innerHTML = `
            <div class="text-center">
              <div class="font-bold text-2xl mb-2">宏觀視角</div>
              <div class="text-sm opacity-75">只是一個蝸牛而已</div>
            </div>
          `;
          indicator.style.opacity = '1';
        } else {
          indicator.style.opacity = '0';
        }
      }
      
      // 更新國家圓形的可見性，根據縮放程度顯示或隱藏
      if (leftKingdom && rightKingdom) {
        if (percentage < 40) {
          // 微觀視角下顯示國家
          leftKingdom.style.opacity = (40 - percentage) / 40;
          rightKingdom.style.opacity = (40 - percentage) / 40;
          leftKingdom.style.pointerEvents = 'auto';
          rightKingdom.style.pointerEvents = 'auto';
        } else {
          // 宏觀視角下隱藏國家
          leftKingdom.style.opacity = '0';
          rightKingdom.style.opacity = '0';
          leftKingdom.style.pointerEvents = 'none';
          rightKingdom.style.pointerEvents = 'none';
        }
      }
    }
    
    // 啟用視角縮放功能
    function enableScaleControl() {
      // 檢查是否已經啟用，避免重複創建
      if (gameState.scaleEnabled) {
        return;
      }
      
      // 創建或顯示縮放控制器
      const controller = document.getElementById('scale-controller') || createScaleController();
      controller.classList.add('active');
      scaleControllerActive = true;
      gameState.scaleEnabled = true;
      
      // 初始設置比例為正常 (50%)
      updateScale(50);
    }
    
    // 禁用視角縮放功能
    function disableScaleControl() {
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.classList.remove('active');
        // 同時移除發光效果
        controller.classList.remove('highlight');
      }
      scaleControllerActive = false;
    }
    
    // 為視角控制器添加發光提示效果
    function highlightScaleController() {
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.classList.add('highlight');
        console.log('🌟 視角控制器發光效果已啟用');
      }
    }
    
    // 移除視角控制器的發光提示效果
    function removeScaleControllerHighlight() {
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.classList.remove('highlight');
        console.log('🌟 視角控制器發光效果已移除');
      }
    }
    
    // 章節過渡函數 - 組合方案實現
    function transitionToChapter(chapterId) {
      console.log('🎬 開始章節過渡到:', chapterId);
      
      // 特殊處理：第七章到尾聲章節的白色連續過渡
      if (gameState.currentChapter === 'chapter7' && chapterId === 'epilogue') {
        console.log('🌅 檢測到第七章到尾聲章節的特殊過渡');
        transitionFromChapter7ToEpilogue();
        return;
      }
      
      // 標準過渡流程
      // 階段1：結束過渡 (1.5秒)
      createChapterTransitionOverlay();
      
      setTimeout(() => {
        // 階段2：標題出現 (2-3秒)
        showChapterTitle(chapterId);
        
        setTimeout(() => {
          // 階段3：場景轉換 (1.5秒)
          // 等待打字機效果完成：標題(200ms/字) + 描述間隔(500ms) + 描述(180ms/字) + 緩衝(1000ms)
          startChapter(chapterId);
          removeChapterTransitionOverlay();
          
          // 保存進度
          saveGameProgress();
        }, 4500); // 從2500ms增加到4500ms，確保打字機效果完成
      }, 1500);
    }
    
    // 第七章到尾聲章節的特殊白色過渡
    function transitionFromChapter7ToEpilogue() {
      console.log('🌅 開始第七章到尾聲的特殊白色過渡');
      
      // 創建白色過渡覆蓋層
      const whiteOverlay = document.createElement('div');
      whiteOverlay.id = 'white-transition-overlay';
      whiteOverlay.className = 'fixed inset-0 pointer-events-none';
      whiteOverlay.style.cssText = `
        background: linear-gradient(135deg, 
          rgba(255, 255, 255, 0.8) 0%, 
          rgba(250, 250, 250, 0.95) 50%, 
          rgba(255, 255, 255, 1) 100%
        );
        z-index: 9999;
        opacity: 0;
        transition: opacity 2s ease-in-out;
        animation: white-transition-fade 2s ease-in-out forwards;
      `;
      
      document.body.appendChild(whiteOverlay);
      
      // 觸發白色覆蓋層淡入
      setTimeout(() => {
        whiteOverlay.style.opacity = '1';
      }, 50);
      
      setTimeout(() => {
        // 顯示尾聲章節標題（在白色背景上）
        showEpilogueTitle();
        
        setTimeout(() => {
          // 開始尾聲章節（在白色覆蓋層存在的情況下）
          console.log('🌅 在白色覆渡層存在時開始尾聲章節');
          startChapter('epilogue');
          
          // 在尾聲章節開始後，逐漸移除白色覆蓋層
          setTimeout(() => {
            whiteOverlay.style.opacity = '0';
            
            setTimeout(() => {
              if (whiteOverlay && whiteOverlay.parentNode) {
                whiteOverlay.remove();
              }
              
              // 強制檢查確保沒有殘留的覆蓋層
              const remainingOverlay = document.getElementById('white-transition-overlay');
              if (remainingOverlay) {
                remainingOverlay.remove();
              }
              
              console.log('🌅 白色過渡層已完全移除，尾聲章節正常運行');
            }, 500);
          }, 4000); // 尾聲章節開始後4秒開始移除覆蓋層，給標題更多顯示時間
        }, 7000); // 延長到7秒，讓標題有更充分的顯示時間
      }, 2000);
    }
    
    // 尾聲章節標題顯示（白色背景版本）
    function showEpilogueTitle() {
      const chapter = gameChapters['epilogue'];
      if (!chapter) return;
      
      const whiteOverlay = document.getElementById('white-transition-overlay');
      if (!whiteOverlay) return;
      
      // 創建標題容器
      const titleContainer = document.createElement('div');
      titleContainer.className = 'absolute inset-0 flex flex-col items-center justify-center text-center';
      titleContainer.style.zIndex = '10000';
      
      // 章節標題（黑色文字，適合白色背景）
      const title = document.createElement('h1');
      title.className = 'chapter-title-text text-black mb-4';
      title.style.cssText = `
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        animation: epilogue-title-emerge 1.5s ease-out forwards;
        opacity: 0;
        color: #1a1a1a;
      `;
      titleContainer.appendChild(title);
      
      // 章節描述（深灰色文字）
      const description = document.createElement('p');
      description.className = 'text-xl md:text-2xl text-gray-700 max-w-2xl px-4';
      description.style.cssText = `
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        animation: epilogue-title-emerge 1.5s ease-out 0.8s forwards;
        opacity: 0;
        color: #4a4a4a;
      `;
      titleContainer.appendChild(description);
      
      whiteOverlay.appendChild(titleContainer);
      
      // 標題打字機效果
      typeWriterEffect(title, chapter.title, 150, () => {
        // 標題完成後，開始描述打字機效果
        setTimeout(() => {
          typeWriterEffect(description, chapter.description, 120);
        }, 500);
      });
    }

    // 創建章節過渡覆蓋層
    function createChapterTransitionOverlay() {
      const overlay = document.createElement('div');
      overlay.id = 'chapter-transition-overlay';
      overlay.className = 'fixed inset-0 pointer-events-none';
      overlay.style.cssText = `
        background: linear-gradient(135deg, 
          rgba(0, 0, 0, 0.8) 0%, 
          rgba(30, 30, 30, 0.9) 50%, 
          rgba(0, 0, 0, 0.8) 100%
        );
        z-index: 9999;
        opacity: 0;
        transition: opacity 1.5s ease-in-out;
        backdrop-filter: blur(10px);
      `;
      
      document.body.appendChild(overlay);
      
      // 觸發淡入動畫
      setTimeout(() => {
        overlay.style.opacity = '1';
      }, 50);
    }
    
    // 顯示章節標題（打字機效果）
    function showChapterTitle(chapterId) {
      const chapter = gameChapters[chapterId];
      if (!chapter) return;
      
      const overlay = document.getElementById('chapter-transition-overlay');
      if (!overlay) return;
      
      // 創建標題容器
      const titleContainer = document.createElement('div');
      titleContainer.className = 'absolute inset-0 flex flex-col items-center justify-center text-center';
      titleContainer.style.zIndex = '10000';
      
      // 章節標題
      const title = document.createElement('h1');
      title.className = 'chapter-title-text text-white mb-4';
      title.style.cssText = `
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        animation: chapter-title-emerge 1s ease-out forwards;
        opacity: 0;
      `;
      titleContainer.appendChild(title);
      
      // 章節描述
      const description = document.createElement('p');
      description.className = 'text-xl md:text-2xl text-gray-300 max-w-2xl px-4';
      description.style.cssText = `
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        animation: chapter-title-emerge 1s ease-out 0.5s forwards;
        opacity: 0;
      `;
      titleContainer.appendChild(description);
      
      overlay.appendChild(titleContainer);
      
      // 播放打字機效果音效（如果音效開啟）
      if (gameState.audioEnabled) {
        // 這裡可以添加打字機音效
        console.log('🔊 播放章節過渡音效');
      }
      
      // 標題打字機效果
      typeWriterEffect(title, chapter.title, 200, () => {
        // 標題完成後，開始描述打字機效果
        setTimeout(() => {
          typeWriterEffect(description, chapter.description, 180);
        }, 500);
      });
    }
    
    // 移除章節過渡覆蓋層
    function removeChapterTransitionOverlay() {
      const overlay = document.getElementById('chapter-transition-overlay');
      if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.remove();
        }, 1500);
      }
    }
    
    // 打字機效果函數
    function typeWriterEffect(element, text, speed = 100, callback = null) {
      element.textContent = '';
      let i = 0;
      
      const typeInterval = setInterval(() => {
        if (i < text.length) {
          element.textContent += text.charAt(i);
          i++;
          
          // 播放打字音效（如果音效開啟）
          if (gameState.audioEnabled && i % 3 === 0) {
            // 這裡可以添加打字音效
            console.log('🔊 打字音效');
          }
        } else {
          clearInterval(typeInterval);
          if (callback) callback();
        }
      }, speed);
    }

    function startChapter(chapterId) {
      console.log('🚀 startChapter 被調用，章節ID:', chapterId);
      gameState.currentChapter = chapterId;
      gameState.currentScene = 0;
      
      // 初始化場景停留時間記錄
      gameState.playerChoices.sceneDwellTime.currentSceneStartTime = Date.now();
      
      console.log('🚀 設置遊戲狀態:', {
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene
      });
      
      // 只在非跳轉情況下自動保存遊戲進度
      // 章節跳轉時的進度保存由transitionToChapter處理
      if (!document.getElementById('chapter-transition-overlay') && !document.getElementById('white-transition-overlay')) {
        saveGameProgress();
      }
      
      // 更新章節卡片（如果主菜單可見）
      if (document.getElementById('main-menu').style.display !== 'none') {
        generateChapterCards();
      }
      
      // 確保在章節開始時恢復日常物化按鈕顯示
      showFormButtons();
      
      const chapter = gameChapters[chapterId];
      
      // 確保章節開始時玩家為人形狀態（除非在日常物化中）
      if (!gameState.isInDailyTransformation) {
        if (gameState.currentForm !== 'human') {
          gameState.currentForm = 'human';
          updateFormView('human');
        }
          
        // 更新底部按鈕狀態 - 首先確保所有解鎖的按鈕都可見
          Object.values(formButtons).forEach(button => {
            if (button) {
              button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
              button.classList.add('bg-gray-500');
            }
          });
        
        // 顯示所有已解鎖的形態按鈕
        console.log('📋 當前已解鎖的形態:', gameState.unlockedForms);
        gameState.unlockedForms.forEach(form => {
          if (formButtons[form]) {
            formButtons[form].classList.remove('hidden');
            formButtons[form].style.visibility = 'visible';
            console.log(`📋 顯示已解鎖形態按鈕: ${form}`);
          } else {
            console.log(`❌ 形態按鈕不存在: ${form}`);
            }
          });
          
          if (formButtons['human']) {
            formButtons['human'].classList.remove('bg-gray-500');
            formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }
      }
      
      // 檢查是否在過渡效果中，如果是則跳過原始標題顯示
      const isInTransition = document.getElementById('chapter-transition-overlay') || document.getElementById('white-transition-overlay');
      
      if (!isInTransition) {
        // Show chapter title (只在非過渡模式下顯示)
        chapterName.textContent = chapter.title;
        chapterDescription.textContent = chapter.description;
        
        // 為尾聲章節設置特殊的空白背景和隱藏UI
        if (chapterId === 'epilogue') {
          chapterTitle.style.background = '#ffffff';
          chapterTitle.classList.remove('bg-black', 'bg-opacity-80');
          // 修改文字顏色為黑色，以便在白色背景上顯示
          chapterName.style.color = '#000000';
          chapterDescription.style.color = '#333333';
          // 隱藏所有UI元素
          gameUI.style.opacity = 0;
          
          // 隱藏左上角當前形態指示器
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 0;
          }
          
          // 隱藏右上角七竅追蹤器
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 0;
          }
        } else {
          chapterTitle.style.background = '';
          chapterTitle.classList.add('bg-black', 'bg-opacity-80');
          // 恢復原始文字顏色
          chapterName.style.color = '';
          chapterDescription.style.color = '';
          // 顯示所有UI元素
          gameUI.style.opacity = 1;
          
          // 恢復左上角當前形態指示器
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 1;
          }
          
          // 恢復右上角七竅追蹤器
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 1;
          }
        }
        
        chapterTitle.style.opacity = 1;
        chapterTitle.style.pointerEvents = 'auto';
      } else {
        // 在過渡模式下，設置UI狀態但不顯示標題
        if (chapterId === 'epilogue') {
          console.log('🌅 尾聲章節在白色過渡模式下，隱藏所有UI並設置白色背景');
          gameUI.style.opacity = 0;
          
          // 隱藏左上角當前形態指示器
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 0;
          }
          
          // 隱藏右上角七竅追蹤器
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 0;
          }
          
          // 確保gameContainer和gameContent在白色過渡層下正確顯示
          gameContainer.style.background = '#ffffff';
          gameContent.style.background = '#ffffff';
          
          // 清理白色過渡層中的標題元素，讓尾聲章節內容能夠顯示
          const whiteOverlay = document.getElementById('white-transition-overlay');
          if (whiteOverlay) {
            const titleContainer = whiteOverlay.querySelector('.absolute.inset-0.flex.flex-col');
            if (titleContainer) {
              titleContainer.remove();
              console.log('🌅 已清理白色過渡層中的尾聲標題');
            }
          }
        } else {
          gameUI.style.opacity = 1;
          
          // 恢復其他章節的UI顯示
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 1;
          }
          
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 1;
          }
        }
      }
      
      // Clean up previous chapter elements
      cleanupChapterEffects();
      
      // Set background (尾聲章節跳過背景設置，保持白色)
      gameContainer.classList.remove('dream-scene', 'water-scene', 'cloud-scene', 'forest-scene', 'spiral-scene', 'time-scene', 'heaven-earth-scene', 'void-scene', 'epilogue-scene');
      if (chapterId !== 'epilogue') {
      gameContainer.classList.add(chapter.background);
      } else {
        // 尾聲章節保持白色背景
        gameContainer.style.background = '#ffffff';
      }
      
      // 調試信息：特別針對尾聲章節
      if (chapterId === 'epilogue') {
        console.log('🌅 尾聲章節調試信息:');
        console.log('- 章節背景配置:', chapter.background);
        console.log('- gameContainer類列表:', gameContainer.classList.toString());
        console.log('- gameContainer內聯樣式background:', gameContainer.style.background);
        console.log('- 計算後的背景樣式:', window.getComputedStyle(gameContainer).backgroundImage);
        
        // 強制確保背景設置
        setTimeout(() => {
          console.log('🌅 延遲檢查尾聲章節背景:');
          console.log('- gameContainer類列表:', gameContainer.classList.toString());
          console.log('- gameContainer內聯樣式background:', gameContainer.style.background);
          console.log('- 計算後的背景樣式:', window.getComputedStyle(gameContainer).backgroundImage);
        }, 100);
      }
      
      // Add chapter-specific effects
      if (chapter.background === 'dream-scene') {
        createDreamEffects();
      } else if (chapter.background === 'water-scene') {
        createWaterEffects();
      } else if (chapter.background === 'cloud-scene') {
        createClouds();
      } else if (chapter.background === 'forest-scene') {
        createForestBackground();
      } else if (chapter.background === 'spiral-scene') {
        createSpiralBackground();
      } else if (chapter.background === 'void-scene') {
        createVoidScene();
      } else if (chapter.background === 'epilogue-scene') {
        // 尾聲章節的動畫效果
        console.log('🌅 開始創建尾聲章節動畫效果');
        createEpilogueEffects();
      } else if (chapterId === 'chapter5') {
        // 创建时间森林背景效果
        createTimeEffectScene({
          text: '你来到了一片神奇的时间森林，这里居住着不同的生灵，它们对时间的感知截然不同。',
          type: 'time-effect'
        });
      }

      // 處理章節音頻切換
      handleChapterAudioTransition(chapterId);
      
      if (!isInTransition) {
        // 非過渡模式：顯示原始標題並延遲加載
        setTimeout(() => {
          chapterTitle.style.opacity = 0;
          chapterTitle.style.pointerEvents = 'none';
          
          setTimeout(() => {
            loadScene();
          }, 1000);
        }, 2000);
      } else {
        // 過渡模式：立即加載場景
        loadScene();
      }
    }
    
    // Function to clean up chapter-specific elements
    function cleanupChapterEffects() {
      // Remove dream elements
      document.querySelectorAll('.dream-particles, .dream-particle, .dream-butterfly').forEach(el => el.remove());
      
      // Remove water elements
      document.querySelectorAll('.water-ripples, .water-ripple, .water-bubble, .water-fish').forEach(el => el.remove());
      
      // Remove cloud elements
      document.querySelectorAll('.background-cloud, .cloud-container').forEach(el => el.remove());
      
      // Remove forest elements
      document.querySelectorAll('.forest-background').forEach(el => {
        // 清理森林定時器
        if (el.leafInterval) {
          clearInterval(el.leafInterval);
        }
        // 清理Three.js場景
        if (el.threeCleanup) {
          el.threeCleanup();
        }
        el.remove();
      });
      document.querySelectorAll('.leaf-container, .tree, .tree-trunk, .tree-crown, .falling-leaf, .forest-light, .forest-sunlight, .wind-effects, .wind-particle, .three-forest-scene').forEach(el => el.remove());
      
      // Remove spiral elements
      document.querySelectorAll('.spiral-container, .spiral-effect, .spiral-particle').forEach(el => el.remove());
      
      // Remove time-scene (Chapter 5) elements
      document.querySelectorAll('.time-background-container').forEach(el => el.remove());
      document.querySelectorAll('.time-particle-global').forEach(el => el.remove());
      document.querySelectorAll('.time-amber-glow').forEach(el => el.remove());
      document.querySelectorAll('.dachun-tree-emoji').forEach(el => el.remove());
      document.querySelectorAll('.morning-fungus-emoji').forEach(el => el.remove());
      document.querySelectorAll('.flying-cicada').forEach(el => el.remove());
      // Remove time animations style element
      const timeAnimationsStyle = document.getElementById('time-animations');
      if (timeAnimationsStyle) {
        timeAnimationsStyle.remove();
      }
      
      // Remove underwater effects
      document.querySelectorAll('.underwater-overlay, .water-effect').forEach(el => el.remove());
      
      // Remove heaven-earth effects
      document.querySelectorAll('.heaven-earth-background-container').forEach(el => el.remove());
      
      // Remove heaven-earth celestial container (第六章天体容器)
      document.querySelectorAll('.heaven-earth-celestial-container').forEach(el => el.remove());
      
      // Remove earth elements
      document.querySelectorAll('.earth-elements-container').forEach(el => el.remove());
      
      // Remove space starfield
      document.querySelectorAll('.space-starfield').forEach(el => el.remove());
      
      // Remove individual space stars (in case some are not in containers)
      document.querySelectorAll('.space-star').forEach(el => el.remove());
      
      // Remove atmosphere particles
      document.querySelectorAll('.atmosphere-particles').forEach(el => el.remove());
      
      // Remove individual atmosphere particles (in case some are not in containers)
      document.querySelectorAll('.atmosphere-particle').forEach(el => el.remove());
      
      // Remove heaven-earth animations style element
      const heavenEarthAnimationsStyle = document.getElementById('heaven-earth-animations');
      if (heavenEarthAnimationsStyle) {
        heavenEarthAnimationsStyle.remove();
      }
      
      // Remove void scene elements
      document.querySelectorAll('.void-particles, .chaos-form, .taiji-container, .bagua-symbols').forEach(el => {
        // 清理八卦符號的定時器
        if (el.classList.contains('bagua-symbols') && el.baguaInterval) {
          clearInterval(el.baguaInterval);
        }
        el.remove();
      });
      
      // Remove epilogue scene effects
      document.querySelectorAll('.wisdom-particles, .ancient-leaves, .butterfly-dream-particles').forEach(el => el.remove());
      
      // 清理Three.js尾聲場景
      cleanupThreeJSEpilogueScene();
      
      // Remove floating ancient text
      document.querySelectorAll('.floating-ancient-text').forEach(el => el.remove());
      
      // 清理螻蟻視覺效果
      removeAntVisionEffect();
      
      // 重置第六章浮動文字禁用標記
      if (gameState.chapter6FloatingTextDisabled) {
        gameState.chapter6FloatingTextDisabled = false;
      }
      
      // Remove chapter6 floating puzzle containers
      document.querySelectorAll('body > .max-w-3xl').forEach(el => {
        if (el.style.position === 'fixed' && el.style.zIndex === '9999') {
          el.remove();
        }
      });
      
      // 清理視角縮放控制器及其提示文字
      const scaleController = document.getElementById('scale-controller');
      if (scaleController) {
        scaleController.remove();
      }
      const scaleIndicator = document.getElementById('snail-perspective-indicator');
      if (scaleIndicator) {
        scaleIndicator.remove();
      }
      // 重置視角縮放相關狀態
      gameState.scaleEnabled = false;
      gameState.viewScale = 100;
      scaleControllerActive = false;
      
      // Reset container styles that might have been modified by transformations
      gameContainer.style.transform = 'scale(1)';
      gameContainer.style.filter = 'none';
      gameContainer.style.background = '';
      
      // 移除物化覆蓋層
      removeTransformationOverlay();
      
      // Clear gameContent
      gameContent.innerHTML = '';
    }

    // 創建尾聲章節動態效果
    function createEpilogueEffects() {
      console.log('🌅 創建尾聲章節動態效果');
      
      // 創建Three.js增強的粒子系統
      createThreeJSEpilogueScene();
      
      // 創建傳統CSS粒子作為備用（低性能設備）
      if (!window.threeJSSupported) {
        // 創建智慧光點粒子容器
        const wisdomParticles = document.createElement('div');
        wisdomParticles.className = 'wisdom-particles';
        gameContainer.appendChild(wisdomParticles);
        
        // 創建飄落樹葉容器
        const ancientLeaves = document.createElement('div');
        ancientLeaves.className = 'ancient-leaves';
        gameContainer.appendChild(ancientLeaves);
        
        // 根據當前場景決定是否立即顯示粒子效果
        if (gameState.currentScene >= 2) {
          console.log('🌅 當前場景>=2，立即顯示粒子效果');
          // 生成智慧光點粒子
          createWisdomParticles(wisdomParticles);
          
          // 生成飄落樹葉
          createAncientLeaves(ancientLeaves);
        } else {
          console.log('🌅 當前場景<2，隱藏粒子效果');
          // 場景0和1時隱藏粒子效果
          wisdomParticles.style.display = 'none';
          ancientLeaves.style.display = 'none';
        }
        
        // 定期刷新粒子效果
        const particleInterval = setInterval(() => {
          if (gameState.currentChapter === 'epilogue') {
            // 只在場景2+時顯示粒子效果
            if (gameState.currentScene >= 2) {
              // 確保容器可見
              wisdomParticles.style.display = 'block';
              ancientLeaves.style.display = 'block';
              
              createWisdomParticles(wisdomParticles);
              createAncientLeaves(ancientLeaves);
            } else {
              // 隱藏粒子效果
              wisdomParticles.style.display = 'none';
              ancientLeaves.style.display = 'none';
            }
          } else {
            clearInterval(particleInterval);
          }
        }, 6000); // 每6秒刷新一次
      }
    }

    // Three.js尾聲章節場景系統
    let epilogueThreeScene = null;
    let epilogueRenderer = null;
    let epilogueCamera = null;
    let epilogueWisdomParticles = null;
    let epilogueAncientLeaves = [];
    let epilogueAnimationId = null;

    function createThreeJSEpilogueScene() {
      console.log('🌅 創建Three.js尾聲章節場景');
      
      try {
        // 創建場景
        epilogueThreeScene = new THREE.Scene();
        
        // 創建攝像機（正交攝像機保持2D效果）
        const aspect = window.innerWidth / window.innerHeight;
        epilogueCamera = new THREE.OrthographicCamera(
          -20 * aspect, 20 * aspect, 20, -20, 0.1, 1000
        );
        epilogueCamera.position.z = 10;
        
        // 創建渲染器
        epilogueRenderer = new THREE.WebGLRenderer({ 
          alpha: true, 
          antialias: true,
          powerPreference: "high-performance"
        });
        epilogueRenderer.setSize(window.innerWidth, window.innerHeight);
        epilogueRenderer.setClearColor(0x000000, 0); // 透明背景
        epilogueRenderer.domElement.style.position = 'absolute';
        epilogueRenderer.domElement.style.top = '0';
        epilogueRenderer.domElement.style.left = '0';
        epilogueRenderer.domElement.style.pointerEvents = 'none';
        epilogueRenderer.domElement.style.zIndex = '5';
        epilogueRenderer.domElement.id = 'epilogue-threejs-canvas';
        
        gameContainer.appendChild(epilogueRenderer.domElement);
        
        // 創建智慧光點粒子系統
        createThreeJSWisdomParticles();
        
        // 創建古樹葉片系統
        createThreeJSAncientLeaves();
        
        // 開始動畫循環
        animateEpilogueScene();
        
        // 響應式處理
        window.addEventListener('resize', onEpilogueWindowResize);
        
        window.threeJSSupported = true;
        console.log('🌅 Three.js尾聲場景創建成功');
        
      } catch (error) {
        console.error('🌅 Three.js初始化失敗，回退到CSS粒子:', error);
        window.threeJSSupported = false;
        cleanupThreeJSEpilogueScene();
      }
    }

    function createThreeJSWisdomParticles() {
      console.log('🌅 創建Three.js智慧光點粒子系統');
      
      const particleCount = 120;
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const phases = new Float32Array(particleCount);
      
      // 初始化粒子屬性
      for (let i = 0; i < particleCount; i++) {
        // 位置：從樹根區域開始，螺旋分佈（整體向右偏移）
        const angle = (i / particleCount) * Math.PI * 4; // 螺旋角度
        const radius = 2 + Math.random() * 8; // 螺旋半徑
        
        positions[i * 3] = Math.cos(angle) * radius + 6;     // x (向右偏移6個單位)
        positions[i * 3 + 1] = -15 - Math.random() * 10; // y (底部開始)
        positions[i * 3 + 2] = Math.sin(angle) * radius; // z
        
        // 速度：螺旋上升 + 隨機擾動（進一步減慢）
        velocities[i * 3] = Math.sin(angle) * 0.0015 + (Math.random() - 0.5) * 0.001;      // x螺旋（再減慢一半）
        velocities[i * 3 + 1] = 0.004 + Math.random() * 0.002; // y上升（再減慢一半）
        velocities[i * 3 + 2] = Math.cos(angle) * 0.0015 + (Math.random() - 0.5) * 0.001;  // z螺旋（再減慢一半）
        
        // 顏色：金色到白色的漸變
        const goldIntensity = 0.7 + Math.random() * 0.3;
        colors[i * 3] = 1.0;                               // r
        colors[i * 3 + 1] = 0.7 + goldIntensity * 0.3;    // g
        colors[i * 3 + 2] = goldIntensity * 0.2;          // b
        
        // 大小：動態變化（增大以顯示發光效果）
        sizes[i] = 3 + Math.random() * 4; // 增大基礎大小
        
        // 相位：用於閃爍效果
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      // 創建粒子幾何體
      const particleGeometry = new THREE.BufferGeometry();
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      // 創建圓形發光紋理
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      
      // 創建徑向漸變實現發光效果
      const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255, 215, 0, 1)');    // 中心：純金色
      gradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.8)'); // 內圈：半透明金色
      gradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.3)'); // 中圈：淡金色
      gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');     // 外圈：完全透明
      
      context.fillStyle = gradient;
      context.fillRect(0, 0, 64, 64);
      
      const texture = new THREE.CanvasTexture(canvas);
      
      // 創建粒子材質（圓形發光效果）
      const particleMaterial = new THREE.PointsMaterial({
        size: 6, // 增大尺寸以顯示發光效果
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 1.0, // 完全不透明，透明度由紋理控制
        blending: THREE.AdditiveBlending, // 加法混合產生強烈光暈
        map: texture, // 使用圓形發光紋理
        alphaTest: 0.01 // 去除完全透明的像素
      });
      
      // 創建粒子系統
      epilogueWisdomParticles = new THREE.Points(particleGeometry, particleMaterial);
      epilogueWisdomParticles.userData = {
        velocities: velocities,
        phases: phases,
        time: 0
      };
      
      epilogueThreeScene.add(epilogueWisdomParticles);
    }

    function createThreeJSAncientLeaves() {
      console.log('🌅 創建Three.js古樹葉片系統');
      
      // 使用ShapeGeometry創建真實葉片形狀
      const leafShape = new THREE.Shape();
      leafShape.moveTo(0, 0);
      leafShape.bezierCurveTo(0, 0.3, 0.3, 0.6, 0.6, 0.3);
      leafShape.bezierCurveTo(0.6, 0, 0.3, -0.3, 0, 0);
      
      const leafGeometry = new THREE.ShapeGeometry(leafShape);
      
      // 創建35片不同的葉子
      const leafCount = 35;
      epilogueAncientLeaves = [];
      
      for (let i = 0; i < leafCount; i++) {
        // 隨機葉子顏色
        const hue = 0.08 + Math.random() * 0.05; // 棕黃色調
        const saturation = 0.6 + Math.random() * 0.3;
        const lightness = 0.3 + Math.random() * 0.2;
        
        const leafMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(hue, saturation, lightness),
          transparent: true,
          opacity: 0.7 + Math.random() * 0.2,
          side: THREE.DoubleSide
        });
        
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        
        // 隨機初始位置（屏幕上方）
        leaf.position.set(
          (Math.random() - 0.5) * 40,  // x: 水平分佈
          20 + Math.random() * 10,     // y: 屏幕上方
          (Math.random() - 0.5) * 5    // z: 深度變化
        );
        
        // 隨機大小
        const scale = 0.8 + Math.random() * 0.6;
        leaf.scale.set(scale, scale, scale);
        
        // 隨機初始旋轉
        leaf.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        // 物理特性
        leaf.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.08,  // 水平風力
            -0.03 - Math.random() * 0.02,  // 下降速度
            (Math.random() - 0.5) * 0.03   // 深度飄移
          ),
          angularVelocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02
          ),
          windResistance: 0.98 + Math.random() * 0.02,
          swayAmplitude: 0.5 + Math.random() * 1.0,
          swayFrequency: 0.02 + Math.random() * 0.01,
          swayPhase: Math.random() * Math.PI * 2,
          resetTimer: 0
        };
        
        epilogueAncientLeaves.push(leaf);
        epilogueThreeScene.add(leaf);
      }
    }

    function animateEpilogueScene() {
      if (!epilogueThreeScene || !epilogueRenderer || !epilogueCamera) return;
      
      epilogueAnimationId = requestAnimationFrame(animateEpilogueScene);
      
      const time = Date.now() * 0.001;
      
      // 更新智慧光點粒子
      if (epilogueWisdomParticles) {
        updateWisdomParticles(time);
      }
      
      // 更新古樹葉片
      updateAncientLeaves(time);
      
      // 根據場景顯示/隱藏粒子效果
      const shouldShowParticles = gameState.currentScene >= 2;
      if (epilogueRenderer.domElement) {
        epilogueRenderer.domElement.style.display = shouldShowParticles ? 'block' : 'none';
      }
      
      // 渲染場景
      if (shouldShowParticles) {
        epilogueRenderer.render(epilogueThreeScene, epilogueCamera);
      }
    }

    function updateWisdomParticles(time) {
      if (!epilogueWisdomParticles) return;
      
      const positions = epilogueWisdomParticles.geometry.attributes.position.array;
      const colors = epilogueWisdomParticles.geometry.attributes.color.array;
      const sizes = epilogueWisdomParticles.geometry.attributes.size.array;
      const velocities = epilogueWisdomParticles.userData.velocities;
      const phases = epilogueWisdomParticles.userData.phases;
      
      epilogueWisdomParticles.userData.time = time;
      
      for (let i = 0; i < positions.length / 3; i++) {
        const i3 = i * 3;
        
        // 更新位置
        positions[i3] += velocities[i3];     // x
        positions[i3 + 1] += velocities[i3 + 1]; // y
        positions[i3 + 2] += velocities[i3 + 2]; // z
        
        // 螺旋運動增強（進一步減慢）
        const spiralTime = time * 0.05 + phases[i]; // 再減慢一半
        positions[i3] += Math.sin(spiralTime) * 0.002; // 再減慢一半
        positions[i3 + 2] += Math.cos(spiralTime) * 0.002; // 再減慢一半
        
        // 重置超出邊界的粒子（保持向右偏移）
        if (positions[i3 + 1] > 25) {
          positions[i3] = (Math.random() - 0.5) * 20 + 6; // 向右偏移6個單位
          positions[i3 + 1] = -15 - Math.random() * 10;
          positions[i3 + 2] = (Math.random() - 0.5) * 10;
        }
        
        // 動態大小變化（緩慢呼吸效果，增強發光）
        const breathe = Math.sin(time * 0.5 + phases[i]) * 0.8 + 1.4; // 增強變化幅度和基礎大小
        sizes[i] = (3 + Math.random() * 0.5) * breathe; // 增大基礎大小範圍
        
        // 加強金色閃爍效果（增強發光強度）
        const primaryFlicker = Math.sin(time * 1.5 + phases[i]) * 0.5 + 1.0; // 主要閃爍，提高基礎亮度
        const secondaryFlicker = Math.sin(time * 0.8 + phases[i] * 1.3) * 0.4 + 0.9; // 次要閃爍
        const tertiaryFlicker = Math.sin(time * 2.2 + phases[i] * 0.7) * 0.3 + 0.8; // 第三層閃爍
        
        // 多層次金色閃爍（增強發光強度）
        colors[i3] = Math.min(2.0, primaryFlicker * 1.3);     // r: 允許過曝效果，增強發光
        colors[i3 + 1] = Math.min(1.8, secondaryFlicker * 1.2); // g: 增強金色調
        colors[i3 + 2] = Math.min(0.6, tertiaryFlicker * 0.4); // b: 適度增強但保持金色純度
      }
      
      // 標記需要更新
      epilogueWisdomParticles.geometry.attributes.position.needsUpdate = true;
      epilogueWisdomParticles.geometry.attributes.color.needsUpdate = true;
      epilogueWisdomParticles.geometry.attributes.size.needsUpdate = true;
    }

    function updateAncientLeaves(time) {
      epilogueAncientLeaves.forEach(leaf => {
        const userData = leaf.userData;
        
        // 更新位置
        leaf.position.add(userData.velocity);
        
        // 風力擾動
        const windForce = Math.sin(time * userData.swayFrequency + userData.swayPhase) * userData.swayAmplitude * 0.01;
        leaf.position.x += windForce;
        
        // 更新旋轉
        leaf.rotation.x += userData.angularVelocity.x;
        leaf.rotation.y += userData.angularVelocity.y;
        leaf.rotation.z += userData.angularVelocity.z;
        
        // 空氣阻力
        userData.velocity.multiplyScalar(userData.windResistance);
        
        // 重置超出邊界的葉子
        if (leaf.position.y < -25) {
          leaf.position.set(
            (Math.random() - 0.5) * 40,
            20 + Math.random() * 10,
            (Math.random() - 0.5) * 5
          );
          
          // 重新隨機化物理屬性
          userData.velocity.set(
            (Math.random() - 0.5) * 0.08,
            -0.03 - Math.random() * 0.02,
            (Math.random() - 0.5) * 0.03
          );
          userData.angularVelocity.set(
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02
          );
        }
        
        // 根據物化形態調整葉子行為
        if (gameState.currentForm === 'butterfly') {
          // 蝴蝶形態：葉子飄動更輕盈
          userData.velocity.y *= 0.7;
          leaf.material.opacity = Math.min(leaf.material.opacity + 0.01, 0.9);
        } else if (gameState.currentForm === 'fish') {
          // 魚形態：葉子如水中飄動
          userData.velocity.x *= 1.2;
          userData.velocity.z *= 1.2;
        }
      });
    }

    function onEpilogueWindowResize() {
      if (!epilogueCamera || !epilogueRenderer) return;
      
      const aspect = window.innerWidth / window.innerHeight;
      epilogueCamera.left = -20 * aspect;
      epilogueCamera.right = 20 * aspect;
      epilogueCamera.updateProjectionMatrix();
      
      epilogueRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function cleanupThreeJSEpilogueScene() {
      console.log('🌅 清理Three.js尾聲場景');
      
      // 停止動畫循環
      if (epilogueAnimationId) {
        cancelAnimationFrame(epilogueAnimationId);
        epilogueAnimationId = null;
      }
      
      // 移除事件監聽器
      window.removeEventListener('resize', onEpilogueWindowResize);
      
      // 清理Three.js對象
      if (epilogueWisdomParticles) {
        epilogueWisdomParticles.geometry.dispose();
        epilogueWisdomParticles.material.dispose();
        epilogueWisdomParticles = null;
      }
      
      epilogueAncientLeaves.forEach(leaf => {
        leaf.geometry.dispose();
        leaf.material.dispose();
      });
      epilogueAncientLeaves = [];
      
      if (epilogueRenderer) {
        epilogueRenderer.dispose();
        if (epilogueRenderer.domElement && epilogueRenderer.domElement.parentNode) {
          epilogueRenderer.domElement.parentNode.removeChild(epilogueRenderer.domElement);
        }
        epilogueRenderer = null;
      }
      
      if (epilogueThreeScene) {
        epilogueThreeScene.clear();
        epilogueThreeScene = null;
      }
      
      epilogueCamera = null;
    }

    // 創建智慧光點粒子
    function createWisdomParticles(container) {
      // 清理舊粒子
      const oldParticles = container.querySelectorAll('.wisdom-particle');
      oldParticles.forEach(particle => {
        if (Math.random() > 0.6) { // 60%概率清理舊粒子
          particle.remove();
        }
      });
      
      // 生成新粒子
      const particleCount = 8 + Math.floor(Math.random() * 5); // 8-12個粒子
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'wisdom-particle';
        
        // 隨機位置
        const leftPos = Math.random() * 100;
        particle.style.left = `${leftPos}%`;
        
        // 隨機大小
        const size = 2 + Math.random() * 3; // 2-5px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 隨機延遲
        const delay = Math.random() * 5;
        particle.style.animationDelay = `${delay}s`;
        
        // 隨機持續時間
        const duration = 12 + Math.random() * 8; // 12-20秒
        particle.style.animationDuration = `${duration}s`;
        
        // 隨機透明度
        const opacity = 0.6 + Math.random() * 0.4; // 0.6-1.0
        particle.style.opacity = opacity;
        
        container.appendChild(particle);
        
        // 粒子生命週期管理
        setTimeout(() => {
          if (particle.parentNode) {
            particle.remove();
          }
        }, (duration + delay) * 1000);
      }
    }

    // 創建飄落樹葉
    function createAncientLeaves(container) {
      // 清理舊樹葉
      const oldLeaves = container.querySelectorAll('.ancient-leaf');
      oldLeaves.forEach(leaf => {
        if (Math.random() > 0.8) { // 80%概率清理舊樹葉
          leaf.remove();
        }
      });
      
      // 生成新樹葉
      const leafCount = 3 + Math.floor(Math.random() * 2); // 3-4片樹葉
      
      for (let i = 0; i < leafCount; i++) {
        const leaf = document.createElement('div');
        leaf.className = 'ancient-leaf';
        
        // 隨機位置
        const leftPos = Math.random() * 100;
        leaf.style.left = `${leftPos}%`;
        // 設置初始Y位置為屏幕外，避免在頂部可見
        const initialY = -300 - Math.random() * 200; // -300px到-500px之間隨機
        leaf.style.transform = `translateY(${initialY}px)`;
        
        // 隨機大小和形狀
        const width = 6 + Math.random() * 4; // 6-10px
        const height = width * (1.2 + Math.random() * 0.4); // 高度比寬度大一些
        leaf.style.width = `${width}px`;
        leaf.style.height = `${height}px`;
        
        // 隨機顏色變化
        const colorVariations = [
          'rgba(139, 69, 19, 0.7)',
          'rgba(160, 82, 45, 0.6)',
          'rgba(101, 67, 33, 0.8)',
          'rgba(205, 133, 63, 0.5)'
        ];
        leaf.style.background = colorVariations[Math.floor(Math.random() * colorVariations.length)];
        
        // 隨機延遲
        const delay = Math.random() * 8;
        leaf.style.animationDelay = `${delay}s`;
        
        // 隨機持續時間
        const duration = 18 + Math.random() * 6; // 18-24秒
        leaf.style.animationDuration = `${duration}s`;
        
        container.appendChild(leaf);
        
        // 樹葉生命週期管理
        setTimeout(() => {
          if (leaf.parentNode) {
            leaf.remove();
          }
               }, (duration + delay) * 1000);
       }
     }





     // 尾聲章節中蝴蝶物化的特殊夢境效果
     function createButterflyDreamEffect() {
       if (gameState.currentChapter !== 'epilogue') return;
       
       console.log('🦋 創建蝴蝶夢境特效');
       
       // 創建夢境粒子容器
       const dreamContainer = document.createElement('div');
       dreamContainer.className = 'butterfly-dream-particles';
       dreamContainer.style.cssText = `
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         pointer-events: none;
         z-index: 15;
       `;
       gameContainer.appendChild(dreamContainer);
       
       // 生成夢境粒子
       for (let i = 0; i < 12; i++) {
         const dreamParticle = document.createElement('div');
         dreamParticle.style.cssText = `
           position: absolute;
           width: 4px;
           height: 4px;
           background: radial-gradient(circle, rgba(147, 51, 234, 0.8), rgba(147, 51, 234, 0.3));
           border-radius: 50%;
           box-shadow: 0 0 12px rgba(147, 51, 234, 0.6);
           left: ${Math.random() * 100}%;
           top: 100%;
           animation: butterfly-dream-rise ${8 + Math.random() * 4}s infinite linear;
           animation-delay: ${Math.random() * 3}s;
         `;
         dreamContainer.appendChild(dreamParticle);
       }
       
       // 添加夢境動畫樣式
       if (!document.getElementById('butterfly-dream-style')) {
         const style = document.createElement('style');
         style.id = 'butterfly-dream-style';
         style.innerHTML = `
           @keyframes butterfly-dream-rise {
             0% { 
               transform: translateY(0) scale(0.5) rotate(0deg); 
               opacity: 0; 
             }
             20% { 
               opacity: 0.8; 
             }
             50% { 
               transform: translateY(-50vh) scale(1) rotate(180deg); 
               opacity: 1; 
             }
             80% { 
               opacity: 0.6; 
             }
             100% { 
               transform: translateY(-100vh) scale(0.3) rotate(360deg); 
               opacity: 0; 
             }
           }
         `;
         document.head.appendChild(style);
       }
       
       // 5秒後清理效果
       setTimeout(() => {
         dreamContainer.remove();
       }, 12000);
    }
    
    function loadScene() {
      console.log('📍 loadScene 被調用');
      console.log('當前遊戲狀態:', {
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene
      });
      
      // 記錄場景停留時間（如果之前有場景）
      if (gameState.playerChoices.sceneDwellTime.currentSceneStartTime) {
        const dwellTime = Date.now() - gameState.playerChoices.sceneDwellTime.currentSceneStartTime;
        const sceneKey = `${gameState.currentChapter}_${gameState.currentScene}`;
        gameState.playerChoices.sceneDwellTime.sceneDwellTimes[sceneKey] = dwellTime;
        gameState.playerChoices.sceneDwellTime.totalDwellTime += dwellTime;
        
        console.log(`📊 場景停留時間記錄: ${sceneKey} = ${dwellTime}ms`);
      }
      
      // 設置新場景開始時間
      gameState.playerChoices.sceneDwellTime.currentSceneStartTime = Date.now();
      
      // 在場景加載時恢復混沌的正常層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('segmentation-mode');
      }
      
      const chapter = gameChapters[gameState.currentChapter];
      console.log('章節配置:', chapter ? '存在' : '不存在');
      
      if (!chapter) {
        console.error('❌ 章節配置不存在:', gameState.currentChapter);
        return;
      }
      
      console.log('章節場景總數:', chapter.scenes.length);
      console.log('嘗試加載場景索引:', gameState.currentScene);
      
      const scene = chapter.scenes[gameState.currentScene];
      
      // 檢查場景是否存在
      if (!scene) {
        console.error('❌ Scene not found:', gameState.currentChapter, gameState.currentScene);
        console.log('章節中所有場景索引:', Object.keys(chapter.scenes));
        console.log('場景總數:', chapter.scenes.length);
        
        // 嘗試回到章節開始
        console.log('嘗試回到章節開始場景...');
        gameState.currentScene = 0;
        if (chapter.scenes[0]) {
          const fallbackScene = chapter.scenes[0];
          console.log('✅ 找到起始場景，類型:', fallbackScene.type);
        } else {
          console.error('❌ No scenes found in chapter:', gameState.currentChapter);
          return;
        }
      } else {
        console.log('✅ 場景找到，類型:', scene.type);
        console.log('場景詳情:', scene);
      }
      
      // Clear previous content
      gameContent.innerHTML = '';
      dialogBox.style.opacity = 0;
      dialogOptions.innerHTML = '';
      
      // Clear any floating puzzle containers from previous scenes
      document.querySelectorAll('body > .max-w-3xl').forEach(el => {
        if (el.style.position === 'fixed' && el.style.zIndex === '9999') {
          el.remove();
        }
      });
      
      // Hide advance button initially
      advanceBtn.style.display = 'none';
      
      setTimeout(() => {
        // Process scene based on type
        console.log('🎭 開始創建場景，類型:', scene.type);
        
        switch (scene.type) {
          case 'narrative':
            console.log('創建敘述場景');
            createNarrativeScene(scene);
            break;
          case 'dialog':
            console.log('創建對話場景');
            createDialogScene(scene);
            break;
          case 'personalized-response':
            console.log('創建個性化回應場景');
            createPersonalizedResponseScene(scene);
            break;
          case 'personalized-summary':
            console.log('創建個性化總結場景');
            createPersonalizedSummaryScene(scene);
            break;
          case 'segmentation-puzzle':
            console.log('創建斷句謎題場景');
            createSegmentationPuzzle(scene);
            break;
          case 'tutorial':
            createTutorialScene(scene);
            break;
          case 'cloud-effect':
            createCloudEffectScene(scene);
            break;

          case 'spiral-effect':
            createSpiralEffectScene(scene);
            break;
          case 'perspective-challenge':
            createPerspectiveChallengeScene(scene);
            break;
          case 'time-effect':
            createTimeEffectScene(scene);
            break;
          case 'heaven-earth-effect':
            createHeavenEarthEffectScene(scene);
            break;
          case 'transformation-experience':
            createTransformationExperienceScene(scene);
            break;
          case 'transformation-required':
            createTransformationRequiredScene(scene);
            break;
          case 'form-unlock-guide':
            createFormUnlockGuideScene(scene);
            break;
          case 'puzzle-taijitu':
            createTaijiPuzzle(scene);
            break;
          case 'form-sequence-guide':
            createFormSequenceGuide(scene);
            break;
          case 'bagua-theory-explanation':
            createBaguaTheoryExplanationScene(scene);
            break;
          case 'bagua-symbols-demonstration':
            createBaguaSymbolsDemonstrationScene(scene);
            break;
          case 'bagua-learning-challenge':
            createBaguaLearningChallengeScene(scene);
            break;
          case 'wanwu-xunqi-guide':
            createWanwuXunqiGuide(scene);
            break;


            
          case 'chaos-breathing-guide':
            createChaosBreathingGuide(scene);
            break;
            
          case 'qi-infusion-ritual':
            createQiInfusionRitual(scene);
            break;
            
          case 'snail-perspective-transition':
            createSnailPerspectiveTransitionScene(scene);
            break;
            
                      case 'dao-revelation':
              console.log('✨ 創建道的顯現場景');
              console.log('場景內容:', scene);
              createDaoRevelationScene(scene);
              break;
              
          case 'credits':
              console.log('✨ 創建製作人員名單場景');
              console.log('場景內容:', scene);
              createCreditsScene(scene);
              break;
              
          case 'blank-emergence':
              console.log('✨ 創建空白浮現場景');
              console.log('場景內容:', scene);
              createBlankEmergenceScene(scene);
              break;
              
          case 'photo-develop':
              console.log('✨ 創建照片顯影場景');
              console.log('場景內容:', scene);
              createPhotoDevelopScene(scene);
              break;
              
          case 'final-meditation':
              console.log('✨ 創建最終冥想場景');
              console.log('場景內容:', scene);
              createFinalMeditationScene(scene);
              break;

          default:
            console.error('Unknown scene type:', scene.type);
            // 創建一個默認場景以避免空白
            createNarrativeScene({
              text: `場景類型 "${scene.type}" 暫未實現。點擊繼續進入下一個場景。`,
              nextScene: scene.nextScene || (gameState.currentScene + 1)
            });
        }
        
        // Process effects
        if (scene.effect) {
          processEffect(scene.effect);
        }
        
        // 尾聲章節的UI和粒子效果邏輯
        if (gameState.currentChapter === 'epilogue') {
          if (gameState.currentScene >= 13 && gameState.currentScene < 19) {
            // 從場景13-18恢復所有UI顯示（對應「所有的生物都出現了」）
            console.log('🎭 尾聲章節場景13-18，恢復所有UI顯示（所有生物都出現了）');
            gameUI.style.opacity = 1;
            gameUI.style.transition = 'opacity 0.5s ease';
            
            // 恢復左上角當前形態指示器
            const currentFormIndicator = document.getElementById('current-form-indicator');
            if (currentFormIndicator) {
              currentFormIndicator.style.opacity = 1;
              currentFormIndicator.style.transition = 'opacity 0.5s ease';
            }
            
            // 恢復右上角七竅追蹤器
            const aperturesTracker = document.getElementById('apertures-tracker');
            if (aperturesTracker) {
              aperturesTracker.style.opacity = 1;
              aperturesTracker.style.transition = 'opacity 0.5s ease';
            }
          } else {
            // 場景0-12和場景19保持所有UI隱藏
            console.log('🎭 尾聲章節場景0-12和19，保持所有UI隱藏');
            gameUI.style.opacity = 0;
            
            // 隱藏左上角當前形態指示器
            const currentFormIndicator = document.getElementById('current-form-indicator');
            if (currentFormIndicator) {
              currentFormIndicator.style.opacity = 0;
            }
            
            // 隱藏右上角七竅追蹤器
            const aperturesTracker = document.getElementById('apertures-tracker');
            if (aperturesTracker) {
              aperturesTracker.style.opacity = 0;
            }
          }
          
          // 粒子效果從場景2開始顯示（背景圖片出現後）
          if (gameState.currentScene >= 2) {
            // 顯示粒子效果
            console.log('🌅 尾聲章節場景2+，顯示粒子效果');
            const wisdomParticles = document.querySelector('.wisdom-particles');
            const ancientLeaves = document.querySelector('.ancient-leaves');
            
            if (wisdomParticles) {
              wisdomParticles.style.display = 'block';
              createWisdomParticles(wisdomParticles);
            }
            if (ancientLeaves) {
              ancientLeaves.style.display = 'block';
              createAncientLeaves(ancientLeaves);
            }
          } else {
            // 隱藏粒子效果
            console.log('🌅 尾聲章節場景0-1，隱藏粒子效果');
            const wisdomParticles = document.querySelector('.wisdom-particles');
            const ancientLeaves = document.querySelector('.ancient-leaves');
            
            if (wisdomParticles) wisdomParticles.style.display = 'none';
            if (ancientLeaves) ancientLeaves.style.display = 'none';
          }
        }
      }, 300);
    }
    

    
    // 隱藏日常物化按鈕（在初次物化流程中使用）
    function hideFormButtons() {
      const formButtonsContainer = document.querySelector('.form-selector');
      if (formButtonsContainer) {
        formButtonsContainer.style.display = 'none';
        console.log('已隱藏日常物化按鈕');
      }
    }
    
    // 顯示日常物化按鈕（恢復正常顯示）
    function showFormButtons() {
      const formButtonsContainer = document.querySelector('.form-selector');
      if (formButtonsContainer) {
        formButtonsContainer.style.display = 'flex';
        console.log('已恢復日常物化按鈕顯示');
      }
    }
    
    function advanceScene() {
      console.log('📈 advanceScene 被調用');
      console.log('當前場景狀態:', {
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene
      });
      
      // 第七章場景39特殊處理：清理添加到document.body的元素
      if (gameState.currentChapter === 'chapter7' && gameState.currentScene === 39) {
        console.log('🌟 清理第七章場景39的document.body元素');
        const chapter7Elements = document.querySelectorAll('.max-w-2xl.mx-auto.p-6.text-left.fixed, .typewriter-container, .fade-in-container');
        chapter7Elements.forEach(el => {
          if (el.parentNode === document.body) {
            el.remove();
          }
        });
      }
      
      // 尾聲章節場景0特殊處理：清除白色過渡層
      if (gameState.currentChapter === 'epilogue' && gameState.currentScene === 0) {
        console.log('🌅 尾聲章節場景0，清除白色過渡層');
        const whiteOverlay = document.getElementById('white-transition-overlay');
        if (whiteOverlay) {
          whiteOverlay.remove();
          console.log('🌅 白色過渡層已清除');
        }
        
        // 確保gameContainer和gameContent正確設置
        gameContainer.style.background = '#ffffff';
        gameContent.style.background = '#ffffff';
        console.log('🌅 已重置背景樣式');
      }
      
      // 在場景切換時恢復混沌的正常層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('segmentation-mode');
      }
      
      // 在正常場景推進時恢復日常物化按鈕顯示
      // 但如果是第七章且氣形態已解鎖，保持按鈕隱藏
      if (gameState.currentChapter === 'chapter7' && gameState.unlockedForms.includes('qi')) {
        console.log('第七章氣形態已解鎖，保持日常物化按鈕隱藏');
      } else {
        showFormButtons();
      }
      
      const chapter = gameChapters[gameState.currentChapter];
      if (!chapter) {
        console.error('❌ advanceScene: 找不到章節配置', gameState.currentChapter);
        return;
      }
      
      const scene = chapter.scenes[gameState.currentScene];
      if (!scene) {
        console.error('❌ advanceScene: 找不到當前場景', {
          chapter: gameState.currentChapter,
          scene: gameState.currentScene,
          totalScenes: chapter.scenes.length
        });
        return;
      }
      
      console.log('當前場景詳情:', scene);
      
      let nextSceneId = scene.nextScene;
      console.log('下一個場景ID:', nextSceneId);
      
      // Handle chapter transitions
      if (typeof nextSceneId === 'string') {
        console.log('檢測到章節跳轉:', nextSceneId);
        const [nextChapter, nextScene] = nextSceneId.split(':');
        
        if (nextChapter === 'end') {
          // End game or show ending for now
          console.log('遊戲結束');
          alert('遊戲章節結束！更多章節敬請期待。');
          return;
        }
        
        console.log('跳轉到新章節:', nextChapter, '場景:', nextScene);
        gameState.currentChapter = nextChapter;
        gameState.currentScene = parseInt(nextScene);
        
        // 更新最高章節記錄
        const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
        const currentIndex = chapters.indexOf(nextChapter);
        const maxIndex = chapters.indexOf(gameState.maxReachedChapter || 'prologue');
        
        if (currentIndex > maxIndex) {
          gameState.maxReachedChapter = nextChapter;
          console.log('📈 更新最高章節記錄:', gameState.maxReachedChapter);
        }
        
        // 使用新的章節過渡函數
        transitionToChapter(nextChapter);
      } else {
        // Regular scene transition
        console.log('常規場景推進，從', gameState.currentScene, '到', nextSceneId);
        gameState.currentScene = nextSceneId;
        
        // 檢查目標場景是否存在
        if (!chapter.scenes[nextSceneId]) {
          console.error('❌ 目標場景不存在:', {
            targetScene: nextSceneId,
            totalScenes: chapter.scenes.length,
            availableScenes: Object.keys(chapter.scenes)
          });
          return;
        }
        
        console.log('調用 loadScene() 加載場景', nextSceneId);
        loadScene();
      }
    }
    
    // === 個性化場景創建函數 ===
    async function createPersonalizedResponseScene(scene) {
      console.log('🤖 創建個性化回應場景:', scene);
      
      // 創建對話場景容器
      const dialogElement = document.createElement('div');
      
      // 檢查特殊章節的樣式需求
      const hasSnail = document.querySelector('.snail-shell');
      const isTimeChapter = gameState.currentChapter === 'chapter5';
      const isHeavenEarthChapter = gameState.currentChapter === 'chapter6';
      
      if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
        dialogElement.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-3xl bg-white dark:bg-gray-800 border-2 border-purple-500 dark:border-purple-400 rounded-lg p-4 shadow-lg bg-opacity-95 dark:bg-opacity-95';
        dialogElement.style.zIndex = isHeavenEarthChapter ? '60' : '30';
      } else {
        dialogElement.className = 'absolute top-1/2 left-0 right-0 mx-auto max-w-3xl -translate-y-1/2 bg-white dark:bg-gray-800 border-2 border-purple-500 dark:border-purple-400 rounded-lg p-4 shadow-lg opacity-0 transition-all duration-300 transform';
      }
      
      // 添加個性化標識
      const aiIndicator = document.createElement('div');
      aiIndicator.className = 'flex items-center mb-2 text-xs text-purple-600 dark:text-purple-400';
      aiIndicator.innerHTML = `
        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
          <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
        個性化回應
      `;
      dialogElement.appendChild(aiIndicator);
      
      // 首先顯示思考狀態
      const thinkingElement = document.createElement('div');
      thinkingElement.className = 'thinking-container';
      thinkingElement.innerHTML = `
        <div class="flex items-center space-x-3">
          <div class="thinking-avatar w-8 h-8 bg-gradient-to-br from-indigo-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-sm" style="animation: pulse 2s ease-in-out infinite;">
            莊
          </div>
          <div class="thinking-text text-lg text-gray-600 dark:text-gray-400" style="animation: text-glow-breathe 2s ease-in-out infinite;">
            <strong>${scene.speaker}</strong> 正在深思你的話語...
          </div>
        </div>
        <div class="thinking-dots mt-2 flex justify-center space-x-1">
          <div class="w-2 h-2 bg-purple-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite"></div>
          <div class="w-2 h-2 bg-purple-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.2s"></div>
          <div class="w-2 h-2 bg-purple-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.4s"></div>
        </div>
      `;
      dialogElement.appendChild(thinkingElement);
      
      gameContent.appendChild(dialogElement);
      
      // 顯示動畫
      setTimeout(() => {
        if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
          dialogElement.style.transform = 'translateX(-50%)';
        } else {
          dialogElement.style.opacity = '1';
          dialogElement.style.transform = 'translateY(0)';
        }
      }, 100);
      
      // 開始生成個性化內容
      let personalizedText;
      try {
        console.log('🔄 ===== 個性化回應場景調試信息 =====');
        console.log('🎯 場景調用時間:', new Date().toLocaleTimeString());
        console.log('📍 場景詳情:', {
          sceneType: scene.sceneType,
          speaker: scene.speaker,
          responseKey: scene.responseKey,
          context: scene.context,
          baseText: scene.baseText?.substring(0, 50) + '...'
        });
        
        const lastChoice = gameState.playerChoices.choiceHistory[gameState.playerChoices.choiceHistory.length - 1];
        
        console.log('📊 玩家最近選擇分析:', {
          選擇文本: lastChoice?.text || lastChoice?.choiceText || '無選擇記錄',
          選擇情境: lastChoice?.situation || '未知情境',
          選擇特質: lastChoice?.traits || {},
          思考時間: lastChoice?.thinkingTime ? `${Math.round(lastChoice.thinkingTime / 1000)}s` : '未記錄',
          章節: lastChoice?.chapter || '未知章節',
          場景: lastChoice?.scene || '未知場景'
        });
        
        console.log('🎮 當前遊戲狀態:', {
          當前章節: gameState.currentChapter,
          當前場景: gameState.currentScene,
          當前形態: gameState.currentForm,
          選擇歷史長度: gameState.playerChoices.choiceHistory.length
        });
        
        console.log('🤖 準備調用AI生成個性化回應...');
        const aiStartTime = Date.now();
        
        personalizedText = await generateSmartResponse(
          lastChoice?.text || lastChoice?.choiceText || '玩家的選擇',
          {
            sceneType: scene.sceneType,
            description: scene.context,
            responseKey: scene.responseKey,
            specificQuestion: lastChoice?.text || lastChoice?.choiceText, // 確保AI知道要回應的具體選擇
            chapter: gameState.currentChapter,
            scene: gameState.currentScene
          }
        );
        
        const aiEndTime = Date.now();
        const aiDuration = aiEndTime - aiStartTime;
        
        console.log('⏱️ AI回應生成耗時:', `${aiDuration}ms`);
        
        if (personalizedText) {
          console.log('✅ AI個性化回應生成成功:');
          console.log('  📏 回應長度:', personalizedText.length, '字符');
          console.log('  📝 回應內容:', personalizedText);
          console.log('  🎯 回應品質檢查:', {
            包含繁體中文: /[\u4e00-\u9fff]/.test(personalizedText),
            長度合適: personalizedText.length >= 50 && personalizedText.length <= 150,
            包含個性化元素: personalizedText.includes('你') || personalizedText.includes('選擇'),
            符合莊子風格: personalizedText.includes('道') || personalizedText.includes('自然') || personalizedText.includes('逍遙')
          });
        } else {
          console.warn('⚠️ AI返回空內容，使用預設內容');
          console.log('📝 預設內容:', scene.baseText);
          personalizedText = scene.baseText;
        }
        
        console.log('========================================');
      } catch (error) {
        console.error('❌ 個性化內容生成失敗:', error);
        console.log('🔄 降級使用預設內容:', scene.baseText);
        console.log('========================================');
        personalizedText = scene.baseText;
      }
      
      // AI回應準備好後，優雅地替換內容
      const finalTextElement = document.createElement('div');
      finalTextElement.className = 'ai-response-text text-lg leading-relaxed opacity-0 transition-all duration-800';
      finalTextElement.innerHTML = `<strong>${scene.speaker}：</strong> ${personalizedText}`;
      
      // 開始優雅的過渡動畫
      setTimeout(() => {
        // 淡出思考狀態
        const thinkingContainer = dialogElement.querySelector('.thinking-container');
        if (thinkingContainer) {
          thinkingContainer.style.transition = 'opacity 500ms ease-out, transform 500ms ease-out';
          thinkingContainer.style.opacity = '0';
          thinkingContainer.style.transform = 'translateY(-10px)';
          
          // 移除思考狀態並添加AI回應
          setTimeout(() => {
            thinkingContainer.remove();
            dialogElement.appendChild(finalTextElement);
            
            // 淡入AI回應，帶有打字機效果
            setTimeout(() => {
              finalTextElement.style.opacity = '1';
              finalTextElement.style.transform = 'translateY(0)';
              
              // 添加subtle的發光效果強調這是AI回應
              finalTextElement.style.animation = 'text-glow-breathe 3s ease-in-out';
              
              // 顯示繼續按鈕
              setTimeout(() => {
      advanceBtn.style.display = 'block';
              }, 300);
              
            }, 100);
          }, 500);
        }
      }, 300); // 給AI一點時間"思考"，即使回應已經準備好
    }
    
    async function createPersonalizedSummaryScene(scene) {
      console.log('📊 創建個性化總結場景:', scene);
      
      // 先創建總結容器並顯示思考狀態
      const summaryElement = document.createElement('div');
      summaryElement.className = 'max-w-4xl mx-auto p-8 text-center bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-blue-900 dark:to-indigo-900 rounded-xl shadow-lg border border-indigo-200 dark:border-indigo-700';
      summaryElement.style.position = 'relative';
      summaryElement.style.zIndex = '100'; // 确保AI总结场景在所有背景元素之上
      
      // 添加章節總結標題
      const titleElement = document.createElement('h3');
      titleElement.className = 'text-2xl font-bold text-indigo-800 dark:text-indigo-200 mb-4';
      
      // 根據章節類型設置不同的標題
      if (gameState.currentChapter === 'epilogue') {
        titleElement.textContent = '莊子的告別信';
      } else if (gameState.currentChapter === 'chapter1') {
        titleElement.textContent = '第一章總結';
      } else {
        titleElement.textContent = '章節總結';
      }
      
      summaryElement.appendChild(titleElement);
      
      // 顯示思考狀態
      const thinkingElement = document.createElement('div');
      thinkingElement.className = 'thinking-summary-container py-8';
      thinkingElement.innerHTML = `
        <div class="flex flex-col items-center space-y-4">
          <div class="thinking-avatar w-16 h-16 bg-gradient-to-br from-indigo-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-xl" style="animation: pulse 2s ease-in-out infinite;">
            莊
          </div>
          <div class="thinking-text text-lg text-gray-600 dark:text-gray-400 text-center" style="animation: text-glow-breathe 2s ease-in-out infinite;">
            ${gameState.currentChapter === 'epilogue' ? '正在回顧你的完整旅程，寫下告別信...' : '正在回顧你的哲學之旅，生成個性化總結...'}
          </div>
          <div class="thinking-dots flex justify-center space-x-2">
            <div class="w-3 h-3 bg-indigo-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite"></div>
            <div class="w-3 h-3 bg-indigo-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.3s"></div>
            <div class="w-3 h-3 bg-indigo-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.6s"></div>
          </div>
        </div>
      `;
      summaryElement.appendChild(thinkingElement);
      gameContent.appendChild(summaryElement);
      
      // 生成章節總結
      let summaryText;
      try {
        console.log('🔄 準備生成章節總結...');
        const playerData = getAIAnalysisData();
                 console.log('📊 獲取到玩家數據:', {
           choicesCount: playerData.context?.recentHistory?.length || 0,
           traitsCount: Object.keys(playerData.traits || {}).length,
           profileType: playerData.profile?.philosophicalProfile,
           totalChoicesInHistory: playerData.choices?.length || 0
         });
         
         console.log('📋 最近選擇詳情:', playerData.context?.recentHistory?.slice(-3).map(h => ({
           text: h.choiceText?.substring(0, 30) + '...',
           scene: h.scene,
           chapter: h.chapter
         })) || []);
        
        console.log('🤖 調用AI生成章節總結...');
        summaryText = await zhuangziAI.generateChapterSummary(gameState.currentChapter, playerData);
        
        if (summaryText) {
          console.log('✅ AI章節總結生成成功:', summaryText.substring(0, 50) + '...');
        } else {
          console.warn('⚠️ AI返回空內容，使用預設內容');
          summaryText = scene.baseText;
        }
      } catch (error) {
        console.error('❌ 章節總結生成失敗:', error);
        console.log('🔄 降級使用預設內容:', scene.baseText);
        summaryText = scene.baseText;
      }
      
      // AI回應準備好後，創建最終內容
      const finalContentElement = document.createElement('div');
      finalContentElement.className = 'final-summary-content text-lg leading-relaxed text-gray-700 dark:text-gray-300 mb-6 opacity-0 transition-all duration-800';
      
      // 添加莊子頭像和引言
      const quoteContainer = document.createElement('div');
      quoteContainer.className = 'flex items-start mb-4';
      quoteContainer.innerHTML = `
        <div class="w-12 h-12 bg-gradient-to-br from-indigo-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 flex-shrink-0">
          莊
        </div>
        <div class="flex-1">
          <p class="text-left italic border-l-4 border-indigo-300 dark:border-indigo-600 pl-4">
            ${summaryText}
          </p>
        </div>
      `;
      finalContentElement.appendChild(quoteContainer);
      
      // 添加數據統計（如果有的話）
      if (gameState.playerChoices.choiceHistory.length > 0) {
        const statsElement = document.createElement('div');
        statsElement.className = 'grid grid-cols-2 gap-4 mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg';
        
        const choiceCount = gameState.playerChoices.choiceHistory.length;
        const avgThinkingTime = choiceCount > 0 ? 
          Math.round(gameState.playerChoices.choiceHistory.reduce((sum, choice) => 
            sum + (choice.thinkingTime || 0), 0) / choiceCount / 1000 * 10) / 10 : 0; // 轉換為秒，保留1位小數
        
        // 根據章節類型顯示不同的統計數據
        if (gameState.currentChapter === 'epilogue') {
          // 尾聲章節顯示完整遊戲統計
          const gameProgress = getGameProgressSummary();
          statsElement.innerHTML = `
            <div class="text-center">
              <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${gameProgress.totalPlayTime}</div>
              <div class="text-sm text-gray-600 dark:text-gray-400">分鐘旅程</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${choiceCount}</div>
              <div class="text-sm text-gray-600 dark:text-gray-400">個選擇</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${gameProgress.formsUnlocked}</div>
              <div class="text-sm text-gray-600 dark:text-gray-400">種形態</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${gameProgress.aperturesCollected}</div>
              <div class="text-sm text-gray-600 dark:text-gray-400">個封印</div>
            </div>
          `;
          statsElement.className = 'grid grid-cols-4 gap-4 mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg';
        } else {
          // 其他章節顯示選擇統計
        statsElement.innerHTML = `
          <div class="text-center">
            <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${choiceCount}</div>
            <div class="text-sm text-gray-600 dark:text-gray-400">個選擇</div>
          </div>
          <div class="text-center">
            <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${avgThinkingTime}s</div>
            <div class="text-sm text-gray-600 dark:text-gray-400">平均思考時間</div>
          </div>
        `;
          statsElement.className = 'grid grid-cols-2 gap-4 mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg';
        }
        finalContentElement.appendChild(statsElement);
      }
      
      // 開始優雅的過渡動畫
      setTimeout(() => {
        const thinkingContainer = summaryElement.querySelector('.thinking-summary-container');
        if (thinkingContainer) {
          thinkingContainer.style.transition = 'opacity 600ms ease-out, transform 600ms ease-out';
          thinkingContainer.style.opacity = '0';
          thinkingContainer.style.transform = 'translateY(-20px)';
          
          // 移除思考狀態並添加AI總結
          setTimeout(() => {
            thinkingContainer.remove();
            summaryElement.appendChild(finalContentElement);
            
            // 淡入AI總結
            setTimeout(() => {
              finalContentElement.style.opacity = '1';
              finalContentElement.style.transform = 'translateY(0)';
              
              // 添加發光效果
              finalContentElement.style.animation = 'text-glow-breathe 3s ease-in-out';
              
              // 顯示繼續按鈕
              setTimeout(() => {
      advanceBtn.style.display = 'block';
              }, 500);
              
            }, 100);
          }, 600);
        }
      }, 400); // 給章節總結一點時間"生成"
    }
    
    function createNarrativeScene(scene) {
      const narrativeElement = document.createElement('div');
      
      // 检查是否有蜗牛存在，或者是第五章（时间森林），或者是第六章（天地場景），或者是尾聲章節
      const hasSnail = document.querySelector('.snail-shell');
      const isTimeChapter = gameState.currentChapter === 'chapter5';
      const isHeavenEarthChapter = gameState.currentChapter === 'chapter6';
      const isEpilogueChapter = gameState.currentChapter === 'epilogue';
      // 特殊處理：第七章場景39（氣注入後的白色過渡場景）
      const isChapter7Scene39 = gameState.currentChapter === 'chapter7' && gameState.currentScene === 39;
      
      if (hasSnail || isTimeChapter || isHeavenEarthChapter || isChapter7Scene39 || isEpilogueChapter) {
        narrativeElement.className = 'max-w-2xl mx-auto p-6 text-left fixed left-1/2 transform -translate-x-1/2 bg-gray-50 dark:bg-gray-700 bg-opacity-90 dark:bg-opacity-90 rounded-lg shadow-lg border border-gray-300 dark:border-gray-600';
        narrativeElement.style.top = isHeavenEarthChapter ? '1rem' : (isEpilogueChapter ? '50%' : '4rem'); // 第六章文字框上移，尾聲章節垂直居中
        narrativeElement.style.transform = isEpilogueChapter ? 'translate(-50%, -50%)' : 'translateX(-50%)'; // 尾聲章節完全居中
        narrativeElement.style.zIndex = isHeavenEarthChapter ? '70' : (isChapter7Scene39 ? '100' : '20'); // 第七章場景39使用最高層級
        
        // 第七章場景39的特殊樣式處理
        if (isChapter7Scene39) {
          narrativeElement.style.background = 'rgba(255, 255, 255, 0.98)';
          narrativeElement.style.border = '2px solid rgba(100, 100, 100, 0.3)';
          narrativeElement.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.2)';
          narrativeElement.style.backdropFilter = 'blur(10px)';
          // 確保白色背景持續顯示
          gameContainer.style.background = '#ffffff';
        }
        
        // 尾聲章節的特殊樣式處理（垂直居中，半透明背景）
        if (isEpilogueChapter) {
          narrativeElement.style.background = 'rgba(255, 255, 255, 0.9)';
          narrativeElement.style.border = '2px solid rgba(139, 69, 19, 0.3)';
          narrativeElement.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.15)';
          narrativeElement.style.backdropFilter = 'blur(8px)';
        }
      } else {
        narrativeElement.className = 'max-w-2xl mx-auto p-6 text-left bg-gray-50 dark:bg-gray-700 bg-opacity-90 dark:bg-opacity-90 rounded-lg shadow-lg border border-gray-300 dark:border-gray-600';
      }
      
      // 根据章节设置合适的文字颜色
      let textColorClass = 'text-lg md:text-xl leading-relaxed';
      if (isEpilogueChapter) {
        // 尾聲章節使用紫色文字，通過CSS自定義樣式控制
        textColorClass += ' epilogue-text-purple';
      } else if (isChapter7Scene39) {
        // 第七章場景39使用深色文字（在白色背景上）
        textColorClass += ' text-gray-800';
      } else {
        // 敘述場景使用稍微不同的文字顏色，與對話場景區分
        // 亮色模式用深灰色，暗色模式用淺灰色，比對話場景稍淺
        textColorClass += ' text-gray-700 dark:text-gray-300';
      }
      
      narrativeElement.innerHTML = `
        <p class="${textColorClass}">${scene.text}</p>
      `;
      
      // 第七章場景39特殊處理：添加到document.body以延續空白效果，使用打字機效果
      if (isChapter7Scene39) {
        // 清空內容，創建純白背景
        gameContent.innerHTML = '';
        gameContainer.style.background = '#ffffff';
        gameContainer.style.transition = 'background 2s ease';
        
        // 移除氣形態濾鏡效果
        removeQiVisionEffect();
        
        // 創建緩慢浮現效果的容器
        const fadeInContainer = document.createElement('div');
        fadeInContainer.className = 'fade-in-container';
        fadeInContainer.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: left;
          z-index: 20;
          width: 90%;
          max-width: 800px;
          font-size: 1.5rem;
          font-family: "Noto Serif SC", "Source Han Serif SC", serif;
          font-weight: 500;
          color: #000000;
          line-height: 1.8;
        `;
        
        // 創建文字元素
        const fadeInText = document.createElement('div');
        fadeInText.className = 'fade-in-text';
        fadeInText.style.cssText = `
          opacity: 0;
          transform: translateY(30px);
          transition: all 3s ease;
        `;
        fadeInText.textContent = scene.text;
        
        fadeInContainer.appendChild(fadeInText);
        document.body.appendChild(fadeInContainer);
        
        // 立即開始緩慢浮現動畫
        setTimeout(() => {
          fadeInText.style.opacity = '1';
          fadeInText.style.transform = 'translateY(0)';
          
          // 3秒後顯示繼續按鈕（延遲更長時間確保玩家充分閱讀）
          setTimeout(() => {
            // 創建繼續按鈕
            const continueButton = document.createElement('button');
            continueButton.className = 'epilogue-continue-button';
            continueButton.style.cssText = `
              position: absolute;
              bottom: -120px;
              left: 50%;
              transform: translateX(-50%) translateY(20px);
              padding: 1rem 2rem;
              background: linear-gradient(135deg, #000000, #333333);
              color: white;
              border: 2px solid #666666;
              border-radius: 8px;
              font-size: 1.1rem;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
              opacity: 0;
              z-index: 21;
            `;
            continueButton.textContent = '繼續';
            
            // 懸停效果
            continueButton.addEventListener('mouseenter', () => {
              continueButton.style.background = 'linear-gradient(135deg, #333333, #555555)';
              continueButton.style.transform = 'translateX(-50%) translateY(-2px)';
              continueButton.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
            });
            
            continueButton.addEventListener('mouseleave', () => {
              continueButton.style.background = 'linear-gradient(135deg, #000000, #333333)';
              continueButton.style.transform = 'translateX(-50%) translateY(0)';
              continueButton.style.boxShadow = 'none';
            });
            
            // 點擊事件：開始第七章到尾聲的特殊過渡
            continueButton.addEventListener('click', () => {
              console.log('🌟 場景39繼續按鈕被點擊，開始第七章到尾聲的特殊過渡');
              
              // 清理場景39的元素
              fadeInContainer.remove();
              
              // 開始第七章到尾聲的特殊白色過渡
              transitionFromChapter7ToEpilogue();
            });
            
            fadeInContainer.appendChild(continueButton);
            
            // 顯示按鈕動畫（和場景38一樣的慢慢浮現效果）
            setTimeout(() => {
              continueButton.style.opacity = '1';
              continueButton.style.transform = 'translateX(-50%) translateY(0)';
            }, 100);
          }, 3000);
        }, 100);
        
        // 隱藏原有的繼續按鈕
        advanceBtn.style.display = 'none';
      } else {
        gameContent.appendChild(narrativeElement);
      }
      
      // Handle narrative options if present
      if (scene.options && scene.options.length > 0) {
        // 開始計時選擇思考時間
        startChoiceTimer();
        
        // Create options container with high z-index to ensure it's above background elements
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'max-w-2xl mx-auto mt-6 space-y-3 relative';
        optionsContainer.style.zIndex = '100'; // 確保選項按鈕在所有背景元素之上
        
        scene.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.className = 'w-full bg-indigo-100 hover:bg-indigo-200 dark:bg-indigo-900 dark:hover:bg-indigo-800 text-indigo-800 dark:text-indigo-200 font-semibold py-3 px-4 rounded text-left transition-all duration-200 relative';
          button.style.zIndex = '101'; // 確保按鈕在選項容器之上
          button.textContent = option.text;
          button.addEventListener('click', () => {
            // 記錄玩家選擇（在場景切換之前）
            const choiceData = {
              text: option.text,
              index: index,
              speaker: scene.speaker || 'narrator',
              situation: getCurrentSituation()
            };
            
            // 處理新的分層特質結構或舊的扁平結構
            if (option.traits) {
              if (option.traits.philosophical || option.traits.mbti || option.traits.story) {
                // 新的分層結構
                choiceData.philosophical = option.traits.philosophical || {};
                choiceData.mbti = option.traits.mbti || {};
                choiceData.story = option.traits.story || {};
              } else {
                // 舊的扁平結構，轉換為新結構
                choiceData.philosophical = option.traits;
                choiceData.mbti = {};
                choiceData.story = {};
              }
            } else {
              // 使用智能特質提取
              console.log('🔍 ===== 選擇處理調試信息 (選項場景) =====');
              console.log('📝 選擇文本:', option.text);
              console.log('🎭 說話者:', scene.speaker);
              console.log('📚 章節:', gameState.currentChapter);
              
              const extractedTraits = extractTraitsFromChoice(option.text, scene.speaker, gameState.currentChapter);
              
              console.log('🧠 提取的特質結構:', extractedTraits);
              console.log('  哲學特質:', extractedTraits.philosophical);
              console.log('  故事特質:', extractedTraits.story);
              
              // 正確處理結構化特質數據
              choiceData.philosophical = extractedTraits.philosophical || {};
              choiceData.mbti = {};
              choiceData.story = extractedTraits.story || {};
              
              console.log('✅ 最終選擇數據:', choiceData);
              console.log('========================================');
            }
            
            recordPlayerChoice(choiceData);
            
            // 原有的場景切換邏輯
            gameState.currentScene = option.next;
            loadScene();
          });
          optionsContainer.appendChild(button);
        });
        
        // 第七章場景39特殊處理：選項容器也添加到document.body
        if (isChapter7Scene39) {
          // 場景39不使用選項，使用自定義繼續按鈕
          console.log('🌟 場景39跳過選項處理，使用自定義繼續按鈕');
        } else {
          gameContent.appendChild(optionsContainer);
        }
        
        // Don't show advance button for options
        advanceBtn.style.display = 'none';
      } else {
        advanceBtn.style.display = 'block';
        
        // 第七章場景39的繼續按鈕特殊樣式處理（已由自定義按鈕替代）
        if (isChapter7Scene39) {
          // 場景39使用自定義繼續按鈕，不需要處理原有按鈕
          console.log('🌟 場景39使用自定義繼續按鈕');
        }
      }
    }
    
    function createCloudEffectScene(scene) {
      const cloudEffectElement = document.createElement('div');
      cloudEffectElement.className = 'max-w-2xl mx-auto p-6 text-left relative';
      
      // Add cloud visual effects
      const cloudContainer = document.createElement('div');
      cloudContainer.className = 'absolute inset-0 pointer-events-none';
      
      // Create several decorative clouds
      for (let i = 0; i < 8; i++) {
        const cloud = document.createElement('div');
        const size = 50 + Math.random() * 100;
        const opacity = 0.4 + Math.random() * 0.4;
        
        cloud.className = 'cloud absolute';
        cloud.style.width = `${size}px`;
        cloud.style.height = `${size * 0.6}px`;
        cloud.style.left = `${Math.random() * 100}%`;
        cloud.style.top = `${Math.random() * 100}%`;
        cloud.style.opacity = opacity.toString();
        
        // Set random cloud animation parameters
        cloud.style.setProperty('--cloud-dx', `${(Math.random() * 40 - 20)}px`);
        cloud.style.setProperty('--cloud-dy', `${(Math.random() * 20 - 10)}px`);
        cloud.style.animation = `float-cloud ${5 + Math.random() * 7}s infinite ease-in-out alternate`;
        cloud.style.animationDelay = `${Math.random() * 5}s`;
        
        cloudContainer.appendChild(cloud);
      }
      
      cloudEffectElement.appendChild(cloudContainer);
      
      // Add text on top of clouds
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed relative z-10 text-gray-800 dark:text-white';
      textElement.textContent = scene.text;
      cloudEffectElement.appendChild(textElement);
      
      gameContent.appendChild(cloudEffectElement);
      advanceBtn.style.display = 'block';
    }
    

    
    function createSpiralEffectScene(scene) {
      const spiralEffectElement = document.createElement('div');
      spiralEffectElement.className = 'max-w-2xl mx-auto p-6 text-left relative z-10';
      spiralEffectElement.style.minHeight = '400px';
      spiralEffectElement.style.display = 'flex';
      spiralEffectElement.style.flexDirection = 'column';
      spiralEffectElement.style.justifyContent = 'center';
      spiralEffectElement.style.alignItems = 'center';
      
      // 確保螺旋背景已經創建
      if (!document.getElementById('spiral-chapter-bg')) {
        createSpiralBackground();
      }
      
      // Add spiral animations CSS if not already present
      if (!document.getElementById('spiral-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'spiral-animations';
        styleElement.textContent = `
          @keyframes spiral-rotate {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
          }
          
          @keyframes spiral-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.9; }
          }
          
          @keyframes spiral-particle-float {
            0% { transform: translate(-50%, -50%) rotate(0deg) translateX(var(--orbit-radius)) scale(1); }
            100% { transform: translate(-50%, -50%) rotate(360deg) translateX(var(--orbit-radius)) scale(var(--end-scale)); }
          }
          
          .spiral-text {
            animation: spiral-text-float 6s infinite ease-in-out;
          }
          
          @keyframes spiral-text-float {
            0%, 100% { transform: rotate(-3deg) scale(1); }
            50% { transform: rotate(3deg) scale(1.03); }
          }
          
          @keyframes text-glow {
            0%, 100% { text-shadow: 0 0 10px rgba(147, 50, 158, 0.8), 0 0 5px rgba(80, 50, 160, 1); }
            50% { text-shadow: 0 0 20px rgba(147, 50, 158, 1), 0 0 10px rgba(80, 50, 160, 1), 0 0 30px rgba(147, 50, 158, 0.6); }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      // Create floating text effect container
      const textContainer = document.createElement('div');
      textContainer.className = 'relative z-20 p-8 rounded-lg';
      textContainer.style.background = 'transparent'; // 設置為透明背景
      textContainer.style.backdropFilter = 'none'; // 移除模糊效果以更好地顯示粒子
      textContainer.style.border = '1px solid rgba(147, 50, 158, 0.5)'; // 稍微增強邊框可見度
      textContainer.style.boxShadow = '0 0 40px rgba(147, 50, 158, 0.6)'; // 增強外發光效果
      
      // Add text with enhanced effects
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed text-white spiral-text';
      textElement.textContent = scene.text;
      textElement.style.animation = 'spiral-text-float 6s infinite ease-in-out, text-glow 4s infinite ease-in-out';
      textElement.style.fontWeight = '500';
      textElement.style.letterSpacing = '0.5px';
      
      textContainer.appendChild(textElement);
      spiralEffectElement.appendChild(textContainer);
      
      // Add some floating particles around the text
      for (let i = 0; i < 8; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full pointer-events-none';
        
        const size = 4 + Math.random() * 6;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.background = `rgba(${147 + Math.random() * 30}, ${50 + Math.random() * 30}, ${158 + Math.random() * 40}, ${0.6 + Math.random() * 0.4})`;
        particle.style.boxShadow = `0 0 ${size * 3}px rgba(147, 50, 158, 0.8)`;
        
        // Random position around the text container
        const angle = (i / 8) * Math.PI * 2;
        const distance = 100 + Math.random() * 50;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.left = `calc(50% + ${x}px)`;
        particle.style.top = `calc(50% + ${y}px)`;
        particle.style.transform = 'translate(-50%, -50%)';
        
        // Animation
        const duration = 8 + Math.random() * 12;
        const delay = Math.random() * 5;
        particle.style.animation = `spiral-particle-float ${duration}s ${delay}s infinite linear`;
        
        // Set orbit radius for animation
        particle.style.setProperty('--orbit-radius', `${30 + Math.random() * 20}px`);
        particle.style.setProperty('--end-scale', `${0.5 + Math.random() * 0.5}`);
        
        spiralEffectElement.appendChild(particle);
      }
      
      gameContent.appendChild(spiralEffectElement);
      
      // 確保顯示繼續按鈕
      setTimeout(() => {
        advanceBtn.style.display = 'block';
      }, 100);
    }
    
    // 簡化的星雲層創建函數 - 必須在使用前定義
    function createNebulaLayer(container, config) {
      const nebula = document.createElement('div');
      nebula.className = 'absolute rounded-full';
      
      // 設置位置
      if (config.position) {
        nebula.style.left = config.position.left;
        nebula.style.top = config.position.top;
        nebula.style.transform = 'translate(-50%, -50%)';
      } else {
        nebula.style.left = '50%';
        nebula.style.top = '50%';
        nebula.style.transform = 'translate(-50%, -50%)';
      }
      
      // 設置大小和外觀
      nebula.style.width = config.size;
      nebula.style.height = config.size;
      nebula.style.background = `radial-gradient(circle, ${config.colors.join(', ')})`;
      nebula.style.filter = `blur(${config.blur})`;
      
      // 設置動畫
      const rotation = config.reverse ? 'reverse' : '';
      nebula.style.animation = `nebula-rotate ${config.duration} linear infinite ${rotation}, nebula-pulse ${parseInt(config.duration) / 4}s ease-in-out infinite`;
      
      container.appendChild(nebula);
    }
    
    // 簡化的星空創建函數 - 必須在使用前定義
    function createStarField(container, count) {
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = 'absolute rounded-full';
        
        // 隨機大小和位置
        const size = 1 + Math.random() * 3;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        
        // 隨機顏色和光效
        const colors = [
          'rgba(255, 255, 255, 0.8)',
          'rgba(147, 146, 255, 0.7)', 
          'rgba(103, 200, 208, 0.6)',
          'rgba(255, 200, 150, 0.7)'
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];
        star.style.backgroundColor = color;
        star.style.boxShadow = `0 0 ${size * 3}px ${color}`;
        
        // 閃爍動畫
        const twinkleDelay = Math.random() * 5;
        const twinkleDuration = 2 + Math.random() * 4;
        star.style.animation = `star-twinkle ${twinkleDuration}s ease-in-out infinite ${twinkleDelay}s`;
        
        container.appendChild(star);
      }
    }
    
    // 創建銀河星團系統 - 圍繞中心軌道運動的星星群
    function createGalaxyStarClusters(container) {
      // 創建多個星團，每個星團有不同的軌道半徑
      const clusterCount = 6;
      
      for (let cluster = 0; cluster < clusterCount; cluster++) {
        const clusterContainer = document.createElement('div');
        clusterContainer.className = 'absolute';
        clusterContainer.style.left = '50%';
        clusterContainer.style.top = '50%';
        clusterContainer.style.transform = 'translate(-50%, -50%)';
        
        // 每個星團包含多顆星星
        const starsInCluster = 8 + Math.random() * 12;
        const orbitRadius = 100 + cluster * 80; // 不同的軌道半徑
        
        for (let star = 0; star < starsInCluster; star++) {
          const starElement = document.createElement('div');
          starElement.className = 'absolute rounded-full';
          
          // 星星大小
          const size = 1.5 + Math.random() * 2.5;
          starElement.style.width = `${size}px`;
          starElement.style.height = `${size}px`;
          
          // 星星在星團內的角度分布
          const angleInCluster = (star / starsInCluster) * Math.PI * 2;
          const radiusVariation = orbitRadius + (Math.random() - 0.5) * 40;
          
          // 設置初始位置
          const x = Math.cos(angleInCluster) * radiusVariation;
          const y = Math.sin(angleInCluster) * radiusVariation;
          
          starElement.style.left = `calc(50% + ${x}px)`;
          starElement.style.top = `calc(50% + ${y}px)`;
          starElement.style.transform = 'translate(-50%, -50%)';
          
          // 星星顏色
          const colors = [
            'rgba(255, 255, 255, 0.7)',
            'rgba(147, 146, 255, 0.6)', 
            'rgba(103, 200, 208, 0.5)',
            'rgba(255, 200, 150, 0.6)'
          ];
          const color = colors[Math.floor(Math.random() * colors.length)];
          starElement.style.backgroundColor = color;
          starElement.style.boxShadow = `0 0 ${size * 2}px ${color}`;
          
          // 設置軌道運動動畫
          starElement.style.setProperty('--orbit-radius', `${radiusVariation}px`);
          starElement.style.setProperty('--star-opacity', `${0.4 + Math.random() * 0.3}`);
          
          // 軌道運動動畫，不同星團有不同速度
          const orbitDuration = 180 + cluster * 60 + Math.random() * 120;
          const delay = Math.random() * orbitDuration;
          starElement.style.animation = `star-orbital-motion ${orbitDuration}s ${delay}s infinite linear`;
          
          clusterContainer.appendChild(starElement);
        }
        
        container.appendChild(clusterContainer);
      }
    }
    
    // 創建背景星星 - 不旋轉的遠景恆星
    function createBackgroundStars(container, count) {
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = 'absolute rounded-full pointer-events-none';
        
        // 背景星星較小且較暗
        const size = 0.5 + Math.random() * 1.5;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        
        // 使用較暗的顏色，模擬遠距離恆星
        const colors = [
          'rgba(255, 255, 255, 0.3)',
          'rgba(200, 200, 255, 0.2)', 
          'rgba(255, 200, 200, 0.25)',
          'rgba(200, 255, 200, 0.2)'
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];
        star.style.backgroundColor = color;
        star.style.boxShadow = `0 0 ${size * 2}px ${color}`;
        
        // 緩慢的閃爍動畫
        star.style.setProperty('--base-opacity', `${0.2 + Math.random() * 0.2}`);
        const twinkleDuration = 8 + Math.random() * 12;
        const delay = Math.random() * twinkleDuration;
        star.style.animation = `star-twinkle-enhanced ${twinkleDuration}s ${delay}s ease-in-out infinite`;
        
        container.appendChild(star);
      }
    }

    function createSpiralBackground() {
      // 檢查是否已存在螺旋背景，避免重複創建
      if (document.getElementById('spiral-chapter-bg')) {
        return;
      }
      
      // 創建宇宙星空背景容器
      const cosmicBackground = document.createElement('div');
      cosmicBackground.id = 'spiral-chapter-bg';
      cosmicBackground.className = 'cosmic-background';
      cosmicBackground.style.position = 'fixed';
      cosmicBackground.style.top = '0';
      cosmicBackground.style.left = '0';
      cosmicBackground.style.width = '100%';
      cosmicBackground.style.height = '100%';
      cosmicBackground.style.zIndex = '-1';
      cosmicBackground.style.overflow = 'hidden';
      
      // 設置星空漸變背景
      cosmicBackground.style.background = `
        radial-gradient(ellipse at 20% 30%, rgba(72, 61, 139, 0.6) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(75, 0, 130, 0.5) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(25, 25, 112, 0.4) 0%, transparent 60%),
        linear-gradient(135deg, #000428 0%, #004e92 25%, #483d8b 50%, #2f1b69 75%, #0f0c29 100%)
      `;
      
      // 創建星雲層
      createNebulaLayers(cosmicBackground);
      
      // 創建旋轉星空容器
      const rotatingStarfield = document.createElement('div');
      rotatingStarfield.className = 'rotating-starfield';
      rotatingStarfield.style.position = 'absolute';
      rotatingStarfield.style.width = '200%';
      rotatingStarfield.style.height = '200%';
      rotatingStarfield.style.left = '-50%';
      rotatingStarfield.style.top = '-50%';
      rotatingStarfield.style.animation = 'cosmic-rotation 300s linear infinite';
      
      // 創建多層星星
      createStarLayers(rotatingStarfield);
      
      // 創建背景星星（不旋轉）
      createBackgroundStars(cosmicBackground, 150);
      
      cosmicBackground.appendChild(rotatingStarfield);
      
      // 添加到遊戲容器
      gameContainer.appendChild(cosmicBackground);
      
      // 添加宇宙星空動畫樣式
      if (!document.getElementById('cosmic-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'cosmic-animations';
        styleElement.textContent = `
          .spiral-scene {
            background: transparent !important;
          }
          
          /* 星雲旋轉動畫 */
          @keyframes cosmic-rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          /* 星雲脈動動畫 */
          @keyframes nebula-pulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
          }
          
          /* 星星閃爍動畫 */
          @keyframes star-twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            25% { opacity: 0.8; transform: scale(1.1); }
            50% { opacity: 1; transform: scale(1.2); }
            75% { opacity: 0.6; transform: scale(1.05); }
          }
          
          /* 增強版星星閃爍 */
          @keyframes star-twinkle-enhanced {
            0%, 100% { opacity: var(--base-opacity, 0.3); transform: scale(1); }
            20% { opacity: 0.7; transform: scale(1.15); }
            40% { opacity: 1; transform: scale(1.3); }
            60% { opacity: 0.8; transform: scale(1.1); }
            80% { opacity: 0.5; transform: scale(1.05); }
          }
          
          /* 軌道運動動畫 */
          @keyframes star-orbital-motion {
            0% { transform: rotate(0deg) translateX(var(--orbit-radius)) rotate(0deg); opacity: var(--star-opacity, 0.6); }
            25% { opacity: 0.9; }
            50% { opacity: 1; }
            75% { opacity: 0.7; }
            100% { transform: rotate(360deg) translateX(var(--orbit-radius)) rotate(-360deg); opacity: var(--star-opacity, 0.6); }
          }
          
          /* 確保文字在深色背景上清晰可見 */
          .spiral-scene .text-white {
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.9), 0 0 12px rgba(147, 50, 158, 0.8), 0 0 4px rgba(0, 0, 0, 1);
            font-weight: 500;
          }
          
          .spiral-scene .text-lg,
          .spiral-scene .text-xl {
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.9), 0 0 10px rgba(147, 50, 158, 0.6), 0 0 3px rgba(0, 0, 0, 1);
            font-weight: 500;
          }
          
          /* 星空背景樣式 */
          .cosmic-background {
            will-change: transform;
          }
          
          .rotating-starfield {
            transform-origin: 50% 50%;
            will-change: transform;
          }
          
          /* 星雲樣式 */
          .cosmic-nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.4;
            animation: nebula-pulse 15s infinite ease-in-out;
          }
          
          /* 星星基礎樣式 */
          .cosmic-star {
            position: absolute;
            border-radius: 50%;
            transform-origin: center;
          }
          
          /* 黃色星星 */
          .star-yellow {
            background: radial-gradient(circle, rgba(255, 255, 150, 1) 0%, rgba(255, 215, 0, 0.8) 50%, rgba(255, 215, 0, 0) 100%);
            box-shadow: 0 0 6px rgba(255, 215, 0, 0.8), 0 0 12px rgba(255, 215, 0, 0.4);
          }
          
          /* 藍色星星 */
          .star-blue {
            background: radial-gradient(circle, rgba(173, 216, 230, 1) 0%, rgba(100, 149, 237, 0.8) 50%, rgba(100, 149, 237, 0) 100%);
            box-shadow: 0 0 6px rgba(100, 149, 237, 0.8), 0 0 12px rgba(100, 149, 237, 0.4);
          }
          
          /* 白色星星 */
          .star-white {
            background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 100%);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 255, 255, 0.4);
          }
          
          /* 紫色星星（特殊） */
          .star-purple {
            background: radial-gradient(circle, rgba(221, 160, 221, 1) 0%, rgba(147, 112, 219, 0.8) 50%, rgba(147, 112, 219, 0) 100%);
            box-shadow: 0 0 6px rgba(147, 112, 219, 0.8), 0 0 12px rgba(147, 112, 219, 0.4);
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建星雲層
    function createNebulaLayers(container) {
      const nebulaConfigs = [
        {
          size: '400px',
          position: { left: '15%', top: '20%' },
          colors: ['rgba(72, 61, 139, 0.3)', 'rgba(123, 104, 238, 0.2)', 'transparent'],
          blur: '25px',
          duration: '20s'
        },
        {
          size: '350px',
          position: { left: '70%', top: '60%' },
          colors: ['rgba(75, 0, 130, 0.4)', 'rgba(138, 43, 226, 0.2)', 'transparent'],
          blur: '30px',
          duration: '25s',
          reverse: true
        },
        {
          size: '300px',
          position: { left: '40%', top: '80%' },
          colors: ['rgba(25, 25, 112, 0.3)', 'rgba(65, 105, 225, 0.2)', 'transparent'],
          blur: '20px',
          duration: '30s'
        },
        {
          size: '250px',
          position: { left: '80%', top: '15%' },
          colors: ['rgba(147, 50, 158, 0.3)', 'rgba(186, 85, 211, 0.2)', 'transparent'],
          blur: '18px',
          duration: '35s',
          reverse: true
        }
      ];
      
      nebulaConfigs.forEach((config, index) => {
        createNebulaLayer(container, config);
      });
    }
    
    // 創建多層星星
    function createStarLayers(container) {
      // 內層星團 - 較大較亮的星星
      createGalaxyStarClusters(container);
      
      // 中層散佈星星
      createRandomStars(container, 80, 'medium');
      
      // 外層小星星
      createRandomStars(container, 120, 'small');
    }
    
    // 創建隨機分佈的星星
    function createRandomStars(container, count, size) {
      const colors = ['star-yellow', 'star-blue', 'star-white', 'star-purple'];
      const sizeMap = {
        small: { min: 1, max: 3 },
        medium: { min: 2, max: 5 },
        large: { min: 4, max: 8 }
      };
      
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = `cosmic-star ${colors[Math.floor(Math.random() * colors.length)]}`;
        
        // 隨機大小
        const starSize = sizeMap[size];
        const starWidth = starSize.min + Math.random() * (starSize.max - starSize.min);
        star.style.width = `${starWidth}px`;
        star.style.height = `${starWidth}px`;
        
        // 隨機位置 - 避免太靠近中心
        let x, y, distanceFromCenter;
        do {
          x = Math.random() * 100;
          y = Math.random() * 100;
          distanceFromCenter = Math.sqrt(Math.pow(x - 50, 2) + Math.pow(y - 50, 2));
        } while (distanceFromCenter < 15); // 確保不會太靠近中心
        
        star.style.left = `${x}%`;
        star.style.top = `${y}%`;
        
        // 隨機閃爍動畫
        const twinkleDuration = 3 + Math.random() * 8;
        const twinkleDelay = Math.random() * 10;
        star.style.animation = `star-twinkle ${twinkleDuration}s ${twinkleDelay}s infinite ease-in-out`;
        
        container.appendChild(star);
      }
    }
    
    // 特別設置一個函數來創建並顯示蝸牛
    function createSnailAndKingdoms() {
      // 檢查是否已經存在蝸牛，避免重複創建
      if (document.querySelector('.snail-shell')) {
        return;
      }
      
      // 创建一个完整蜗牛的几何背景
      const snailShellContainer = document.createElement('div');
      snailShellContainer.className = 'absolute pointer-events-none';
      snailShellContainer.style.width = '100%';
      snailShellContainer.style.height = '100%';
      snailShellContainer.style.overflow = 'hidden';
      snailShellContainer.style.zIndex = '1';
      
      // 创建emoji蜗牛
      const snailShell = document.createElement('div');
      snailShell.className = 'snail-shell';
      
      // 基础蜗牛元素 - 使用emoji
      const snailElement = document.createElement('div');
      snailElement.className = 'snail-emoji';
      snailElement.style.position = 'relative';
      snailElement.style.width = '200px';
      snailElement.style.height = '200px';
      snailElement.style.fontSize = '180px';
      snailElement.style.display = 'flex';
      snailElement.style.alignItems = 'center';
      snailElement.style.justifyContent = 'center';
      snailElement.style.filter = 'drop-shadow(0 0 10px rgba(147, 50, 158, 0.4))';
      snailElement.style.transition = 'all 0.5s ease';
      snailElement.textContent = '🐌';
      
      // 创建触角眼睛定位标记（不可见，仅用于定位）
      const leftEyeMarker = document.createElement('div');
      leftEyeMarker.id = 'left-eye-marker';
      leftEyeMarker.style.position = 'absolute';
      leftEyeMarker.style.width = '8px';
      leftEyeMarker.style.height = '8px';
      leftEyeMarker.style.borderRadius = '50%';
      leftEyeMarker.style.background = 'transparent'; // 透明，不可见
      leftEyeMarker.style.left = '60px';  // 調整到左觸角眼睛位置
      leftEyeMarker.style.top = '25px';   // 調整高度
      leftEyeMarker.style.zIndex = '10';
      
      const rightEyeMarker = document.createElement('div');
      rightEyeMarker.id = 'right-eye-marker';
      rightEyeMarker.style.position = 'absolute';
      rightEyeMarker.style.width = '8px';
      rightEyeMarker.style.height = '8px';
      rightEyeMarker.style.borderRadius = '50%';
      rightEyeMarker.style.background = 'transparent'; // 透明，不可见
      rightEyeMarker.style.left = '85px'; // 調整到右觸角眼睛位置
      rightEyeMarker.style.top = '25px';  // 調整高度
      rightEyeMarker.style.zIndex = '10';
      
      snailElement.appendChild(leftEyeMarker);
      snailElement.appendChild(rightEyeMarker);
      
      // 创建蜗牛王国容器
      const kingdomsContainer = document.createElement('div');
      kingdomsContainer.className = 'kingdoms-container';
      kingdomsContainer.style.position = 'absolute';
      kingdomsContainer.style.top = 0;
      kingdomsContainer.style.left = 0;
      kingdomsContainer.style.width = '100%';
      kingdomsContainer.style.height = '100%';
      kingdomsContainer.style.pointerEvents = 'none';
      
      // 创建左触角王国（触氏国）- 使用相对于蜗牛的精确位置
      const touchKingdom = document.createElement('div');
      touchKingdom.className = 'kingdom-circle';
      touchKingdom.id = 'touch-kingdom-circle';
      touchKingdom.style.position = 'absolute'; // 使用absolute定位相对于蜗牛
      touchKingdom.style.width = '24px'; // 擴大一倍的大小
      touchKingdom.style.height = '24px';
      touchKingdom.style.borderRadius = '50%';
      touchKingdom.style.backgroundColor = '#aa6ed8'; // 添加紫色系，代表触氏国
      touchKingdom.style.border = '2px solid rgba(170, 120, 220, 0.8)'; // 添加明亮的边框
      // 使用精確的相對于蜗牛中心的坐标，整體向左上方偏移21px (-80, -80)
      touchKingdom.style.left = 'calc(50% + -80px - 6px)'; // 相对坐标 X - 圆点半径
      touchKingdom.style.top = 'calc(50% + -80px - 6px)'; // 相对坐标 Y - 圆点半径
      touchKingdom.style.transform = 'none'; // 不使用transform避免双重偏移
      touchKingdom.style.zIndex = '11';
      touchKingdom.style.cursor = 'pointer';
      touchKingdom.style.pointerEvents = 'auto';
      // 添加吸引人的脉冲发光效果
      touchKingdom.style.boxShadow = '0 0 8px rgba(170, 120, 220, 0.7), 0 0 12px rgba(170, 120, 220, 0.4)';
      touchKingdom.style.animation = 'touch-pulse 3s infinite ease-in-out';
      touchKingdom.innerHTML = '<span style="position:absolute; top:-25px; left:50%; transform:translateX(-50%); white-space:nowrap; font-size:12px; background:rgba(0,0,0,0.6); color:white; padding:2px 6px; border-radius:3px; opacity:0; transition:opacity 0.3s ease;">觸氏國</span>';
      
      // 添加悬停效果
      touchKingdom.addEventListener('mouseenter', () => {
        touchKingdom.querySelector('span').style.opacity = '1';
        // 强调高亮显示
        touchKingdom.style.border = '2px solid rgba(190, 140, 240, 1)';
        touchKingdom.style.boxShadow = '0 0 12px rgba(170, 120, 220, 0.9), 0 0 20px rgba(170, 120, 220, 0.6)';
        touchKingdom.style.transform = 'scale(1.1)'; // 轻微放大
      });
      touchKingdom.addEventListener('mouseleave', () => {
        touchKingdom.querySelector('span').style.opacity = '0';
        // 恢复原始状态
        touchKingdom.style.border = '2px solid rgba(170, 120, 220, 0.8)';
        touchKingdom.style.boxShadow = '0 0 8px rgba(170, 120, 220, 0.7), 0 0 12px rgba(170, 120, 220, 0.4)';
        touchKingdom.style.transform = 'scale(1)';
      });
      
      // 添加拖拽功能
      makeDraggable(touchKingdom, 'touch-kingdom-circle');
      
      // 创建右触角王国（蛮氏国）- 使用相对于蜗牛的精确位置，整體向左上方偏移10px
      const savageKingdom = document.createElement('div');
      savageKingdom.className = 'kingdom-circle';
      savageKingdom.id = 'savage-kingdom-circle';
      savageKingdom.style.position = 'absolute'; // 使用absolute定位相对于蜗牛
      savageKingdom.style.width = '24px'; // 擴大一倍的大小
      savageKingdom.style.height = '24px';
      savageKingdom.style.borderRadius = '50%';
      savageKingdom.style.backgroundColor = '#357ec7'; // 蓝色系，代表蛮氏国
      savageKingdom.style.border = '2px solid rgba(120, 220, 250, 0.8)'; // 添加明亮的边框
      // 使用精确的相对于蜗牛中心的坐标，整體向左上方偏移20.5px (-57, -79.5)
      savageKingdom.style.left = 'calc(50% + -57px - 6px)'; // 相对坐标 X - 圆点半径
      savageKingdom.style.top = 'calc(50% + -79.5px - 6px)'; // 相对坐标 Y - 圆点半径
      savageKingdom.style.transform = 'none'; // 不使用transform避免双重偏移
      savageKingdom.style.zIndex = '11';
      savageKingdom.style.cursor = 'pointer';
      savageKingdom.style.pointerEvents = 'auto';
      // 添加吸引人的脉冲发光效果
      savageKingdom.style.boxShadow = '0 0 8px rgba(53, 126, 199, 0.7), 0 0 12px rgba(53, 126, 199, 0.4)';
      savageKingdom.style.animation = 'savage-pulse 3s infinite ease-in-out';
      savageKingdom.innerHTML = '<span style="position:absolute; top:-25px; left:50%; transform:translateX(-50%); white-space:nowrap; font-size:12px; background:rgba(0,0,0,0.6); color:white; padding:2px 6px; border-radius:3px; opacity:0; transition:opacity 0.3s ease;">蠻氏國</span>';
      
      // 添加悬停效果
      savageKingdom.addEventListener('mouseenter', () => {
        savageKingdom.querySelector('span').style.opacity = '1';
        // 强调高亮显示
        savageKingdom.style.border = '2px solid rgba(120, 220, 250, 1)';
        savageKingdom.style.boxShadow = '0 0 12px rgba(53, 126, 199, 0.9), 0 0 20px rgba(53, 126, 199, 0.6)';
        savageKingdom.style.transform = 'scale(1.1)'; // 轻微放大
      });
      savageKingdom.addEventListener('mouseleave', () => {
        savageKingdom.querySelector('span').style.opacity = '0';
        // 恢复原始状态
        savageKingdom.style.border = '2px solid rgba(120, 220, 250, 0.8)';
        savageKingdom.style.boxShadow = '0 0 8px rgba(53, 126, 199, 0.7), 0 0 12px rgba(53, 126, 199, 0.4)';
        savageKingdom.style.transform = 'scale(1)';
      });
      
      // 添加拖拽功能
      makeDraggable(savageKingdom, 'savage-kingdom-circle');
      
      // 装配王国元素
      kingdomsContainer.appendChild(touchKingdom);
      kingdomsContainer.appendChild(savageKingdom);
      
      // 创建视角指示器
      const perspectiveIndicator = document.createElement('div');
      perspectiveIndicator.className = 'snail-perspective-indicator';
      perspectiveIndicator.id = 'snail-perspective-indicator';
      perspectiveIndicator.style.position = 'absolute';
      perspectiveIndicator.style.width = '100%';
      perspectiveIndicator.style.height = '100%';
      perspectiveIndicator.style.display = 'flex';
      perspectiveIndicator.style.justifyContent = 'center';
      perspectiveIndicator.style.alignItems = 'center';
      perspectiveIndicator.style.color = 'rgba(255, 255, 255, 0.7)';
      perspectiveIndicator.style.fontSize = '24px';
      perspectiveIndicator.style.zIndex = '1';
      perspectiveIndicator.style.opacity = '0';
      perspectiveIndicator.style.transition = 'opacity 0.5s ease';
      perspectiveIndicator.innerHTML = `
        <div class="text-center">
          <div class="font-bold text-2xl mb-2">微觀視角</div>
          <div class="text-sm opacity-75">你看到了蝸牛角上的國家</div>
        </div>
      `;
      
      // 添加所有元素到蜗牛容器
      snailShell.appendChild(snailElement);
      snailShell.appendChild(kingdomsContainer);
      snailShell.appendChild(perspectiveIndicator);
      
      // 创建左触角国家 - 触氏国
      const leftKingdom = document.createElement('div');
      leftKingdom.className = 'kingdom left';
      leftKingdom.innerHTML = `
        <div class="kingdom-label">觸氏國</div>
      `;
      
      // 创建右触角国家 - 蛮氏国
      const rightKingdom = document.createElement('div');
      rightKingdom.className = 'kingdom right';
      rightKingdom.innerHTML = `
        <div class="kingdom-label">蠻氏國</div>
      `;
      
      // 检查是否已存在视角指示器，如果不存在才创建
      let viewIndicator = document.getElementById('snail-perspective-indicator');
      if (!viewIndicator) {
        viewIndicator = document.createElement('div');
        viewIndicator.className = 'snail-perspective-indicator';
        viewIndicator.id = 'snail-perspective-indicator';
        viewIndicator.innerHTML = `
          <div class="text-center">
            <div class="font-bold text-2xl mb-2">微观视角</div>
            <div class="text-sm opacity-75">使用右侧控制器调整视角</div>
          </div>
        `;
      }
      
      // 添加到容器
      snailShellContainer.appendChild(snailShell);
      snailShellContainer.appendChild(leftKingdom);
      snailShellContainer.appendChild(rightKingdom);
      snailShellContainer.appendChild(perspectiveIndicator);
      
      // 添加到游戏容器
      gameContainer.appendChild(snailShellContainer);
      
      // 添加蝸牛出現動畫
      snailShell.style.opacity = '0';
      snailShell.style.transform = 'translate(-50%, -50%) scale(0.5)';
      
      // 使用動畫讓蝸牛出現
      setTimeout(() => {
        snailShell.style.opacity = '0.85';
        snailShell.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 100);
      

    }
    
    // 創建蝸牛視角特效
    function createSnailPerspectiveEffect() {
      // 蝸牛視角的獨特視覺效果 - 承載者的緩慢視角
      gameContainer.style.transform = 'scale(0.92)';
      gameContainer.style.filter = 'sepia(0.3) saturate(1.3) contrast(1.1) brightness(0.9)'; // 暖色調濾鏡
      
      // 創建蝸牛視角的邊框效果，模擬從蝸牛眼中看出去的感覺
      const snailVisionOverlay = document.createElement('div');
      snailVisionOverlay.id = 'snail-vision-overlay';
      snailVisionOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        background: radial-gradient(ellipse at center, transparent 40%, rgba(139, 69, 19, 0.3) 60%, rgba(101, 67, 33, 0.5) 80%, rgba(62, 39, 35, 0.8) 95%);
        border-radius: 50%;
        transform: scale(1.2);
        animation: snail-vision-breathe 8s infinite ease-in-out;
      `;
      
      // 添加蝸牛視角的粒子效果，模擬空氣中的濕度和微粒
      const particleContainer = document.createElement('div');
      particleContainer.className = 'snail-vision-particles';
      particleContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
      `;
      
      // 創建濕度粒子效果
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement('div');
        particle.style.cssText = `
          position: absolute;
          width: ${2 + Math.random() * 4}px;
          height: ${2 + Math.random() * 4}px;
          background: rgba(135, 206, 235, 0.4);
          border-radius: 50%;
          left: ${Math.random() * 100}%;
          top: ${Math.random() * 100}%;
          animation: snail-particle-float ${8 + Math.random() * 4}s infinite ease-in-out;
          animation-delay: ${Math.random() * 5}s;
        `;
        particleContainer.appendChild(particle);
      }
      
      snailVisionOverlay.appendChild(particleContainer);
      document.body.appendChild(snailVisionOverlay);
      
      // 添加相應的CSS動畫
      if (!document.getElementById('snail-vision-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'snail-vision-styles';
        styleElement.textContent = `
          @keyframes snail-vision-breathe {
            0%, 100% { 
              transform: scale(1.18); 
              opacity: 0.7; 
            }
            50% { 
              transform: scale(1.22); 
              opacity: 0.9; 
            }
          }
          
          @keyframes snail-particle-float {
            0%, 100% { 
              transform: translate(0, 0) scale(1); 
              opacity: 0.2; 
            }
            25% { 
              transform: translate(${-20 + Math.random() * 40}px, ${-15 + Math.random() * 30}px) scale(1.2); 
              opacity: 0.6; 
            }
            50% { 
              transform: translate(${-10 + Math.random() * 20}px, ${-25 + Math.random() * 50}px) scale(0.8); 
              opacity: 0.3; 
            }
            75% { 
              transform: translate(${-30 + Math.random() * 60}px, ${-10 + Math.random() * 20}px) scale(1.1); 
              opacity: 0.5; 
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 移除蝸牛視角效果
    function removeSnailPerspectiveEffect() {
      const snailVisionOverlay = document.getElementById('snail-vision-overlay');
      if (snailVisionOverlay) {
        snailVisionOverlay.remove();
      }
      
      // 恢復正常視角
      gameContainer.style.transform = '';
      gameContainer.style.filter = '';
    }
    
    // 清理第四章特定的視覺元素
    function cleanupChapter4Effects() {
      // 移除蝸牛相關元素
      document.querySelectorAll('.snail-shell, .kingdom-left, .kingdom-right, .kingdom-label, .kingdom-building').forEach(el => el.remove());
      
      // 移除螺旋背景效果
      document.querySelectorAll('.spiral-container, .spiral-effect, .spiral-particle').forEach(el => el.remove());
      
      // 移除視角指示器（宏觀視角/微觀視角文字）
      const scaleIndicator = document.getElementById('snail-perspective-indicator');
      if (scaleIndicator) {
        scaleIndicator.remove();
      }
      
      // 移除並禁用視角控制器
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.remove();
      }
      disableScaleControl();
      
      // 重置視角縮放值
      gameState.viewScale = 100;
      
      // 移除蝸牛視角效果
      removeSnailPerspectiveEffect();
      
      // 重置gameContainer的變換和濾鏡
      gameContainer.style.transform = 'scale(1)';
      gameContainer.style.filter = 'none';
      
      console.log('第四章視覺元素已清理完成');
    }
    
    // 清理第五章特定的視覺元素
    function cleanupChapter5Effects() {
      // 移除時間森林相關的視覺效果
      document.querySelectorAll('.time-particle, .time-wave, .time-glow').forEach(el => el.remove());
      
      // 移除時間感知相關的覆蓋層效果
      document.querySelectorAll('.time-overlay, .time-vision-effect').forEach(el => el.remove());
      
      // 重置gameContainer的時間相關變換和濾鏡
      gameContainer.style.filter = 'none';
      gameContainer.style.transform = 'scale(1)';
      
      // 清理時間森林背景特效
      const timeEffects = document.querySelectorAll('.amber-glow, .forest-shimmer');
      timeEffects.forEach(effect => effect.remove());
      
      console.log('第五章視覺元素已清理完成');
    }
    
    // 創建蝸牛視角過渡場景
    function createSnailPerspectiveTransitionScene(scene) {
      const transitionElement = document.createElement('div');
      transitionElement.className = 'max-w-2xl mx-auto p-6 text-left fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-purple-200 dark:border-purple-700 z-50';
      
      transitionElement.innerHTML = `
        <p class="text-lg md:text-xl leading-relaxed mb-6">${scene.text}</p>
        <div class="text-sm text-gray-600 dark:text-gray-400">視角轉換中...</div>
      `;
      
      gameContent.appendChild(transitionElement);
      
      // 開始視角轉換動畫
      setTimeout(() => {
        // 移除蝸牛視角效果
        removeSnailPerspectiveEffect();
        
        // 創建過渡動畫
        transitionElement.style.transform = 'translate(-50%, -50%) scale(0.8)';
        transitionElement.style.opacity = '0.5';
        
        setTimeout(() => {
          // 創建蝸牛實體和視角系統
          createSnailAndKingdoms();
          enableScaleControl();
          
          // 移除過渡元素
          transitionElement.remove();
          
          // 顯示繼續按鈕
          advanceBtn.style.display = 'block';
        }, 1500);
      }, 2000);
    }
    
    function createDialogScene(scene) {
      dialogText.textContent = scene.text;
      
      // 使用統一的文字顏色：亮色模式用深色文字，暗色模式用淺色文字
      dialogText.className = 'text-gray-800 dark:text-gray-200';
      
      if (scene.speaker) {
        dialogText.innerHTML = `<strong>${scene.speaker}：</strong> ${scene.text}`;
      }
      
      // 检查是否有蜗牛存在，或者是第五章（时间森林），或者是第六章（天地場景）
      const hasSnail = document.querySelector('.snail-shell');
      const isTimeChapter = gameState.currentChapter === 'chapter5';
      const isHeavenEarthChapter = gameState.currentChapter === 'chapter6';
      
      if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
        dialogBox.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-3xl bg-white dark:bg-gray-800 border-2 border-indigo-600 dark:border-indigo-500 rounded-lg p-4 shadow-lg bg-opacity-95 dark:bg-opacity-95';
        dialogBox.style.zIndex = isHeavenEarthChapter ? '9999' : '30'; // 第六章使用極高的z-index確保在最上層
        dialogBox.style.pointerEvents = 'auto'; // 確保對話框可以接收點擊事件
      } else {
        dialogBox.className = 'absolute top-1/2 left-0 right-0 mx-auto max-w-3xl -translate-y-1/2 bg-white dark:bg-gray-800 border-2 border-indigo-600 dark:border-indigo-500 rounded-lg p-4 shadow-lg opacity-0 transition-all duration-300 transform';
      }
      
      // Handle dialog options if present
      if (scene.options && scene.options.length > 0) {
        // 第六章需要確保對話選項容器可以接收點擊事件
        if (isHeavenEarthChapter) {
          dialogOptions.style.pointerEvents = 'auto';
          dialogOptions.style.zIndex = '10000';
        }
        
        // 開始計時選擇思考時間
        startChoiceTimer();
        
        scene.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.className = 'bg-indigo-100 hover:bg-indigo-200 dark:bg-indigo-900 dark:hover:bg-indigo-800 text-indigo-800 dark:text-indigo-200 font-semibold py-2 px-4 rounded text-left relative';
          button.style.zIndex = isHeavenEarthChapter ? '10001' : '102'; // 第六章使用超高z-index確保選項按鈕可點擊
          button.style.pointerEvents = 'auto'; // 確保按鈕可以接收點擊事件
          button.textContent = option.text;
          button.addEventListener('click', () => {
            // 記錄玩家選擇（在場景切換之前）
            const choiceData = {
              text: option.text,
              index: index,
              speaker: scene.speaker || 'unknown',
              situation: getCurrentSituation()
            };
            
            // 處理新的分層特質結構或舊的扁平結構
            if (option.traits) {
              if (option.traits.philosophical || option.traits.mbti || option.traits.story) {
                // 新的分層結構
                choiceData.philosophical = option.traits.philosophical || {};
                choiceData.mbti = option.traits.mbti || {};
                choiceData.story = option.traits.story || {};
              } else {
                // 舊的扁平結構，轉換為新結構
                choiceData.philosophical = option.traits;
                choiceData.mbti = {};
                choiceData.story = {};
              }
            } else {
              // 使用智能特質提取
              console.log('🔍 ===== 選擇處理調試信息 (對話場景) =====');
              console.log('📝 選擇文本:', option.text);
              console.log('🎭 說話者:', scene.speaker);
              console.log('📚 章節:', gameState.currentChapter);
              
              const extractedTraits = extractTraitsFromChoice(option.text, scene.speaker, gameState.currentChapter);
              
              console.log('🧠 提取的特質結構:', extractedTraits);
              console.log('  哲學特質:', extractedTraits.philosophical);
              console.log('  故事特質:', extractedTraits.story);
              
              // 正確處理結構化特質數據
              choiceData.philosophical = extractedTraits.philosophical || {};
              choiceData.mbti = {};
              choiceData.story = extractedTraits.story || {};
              
              console.log('✅ 最終選擇數據:', choiceData);
              console.log('========================================');
            }
            
            recordPlayerChoice(choiceData);
            
            // 原有的場景切換邏輯
            gameState.currentScene = option.next;
            loadScene();
          });
          dialogOptions.appendChild(button);
        });
        
        // Don't show advance button for options
        advanceBtn.style.display = 'none';
      } else {
        advanceBtn.style.display = 'block';
      }
      
      dialogBox.style.opacity = 1;
      if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
        dialogBox.style.transform = 'translateX(-50%)';
      } else {
        dialogBox.style.transform = 'translateY(0)';
      }
    }
    
    function createSegmentationPuzzle(scene) {
      // 在斷句界面時，降低混沌的層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.add('segmentation-mode');
      }
      
      // 在第六章斷句挑戰出現時，清空浮現的古老文字效果，並標記為已禁用
      if (gameState.currentChapter === 'chapter6') {
        document.querySelectorAll('.floating-ancient-text').forEach(el => el.remove());
        // 設置標記，禁止後續再創建浮動古老文字
        gameState.chapter6FloatingTextDisabled = true;
      }
      
      // Reset puzzle state
      gameState.segmentationPuzzleState = {
        solved: false,
        segments: new Array(scene.text.length - 1).fill(false)
      };
      
      // Fix CSS selector issue with previous circles
      document.querySelectorAll('.segment-gap.active').forEach(el => {
        el.classList.remove('active');
      });
      
      const puzzleContainer = document.createElement('div');
      
      // 根據章節設置不同的樣式
      if (gameState.currentChapter === 'chapter4') {
        // 第四章使用螺旋效果的樣式
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center relative z-10 rounded-xl';
        puzzleContainer.style.background = 'transparent'; // 透明背景以顯示粒子
        puzzleContainer.style.border = '1px solid rgba(147, 50, 158, 0.5)';
        puzzleContainer.style.boxShadow = '0 0 40px rgba(147, 50, 158, 0.6)';
        puzzleContainer.style.minHeight = '400px';
        puzzleContainer.style.display = 'flex';
        puzzleContainer.style.flexDirection = 'column';
        puzzleContainer.style.justifyContent = 'center';
        puzzleContainer.style.alignItems = 'center';
      } else if (gameState.currentChapter === 'chapter6') {
        // 第六章使用特殊樣式，創建獨立的頂層懸浮視窗，背景透明，位置向下移動
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center rounded-xl shadow-lg';
        puzzleContainer.style.position = 'fixed'; // 使用fixed定位脫離父容器
        puzzleContainer.style.top = '60%'; // 從50%改為60%，向下移動
        puzzleContainer.style.left = '50%';
        puzzleContainer.style.transform = 'translate(-50%, -50%)';
        puzzleContainer.style.zIndex = '9999'; // 使用極高的z-index確保在所有元素之上
        puzzleContainer.style.maxHeight = '80vh';
        puzzleContainer.style.overflowY = 'auto';
        puzzleContainer.style.width = '90%';
        puzzleContainer.style.maxWidth = '800px';
        puzzleContainer.style.background = 'transparent'; // 設置為透明背景
        puzzleContainer.style.backdropFilter = 'none'; // 移除背景模糊效果
      } else if (gameState.currentChapter === 'chapter7') {
        // 第七章道歸混沌使用透明背景樣式，但確保最高z-index
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center rounded-xl';
        puzzleContainer.style.background = 'transparent'; // 透明背景
        puzzleContainer.style.backdropFilter = 'none'; // 移除背景模糊效果
        puzzleContainer.style.border = 'none'; // 移除邊框
        puzzleContainer.style.boxShadow = 'none'; // 移除陰影
        puzzleContainer.style.position = 'relative'; // 確保z-index生效
        puzzleContainer.style.zIndex = '20000'; // 使用超高z-index確保在氣視覺效果和所有其他元素之上
      } else if (gameState.currentChapter === 'epilogue') {
        // 尾聲章節使用垂直居中樣式
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center rounded-xl';
        puzzleContainer.style.position = 'fixed';
        puzzleContainer.style.top = '50%';
        puzzleContainer.style.left = '50%';
        puzzleContainer.style.transform = 'translate(-50%, -50%)';
        puzzleContainer.style.zIndex = '9999';
        puzzleContainer.style.background = 'rgba(255, 255, 255, 0.9)';
        puzzleContainer.style.border = '2px solid rgba(139, 69, 19, 0.3)';
        puzzleContainer.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.15)';
        puzzleContainer.style.backdropFilter = 'blur(8px)';
      } else {
        // 其他章節使用原有樣式
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center bg-white dark:bg-gray-800 bg-opacity-80 dark:bg-opacity-80 rounded-xl shadow-lg';
      }
      
      // For chapter 2, add special cloud effects
      if (gameState.currentChapter === 'chapter2') {
        // Create a cloud-themed container
        puzzleContainer.classList.add('relative', 'overflow-hidden');
        puzzleContainer.style.borderRadius = '1rem';
        
        // Add cloud top
        const cloudTop = document.createElement('div');
        cloudTop.className = 'absolute top-0 left-0 w-full h-10 opacity-80';
        cloudTop.style.background = 'linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0))';
        puzzleContainer.appendChild(cloudTop);
        
        // Add cloud bottom
        const cloudBottom = document.createElement('div');
        cloudBottom.className = 'absolute bottom-0 left-0 w-full h-10 opacity-80';
        cloudBottom.style.background = 'linear-gradient(to top, rgba(255,255,255,0.9), rgba(255,255,255,0))';
        puzzleContainer.appendChild(cloudBottom);
        
        // Add cloud animation keyframes if not already present
        if (!document.getElementById('cloud-animations')) {
          const styleElement = document.createElement('style');
          styleElement.id = 'cloud-animations';
          styleElement.textContent = `
            @keyframes cloudMove {
              0% { background-position-x: 0; }
              100% { background-position-x: 1000px; }
            }
            
            @keyframes float-cloud-particle {
              0%, 100% { transform: translateY(0); }
              50% { transform: translateY(-20px); }
            }
            
            @keyframes drift-char {
              0%, 100% { transform: translateY(0) rotate(0deg); }
              25% { transform: translateY(-3px) rotate(1deg); }
              75% { transform: translateY(3px) rotate(-1deg); }
            }
            
            .cloud-char {
              display: inline-block;
              animation: drift-char 5s infinite ease-in-out;
            }
          `;
          document.head.appendChild(styleElement);
        }
        
        // Add some floating cloud particles
        for (let i = 0; i < 10; i++) {
          const cloudParticle = document.createElement('div');
          const size = 20 + Math.random() * 40;
          cloudParticle.className = 'absolute rounded-full bg-white dark:bg-gray-300 bg-opacity-60 dark:bg-opacity-40 pointer-events-none';
          cloudParticle.style.width = size + 'px';
          cloudParticle.style.height = size + 'px';
          cloudParticle.style.filter = 'blur(8px)';
          cloudParticle.style.left = Math.random() * 100 + '%';
          cloudParticle.style.top = Math.random() * 80 + 10 + '%';
          cloudParticle.style.animation = `float-cloud-particle ${8 + Math.random() * 7}s infinite ease-in-out ${Math.random() * 5}s`;
          cloudParticle.style.zIndex = '1';
          puzzleContainer.appendChild(cloudParticle);
        }
      }
      
      // Create hint
      const hintElement = document.createElement('p');
      // 根據章節設置不同的文字顏色
      let hintTextColor;
      if (gameState.currentChapter === 'chapter7') {
        // 第七章使用淺色文字以在深色背景中更明顯
        hintTextColor = 'text-gray-600 dark:text-gray-300';
      } else if (gameState.currentChapter === 'epilogue') {
        // 尾聲章節使用黑色文字以在白色背景中更明顯
        hintTextColor = 'text-black';
      } else {
        // 其他章節使用默認顏色
        hintTextColor = 'text-gray-600 dark:text-gray-300';
      }
      hintElement.className = `text-sm ${hintTextColor} mb-6 relative z-10 text-left`;
      
      // 添加斷句位置數量提示
      const segmentCount = scene.solution.length;
      const baseHint = scene.hint || '仔細閱讀這段古文，理解其含義並找出正確的斷句位置。';
      const enhancedHint = baseHint + ` 本文共有 <span class="inline-block px-2 py-1 bg-indigo-100 dark:bg-indigo-800 text-indigo-800 dark:text-indigo-200 rounded-md font-bold text-base">${segmentCount}</span> 個斷句位置。`;
      
      hintElement.innerHTML = enhancedHint;
      puzzleContainer.appendChild(hintElement);
      
      // Create text segment container
      const textContainer = document.createElement('div');
      // 根據章節設置不同的文字顏色
      let textColor;
      if (gameState.currentChapter === 'chapter7') {
        // 第七章使用淺色文字以在深色背景中更明顯
        textColor = 'text-gray-800 dark:text-gray-200';
      } else if (gameState.currentChapter === 'epilogue') {
        // 尾聲章節使用黑色文字以在白色背景中更明顯
        textColor = 'text-black';
      } else {
        // 其他章節使用默認顏色
        textColor = 'text-gray-800 dark:text-gray-200';
      }
      textContainer.className = `text-segment-container text-2xl ${scene.textStyle} ${textColor} relative`;
      textContainer.style.zIndex = gameState.currentChapter === 'chapter7' ? '15002' : '10';
      
      // Define a fixed width for characters to maintain precise gap positioning
      const CHAR_WIDTH = 30; // Fixed width for each character
      
      // Create text characters and gaps with absolute positioning for precise control
      scene.text.split('').forEach((char, index) => {
        // Add character with fixed width
        const charSpan = document.createElement('span');
        charSpan.className = 'text-char';
        charSpan.style.display = 'inline-block';
        charSpan.style.width = `${CHAR_WIDTH}px`; // Fixed width for consistent spacing
        charSpan.style.textAlign = 'center'; // Center the text within the fixed width
        
        // For Chapter 2 (cloud), add cloud-specific animation to each character
        if (gameState.currentChapter === 'chapter2') {
          charSpan.classList.add('cloud-char');
          // Add slight delay variation for more natural cloud movement
          charSpan.style.animationDelay = (index * 0.08) % 1 + 's';
        }
        

        
        // Apply consistent styling for precise character spacing
        charSpan.style.margin = '0';
        charSpan.style.padding = '0';
        
        charSpan.textContent = char;
        textContainer.appendChild(charSpan);
        
        // Add gap after character (except for the last character)
        if (index < scene.text.length - 1) {
          // Create a completely revised character gap with more precise positioning
          const charGap = document.createElement('div');
          charGap.className = 'char-gap';
          
          // Changed from inline-block to absolute positioning for precise control
          charGap.style.display = 'inline-block';
          charGap.style.width = '18px'; // Narrower gap to ensure it's right between characters
          charGap.style.height = '1.75em'; // Match text height
          charGap.style.position = 'relative';
          charGap.style.verticalAlign = 'middle';
          charGap.style.cursor = 'pointer';
          charGap.style.marginLeft = '-6px'; // 左移6px修正偏右问题
          charGap.style.marginBottom = '2px'; // 轻微上移以确保垂直居中
          charGap.style.zIndex = gameState.currentChapter === 'chapter6' ? '5' : (gameState.currentChapter === 'chapter7' ? '15005' : '45'); // 第七章使用超高z-index確保可點擊
          
          // Create the perfectly centered dot with improved positioning
          const dot = document.createElement('span');
          dot.className = 'segment-dot';
          dot.dataset.index = index;
          dot.style.position = 'absolute';
          dot.style.width = '10px';
          dot.style.height = '10px'; 
          dot.style.borderRadius = '50%';
          dot.style.backgroundColor = '#4F46E5';
          dot.style.opacity = gameState.segmentationPuzzleState.segments[index] ? '1' : '0';
          dot.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
          dot.style.boxShadow = '0 0 8px 2px rgba(79, 70, 229, 0.7)';
          
          // Force exact centered positioning with explicit transform
          dot.style.top = 'calc(50% - 1px)'; // 微调垂直位置以完全居中
          dot.style.left = '50%';
          dot.style.transform = 'translate(-50%, -50%)';
          dot.style.margin = '0';
          dot.style.padding = '0';
          dot.style.zIndex = gameState.currentChapter === 'chapter6' ? '10' : (gameState.currentChapter === 'chapter7' ? '15010' : '50'); // 第七章使用超高z-index確保可見
          
          // Add click-ripple animation
          if (!document.getElementById('click-ripple-animation')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'click-ripple-animation';
            styleEl.textContent = `
              @keyframes click-ripple {
                0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
                100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
              }
            `;
            document.head.appendChild(styleEl);
          }
          
          // Add hover effect animation
          const glowEffect = document.createElement('span');
          glowEffect.className = 'glow-effect';
          glowEffect.style.position = 'absolute';
          glowEffect.style.width = '14px';
          glowEffect.style.height = '14px';
          glowEffect.style.borderRadius = '50%';
          glowEffect.style.backgroundColor = 'rgba(79, 70, 229, 0.4)';
          glowEffect.style.opacity = '0';
          glowEffect.style.transform = 'translate(-50%, -50%) scale(0.8)';
          glowEffect.style.top = '50%';
          glowEffect.style.left = '50%';
          glowEffect.style.transition = 'all 0.2s ease-out';
          glowEffect.style.boxShadow = '0 0 10px 4px rgba(79, 70, 229, 0.3)';
          glowEffect.style.zIndex = gameState.currentChapter === 'chapter6' ? '9' : (gameState.currentChapter === 'chapter7' ? '15009' : '49'); // 第七章使用超高z-index確保可見
          
          // Active state styling
          if (gameState.segmentationPuzzleState.segments[index]) {
            dot.classList.add('active');
            dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
          }
          
          // Add hover effects
          charGap.addEventListener('mouseenter', () => {
            if (!gameState.segmentationPuzzleState.segments[index]) {
              dot.style.opacity = '0.8';
              glowEffect.style.opacity = '1';
              glowEffect.style.transform = 'translate(-50%, -50%) scale(1.2)';
            }
          });
          
          charGap.addEventListener('mouseleave', () => {
            if (!gameState.segmentationPuzzleState.segments[index]) {
              dot.style.opacity = '0';
              glowEffect.style.opacity = '0';
              glowEffect.style.transform = 'translate(-50%, -50%) scale(0.8)';
            }
          });
          
          // Add click event to the entire gap
          charGap.addEventListener('click', (e) => {
            // Toggle active state
            toggleSegment(index);
            
            // Add click animation
            const clickAnimation = document.createElement('span');
            clickAnimation.style.position = 'absolute';
            clickAnimation.style.top = '50%';
            clickAnimation.style.left = '50%';
            clickAnimation.style.width = '20px';
            clickAnimation.style.height = '20px';
            clickAnimation.style.backgroundColor = 'rgba(79, 70, 229, 0.3)';
            clickAnimation.style.borderRadius = '50%';
            clickAnimation.style.transform = 'translate(-50%, -50%) scale(0)';
            clickAnimation.style.animation = 'click-ripple 0.6s ease-out forwards';
            clickAnimation.style.zIndex = gameState.currentChapter === 'chapter7' ? '15008' : '48';
            charGap.appendChild(clickAnimation);
            
            // Remove animation element after it completes
            setTimeout(() => {
              clickAnimation.remove();
            }, 600);
            
            // For Chapter 2, add cloud ripple effect on click
            if (gameState.currentChapter === 'chapter2') {
              createCloudRipple(e.clientX, e.clientY);
            }
          });
          
          // Add elements to the DOM
          charGap.appendChild(glowEffect);
          charGap.appendChild(dot);
          textContainer.appendChild(charGap);
        }
      });
      
      puzzleContainer.appendChild(textContainer);
      
      // Create result element
      const resultElement = document.createElement('p');
      resultElement.id = 'puzzle-result';
      resultElement.className = 'text-lg mt-6 hidden relative z-10';
      puzzleContainer.appendChild(resultElement);
      
      // Add check answer button
      const checkButton = document.createElement('button');
      checkButton.id = 'check-segmentation';
      checkButton.className = 'mt-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-full relative z-10';
      checkButton.textContent = '檢查答案';
      checkButton.addEventListener('click', () => checkSegmentationSolution(scene.solution));
      puzzleContainer.appendChild(checkButton);
      
      // 添加AI解讀按鈕
      const aiInterpretButton = document.createElement('button');
      aiInterpretButton.id = 'ai-interpret-button';
      aiInterpretButton.className = 'mt-4 bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-full relative z-10 mx-auto';
      aiInterpretButton.style.display = 'flex';
      aiInterpretButton.style.alignItems = 'center';
      aiInterpretButton.style.gap = '8px';
      aiInterpretButton.style.justifyContent = 'center';
      aiInterpretButton.innerHTML = `
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
        </svg>
        莊子解讀
      `;
      aiInterpretButton.addEventListener('click', () => openAIInterpretModal(scene));
      puzzleContainer.appendChild(aiInterpretButton);
      
      // Add developer skip button for testing (only in dev mode)
      if (gameState.devMode) {
        const skipButton = document.createElement('button');
        skipButton.id = 'skip-segmentation';
        skipButton.className = 'ml-4 mt-6 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-full relative z-10 text-sm';
        skipButton.textContent = '開發者跳過';
        skipButton.title = '僅供開發測試使用';
        skipButton.addEventListener('click', () => {
          // Automatically complete the puzzle for testing
          skipSegmentationPuzzle(scene);
        });
        puzzleContainer.appendChild(skipButton);
      }
      
      // 第六章將斷句挑戰容器直接添加到body，脫離game-content的堆疊上下文
      if (gameState.currentChapter === 'chapter6') {
        document.body.appendChild(puzzleContainer);
      } else {
        gameContent.appendChild(puzzleContainer);
      }
      
      // Hide advance button until puzzle is solved
      advanceBtn.style.display = 'none';
    }
    

    
    // Create cloud ripple effect for Chapter 2
    function createCloudRipple(x, y) {
      const ripple = document.createElement('div');
      ripple.className = 'absolute rounded-full pointer-events-none';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';
      ripple.style.width = '10px';
      ripple.style.height = '10px';
      ripple.style.marginLeft = '-5px';
      ripple.style.marginTop = '-5px';
      ripple.style.border = '2px solid rgba(64, 186, 213, 0.6)';
      ripple.style.animation = 'cloud-ripple 1.5s linear';
      
      document.body.appendChild(ripple);
      
      // Remove the ripple after animation completes
      setTimeout(() => {
        ripple.remove();
      }, 1500);
      
      // Add keyframes for cloud ripple effect
      if (!document.getElementById('cloud-ripple-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'cloud-ripple-animation';
        styleElement.textContent = `
          @keyframes cloud-ripple {
            0% { transform: scale(1); opacity: 1; border-color: rgba(64, 186, 213, 0.6); }
            100% { transform: scale(10); opacity: 0; border-color: rgba(103, 200, 208, 0.3); }
          }

          @keyframes sound-wave {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(7); opacity: 0; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Add necessary keyframes for animations
    if (!document.getElementById('ripple-animation')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'ripple-animation';
      styleElement.textContent = `
        @keyframes ripple {
          0% { transform: scale(1); opacity: 1; }
          100% { transform: scale(10); opacity: 0; }
        }
        
        @keyframes pulse-subtle {
          0%, 100% { opacity: 1; transform: scale(1); }
          50% { opacity: 0.95; transform: scale(0.98); }
        }
        
        @keyframes glow-slide {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }
        
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes spin-slow-reverse {
          from { transform: rotate(0deg); }
          to { transform: rotate(-360deg); }
        }
        
        @keyframes segment-hover {
          0% { transform: scaleY(1); background-color: rgba(93, 92, 222, 0.05); }
          100% { transform: scaleY(1.05); background-color: rgba(93, 92, 222, 0.15); }
        }
        
        @keyframes segment-active-pulse {
          0%, 100% { box-shadow: 0 0 8px 1px rgba(93, 92, 222, 0.4); }
          50% { box-shadow: 0 0 12px 3px rgba(93, 92, 222, 0.6); }
        }
        
        .segment-clicked {
          animation: segment-click 0.3s cubic-bezier(.17,.67,.83,.67);
        }
        
        @keyframes segment-click {
          0% { transform: scaleY(1); }
          50% { transform: scaleY(0.85); }
          100% { transform: scaleY(1); }
        }
      `;
      document.head.appendChild(styleElement);
    }
    
    function createTutorialScene(scene) {
      const tutorialElement = document.createElement('div');
      
      // 检查是否有蜗牛存在，如果有则调整教程文字位置
      const hasSnail = document.querySelector('.snail-shell');
      if (hasSnail) {
        tutorialElement.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-2xl p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-30 border border-indigo-200 dark:border-indigo-700';
      } else {
        tutorialElement.className = 'max-w-2xl mx-auto p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-90 dark:bg-opacity-90 rounded-lg';
      }
      
      tutorialElement.innerHTML = `
        <p class="text-lg">${scene.text}</p>
      `;
      
      gameContent.appendChild(tutorialElement);
      
      // 如果是视角控制器教程，先显示文字，然后启用控制器
      if (scene.effect === 'unlockViewScale') {
        // 2秒后启用视角控制器，让用户先看到教程文字
        setTimeout(() => {
          enableScaleControl();
        }, 2000);
      }
      
      // Set up event listener based on waitFor condition
      if (scene.waitFor) {
        const [action, target] = scene.waitFor.split(':');
        
        // Hide advance button until transformation is done
        advanceBtn.style.display = 'none';
        
        if (action === 'transform') {
          if (target === 'bird-toggle') {
            // Special case for bird toggle
            const onClick = () => {
              // Listen for bird state toggle
              const currentState = gameState.birdState;
              
              setTimeout(() => {
                if (gameState.birdState !== currentState) {
                  // Bird state was toggled
                  advanceBtn.style.display = 'block';
                  tutorialElement.style.display = 'none';
                  formButtons.bird.removeEventListener('click', onClick);
                }
              }, 1600);
            };
            
            // Add event listeners to both yuanchu and chixiao buttons
            formButtons.yuanchu.addEventListener('click', onClick);
            formButtons.chixiao.addEventListener('click', onClick);
          } else {
            // Regular transformation - for butterfly, fish, etc.
            let targetButton = null;
            
            // 找到目標變身按鈕
            for (const [form, button] of Object.entries(formButtons)) {
              if (form === target) {
                targetButton = button;
                break;
              }
            }
            
            if (targetButton) {
              const onClick = () => {
                // 設置定時器等待變身完成後再檢查
                setTimeout(() => {
                  if (gameState.currentForm === target) {
                    // 顯示繼續按鈕
                    advanceBtn.style.display = 'block';
                    // 隱藏提示信息
                    tutorialElement.style.display = 'none';
                    // 移除事件監聽器
                    targetButton.removeEventListener('click', onClick);
                  }
                }, 1600); // 等待變身動畫完成
              };
              
              // 只監聽目標按鈕而不是所有按鈕
              targetButton.addEventListener('click', onClick);
            }
          }
        } else if (action === 'scale') {
          // Handle scale-related waitFor conditions
          if (target === 'change') {
            // Listen for scale change events
            const scaleChangeHandler = () => {
              advanceBtn.style.display = 'block';
              tutorialElement.style.display = 'none';
              document.removeEventListener('scaleChange', scaleChangeHandler);
            };
            document.addEventListener('scaleChange', scaleChangeHandler);
          } else if (target === 'macro') {
            // Listen for macro scale events
            const scaleMacroHandler = () => {
              advanceBtn.style.display = 'block';
              tutorialElement.style.display = 'none';
              document.removeEventListener('scaleMacro', scaleMacroHandler);
            };
            document.addEventListener('scaleMacro', scaleMacroHandler);
          }
        }
      } else {
        advanceBtn.style.display = 'block';
      }
    }
    
    function toggleSegment(index) {
      // Toggle segment state
      gameState.segmentationPuzzleState.segments[index] = !gameState.segmentationPuzzleState.segments[index];
      
      // 清除該位置的錯誤標識（如果存在）
      const dot = document.querySelector(`.segment-dot[data-index="${index}"]`);
      if (dot && dot.classList.contains('error-highlight')) {
        dot.classList.remove('error-highlight');
        dot.style.animation = '';
      }
      
      // 添加第六章和第七章的點擊調試log
      if (gameState.currentChapter === 'chapter6') {
        console.log(`第六章點擊調試: 點擊位置 ${index}, 新狀態: ${gameState.segmentationPuzzleState.segments[index]}`);
        console.log('當前所有點擊狀態:', gameState.segmentationPuzzleState.segments);
      }
      
      // 添加第七章的點擊調試log
      if (gameState.currentChapter === 'chapter7') {
        console.log(`第七章點擊調試: 點擊位置 ${index}, 新狀態: ${gameState.segmentationPuzzleState.segments[index]}`);
        console.log('當前所有點擊狀態:', gameState.segmentationPuzzleState.segments);
        
        // 顯示當前已點擊的位置
        const clickedPositions = gameState.segmentationPuzzleState.segments
          .map((val, idx) => val ? idx : null)
          .filter(x => x !== null);
        console.log('第七章已點擊的位置索引:', clickedPositions);
      }
      
      // Update visual state (使用已經獲取的dot元素)
      if (dot) { // Check if dot exists before accessing its properties
        // Update opacity and active state
        if (gameState.segmentationPuzzleState.segments[index]) {
          dot.style.opacity = '1';
          dot.classList.add('active');
          dot.style.backgroundColor = '#4F46E5'; // 確保恢復正確顏色
          dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
          
          // Add pulsating animation for active dot
          if (!document.getElementById('dot-pulse-animation')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'dot-pulse-animation';
            styleEl.textContent = `
              @keyframes dot-pulse {
                0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 12px 4px rgba(79, 70, 229, 0.8); }
                50% { transform: translate(-50%, -50%) scale(1.15); box-shadow: 0 0 16px 6px rgba(79, 70, 229, 0.9); }
              }
              
              @keyframes click-ripple {
                0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
                100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
              }
              
              .segment-dot.active {
                animation: dot-pulse 2s infinite ease-in-out;
              }
            `;
            document.head.appendChild(styleEl);
          }
        } else {
          dot.style.opacity = '0';
          dot.classList.remove('active');
          dot.style.backgroundColor = '#4F46E5'; // 確保恢復正確顏色
          dot.style.boxShadow = '0 0 8px 2px rgba(79, 70, 229, 0.7)';
        }
      } else {
        console.warn(`No dot found with index ${index}`);
      }
    }
    
    function checkSegmentationSolution(solution) {
      const currentState = gameState.segmentationPuzzleState.segments;
      let isCorrect = true;
      
      // 添加第六章的詳細調試log
      if (gameState.currentChapter === 'chapter6') {
        console.log('=== 第六章斷句調試信息 ===');
        console.log('當前章節:', gameState.currentChapter);
        console.log('當前場景:', gameState.currentScene);
        console.log('正確答案 solution:', solution);
        console.log('用戶點擊狀態 currentState:', currentState);
        console.log('用戶點擊的位置 (true的索引):', currentState.map((val, idx) => val ? idx : null).filter(x => x !== null));
        console.log('正確位置應該是:', solution);
        console.log('currentState長度:', currentState.length);
        console.log('solution長度:', solution.length);
      }
      
      // 添加第七章的詳細調試log
      if (gameState.currentChapter === 'chapter7') {
        console.log('=== 第七章斷句調試信息 ===');
        console.log('當前章節:', gameState.currentChapter);
        console.log('當前場景:', gameState.currentScene);
        console.log('正確答案 solution:', solution);
        console.log('用戶點擊狀態 currentState:', currentState);
        console.log('用戶點擊的位置 (true的索引):', currentState.map((val, idx) => val ? idx : null).filter(x => x !== null));
        console.log('正確位置應該是:', solution);
        console.log('currentState長度:', currentState.length);
        console.log('solution長度:', solution.length);
        
        // 顯示文本內容以便對照
        const currentChapter = gameChapters[gameState.currentChapter];
        const currentScene = currentChapter.scenes[gameState.currentScene];
        console.log('斷句文本:', currentScene.text);
        console.log('文本長度:', currentScene.text.length);
      }
      
      // 添加尾聲章節的詳細調試log
      if (gameState.currentChapter === 'epilogue') {
        console.log('=== 尾聲章節斷句調試信息 ===');
        console.log('當前章節:', gameState.currentChapter);
        console.log('當前場景:', gameState.currentScene);
        console.log('正確答案 solution:', solution);
        console.log('用戶點擊狀態 currentState:', currentState);
        console.log('用戶點擊的位置 (true的索引):', currentState.map((val, idx) => val ? idx : null).filter(x => x !== null));
        console.log('正確位置應該是:', solution);
        console.log('currentState長度:', currentState.length);
        console.log('solution長度:', solution.length);
        
        // 顯示文本內容以便對照
        const currentChapter = gameChapters[gameState.currentChapter];
        const currentScene = currentChapter.scenes[gameState.currentScene];
        console.log('斷句文本:', currentScene.text);
        console.log('文本長度:', currentScene.text.length);
        
        // 特殊功能：當用戶正確完成時，生成可複製的答案
        const userClickedPositions = currentState.map((val, idx) => val ? idx : null).filter(x => x !== null);
        const isUserCorrect = userClickedPositions.length === solution.length && 
                             userClickedPositions.every(pos => solution.includes(pos));
        
        if (isUserCorrect) {
          console.log('🎉 尾聲章節斷句挑戰完成正確！');
          console.log('📋 可複製的答案格式：');
          console.log(`solution: [${userClickedPositions.join(', ')}]`);
          console.log('📝 完整的場景配置建議：');
          console.log(`{
  type: 'segmentation-puzzle',
  text: '${currentScene.text}',
  solution: [${userClickedPositions.join(', ')}],
  hint: '${currentScene.hint || '請根據文意斷句'}',
  success: '${currentScene.success || '斷句正確！'}',
  nextScene: ${currentScene.nextScene || 'NEXT_SCENE_NUMBER'}
}`);
        }
      }
      
      // Check if all correct segments are marked and no incorrect ones
      for (let i = 0; i < currentState.length; i++) {
        const shouldBeMarked = solution.includes(i);
        if (shouldBeMarked !== currentState[i]) {
          if (gameState.currentChapter === 'chapter6') {
            console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 不匹配!`);
          }
          if (gameState.currentChapter === 'chapter7') {
            console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 不匹配!`);
          }
          if (gameState.currentChapter === 'epilogue') {
            console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 不匹配!`);
          }
          isCorrect = false;
          break;
        } else if (gameState.currentChapter === 'chapter6') {
          console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 匹配`);
        } else if (gameState.currentChapter === 'chapter7') {
          console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 匹配`);
        } else if (gameState.currentChapter === 'epilogue') {
          console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 匹配`);
        }
      }
      
      if (gameState.currentChapter === 'chapter6') {
        console.log('最終判定結果:', isCorrect ? '正確' : '錯誤');
        console.log('=== 調試信息結束 ===');
      }
      
      if (gameState.currentChapter === 'chapter7') {
        console.log('最終判定結果:', isCorrect ? '正確' : '錯誤');
        console.log('=== 第七章調試信息結束 ===');
      }
      
      if (gameState.currentChapter === 'epilogue') {
        console.log('最終判定結果:', isCorrect ? '正確' : '錯誤');
        console.log('=== 尾聲章節調試信息結束 ===');
      }
      
      const resultElement = document.getElementById('puzzle-result');
      const checkButton = document.getElementById('check-segmentation');
      
      if (isCorrect) {
        if (!gameState.segmentationPuzzleState.solved) {
          // Mark as solved
          gameState.segmentationPuzzleState.solved = true;
          
          // 記錄斷句挑戰完成數據
          recordSegmentationPuzzleCompletion(true);
          
          // 恢復混沌的正常層級
          const chaosForm = document.querySelector('.chaos-form');
          if (chaosForm) {
            chaosForm.classList.remove('segmentation-mode');
          }
          
          // Show success message
          resultElement.textContent = gameChapters[gameState.currentChapter].scenes[gameState.currentScene].success;
          resultElement.className = 'text-lg mt-6 text-indigo-600 dark:text-indigo-400';
          resultElement.classList.remove('hidden');
          
          // Change button text
          checkButton.textContent = '繼續';
          checkButton.addEventListener('click', advanceScene, { once: true });
          
          // Hide advance button since we're using the check button as continue
          advanceBtn.style.display = 'none';
        }
      } else {
        // 記錄斷句挑戰嘗試數據
        recordSegmentationPuzzleAttempt(false);
        // 標識錯誤的位置
        highlightIncorrectSegments(solution, currentState);
        
        // 計算用戶多標記的錯誤數量
        const incorrectCount = currentState.reduce((count, userMarked, index) => {
          const shouldBeMarked = solution.includes(index);
          // 只計算用戶多標記的錯誤（不應該標記但標記了）
          return count + (!shouldBeMarked && userMarked ? 1 : 0);
        }, 0);
        
        // 計算用戶已正確標記的數量
        const correctlyMarkedCount = solution.reduce((count, correctIndex) => {
          return count + (currentState[correctIndex] ? 1 : 0);
        }, 0);
        
        const totalSegments = solution.length;
        
        // 生成正面鼓勵的提示信息
        let encouragingMessage = '';
        if (incorrectCount === 0) {
          // 沒有多標記錯誤，但還有位置沒標記
          const missingCount = totalSegments - correctlyMarkedCount;
          encouragingMessage = `很好！沒有多餘的標記。還需要找到 ${missingCount} 個正確的斷句位置。`;
        } else if (incorrectCount === 1) {
          encouragingMessage = `很棒！只有一個位置標記錯了。請移除標紅的位置，然後繼續尋找正確的斷句點。`;
        } else if (incorrectCount <= 3) {
          encouragingMessage = `做得不錯！請移除 ${incorrectCount} 個標紅的錯誤位置，然後重新思考正確的斷句點。`;
        } else {
          encouragingMessage = `請仔細思考斷句的邏輯！紅色標記顯示了 ${incorrectCount} 個不應該斷句的位置。`;
        }
        
        // Show error message with encouragement
        resultElement.textContent = encouragingMessage;
        resultElement.className = 'text-lg mt-6 text-orange-600 dark:text-orange-400';
        resultElement.classList.remove('hidden');
        
        // Hide message after 4 seconds (longer for encouragement)
        setTimeout(() => {
          resultElement.classList.add('hidden');
          // 不自動清除錯誤標識，讓玩家主動調整
        }, 4000);
      }
    }
    
    // 標識錯誤的斷句位置
    function highlightIncorrectSegments(solution, currentState) {
      // 清除之前的錯誤標識
      clearErrorHighlights();
      
      console.log('錯誤標識: 正確答案=', solution, '用戶狀態=', currentState);
      
      for (let i = 0; i < currentState.length; i++) {
        const shouldBeMarked = solution.includes(i);
        const userMarked = currentState[i];
        
        // 只標識用戶多標記的錯誤位置：不應該標記但用戶標記了
        if (!shouldBeMarked && userMarked) {
          const dot = document.querySelector(`.segment-dot[data-index="${i}"]`);
          
          if (dot) {
            console.log(`位置 ${i} 標記為錯誤: 用戶多標記了不應該標記的位置`);
            
            // 添加錯誤標識樣式
            dot.classList.add('error-highlight');
            
            // 設置錯誤樣式（只是紅色點，沒有邊框）
            dot.style.backgroundColor = '#EF4444'; // 紅色
            dot.style.boxShadow = '0 0 12px 4px rgba(239, 68, 68, 0.8)';
            dot.style.opacity = '1'; // 確保顯示
            
            // 添加輕微的錯誤動畫
            dot.style.animation = 'error-pulse 2s infinite';
          }
        }
      }
      
      // 添加錯誤動畫樣式（如果不存在）
      if (!document.getElementById('error-animation-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'error-animation-styles';
        styleElement.textContent = `
          @keyframes error-pulse {
            0%, 100% { 
              background-color: #EF4444;
              box-shadow: 0 0 12px 4px rgba(239, 68, 68, 0.8);
            }
            50% { 
              background-color: #DC2626;
              box-shadow: 0 0 16px 6px rgba(239, 68, 68, 1);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 清除錯誤標識
    function clearErrorHighlights() {
      // 移除所有錯誤標識樣式
      document.querySelectorAll('.segment-dot.error-highlight').forEach(dot => {
        dot.classList.remove('error-highlight');
        dot.style.animation = '';
        
        // 恢復原始樣式
        const index = parseInt(dot.dataset.index);
        const isActive = gameState.segmentationPuzzleState.segments[index];
        
        if (isActive) {
          dot.style.backgroundColor = '#4F46E5'; // 恢復藍色
          dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
          dot.style.opacity = '1';
        } else {
          dot.style.backgroundColor = '#4F46E5';
          dot.style.boxShadow = '0 0 8px 2px rgba(79, 70, 229, 0.7)';
          dot.style.opacity = '0';
        }
      });
    }
    
    function skipSegmentationPuzzle(scene) {
      // Automatically set correct segments for testing
      scene.solution.forEach(index => {
        gameState.segmentationPuzzleState.segments[index] = true;
        // Update visual state
        const dot = document.querySelector(`.segment-dot[data-index="${index}"]`);
        if (dot) {
          dot.style.opacity = '1';
          dot.classList.add('active');
          dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
        }
      });
      
      // Mark as solved
      gameState.segmentationPuzzleState.solved = true;
      
      // 恢復混沌的正常層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('segmentation-mode');
      }
      
      // Show success message
      const resultElement = document.getElementById('puzzle-result');
      const checkButton = document.getElementById('check-segmentation');
      const skipButton = document.getElementById('skip-segmentation');
      
      resultElement.textContent = scene.success + ' （開發者跳過）';
      resultElement.className = 'text-lg mt-6 text-green-600 dark:text-green-400';
      resultElement.classList.remove('hidden');
      
      // Change button text and hide skip button
      checkButton.textContent = '繼續';
      checkButton.addEventListener('click', advanceScene, { once: true });
      skipButton.style.display = 'none';
      
      // Hide advance button since we're using the check button as continue
      advanceBtn.style.display = 'none';
    }
    
    function transformTo(form, isFirstTimeTransformation = false) {
      if (!gameState.unlockedForms.includes(form)) {
        return;
      }
      
      // If already in this form, do nothing
      if (gameState.currentForm === form) {
        return;
      }
      
      // 檢查是否是萬物回響模式或萬物尋氣模式
      if ((gameState.formSequenceGuideActive || gameState.wanwuXunqiActive) && gameState.handleFormSequenceClick) {
        const handled = gameState.handleFormSequenceClick(form);
        if (handled) {
          return; // 特殊模式已處理，不執行常規物化
        }
      }
      
      // Store current form for transition animation
      const fromForm = gameState.currentForm;
      
      // 判斷是否為日常物化：明確排除初次物化按鈕的調用
      const isDailyTransformation = !isFirstTimeTransformation && !gameState.transformationInProgress;
      
      if (isDailyTransformation) {
        // 日常物化：進入特殊視角模式
        
        // 只有在第一次進入日常物化時才保存原始狀態
        if (!gameState.isInDailyTransformation) {
        gameState.dailyTransformationPreviousForm = fromForm;
        
        // 保存當前的繼續按鈕狀態
        gameState.dailyTransformationAdvanceBtnVisible = (advanceBtn && advanceBtn.style.display !== 'none');
        
          console.log(`首次進入日常物化: ${fromForm} -> ${form}，保存的原始形態: ${fromForm}，繼續按鈕可見: ${gameState.dailyTransformationAdvanceBtnVisible}`);
        
        // 隱藏繼續按鈕（如果存在）
        if (advanceBtn) {
          advanceBtn.style.display = 'none';
        }
        
        // 創建退出視角按鈕
        createExitTransformationButton();
        } else {
          console.log(`連續日常物化: ${fromForm} -> ${form}，保持原始形態: ${gameState.dailyTransformationPreviousForm}`);
        }
        
        gameState.isInDailyTransformation = true;
      } else {
        // 劇情物化：設置進行中狀態
        gameState.transformationInProgress = form;
      }
      
      // First, remove active state from all buttons
      Object.values(formButtons).forEach(button => {
        button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
        button.classList.add('bg-gray-500');
      });
      
      // Highlight active form button
      formButtons[form].classList.remove('bg-gray-500');
      formButtons[form].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
      
      // Create the transition animation between current form and target form
      showTransformationTransition(fromForm, form);
      
      // Set timeout to update the game state after animation
      setTimeout(() => {
        // Update game state
        gameState.currentForm = form;
        
        // 記錄物化體驗數據
        recordTransformationData(form, isDailyTransformation, fromForm);
        
        // 更新視圖顯示
        updateFormView(form);
        
        // 檢查是否滿足transformation-required的條件（僅在劇情物化時）
        if (!isDailyTransformation) {
          checkTransformationProgress();
          // Clear transformation in progress flag after animation completes
          gameState.transformationInProgress = null;
        }
      }, 1500);
    }
    
                // 已移除的toggleKunpengForm和updateKunpengView函數 - 現在使用獨立的kun和peng形態
      // 這些函數已不再需要，因為鯤和鵬現在作為獨立的形態來處理
      // kunpeng舊形態已完全清理，所有相關代碼已更新為使用kun和peng
    
    // 創建物化覆蓋層的通用函數
    function createTransformationOverlay(overlayConfig) {
      // 移除現有覆蓋層
      const existingOverlay = document.querySelector('.transformation-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      // 創建新覆蓋層
      const overlay = document.createElement('div');
      overlay.className = 'transformation-overlay';
      overlay.style.background = overlayConfig.background;
      overlay.style.boxShadow = overlayConfig.boxShadow || '';
      
      gameContainer.appendChild(overlay);
      
      // 應用濾鏡和變換到gameContainer
      gameContainer.style.transform = overlayConfig.transform || 'scale(1)';
      gameContainer.style.filter = overlayConfig.filter || 'none';
    }
    
    // 移除物化覆蓋層
    function removeTransformationOverlay() {
      const overlay = document.querySelector('.transformation-overlay');
      if (overlay) {
        overlay.remove();
      }
      gameContainer.style.transform = 'scale(1)';
      gameContainer.style.filter = 'none';
    }
    
    // ===== AI解讀系統 =====
    
    // 獲取斷句挑戰的詳細信息
    function getSegmentationPuzzleInfo(scene) {
      const chapterMappings = {
        'prologue': {
          title: '序章：夢蝶',
          source: '《莊子·齊物論》',
          theme: '物我兩忘的變化智慧',
          text: '昔者莊周夢為胡蝶栩栩然胡蝶也自喻適志與不知周也俄然覺則蘧蘧然周也',
          interpretation: '這是莊子最著名的故事之一。莊周夢見自己變成蝴蝶，在夢中他完全忘記了自己是莊周，只知道自己是一隻快樂飛舞的蝴蝶。醒來後，他不知道是莊周夢見了蝴蝶，還是蝴蝶夢見了莊周。這個故事揭示了現實與夢境、自我與他物之間界限的模糊性，體現了「物我兩忘」的哲學境界。',
          gameConnection: '在遊戲中，這段古文是你獲得第一次物化能力的關鍵。通過理解夢蝶的智慧，你開啟了在不同形態間自由轉換的可能性，這正是莊子「齊物論」思想的體現——萬物本質相同，形態只是表象。'
        },
                 'chapter1': {
           title: '第一章：子非魚',
           source: '《莊子·秋水》',
           theme: '知魚之樂的認知智慧',
           text: '莊子與惠子遊於濠梁之上莊子曰儵魚出遊從容是魚樂也惠子曰子非魚安知魚之樂莊子曰子非我安知我不知魚之樂',
           interpretation: '這是莊子與惠子的經典辯論。莊子看到魚兒悠遊，說這是魚的快樂；惠子質疑：你不是魚，怎麼知道魚的快樂？莊子反問：你不是我，怎麼知道我不知道魚的快樂？這個對話探討了認知的界限和同理心的可能性，展現了不同的思維方式。',
           gameConnection: '在遊戲的濠梁之上，你親身體驗了這場千古辯論。通過不同的選擇，你展現了自己對認知和同理心的理解。這段古文的解讀將幫助你獲得「左目之竅」的封印，開啟更深層的感知能力。'
         },
        'chapter2': {
          title: '第二章：北冥有魚',
          source: '《莊子·逍遙遊》',
          theme: '鯤鵬變化的逍遙境界',
          text: '北冥有魚其名為鯤鯤之大不知其幾千里也化而為鳥其名為鵬鵬之背不知其幾千里也怒而飛其翼若垂天之雲',
          interpretation: '這段描述了鯤鵬變化的壯闊場面。在北方的大海中有一條巨魚叫鯤，大到不知道有幾千里。它化身為大鳥叫鵬，背部也不知道有幾千里寬。當它振翅高飛時，翅膀就像天邊的雲彩。這體現了莊子對自由變化和超越束縛的嚮往。',
          gameConnection: '在雲海之中，你將親身體驗鯤鵬的變化之道。這種從魚到鳥、從水中到天空的轉換，象徵著突破固有形態的束縛。通過解讀這段古文，你將獲得鯤和鵬的物化能力，體驗真正的逍遙自在。'
        },
        'chapter3': {
          title: '第三章：鴟得腐鼠',
          source: '《莊子·秋水》',
          theme: '價值觀的相對性',
          text: '惠子相梁莊子往見之或謂惠子曰莊子來欲代子相於是惠子恐搜於國中三日三夜莊子往見之曰南方有鳥其名為鵷鶵子知之乎',
          interpretation: '惠子在梁國當宰相，有人告訴他莊子來是要取代他的位置，惠子因此恐慌，在全國搜查了三天三夜。莊子去見他，講了鵷鶵的故事。鵷鶵是神鳥，只吃甘露，不食腐物。這個故事暗示不同的價值觀念，有些人追求的「寶物」，在另一些人眼中可能毫無價值。',
          gameConnection: '在森林深處，你將遇到鵷鶵和鴟鴞這兩種截然不同的鳥類，體驗它們不同的生活方式和價值觀。這段古文揭示了價值判斷的相對性，幫助你獲得「左耳之竅」的封印，學會以更包容的心態看待世界。'
        },
        'chapter4': {
          title: '第四章：蝸角之爭',
          source: '《莊子·則陽》',
          theme: '事物規模的相對性',
          text: '有國於蝸之左角者曰觸氏有國於蝸之右角者曰蠻氏時相與爭地而戰伏尸數萬逐北旬有五日而後反',
          interpretation: '在蝸牛的左角上有個國家叫觸氏，右角上有個國家叫蠻氏。它們經常為了爭奪土地而戰爭，死傷數萬，追擊敗軍十五天才回來。這個寓言揭示了人類爭鬥的荒謬性——從更大的視角看，我們的爭鬥就像蝸牛角上的戰爭一樣微不足道。',
          gameConnection: '在螺旋的幻境中，你將親眼目睹蝸角之爭的荒謬。通過這段古文的理解，你將獲得蝸牛的物化能力，學會從微觀的角度審視世界，同時也理解規模和視角的相對性，最終找到「右耳之竅」的封印。'
        },
        'chapter5': {
          title: '第五章：朝菌大椿',
          source: '《莊子·逍遙遊》',
          theme: '時間感知的相對性',
          text: '朝菌不知晦朔蟪蛄不知春秋此小年也楚之南有冥靈者以五百歲為春五百歲為秋上古有大椿者以八千歲為春八千歲為秋',
          interpretation: '朝菌不知道月亮的陰晴圓缺，蟪蛄不知道春秋的變化，這是短命的生物。楚國南方有一種叫冥靈的樹，以五百年為春季，五百年為秋季。上古時有大椿樹，以八千年為春季，八千年為秋季。這說明了時間感知的相對性。',
          gameConnection: '在時間森林中，你將遇到不同壽命的生物，體驗它們對時間的不同感知。這段古文幫助你理解時間的相對性，獲得朝菌、蟪蛄、大椿的物化能力，最終找到「左鼻之竅」的封印，學會以不同的時間尺度看待生命。'
        },
        'chapter6': {
          title: '第六章：天地為棺槨',
          source: '《莊子·列禦寇》',
          theme: '生死觀的超脫智慧',
          text: '莊子將死弟子欲厚葬之莊子曰吾以天地為棺槨以日月為連璧星辰為珠璣萬物為齎送吾葬具豈不備邪何以加此弟子曰吾恐烏鳶之食夫子也莊子曰在上為烏鳶食在下為螻蟻食奪彼與此何其偏也',
          interpretation: '莊子將要去世時，弟子們想要厚葬他。莊子說：我以天地為棺材，以日月為陪葬的璧玉，以星辰為珠寶，以萬物為送葬品，我的葬具難道不齊備嗎？弟子擔心他被鳥獸吃掉，莊子說：在上面被鳥吃，在下面被螻蟻吃，偏愛其中一種，豈不是很偏頗嗎？這體現了莊子對生死的超脫態度。',
          gameConnection: '在天地交接的聖地，你將體驗莊子的生死智慧。通過理解這段古文，你將獲得螻蟻和星辰的物化能力，從「在下」和「在上」兩個角度體驗生死的自然性，最終找到「右鼻之竅」的封印。'
        },
        'chapter7': {
          title: '第七章：道歸混沌',
          source: '《莊子·應帝王》',
          theme: '渾沌之死的深刻寓意',
          text: '南海之帝為儵北海之帝為忽中央之帝為渾沌儵與忽時相與遇於渾沌之地渾沌待之甚善儵與忽謀報渾沌之德曰人皆有七竅以視聽食息此獨無有嘗試鑿之日鑿一竅七日而渾沌死',
          interpretation: '南海的帝王叫儵，北海的帝王叫忽，中央的帝王叫渾沌。儵和忽經常在渾沌的地方相遇，渾沌待他們很好。儵和忽商量報答渾沌的恩德，說：人都有七個竅孔用來視聽飲食呼吸，只有渾沌沒有，我們試著為他鑿開。每天鑿一個竅，七天後渾沌就死了。這個故事揭示了善意可能帶來的悲劇後果。',
          gameConnection: '在虛空殿中，你將親身經歷渾沌之死的故事。這段古文是整個遊戲的核心寓意——你的使命就是要修復被鑿開的七竅，讓渾沌重新回到無竅的純真狀態。通過理解這個深刻的哲學寓言，你將獲得最終的智慧。'
        },
        'epilogue': {
          title: '尾聲：逍遙遊',
          source: '《莊子·逍遙遊》',
          theme: '無用之用的人生智慧',
          text: '今子有大樹患其無用何不樹之於無何有之鄉廣莫之野徬徨乎無為其側逍遙乎寢臥其下不夭斤斧物無害者無所可用安所困苦哉',
          interpretation: '現在你有一棵大樹，擔心它沒有用處，為什麼不把它種在空曠無物的地方、廣闊的原野上，在它旁邊自由自在地徘徊，在它下面逍遙地躺臥休息？它不會遭受斧頭的砍伐，沒有什麼能傷害它。沒有用處，哪裡會有困苦呢？這體現了莊子「無用之用」的智慧。',
          gameConnection: '在逍遙遊的最終境界中，你已經體驗了所有生物的形態，理解了萬物的本質。這段古文總結了整個遊戲的哲學主題——真正的自由來自於超越世俗的「有用」標準，在「無用」中找到真正的價值和快樂。'
        }
      };
      
      return chapterMappings[gameState.currentChapter] || {
        title: '未知章節',
        source: '《莊子》',
        theme: '莊子哲學',
        text: scene.text,
        interpretation: '這段古文蘊含著深刻的哲學智慧。',
        gameConnection: '通過理解這段古文，你將獲得新的能力和洞察。'
      };
    }
    
    // 打開AI解讀模態窗口
    function openAIInterpretModal(scene) {
      // 移除現有的模態窗口
      const existingModal = document.getElementById('ai-interpret-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const puzzleInfo = getSegmentationPuzzleInfo(scene);
      
      // 創建模態窗口
      const modal = document.createElement('div');
      modal.id = 'ai-interpret-modal';
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.style.zIndex = '99999'; // 確保在所有元素之上
      
      const modalContent = document.createElement('div');
      modalContent.className = 'bg-white dark:bg-slate-800 rounded-xl shadow-2xl max-w-4xl w-11/12 h-[85vh] overflow-hidden flex flex-col border border-slate-200 dark:border-slate-700';
      
      // 模態窗口頭部
      const modalHeader = document.createElement('div');
      modalHeader.className = 'bg-gradient-to-r from-slate-800 to-slate-700 text-white p-5 flex items-center justify-between flex-shrink-0 border-b border-slate-600';
      modalHeader.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 bg-gradient-to-br from-amber-400 to-orange-500 rounded-full flex items-center justify-center shadow-lg">
            <span class="text-white font-bold text-lg">莊</span>
          </div>
          <div>
            <h2 class="text-2xl font-bold text-white">莊子解讀</h2>
          </div>
        </div>
        <button id="close-modal" class="text-slate-300 hover:text-white transition-colors p-2 hover:bg-slate-600 rounded-full">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      `;
      
      // 模態窗口主體 - 固定高度，不滾動
      const modalBody = document.createElement('div');
      modalBody.className = 'flex-1 flex flex-col overflow-hidden';
      
      // 解讀內容區域 - 自適應高度
      const interpretationSection = document.createElement('div');
      interpretationSection.className = 'border-b border-gray-200 dark:border-gray-600 flex-shrink-0';
      interpretationSection.innerHTML = `
        <div class="p-4 bg-gradient-to-b from-slate-50 to-white dark:from-slate-800 dark:to-slate-700">
          <!-- 解讀內容 -->
          <div id="interpretation-content" class="space-y-4">
            <!-- 古文原文 -->
            <div class="bg-gradient-to-r from-amber-50 to-orange-50 dark:from-amber-900 dark:to-orange-900 p-4 rounded-lg border-l-4 border-amber-400 shadow-sm">
              <div class="flex items-center gap-2 mb-3">
                <span class="text-amber-600 text-lg">📜</span>
                <span class="font-semibold text-amber-700 dark:text-amber-300">古文原文</span>
              </div>
              <p class="text-lg text-slate-800 dark:text-slate-200 font-serif leading-relaxed tracking-wide">${puzzleInfo.text}</p>
            </div>
            
            <!-- 莊子解讀 -->
            <div class="bg-gradient-to-r from-emerald-50 to-teal-50 dark:from-emerald-900 dark:to-teal-900 border border-emerald-200 dark:border-emerald-700 rounded-lg p-4 shadow-sm">
              <div class="flex items-center gap-2 mb-3">
                <span class="text-emerald-600 text-lg">🧘</span>
                <span class="font-semibold text-emerald-700 dark:text-emerald-300">莊子的解讀</span>
              </div>
              <p class="text-slate-700 dark:text-slate-300 leading-relaxed mb-3">
                <span class="font-medium text-emerald-800 dark:text-emerald-200">這段文字出自${puzzleInfo.source}，探討的是${puzzleInfo.theme}的深刻主題。</span>
              </p>
              <p class="text-slate-700 dark:text-slate-300 leading-relaxed">${puzzleInfo.interpretation}</p>
            </div>
            
            <!-- 遊戲聯繫 -->
            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900 dark:to-indigo-900 border border-blue-200 dark:border-blue-700 rounded-lg p-4 shadow-sm">
              <div class="flex items-center gap-2 mb-3">
                <span class="text-blue-600 text-lg">🎮</span>
                <span class="font-semibold text-blue-700 dark:text-blue-300">與遊戲劇情的聯繫</span>
              </div>
              <p class="text-slate-700 dark:text-slate-300 leading-relaxed">${puzzleInfo.gameConnection}</p>
            </div>
          </div>
        </div>
      `;
      

      
      // 聊天記錄區域 - 佔據剩餘空間
      const qaSection = document.createElement('div');
      qaSection.className = 'flex-1 flex flex-col min-h-0';
      qaSection.innerHTML = `
        <!-- 聊天記錄區域 - 佔據剩餘空間 -->
        <div id="chat-history" class="flex-1 bg-gradient-to-b from-slate-50 to-white dark:from-slate-800 dark:to-slate-700 p-4 space-y-3 overflow-y-auto min-h-0">
          <div class="text-center text-slate-500 dark:text-slate-400 text-sm py-8">
            <div class="w-16 h-16 bg-gradient-to-br from-purple-100 to-indigo-100 dark:from-purple-900 dark:to-indigo-900 rounded-full flex items-center justify-center mx-auto mb-3">
              <span class="text-2xl">💬</span>
            </div>
            <p class="font-medium">在這裡與莊子對話，探討古文的智慧</p>
            <p class="text-xs mt-1 text-slate-400">請在下方輸入你的問題</p>
          </div>
        </div>
        
        <!-- 輸入區域 -->
        <div class="p-3 bg-gradient-to-r from-slate-100 to-slate-50 dark:from-slate-700 dark:to-slate-800 flex-shrink-0 border-t border-slate-200 dark:border-slate-600">
          <div class="flex gap-3">
            <input type="text" id="user-question" placeholder="請輸入你想問莊子的問題..." 
                   class="flex-1 px-4 py-3 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-amber-500 focus:border-amber-500 dark:bg-slate-700 dark:text-white placeholder-slate-400 dark:placeholder-slate-500 shadow-sm">
            <button id="ask-question" class="bg-gradient-to-r from-amber-500 to-orange-500 hover:from-amber-600 hover:to-orange-600 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 shadow-sm hover:shadow-md">
              提問
            </button>
          </div>
        </div>
      `;
      
      // 組裝模態窗口
      modalBody.appendChild(interpretationSection);
      modalBody.appendChild(qaSection);
      
      modalContent.appendChild(modalHeader);
      modalContent.appendChild(modalBody);
      modal.appendChild(modalContent);
      
      // 添加到頁面
      document.body.appendChild(modal);
      
      // 綁定事件
      setupModalEvents(modal, scene);
    }
    
    // 設置模態窗口事件
    function setupModalEvents(modal, scene) {
      const closeBtn = modal.querySelector('#close-modal');
      const askBtn = modal.querySelector('#ask-question');
      const questionInput = modal.querySelector('#user-question');
      const chatHistory = modal.querySelector('#chat-history');
      
      // 關閉模態窗口
      const closeModal = () => {
        modal.remove();
      };
      
      closeBtn.addEventListener('click', closeModal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
      });
      
      // ESC鍵關閉
      const handleEsc = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', handleEsc);
        }
      };
      document.addEventListener('keydown', handleEsc);
      
      // 設置解讀內容自適應高度（不滾動）
      const interpretationContent = modal.querySelector('#interpretation-content');
      if (interpretationContent) {
        interpretationContent.style.maxHeight = 'none'; // 移除高度限制，讓內容自適應
        interpretationContent.style.overflowY = 'visible'; // 不添加滾動條
      }
      
      // 確保聊天記錄區域使用剩餘空間並可滾動
      if (chatHistory) {
        // 移除固定高度設置，讓flex布局自動分配剩餘空間
        chatHistory.style.minHeight = '0';
        chatHistory.style.maxHeight = 'none';
        chatHistory.style.overflowY = 'auto';
        chatHistory.style.overflowX = 'hidden';
        
        // 確保滾動區域正確工作
        setTimeout(() => {
          chatHistory.scrollTop = 0; // 重置滾動位置到頂部
        }, 100);
      }
      
      // 添加消息到聊天記錄
      const addMessageToChat = (message, isUser = false) => {
        // 如果是第一條消息，清除提示文字
        const placeholder = chatHistory.querySelector('.text-center');
        if (placeholder) {
          placeholder.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex items-start gap-3 ${isUser ? 'flex-row-reverse' : ''}`;
        
        const avatar = document.createElement('div');
        avatar.className = `w-10 h-10 rounded-full flex items-center justify-center text-white text-sm font-bold flex-shrink-0 shadow-md ${
          isUser ? 'bg-gradient-to-br from-blue-500 to-indigo-600' : 'bg-gradient-to-br from-amber-400 to-orange-500'
        }`;
        avatar.textContent = isUser ? '你' : '莊';
        
        const messageContent = document.createElement('div');
        messageContent.className = `flex-1 ${isUser ? 'text-right' : ''}`;
        
        const messageBubble = document.createElement('div');
        messageBubble.className = `inline-block max-w-full px-4 py-3 rounded-lg shadow-sm ${
          isUser 
            ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white' 
            : 'bg-white dark:bg-slate-600 border border-slate-200 dark:border-slate-500 text-slate-700 dark:text-slate-300'
        }`;
        messageBubble.textContent = message;
        
        messageContent.appendChild(messageBubble);
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(messageContent);
        
        chatHistory.appendChild(messageDiv);
        
        // 自動滾動到底部
        chatHistory.scrollTop = chatHistory.scrollHeight;
        
        // 返回創建的消息元素
        return messageDiv;
      };
      
      // 提問功能
      const askQuestion = async () => {
        const question = questionInput.value.trim();
        if (!question) return;
        
        // 添加用戶問題到聊天記錄
        addMessageToChat(question, true);
        
        // 在聊天記錄中添加"莊子正在思考..."消息
        const thinkingMessage = addMessageToChat('莊子正在思考...', false);
        thinkingMessage.id = 'thinking-message'; // 添加ID以便後續移除
        
        // 禁用按鈕但保持原始文字
        askBtn.disabled = true;
        
        // 清空輸入框
        questionInput.value = '';
        
        try {
          const puzzleInfo = getSegmentationPuzzleInfo(scene);
          
          // 強制調用AI，如果AI不可用則使用靜態回應
          let response;
          console.log('🔍 AI系統詳細檢查:', {
            'window.zhuangziAI存在': !!window.zhuangziAI,
            'zhuangziAI變量存在': typeof zhuangziAI !== 'undefined',
            'zhuangziAI.isEnabled': window.zhuangziAI?.isEnabled,
            'API密鑰存在': !!window.zhuangziAI?.apiKey,
            'API密鑰長度': window.zhuangziAI?.apiKey?.length || 0,
            'zhuangziAI類型': typeof zhuangziAI,
            'zhuangziAI實例': zhuangziAI
          });
          
          // 檢查AI系統是否可用
          if (window.zhuangziAI && window.zhuangziAI.isEnabled) {
            console.log('🤖 AI系統可用，調用AI生成莊子回應...');
            try {
              response = await generateZhuangziResponse(question, puzzleInfo);
              if (response && response !== getStaticZhuangziResponse(question, puzzleInfo)) {
                console.log('✅ AI調用成功！');
              } else {
                console.log('⚠️ AI調用返回了靜態回應，可能失敗');
              }
            } catch (error) {
              console.error('❌ AI調用出錯:', error);
              response = getStaticZhuangziResponse(question, puzzleInfo);
            }
          } else {
            console.log('📝 AI系統不可用，使用靜態回應...');
            response = getStaticZhuangziResponse(question, puzzleInfo);
          }
          
          // 移除"思考中"消息
          const thinkingMsg = document.getElementById('thinking-message');
          if (thinkingMsg) {
            thinkingMsg.remove();
          }
          
          // 添加AI回應到聊天記錄
          addMessageToChat(response, false);
          
        } catch (error) {
          console.error('AI回應生成失敗:', error);
          
          // 移除"思考中"消息
          const thinkingMsg = document.getElementById('thinking-message');
          if (thinkingMsg) {
            thinkingMsg.remove();
          }
          
          const errorResponse = '抱歉，我現在無法回答你的問題。請稍後再試，或者先專心完成斷句挑戰吧。';
          addMessageToChat(errorResponse, false);
        } finally {
          askBtn.disabled = false;
        }
      };
      
      askBtn.addEventListener('click', askQuestion);
      questionInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          askQuestion();
        }
      });
      
      // 聚焦到輸入框
      setTimeout(() => questionInput.focus(), 100);
    }
    
         // 生成莊子風格的AI回應
     async function generateZhuangziResponse(question, puzzleInfo) {
       try {
         console.log('🤖 ===== generateZhuangziResponse 開始 =====');
         console.log('❓ 問題:', question);
         console.log('📜 古文信息:', puzzleInfo);
         
         // 檢查zhuangziAI是否可用
         console.log('🔍 zhuangziAI狀態檢查:', {
           'window.zhuangziAI存在': !!window.zhuangziAI,
           'zhuangziAI類型': typeof window.zhuangziAI,
           'isEnabled': window.zhuangziAI?.isEnabled,
           'API密鑰': window.zhuangziAI?.apiKey?.substring(0, 10) + '...',
           'generatePersonalizedResponse方法存在': typeof window.zhuangziAI?.generatePersonalizedResponse === 'function'
         });
         
         // 構建正確的context和playerData參數
         const context = {
           chapter: gameState.currentChapter || 'unknown',
           scene: gameState.currentScene || 0,
           sceneType: 'segmentation-interpretation',
           description: `斷句挑戰：${puzzleInfo.title} - ${puzzleInfo.theme}`,
           specificQuestion: question,
           puzzleInfo: puzzleInfo
         };
         
         const playerData = getAIAnalysisData();
         
         console.log('📍 調用上下文:', context);
         console.log('👤 玩家數據類型:', typeof playerData);
         console.log('👤 玩家數據概要:', {
           hasProfile: !!playerData.profile,
           hasPatterns: !!playerData.patterns,
           hasContext: !!playerData.context,
           profileType: playerData.profile?.philosophicalProfile
         });
         
         console.log('🚀 準備調用window.zhuangziAI.generatePersonalizedResponse...');
         const response = await window.zhuangziAI.generatePersonalizedResponse(context, playerData);
         
         console.log('🎯 AI回應結果:', {
           '回應存在': !!response,
           '回應類型': typeof response,
           '回應長度': response?.length || 0,
           '回應預覽': response?.substring(0, 50) + '...'
         });
         
         if (response) {
           console.log('✅ AI回應生成成功:', response);
           return response;
         } else {
           console.log('⚠️ AI回應為空，使用靜態回應');
           return getStaticZhuangziResponse(question, puzzleInfo);
         }
       } catch (error) {
         console.error('🚫 生成莊子回應時出錯:', error);
         console.error('錯誤堆疊:', error.stack);
         return getStaticZhuangziResponse(question, puzzleInfo);
       }
     }
     
     // 靜態莊子回應（當AI不可用時使用）
     function getStaticZhuangziResponse(question, puzzleInfo) {
       const lowerQuestion = question.toLowerCase();
       
       // 基於問題關鍵詞提供相應回答
       if (lowerQuestion.includes('斷句') || lowerQuestion.includes('怎麼') || lowerQuestion.includes('如何')) {
         return `我的朋友，斷句如同人生的選擇，沒有絕對的對錯。重要的是用心感受文字的韻律和意境。就像${puzzleInfo.theme}一樣，每個人的理解都有其獨特之處。相信你的直覺，大膽嘗試吧！`;
       }
       
       if (lowerQuestion.includes('意思') || lowerQuestion.includes('含義') || lowerQuestion.includes('理解')) {
         return `這段古文講述的是${puzzleInfo.theme}。在我看來，文字只是載體，真正的智慧在於你的體悟。通過完成這個挑戰，你將更深刻地理解其中的道理。`;
       }
       
       if (lowerQuestion.includes('為什麼') || lowerQuestion.includes('原因')) {
         return `萬事萬物都有其道理，但道理往往不在於「為什麼」，而在於「如何」。就像這段古文一樣，重要的不是為什麼要這樣斷句，而是如何在過程中體會智慧。`;
       }
       
       if (lowerQuestion.includes('困難') || lowerQuestion.includes('難')) {
         return `困難是成長的機會，我的朋友。正如水遇到石頭會繞道而行，你也可以換個角度來思考。這段關於${puzzleInfo.theme}的古文，或許能給你新的啟發。`;
       }
       
       // 默認回應
       return `我的朋友，你的問題很有趣。在這個關於${puzzleInfo.theme}的挑戰中，答案往往藏在實踐裡。不如先完成斷句挑戰，在過程中你可能會找到自己的答案。記住，最好的老師是你自己的體驗。`;
     }
    
    // 鵷鶵視角效果函數
    function applyYuanchuView() {
      createTransformationOverlay({
        background: 'linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(173, 216, 230, 0.2), rgba(255, 182, 193, 0.1))',
        boxShadow: 'inset 0 0 50px rgba(255, 255, 255, 0.3)',
        transform: 'scale(0.88)',
        filter: 'brightness(1.3) contrast(0.85) saturate(1.2) hue-rotate(10deg)'
      });
    }
    
    // 鴟鴞視角效果函數
    function applyChixiaoView() {
      createTransformationOverlay({
        background: 'linear-gradient(to bottom, rgba(75, 0, 130, 0.2), rgba(139, 69, 19, 0.3), rgba(0, 0, 0, 0.4))',
        boxShadow: 'inset 0 0 30px rgba(255, 215, 0, 0.2)',
        transform: 'scale(0.88)',
        filter: 'brightness(0.7) contrast(1.4) saturate(0.8) hue-rotate(45deg) sepia(0.3)'
      });
    }
    
    // Function to show transformation transition between two forms
    function showTransformationTransition(fromForm, toForm) {
      // 🔧 修复：确保目标图标在动画前已存在
      ensureIconExists(toForm);
      ensureIconExists(fromForm);
      
      // Remove any existing transformation containers
      const existingTransform = document.querySelector('.transformation-container');
      if (existingTransform) {
        existingTransform.remove();
      }
      
      // Create transformation container
      const transformContainer = document.createElement('div');
      transformContainer.className = 'transformation-container';
      
      // 創建圓形背景，使用漸變色以視覺呈現形態轉換過程
      const transformCircle = document.createElement('div');
      transformCircle.className = 'transformation-circle';
      
      // 基於目標形態設置背景顏色 - 支持所有物化角色
      let bgColor = 'rgba(147, 146, 255, 0.8)'; // 默認人形顏色
      
      // 使用emoji映射系统中的颜色
      const formColorMap = {
        'human': 'rgba(147, 146, 255, 0.8)',
        'butterfly': 'rgba(147, 51, 234, 0.8)',
        'fish': 'rgba(59, 130, 246, 0.8)',
        'kun': 'rgba(6, 182, 212, 0.8)',
        'peng': 'rgba(14, 165, 233, 0.8)',
        'yuanchu': 'rgba(255, 215, 0, 0.8)',
        'chixiao': 'rgba(139, 69, 19, 0.8)',
        'snail': 'rgba(147, 50, 158, 0.8)',
        'morning-fungus': 'rgba(245, 158, 11, 0.8)',
        'cicada': 'rgba(34, 197, 94, 0.8)',
        'great-chun': 'rgba(22, 163, 74, 0.8)',
        'ant': 'rgba(120, 53, 15, 0.8)',
        'star': 'rgba(255, 215, 0, 0.8)'
      };
      
      bgColor = formColorMap[toForm] || bgColor;
      
      transformCircle.style.background = `radial-gradient(circle, ${bgColor.replace('0.8', '0.2')} 0%, ${bgColor} 70%, ${bgColor.replace('0.8', '0.2')} 100%)`;
      transformContainer.appendChild(transformCircle);
      
      // Create particles for transition effect
      const particleContainer = document.createElement('div');
      particleContainer.className = 'particle-container';
      
      // Add particles with color matching the target form
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = bgColor;
        
        // Random position and delay
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 100;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.left = `calc(50% + ${x}px)`;
        particle.style.top = `calc(50% + ${y}px)`;
        
        // Add animation with random delay
        const delay = Math.random() * 1.5;
        particle.style.animation = `particle-float 1.5s ${delay}s forwards ease-out`;
        
        particleContainer.appendChild(particle);
      }
      
      transformContainer.appendChild(particleContainer);
      
      // 使用現有的形態圖標進行流暢轉換，而不是創建新的SVG
      // 從源圖標淡出並將目標圖標淡入
      const iconContainer = document.createElement('div');
      iconContainer.className = 'icon-transformation';
      iconContainer.style.position = 'absolute';
      iconContainer.style.width = '200px';
      iconContainer.style.height = '200px';
      iconContainer.style.left = '50%';
      iconContainer.style.top = '50%';
      iconContainer.style.transform = 'translate(-50%, -50%)';
      iconContainer.style.zIndex = '10';
      
      // 查找源圖標和目標圖標的內容
      const fromIconId = `${fromForm}-icon`;
      const toIconId = `${toForm}-icon`;
      
      const fromIconElement = document.getElementById(fromIconId);
      const toIconElement = document.getElementById(toIconId);
      
      if (fromIconElement && toIconElement) {
        // 創建克隆用於動畫，這樣不會干擾原始圖標
        const fromIconClone = fromIconElement.cloneNode(true);
        const toIconClone = toIconElement.cloneNode(true);
        
        // 設置起始樣式
        fromIconClone.id = 'from-icon-clone';
        toIconClone.id = 'to-icon-clone';
        
        fromIconClone.style.opacity = '1';
        fromIconClone.style.transform = 'scale(1)';
        fromIconClone.style.position = 'absolute';
        fromIconClone.style.width = '100%';
        fromIconClone.style.height = '100%';
        fromIconClone.style.left = '0';
        fromIconClone.style.top = '0';
        
        toIconClone.style.opacity = '0';
        toIconClone.style.transform = 'scale(0.5)';
        toIconClone.style.position = 'absolute';
        toIconClone.style.width = '100%';
        toIconClone.style.height = '100%';
        toIconClone.style.left = '0';
        toIconClone.style.top = '0';
        
        // 添加到容器
        iconContainer.appendChild(fromIconClone);
        iconContainer.appendChild(toIconClone);
        
        // 動畫淡出源圖標並放大目標圖標
        setTimeout(() => {
          // 源圖標淡出並縮小
          fromIconClone.style.transition = 'all 1.2s ease-in-out';
          fromIconClone.style.opacity = '0';
          fromIconClone.style.transform = 'scale(0.5)';
          
          // 目標圖標淡入並放大 - 使用transformation-emoji類增強效果
          toIconClone.style.transition = 'all 1.2s ease-in-out';
          toIconClone.style.opacity = '1';
          toIconClone.style.transform = 'scale(1)';
          
          // 為emoji添加特殊變身效果
          const emojiElement = toIconClone.querySelector('.emoji-unified');
          if (emojiElement) {
            emojiElement.classList.add('transformation-emoji');
            // 移除原有的動畫類，避免衝突
            emojiElement.style.animation = 'transformation-spin 2s ease-in-out';
          }
          
          // 為所有物化角色添加特殊粒子效果
          addTransformationParticleEffects(toForm, iconContainer);
          
          // 保留原有的特殊效果（向后兼容）
          if (toForm === 'kun' || toForm === 'peng') {
            // 波紋效果
            const ripple = document.createElement('div');
            ripple.style.position = 'absolute';
            ripple.style.width = '100%';
            ripple.style.height = '100%';
            ripple.style.border = '2px solid rgba(64, 186, 213, 0.8)';
            ripple.style.borderRadius = '50%';
            ripple.style.top = '0';
            ripple.style.left = '0';
            ripple.style.animation = 'ripple-effect 1.5s ease-out';
            
            iconContainer.appendChild(ripple);
            
            if (!document.getElementById('kun-peng-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'kun-peng-animation-style';
              styleEl.innerHTML = `
                @keyframes ripple-effect {
                  0% { transform: scale(0.8); opacity: 1; }
                  100% { transform: scale(1.5); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
          
          // 為鳥添加特殊效果
          if (toForm === 'bird') {
            // 羽毛效果
            for (let i = 0; i < 12; i++) {
              const feather = document.createElement('div');
              feather.style.position = 'absolute';
              feather.style.width = '10px';
              feather.style.height = '20px';
              feather.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
              feather.style.borderRadius = '50% 50% 20% 20% / 70% 70% 30% 30%';
              
              // 隨機位置和角度
              const angle = Math.random() * Math.PI * 2;
              const distance = 40 + Math.random() * 30;
              const x = Math.cos(angle) * distance;
              const y = Math.sin(angle) * distance;
              
              feather.style.left = `calc(50% + ${x}px)`;
              feather.style.top = `calc(50% + ${y}px)`;
              feather.style.transform = `rotate(${Math.random() * 360}deg)`;
              
              // 動畫與延遲
              feather.style.animation = `feather-float 2s ${Math.random() * 0.5}s ease-out forwards`;
              
              iconContainer.appendChild(feather);
            }
            
            if (!document.getElementById('bird-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'bird-animation-style';
              styleEl.innerHTML = `
                @keyframes feather-float {
                  0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
                  10% { opacity: 0.8; }
                  100% { transform: translate(calc(var(--tx, 20px) * 2), calc(var(--ty, -30px) * 2)) rotate(360deg); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
          
          // 為魚添加特殊效果
          if (toForm === 'fish') {
            // 水泡效果
            for (let i = 0; i < 15; i++) {
              const bubble = document.createElement('div');
              bubble.style.position = 'absolute';
              bubble.style.width = `${5 + Math.random() * 10}px`;
              bubble.style.height = bubble.style.width;
              bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
              bubble.style.borderRadius = '50%';
              
              // 隨機位置
              const angle = Math.random() * Math.PI * 2;
              const distance = 30 + Math.random() * 40;
              const x = Math.cos(angle) * distance;
              const y = Math.sin(angle) * distance;
              
              bubble.style.left = `calc(50% + ${x}px)`;
              bubble.style.top = `calc(50% + ${y}px)`;
              
              // 動畫與延遲
              bubble.style.animation = `bubble-float 1.5s ${Math.random() * 1}s ease-out forwards`;
              
              iconContainer.appendChild(bubble);
            }
            
            if (!document.getElementById('fish-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'fish-animation-style';
              styleEl.innerHTML = `
                @keyframes bubble-float {
                  0% { transform: scale(0.5); opacity: 0; }
                  10% { opacity: 0.8; }
                  100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
          
          // 為蝴蝶添加特殊效果
          if (toForm === 'butterfly') {
            // 花粉效果
            for (let i = 0; i < 20; i++) {
              const pollen = document.createElement('div');
              pollen.style.position = 'absolute';
              pollen.style.width = `${3 + Math.random() * 5}px`;
              pollen.style.height = pollen.style.width;
              pollen.style.backgroundColor = 'rgba(255, 255, 150, 0.8)';
              pollen.style.borderRadius = '50%';
              
              // 隨機位置
              const angle = Math.random() * Math.PI * 2;
              const distance = 20 + Math.random() * 60;
              const x = Math.cos(angle) * distance;
              const y = Math.sin(angle) * distance;
              
              pollen.style.left = `calc(50% + ${x}px)`;
              pollen.style.top = `calc(50% + ${y}px)`;
              
              // 動畫與延遲
              pollen.style.animation = `pollen-float 2s ${Math.random() * 1}s ease-out forwards`;
              
              iconContainer.appendChild(pollen);
            }
            
            if (!document.getElementById('butterfly-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'butterfly-animation-style';
              styleEl.innerHTML = `
                @keyframes pollen-float {
                  0% { transform: scale(0.5); opacity: 0; }
                  10% { opacity: 0.9; }
                  100% { transform: translate(${Math.random() > 0.5 ? '30px' : '-30px'}, ${Math.random() > 0.5 ? '30px' : '-30px'}) scale(1.2); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
        }, 300);
      } else {
        // 如果找不到圖標，使用通用的能量效果
        const energyEffect = document.createElement('div');
        energyEffect.style.position = 'absolute';
        energyEffect.style.width = '100%';
        energyEffect.style.height = '100%';
        energyEffect.style.borderRadius = '50%';
        energyEffect.style.background = `radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, ${bgColor} 70%)`;
        energyEffect.style.boxShadow = `0 0 30px ${bgColor}, 0 0 60px ${bgColor.replace('0.8', '0.4')}`;
        energyEffect.style.animation = 'energy-pulse 2s infinite alternate ease-in-out';
        
        iconContainer.appendChild(energyEffect);
        
        if (!document.getElementById('energy-animation-style')) {
          const styleEl = document.createElement('style');
          styleEl.id = 'energy-animation-style';
          styleEl.innerHTML = `
            @keyframes energy-pulse {
              0% { transform: scale(0.8); opacity: 0.8; }
              100% { transform: scale(1.1); opacity: 1; }
            }
          `;
          document.head.appendChild(styleEl);
        }
      }
      
      transformContainer.appendChild(iconContainer);
      
      // Add to page
      document.body.appendChild(transformContainer);
      
      // Trigger animation after a small delay to ensure DOM is updated
      setTimeout(() => {
        transformContainer.classList.add('transform-active');
        
        // Remove the transformation container after animation completes
        setTimeout(() => {
          transformContainer.classList.add('fade-out');
          setTimeout(() => {
            transformContainer.remove();
          }, 800);
        }, 2000);
      }, 50);
    }
    
    function updateFormView(form) {
      // Update the form indicator icon
      const humanIcon = document.getElementById('human-icon');
      const butterflyIcon = document.getElementById('butterfly-icon');
      const fishIcon = document.getElementById('fish-icon');
      const formLabel = document.getElementById('form-label');
      
      // 獲取鯤和鵬的圖標
      const kunIcon = document.getElementById('kun-icon');
      const pengIcon = document.getElementById('peng-icon');
      
      // 使用统一emoji系统创建动态图标
        const formIconContainer = document.querySelector('.form-icon-container');
      
      // 创建缺失的图标（使用emoji系统）
      const iconsToCreate = ['kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      iconsToCreate.forEach(iconForm => {
        if (!document.getElementById(`${iconForm}-icon`) && form === iconForm && formIconContainer) {
          const newIcon = document.createElement('div');
          newIcon.id = `${iconForm}-icon`;
          newIcon.className = 'absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0';
          newIcon.appendChild(createEmojiIcon(iconForm));
          formIconContainer.appendChild(newIcon);
        }
      });
      
      // 重新獲取所有圖標元素（包括可能剛創建的）
      const kunIconUpdated = document.getElementById('kun-icon');
      const pengIconUpdated = document.getElementById('peng-icon');
      const birdIconUpdated = document.getElementById('bird-icon');
      
      // 隱藏所有圖標
      humanIcon.style.opacity = '0';
      humanIcon.style.transform = 'scale(0)';
      butterflyIcon.style.opacity = '0';
      butterflyIcon.style.transform = 'scale(0)';
      fishIcon.style.opacity = '0';
      fishIcon.style.transform = 'scale(0)';
      
      // 隱藏所有動態創建的圖標（如果存在）
      const allFormIcons = ['kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      allFormIcons.forEach(iconForm => {
        const iconElement = document.getElementById(`${iconForm}-icon`);
        if (iconElement) {
          iconElement.style.opacity = '0';
          iconElement.style.transform = 'scale(0)';
        }
      });
      
      // 隱藏鳥圖標（如果存在）
      if (birdIconUpdated) {
        birdIconUpdated.style.opacity = '0';
        birdIconUpdated.style.transform = 'scale(0)';
      }
      
      // 清除所有特殊視覺效果（在設置新效果之前）
      removeAntVisionEffect();
      removeButterflyDreamEffect();
      removeSnailPerspectiveEffect();
      removeQiVisionEffect();
      
      // 顯示當前形態圖標並更新標籤
      switch (form) {
        case 'human':
          humanIcon.style.opacity = '1';
          humanIcon.style.transform = 'scale(1)';
          formLabel.textContent = '人形';
          
          // 移除物化覆蓋層，恢復原始背景
          removeTransformationOverlay();
          break;
          
        case 'butterfly':
          butterflyIcon.style.opacity = '1';
          butterflyIcon.style.transform = 'scale(1)';
          formLabel.textContent = '蝴蝶';
          
          // 蝴蝶的視覺效果 - 夢境般的呼吸縮放和色彩變化
          createTransformationOverlay({
            background: 'linear-gradient(45deg, rgba(147, 51, 234, 0.1), rgba(168, 85, 247, 0.05))',
            transform: 'scale(0.95)',
            filter: 'hue-rotate(20deg) brightness(1.1) saturate(1.2)'
          });
          
          // 添加蝴蝶夢境縮放效果
          addButterflyDreamEffect();
          
          // 尾聲章節中的蝴蝶物化觸發特殊夢境粒子效果
          if (gameState.currentChapter === 'epilogue') {
            setTimeout(() => createButterflyDreamEffect(), 1500);
          }
          break;
          
        case 'fish':
          fishIcon.style.opacity = '1';
          fishIcon.style.transform = 'scale(1)';
          formLabel.textContent = '儵魚';
          
          // 魚的視覺效果 - 統一的水中游弋視角（不再根據章節區分）
          createTransformationOverlay({
            background: 'rgba(0, 100, 255, 0.08)',
            transform: 'scale(0.9)',
            filter: 'hue-rotate(180deg) saturate(1.2)'
          });
          break;
          
        case 'kun':
          // 確保鯤的圖標存在
          if (kunIconUpdated) {
            // 顯示鯤圖標
            kunIconUpdated.style.opacity = '1';
            kunIconUpdated.style.transform = 'scale(1)';
            formLabel.textContent = '鯤';
            
            // 鯤的視覺效果 - 深海巨獸視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(64, 186, 213, 0.3), rgba(103, 200, 208, 0.2))',
              transform: 'scale(0.85)',
              filter: 'hue-rotate(160deg) saturate(1.3)'
            });
          }
          break;
          
        case 'peng':
          // 確保鵬的圖標存在
          if (pengIconUpdated) {
            // 顯示鵬圖標
            pengIconUpdated.style.opacity = '1';
            pengIconUpdated.style.transform = 'scale(1)';
            formLabel.textContent = '鵬';
            
            // 鵬的視覺效果 - 九萬里高空視角
            createTransformationOverlay({
              background: 'linear-gradient(to top, rgba(64, 186, 213, 0.2), rgba(167, 232, 249, 0.3))',
              transform: 'scale(0.7)',
              filter: 'hue-rotate(190deg) brightness(1.2) saturate(0.8)'
            });
          }
          break;
          
        case 'yuanchu':
          // 確保鵷鶵的圖標存在
          let yuanchuIcon = document.getElementById('yuanchu-icon');
          if (yuanchuIcon) {
            yuanchuIcon.style.opacity = '1';
            yuanchuIcon.style.transform = 'scale(1)';
            formLabel.textContent = '鵷鶵';
            
            // 應用鵷鶵視角效果
            applyYuanchuView();
          }
          break;
          
        case 'chixiao':
          // 確保鴟鴞的圖標存在
          let chixiaoIcon = document.getElementById('chixiao-icon');
          if (chixiaoIcon) {
            chixiaoIcon.style.opacity = '1';
            chixiaoIcon.style.transform = 'scale(1)';
            formLabel.textContent = '鴟鴞';
            
            // 應用鴟鴞視角效果
            applyChixiaoView();
          }
          break;
          
        case 'snail':
          // 確保蝸牛的圖標存在
          let snailIconUpdated = document.getElementById('snail-icon');
          if (snailIconUpdated) {
            snailIconUpdated.style.opacity = '1';
            snailIconUpdated.style.transform = 'scale(1)';
            formLabel.textContent = '蝸牛';
            
            // 使用原本的蝸牛視角效果，而不是覆蓋層系統
            createSnailPerspectiveEffect();
          }
          break;
          
        case 'morning-fungus':
          // 獲取或創建朝菌圖標
          let morningFungusIcon = document.getElementById('morning-fungus-icon');
          if (morningFungusIcon) {
            morningFungusIcon.style.opacity = '1';
            morningFungusIcon.style.transform = 'scale(1)';
            formLabel.textContent = '朝菌';
            
            // 朝菌的視覺效果 - 微觀晨露視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(254, 243, 199, 0.4), rgba(251, 191, 36, 0.3))',
              transform: 'scale(0.82)',
              filter: 'hue-rotate(45deg) brightness(1.3) saturate(1.4)'
            });
          }
          break;
          
        case 'cicada':
          // 獲取或創建蟪蛄圖標
          let cicadaIcon = document.getElementById('cicada-icon');
          if (cicadaIcon) {
            cicadaIcon.style.opacity = '1';
            cicadaIcon.style.transform = 'scale(1)';
            formLabel.textContent = '蟪蛄';
            
            // 蟪蛄的視覺效果 - 夏日韻律視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.2))',
              transform: 'scale(0.8)',
              filter: 'hue-rotate(90deg) brightness(1.1) saturate(1.2)'
            });
          }
          break;
          
        case 'great-chun':
          // 獲取或創建大椿圖標
          let greatChunIcon = document.getElementById('great-chun-icon');
          if (greatChunIcon) {
            greatChunIcon.style.opacity = '1';
            greatChunIcon.style.transform = 'scale(1)';
            formLabel.textContent = '大椿';
            
            // 大椿的視覺效果 - 千年古樹視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(120, 53, 15, 0.4), rgba(146, 64, 14, 0.3))',
              transform: 'scale(0.75)',
              filter: 'sepia(0.6) brightness(0.9) saturate(0.8)'
            });
          }
          break;
          
        case 'ant':
          // 確保螻蟻的圖標存在
          let antIcon = document.getElementById('ant-icon');
          if (antIcon) {
            antIcon.style.opacity = '1';
            antIcon.style.transform = 'scale(1)';
            formLabel.textContent = '螻蟻';
            
            // 螻蟻的視覺效果 - 模擬螞蟻的微觀放大視角：黑白、低亮度，放大觀察
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(42, 42, 42, 0.6), rgba(26, 26, 26, 0.8))',
              transform: 'scale(0.65)',
              filter: 'grayscale(0.9) brightness(0.8) contrast(1.1)'
            });
            
            // 添加螻蟻視角的特殊效果
            addAntVisionEffect();
          }
          break;
          
        case 'star':
          // 確保星辰的圖標存在
          let starIcon = document.getElementById('star-icon');
          if (starIcon) {
            starIcon.style.opacity = '1';
            starIcon.style.transform = 'scale(1)';
            formLabel.textContent = '星辰';
            
            // 星辰的視覺效果 - 宇宙無限視角，最大縮小率
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(25, 25, 112, 0.4), rgba(65, 105, 225, 0.3))',
              transform: 'scale(0.6)',
              filter: 'hue-rotate(240deg) brightness(1.1) saturate(1.3)'
            });
          }
          break;
          
        case 'qi':
          // 確保氣的圖標存在
          let qiIcon = document.getElementById('qi-icon');
          if (qiIcon) {
            qiIcon.style.opacity = '1';
            qiIcon.style.transform = 'scale(1)';
            formLabel.textContent = '氣';
            
            // 氣的視覺效果 - 直接設置gameContainer樣式，不使用覆蓋層系統
            // 移除可能存在的覆蓋層
            const existingOverlay = document.querySelector('.transformation-overlay');
            if (existingOverlay) {
              existingOverlay.remove();
            }
            
            // 直接設置gameContainer樣式
            gameContainer.style.transform = 'scale(0.95)';
            gameContainer.style.filter = 'brightness(1.2) saturate(0.7) opacity(0.9)';
            
            // 在尾聲章節中保留背景圖片，其他章節使用氣形態背景
            if (gameState.currentChapter === 'epilogue') {
              // 尾聲章節：保留莊子背景圖片，但應用氣形態的濾鏡效果
              gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
              console.log('尾聲章節氣形態：保留背景圖片');
            } else {
              // 其他章節：使用氣形態的淡藍紫色背景
              gameContainer.style.background = 'linear-gradient(45deg, rgba(147, 146, 255, 0.1), rgba(255, 255, 255, 0.05))';
              console.log('非尾聲章節氣形態：使用氣形態背景');
            }
            
            // 添加氣形態的特殊效果（包含原本的黑白濾鏡）
            addQiVisionEffect();
          }
          break;
      }
      
      // 图标隐藏逻辑已在函数开头统一处理
      
      // 當改變形態時清理效果（魚形態已統一，不再需要特殊清理）
      
      // 當切換到非螻蟻形態時，移除螻蟻視覺效果
      if (form !== 'ant') {
        removeAntVisionEffect();
      }
      
      // 更新時間感知動畫速度
      updateTimePerceptionAnimations();
    }
    
    // 添加螻蟻視角的特殊視覺效果
    function addAntVisionEffect() {
      // 移除之前的螻蟻視覺效果
      const existingEffect = document.getElementById('ant-vision-overlay');
      if (existingEffect) {
        existingEffect.remove();
      }
      
      // 創建螻蟻視覺覆蓋層
      const antVisionOverlay = document.createElement('div');
      antVisionOverlay.id = 'ant-vision-overlay';
      antVisionOverlay.style.position = 'fixed';
      antVisionOverlay.style.top = '0';
      antVisionOverlay.style.left = '0';
      antVisionOverlay.style.width = '100%';
      antVisionOverlay.style.height = '100%';
      antVisionOverlay.style.pointerEvents = 'none';
      antVisionOverlay.style.zIndex = '500'; // 降低z-index，避免覆蓋重要UI
      
      // 創建放大鏡效果，模擬螞蟻的近視和有限視野
      antVisionOverlay.style.background = `
        radial-gradient(circle at center, 
          transparent 15%, 
          rgba(0, 0, 0, 0.1) 25%, 
          rgba(0, 0, 0, 0.4) 50%, 
          rgba(0, 0, 0, 0.7) 80%, 
          rgba(0, 0, 0, 0.9) 100%)
      `;
      
      // 添加放大效果的CSS變換
      antVisionOverlay.style.transform = 'scale(1.2)';
      antVisionOverlay.style.transformOrigin = 'center center';
      
      // 添加少量動態粒子，模擬螞蟻視覺的不完美，但不過度干擾
      for (let i = 0; i < 4; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = `${15 + Math.random() * 25}px`;
        particle.style.height = `${15 + Math.random() * 25}px`;
        particle.style.background = 'rgba(0, 0, 0, 0.05)';
        particle.style.borderRadius = '50%';
        particle.style.filter = 'blur(2px)';
        particle.style.left = `${20 + Math.random() * 60}%`; // 避免在中心區域
        particle.style.top = `${20 + Math.random() * 60}%`;
        particle.style.animation = `ant-vision-float ${4 + Math.random() * 6}s infinite ease-in-out`;
        particle.style.animationDelay = `${Math.random() * 3}s`;
        
        antVisionOverlay.appendChild(particle);
      }
      
      document.body.appendChild(antVisionOverlay);
      
      // 添加螻蟻視覺類到body
      document.body.classList.add('ant-vision');
      
      // 添加螻蟻視覺動畫樣式
      if (!document.getElementById('ant-vision-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'ant-vision-styles';
        styleElement.textContent = `
          @keyframes ant-vision-float {
            0%, 100% { 
              transform: translate(0, 0) scale(1); 
              opacity: 0.3; 
            }
            50% { 
              transform: translate(${-10 + Math.random() * 20}px, ${-10 + Math.random() * 20}px) scale(1.2); 
              opacity: 0.1; 
            }
          }
          
          /* 為螻蟻視角添加視覺效果，但保持文字清晰 */
          body.ant-vision {
            /* 移除blur效果，保持文字清晰 */
          }
          
          body.ant-vision * {
            /* 為所有元素添加輕微陰影增強對比度 */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
          }
          
          /* 確保重要UI元素在螻蟻視角下保持清晰和可見 */
          body.ant-vision .transformation-experience-text,
          body.ant-vision .transformation-experience-text *,
          body.ant-vision #advance-btn,
          body.ant-vision #advance-btn *,
          body.ant-vision .typewriter-text,
          body.ant-vision .typewriter-text *,
          body.ant-vision button,
          body.ant-vision button *,
          body.ant-vision .max-w-2xl,
          body.ant-vision .max-w-3xl,
          body.ant-vision p,
          body.ant-vision div[class*="text"] {
            filter: none !important;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.9) !important;
            color: #ffffff !important;
            position: relative !important;
            z-index: 1000 !important;
          }
          
          /* 為按鈕和重要容器添加背景 */
          body.ant-vision #advance-btn,
          body.ant-vision button,
          body.ant-vision .transformation-experience-text {
            background: rgba(0, 0, 0, 0.85) !important;
            border: 2px solid #888 !important;
            border-radius: 12px !important;
            padding: 12px 20px !important;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3) !important;
          }
          
          /* 確保文字容器有足夠的對比度 */
          body.ant-vision .max-w-2xl,
          body.ant-vision .max-w-3xl {
            background: rgba(0, 0, 0, 0.8) !important;
            border: 1px solid #666 !important;
            border-radius: 12px !important;
            padding: 20px !important;
            backdrop-filter: none !important;
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      // 為body添加螻蟻視覺類
      document.body.classList.add('ant-vision');
    }
    
    // 移除螻蟻視覺效果
    function removeAntVisionEffect() {
      const antVisionOverlay = document.getElementById('ant-vision-overlay');
      if (antVisionOverlay) {
        antVisionOverlay.remove();
      }
      
      document.body.classList.remove('ant-vision');
    }
    
    // 添加蝴蝶夢境縮放效果
    function addButterflyDreamEffect() {
      // 移除之前的蝴蝶夢境效果
      const existingEffect = document.getElementById('butterfly-dream-overlay');
      if (existingEffect) {
        existingEffect.remove();
      }
      
      // 移除之前的樣式
      const existingStyles = document.getElementById('butterfly-dream-styles');
      if (existingStyles) {
        existingStyles.remove();
      }
      
      // 創建蝴蝶夢境覆蓋層
      const butterflyDreamOverlay = document.createElement('div');
      butterflyDreamOverlay.id = 'butterfly-dream-overlay';
      butterflyDreamOverlay.style.position = 'fixed';
      butterflyDreamOverlay.style.top = '0';
      butterflyDreamOverlay.style.left = '0';
      butterflyDreamOverlay.style.width = '100%';
      butterflyDreamOverlay.style.height = '100%';
      butterflyDreamOverlay.style.pointerEvents = 'none';
      butterflyDreamOverlay.style.zIndex = '400';
      
      // 創建夢境粒子效果
      for (let i = 0; i < 8; i++) {
        const dreamParticle = document.createElement('div');
        dreamParticle.style.position = 'absolute';
        dreamParticle.style.width = `${20 + Math.random() * 30}px`;
        dreamParticle.style.height = `${20 + Math.random() * 30}px`;
        dreamParticle.style.background = `rgba(147, 51, 234, ${0.1 + Math.random() * 0.2})`;
        dreamParticle.style.borderRadius = '50%';
        dreamParticle.style.filter = 'blur(15px)';
        dreamParticle.style.left = `${10 + Math.random() * 80}%`;
        dreamParticle.style.top = `${10 + Math.random() * 80}%`;
        dreamParticle.style.animation = `butterfly-dream-float ${6 + Math.random() * 8}s infinite ease-in-out`;
        dreamParticle.style.animationDelay = `${Math.random() * 4}s`;
        
        butterflyDreamOverlay.appendChild(dreamParticle);
      }
      
      document.body.appendChild(butterflyDreamOverlay);
      
      // 添加蝴蝶夢境動畫樣式
      const styleElement = document.createElement('style');
      styleElement.id = 'butterfly-dream-styles';
      styleElement.textContent = `
        @keyframes butterfly-dream-float {
          0%, 100% { 
            transform: translate(0, 0) scale(0.8); 
            opacity: 0.1; 
          }
          25% { 
            transform: translate(${-30 + Math.random() * 60}px, ${-20 + Math.random() * 40}px) scale(1.2); 
            opacity: 0.3; 
          }
          50% { 
            transform: translate(${-20 + Math.random() * 40}px, ${-30 + Math.random() * 60}px) scale(1.0); 
            opacity: 0.2; 
          }
          75% { 
            transform: translate(${-40 + Math.random() * 80}px, ${-10 + Math.random() * 20}px) scale(1.1); 
            opacity: 0.25; 
          }
        }
        
        @keyframes butterfly-dream-breath {
          0%, 100% { transform: scale(0.95); }
          50% { transform: scale(1.02); }
        }
        
        /* 為遊戲容器添加呼吸縮放效果 */
        body.butterfly-dream #game-container {
          animation: butterfly-dream-breath 8s infinite ease-in-out;
          transform-origin: center center;
        }
        
        /* 為重要元素添加夢境光暈 */
        body.butterfly-dream .transformation-experience-text,
        body.butterfly-dream #advance-btn,
        body.butterfly-dream .typewriter-text,
        body.butterfly-dream button {
          box-shadow: 0 0 20px rgba(147, 51, 234, 0.3) !important;
          border: 1px solid rgba(147, 51, 234, 0.4) !important;
          backdrop-filter: blur(5px) !important;
        }
      `;
      document.head.appendChild(styleElement);
      
      // 為body添加蝴蝶夢境類
      document.body.classList.add('butterfly-dream');
    }
    
    // 移除蝴蝶夢境效果
    function removeButterflyDreamEffect() {
      const butterflyDreamOverlay = document.getElementById('butterfly-dream-overlay');
      if (butterflyDreamOverlay) {
        butterflyDreamOverlay.remove();
      }
      
      const butterflyDreamStyles = document.getElementById('butterfly-dream-styles');
      if (butterflyDreamStyles) {
        butterflyDreamStyles.remove();
      }
      
      document.body.classList.remove('butterfly-dream');
    }
    
    // 添加氣視覺效果
    function addQiVisionEffect() {
      // 移除之前的氣視覺效果
      const existingEffect = document.getElementById('qi-vision-overlay');
      if (existingEffect) {
        existingEffect.remove();
      }
      
      // 創建氣視覺覆蓋層
      const qiVisionOverlay = document.createElement('div');
      qiVisionOverlay.id = 'qi-vision-overlay';
      qiVisionOverlay.style.position = 'fixed';
      qiVisionOverlay.style.top = '0';
      qiVisionOverlay.style.left = '0';
      qiVisionOverlay.style.width = '100%';
      qiVisionOverlay.style.height = '100%';
      qiVisionOverlay.style.pointerEvents = 'none';
      qiVisionOverlay.style.zIndex = '400';
      
      // 創建陰陽流動的氣粒子效果（黑色）
      for (let i = 0; i < 15; i++) {
        const qiParticle = document.createElement('div');
        qiParticle.className = 'qi-magnetic-particle';
        qiParticle.style.position = 'absolute';
        qiParticle.style.width = `${6 + Math.random() * 12}px`;
        qiParticle.style.height = `${6 + Math.random() * 12}px`;
        qiParticle.style.background = `radial-gradient(circle, rgba(0, 0, 0, ${0.6 + Math.random() * 0.4}), transparent)`;
        qiParticle.style.borderRadius = '50%';
        qiParticle.style.filter = 'blur(2px)';
        qiParticle.style.left = `${Math.random() * 100}%`;
        qiParticle.style.top = `${Math.random() * 100}%`;
        qiParticle.style.animation = `qi-black-flow ${10 + Math.random() * 15}s infinite ease-in-out`;
        qiParticle.style.animationDelay = `${Math.random() * 8}s`;
        
        // 存儲初始位置用於磁力計算
        qiParticle.dataset.initialX = qiParticle.style.left;
        qiParticle.dataset.initialY = qiParticle.style.top;
        
        qiVisionOverlay.appendChild(qiParticle);
      }
      
      document.body.appendChild(qiVisionOverlay);
      
      // 添加氣視覺動畫樣式
      if (!document.getElementById('qi-vision-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'qi-vision-styles';
        styleElement.textContent = `
                     /* 氣化視角：純粹黑白濾鏡效果 */
           body.qi-vision {
             filter: grayscale(100%) contrast(1.5);
             cursor: crosshair; /* 使用十字光標確保在黑白場景中可見 */
           }
          
          /* 黑色氣粒子流動動畫 */
          @keyframes qi-black-flow {
            0%, 100% { 
              transform: translate(0, 0) scale(0.8); 
              opacity: 0.4; 
            }
            25% { 
              transform: translate(${-40 + Math.random() * 80}px, ${-30 + Math.random() * 60}px) scale(1.2); 
              opacity: 0.8; 
            }
            50% { 
              transform: translate(${-30 + Math.random() * 60}px, ${-40 + Math.random() * 80}px) scale(1.0); 
              opacity: 0.6; 
            }
            75% { 
              transform: translate(${-35 + Math.random() * 70}px, ${-25 + Math.random() * 50}px) scale(1.1); 
              opacity: 0.7; 
            }
          }
          
                     /* 確保所有八卦符號變成黑色 */
           body.qi-vision .bagua-symbol,
           body.qi-vision .bagua-qian,
           body.qi-vision .bagua-dui,
           body.qi-vision .bagua-li,
           body.qi-vision .bagua-zhen,
           body.qi-vision .bagua-xun,
           body.qi-vision .bagua-kan,
           body.qi-vision .bagua-gen,
           body.qi-vision .bagua-kun {
             color: #000000 !important;
             text-shadow: 
               0 0 8px #000000,
               0 0 16px #000000,
               0 0 24px #000000 !important;
             filter: drop-shadow(0 0 10px #000000) !important;
           }
          
          /* 確保所有虛空粒子變成黑色 */
          body.qi-vision .void-particle {
            background: radial-gradient(circle, rgba(0, 0, 0, 0.8), transparent) !important;
            box-shadow: 0 0 15px rgba(0, 0, 0, 0.6) !important;
          }
          
          /* 確保太極符號變成黑色 */
          body.qi-vision .yin-yang-emoji {
            color: #000000 !important;
            filter: drop-shadow(0 0 20px #000000) !important;
          }
          
          /* 確保渾沌形體變成黑白 */
          body.qi-vision .chaos-form {
            background: radial-gradient(ellipse, rgba(255, 255, 255, 0.4) 0%, rgba(0, 0, 0, 0.3) 50%, transparent 100%) !important;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5), 0 0 80px rgba(255, 255, 255, 0.3) !important;
          }
          
          
          
          /* 文字確保清晰可讀 - 黑色文字（無白邊） */
          body.qi-vision .transformation-experience-text,
          body.qi-vision .transformation-experience-text *,
          body.qi-vision #advance-btn,
          body.qi-vision #advance-btn *,
          body.qi-vision .typewriter-text,
          body.qi-vision .typewriter-text *,
          body.qi-vision button,
          body.qi-vision button *,
          body.qi-vision .max-w-2xl,
          body.qi-vision .max-w-3xl,
          body.qi-vision p,
          body.qi-vision div[class*="text"] {
            color: #000000 !important;
            text-shadow: none !important;
            font-weight: bold !important;
          }
          
                     /* 重要容器背景確保對比度 */
           body.qi-vision .transformation-experience-text {
             background: rgba(255, 255, 255, 0.2) !important;
             border: 2px solid rgba(0, 0, 0, 0.4) !important;
             border-radius: 12px !important;
             padding: 2rem !important;
             box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
             backdrop-filter: blur(15px) !important;
             -webkit-backdrop-filter: blur(15px) !important;
           }
           
           body.qi-vision #advance-btn,
           body.qi-vision button {
             background: rgba(255, 255, 255, 0.9) !important;
             border: 2px solid #000000 !important;
             border-radius: 12px !important;
             padding: 12px 20px !important;
             box-shadow: 0 0 20px rgba(0, 0, 0, 0.5) !important;
           }
           
           /* 文字容器背景 */
           body.qi-vision .max-w-2xl,
           body.qi-vision .max-w-3xl {
             background: rgba(255, 255, 255, 0.95) !important;
             border: 2px solid #000000 !important;
             border-radius: 12px !important;
             padding: 20px !important;
           }
        `;
        document.head.appendChild(styleElement);
      }
      
      // 為body添加氣視覺類
      document.body.classList.add('qi-vision');
      
      // 鼠標磁力效果
      let mouseX = 0, mouseY = 0;
      const handleMouseMove = (e) => {
        mouseX = e.clientX;
        mouseY = e.clientY;
        
        // 更新鼠標位置CSS變量
        document.documentElement.style.setProperty('--mouse-x', mouseX + 'px');
        document.documentElement.style.setProperty('--mouse-y', mouseY + 'px');
        
        // 對所有磁性粒子應用磁力效果
        const magneticParticles = document.querySelectorAll('.qi-magnetic-particle');
        magneticParticles.forEach((particle, index) => {
          const rect = particle.getBoundingClientRect();
          const particleX = rect.left + rect.width / 2;
          const particleY = rect.top + rect.height / 2;
          
          // 計算距離
          const distance = Math.sqrt(Math.pow(mouseX - particleX, 2) + Math.pow(mouseY - particleY, 2));
          const maxDistance = 200; // 磁力影響範圍
          
          if (distance < maxDistance) {
            // 計算磁力強度（距離越近，磁力越強）
            const magneticForce = (maxDistance - distance) / maxDistance;
            const offsetX = (mouseX - particleX) * magneticForce * 0.3; // 緩慢的磁力係數
            const offsetY = (mouseY - particleY) * magneticForce * 0.3;
            
            // 應用磁力偏移，但保持原有動畫
            particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
            particle.style.transition = 'transform 0.8s ease-out'; // 緩慢跟隨
          } else {
            // 距離太遠時恢復原位
            particle.style.transform = 'translate(0, 0)';
            particle.style.transition = 'transform 1.2s ease-out';
          }
        });
        
                 // 對八卦符號也應用磁力效果
         const baguaSymbols = document.querySelectorAll('.bagua-symbol');
         baguaSymbols.forEach((symbol) => {
           const rect = symbol.getBoundingClientRect();
           const symbolX = rect.left + rect.width / 2;
           const symbolY = rect.top + rect.height / 2;
           
           const distance = Math.sqrt(Math.pow(mouseX - symbolX, 2) + Math.pow(mouseY - symbolY, 2));
           const maxDistance = 150;
           
           if (distance < maxDistance) {
             const magneticForce = (maxDistance - distance) / maxDistance;
             const offsetX = (mouseX - symbolX) * magneticForce * 0.2;
             const offsetY = (mouseY - symbolY) * magneticForce * 0.2;
             
             // 保留原有的旋轉動畫，只添加磁力偏移
             const currentTransform = symbol.style.transform || '';
             const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);
             const currentRotate = rotateMatch ? rotateMatch[0] : 'rotate(0deg)';
             
             symbol.style.transform = `translate(${offsetX}px, ${offsetY}px) ${currentRotate}`;
             symbol.style.transition = 'transform 0.6s ease-out';
           } else {
             // 距離太遠時恢復原位，但保持旋轉
             const currentTransform = symbol.style.transform || '';
             const rotateMatch = currentTransform.match(/rotate\(([^)]+)\)/);
             const currentRotate = rotateMatch ? rotateMatch[0] : 'rotate(0deg)';
             
             symbol.style.transform = `translate(0, 0) ${currentRotate}`;
             symbol.style.transition = 'transform 1.0s ease-out';
           }
         });
         
         // 對虛空粒子也應用磁力效果
         const voidParticles = document.querySelectorAll('.void-particle');
         voidParticles.forEach((particle) => {
           const rect = particle.getBoundingClientRect();
           const particleX = rect.left + rect.width / 2;
           const particleY = rect.top + rect.height / 2;
           
           const distance = Math.sqrt(Math.pow(mouseX - particleX, 2) + Math.pow(mouseY - particleY, 2));
           const maxDistance = 180;
           
           if (distance < maxDistance) {
             const magneticForce = (maxDistance - distance) / maxDistance;
             const offsetX = (mouseX - particleX) * magneticForce * 0.25;
             const offsetY = (mouseY - particleY) * magneticForce * 0.25;
             
             particle.style.transform = `translate(${offsetX}px, ${offsetY}px)`;
             particle.style.transition = 'transform 0.7s ease-out';
           } else {
             particle.style.transform = 'translate(0, 0)';
             particle.style.transition = 'transform 1.1s ease-out';
           }
         });
      };
      
      document.addEventListener('mousemove', handleMouseMove);
      qiVisionOverlay.dataset.mouseMoveHandler = 'true';
    }
    
    // 移除氣視覺效果
    function removeQiVisionEffect() {
      console.log('🧹 開始清理氣視覺效果...');
      
      try {
        // 移除氣視覺覆蓋層（這會自動清理其中的事件監聽器）
        const qiVisionOverlay = document.getElementById('qi-vision-overlay');
        if (qiVisionOverlay) {
          console.log('移除氣視覺覆蓋層');
          qiVisionOverlay.remove();
        }
        
        // 移除氣視覺樣式
        const qiVisionStyles = document.getElementById('qi-vision-styles');
        if (qiVisionStyles) {
          console.log('移除氣視覺樣式');
          qiVisionStyles.remove();
        }
        
        // 移除body上的氣視覺類
        document.body.classList.remove('qi-vision');
        console.log('移除body上的qi-vision類');
        
        // 清理gameContainer的氣形態樣式
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
        
        // 在尾聲章節中保留背景圖片，其他章節清空背景
        if (gameState.currentChapter === 'epilogue') {
          // 尾聲章節：保留莊子背景圖片和濾鏡
          gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
          gameContainer.style.filter = 'sepia(0.15) saturate(1.2) brightness(1.1)';
          console.log('尾聲章節：保留背景圖片，重置其他樣式');
        } else {
          // 其他章節：清空背景
          gameContainer.style.background = '';
          console.log('非尾聲章節：重置所有gameContainer樣式');
        }
        
        // 重置可能的CSS變量
        document.documentElement.style.removeProperty('--mouse-x');
        document.documentElement.style.removeProperty('--mouse-y');
        console.log('重置CSS變量');
        
        console.log('✅ 氣視覺效果清理完成');
      } catch (error) {
        console.error('❌ 清理氣視覺效果時發生錯誤:', error);
        // 至少嘗試移除body類，防止視覺效果殘留
        document.body.classList.remove('qi-vision');
        // 重置基本樣式
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
        
        // 在尾聲章節中保留背景圖片
        if (gameState.currentChapter === 'epilogue') {
          gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
          gameContainer.style.filter = 'sepia(0.15) saturate(1.2) brightness(1.1)';
        } else {
          gameContainer.style.background = '';
        }
      }
    }
    
    // 根據當前形態更新時間感知動畫速度
    function updateTimePerceptionAnimations() {
      let speedMultiplier = 1; // 正常速度
      
      switch(gameState.currentForm) {
        case 'morning-fungus':
          speedMultiplier = 0.15; // 朝菌視角：生命短暫，感受時間很快，動畫變得很快（持續時間變短）
          break;
        case 'cicada':
          speedMultiplier = 0.4; // 蟪蛄視角：生命較短，感受時間較快，動畫比正常快（持續時間較短）
          break;
        case 'great-chun':
          speedMultiplier = 4.0; // 大椿視角：生命漫長，感受時間很慢，動畫變得很慢（持續時間變長）
          break;
        default:
          speedMultiplier = 1; // 其他形態保持正常速度
          break;
      }
      
      console.log(`更新時間感知動畫 - 當前形態: ${gameState.currentForm}, 速度倍數: ${speedMultiplier}`);
      
      // 更新時間粒子動畫速度
      const timeParticles = document.querySelectorAll('.time-particle-global');
      console.log(`找到 ${timeParticles.length} 個時間粒子`);
      
      timeParticles.forEach((particle, index) => {
        const originalDuration = particle.dataset.originalDuration;
        const delay = particle.dataset.delay;
        const animationType = particle.dataset.animationType;
        const easing = particle.dataset.easing;
        
        if (originalDuration && animationType) {
          const newDuration = parseFloat(originalDuration) * speedMultiplier;
          const oldAnimation = particle.style.animation;
          particle.style.animation = `${animationType} ${newDuration}s ${delay}s infinite ${easing}`;
          console.log(`粒子 ${index}: ${originalDuration}s -> ${newDuration}s (${animationType})`);
        } else {
          console.log(`粒子 ${index}: 缺少數據屬性`, {originalDuration, animationType, easing});
        }
      });
      
      // 更新蟪蛄飛行動畫速度
      const flyingCicadas = document.querySelectorAll('[data-original-flight-duration]');
      console.log(`找到 ${flyingCicadas.length} 個飛行蟪蛄`);
      
      flyingCicadas.forEach((cicada, index) => {
        const originalDuration = cicada.dataset.originalFlightDuration;
        const delay = cicada.dataset.flightDelay;
        
        if (originalDuration) {
          const newDuration = parseFloat(originalDuration) * speedMultiplier;
          cicada.style.animation = `cicada-flight ${newDuration}s ${delay}s infinite linear`;
          console.log(`蟪蛄飛行 ${index}: ${originalDuration}s -> ${newDuration}s`);
        }
      });
      
      // 更新蟪蛄翅膀扇動速度
      const cicadaWings = document.querySelectorAll('[data-original-wing-duration]');
      console.log(`找到 ${cicadaWings.length} 個蟪蛄翅膀`);
      
      cicadaWings.forEach((wing, index) => {
        const originalDuration = wing.dataset.originalWingDuration;
        const animationType = wing.style.animation.includes('left') ? 'cicada-wing-left' : 'cicada-wing-right';
        
        if (originalDuration) {
          const newDuration = parseFloat(originalDuration) * speedMultiplier;
          wing.style.animation = `${animationType} ${newDuration}s infinite ease-in-out`;
          console.log(`蟪蛄翅膀 ${index}: ${originalDuration}s -> ${newDuration}s (${animationType})`);
        }
      });
    }
    
    function processEffect(effect) {
      const [effectType, effectValue] = effect.split(':');
      
      switch (effectType) {
        case 'unlockButterfly':
          unlockForm('butterfly');
          break;
        case 'unlockFish':
          unlockForm('fish');
          break;
        case 'unlockKun':
          unlockForm('kun');
          break;
        case 'unlockPeng':
          unlockForm('peng');
          break;
        case 'unlockBird':
          unlockForm('yuanchu');
          unlockForm('chixiao');
          break;
        case 'collectAperture':
          collectAperture(effectValue);
          break;
        case 'unlockSnail':
          unlockForm('snail');
          break;
        case 'unlockViewScale':
          enableScaleControl();
          break;
        case 'unlockForm':
          unlockForm(effectValue);
          break;
        case 'switchToHuman':
          // 劇情專用：直接切換到人形，不觸發日常物化邏輯
          returnToHumanForStory();
          break;
        case 'cleanupChapter4':
          cleanupChapter4Effects();
          break;
        case 'cleanupChapter5':
          cleanupChapter5Effects();
          break;
      }
    }
    
    // 劇情專用：回到人形，不觸發日常物化邏輯
    function returnToHumanForStory() {
      console.log('🎭 劇情切換：回到人形');
      
      // 儲存當前形態用於轉換動畫
      const fromForm = gameState.currentForm;
      
      // 更新按鈕狀態：移除所有按鈕的活躍狀態
      Object.values(formButtons).forEach(button => {
        button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
        button.classList.add('bg-gray-500');
      });
      
      // 高亮人形按鈕
      if (formButtons['human']) {
        formButtons['human'].classList.remove('bg-gray-500');
        formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
      }
      
      // 顯示物化轉換動畫（從當前形態轉換到人形）
      if (fromForm !== 'human') {
        showTransformationTransition(fromForm, 'human');
      }
      
      // 設置動畫完成後的邏輯（1.5秒後執行，與正常物化轉換保持一致）
      setTimeout(() => {
        // 設置當前形態為人形
        gameState.currentForm = 'human';
        
        // 更新物化指示器和視覺效果
        updateFormView('human');
        
        // 確保繼續按鈕正常顯示（不隱藏）
        if (advanceBtn) {
          advanceBtn.style.display = 'block';
        }
        
        // 確保不處於日常物化狀態
        gameState.isInDailyTransformation = false;
        gameState.dailyTransformationPreviousForm = null;
        
        // 移除退出視角按鈕（如果存在）
        const exitButton = document.querySelector('.exit-transformation-btn');
        if (exitButton) {
          exitButton.remove();
        }
        
        console.log('✅ 已回到人形，物化指示器已更新，繼續按鈕可見，不觸發日常物化邏輯');
      }, fromForm !== 'human' ? 1500 : 0); // 如果已經是人形，立即執行
    }
    
    // 移除所有物化視覺效果的函數
    function removeAllTransformationEffects() {
      // 移除所有可能的視覺效果
      const effects = [
        'removeTransformationOverlay',
        'removeQiVisionEffect', 
        'removeKunView',
        'removePengView',
        'removeHumanView',
        'removeButterflyView',
        'removeFishView',
        'removeAntView',
        'removeStarView'
      ];
      
      effects.forEach(effectName => {
        if (typeof window[effectName] === 'function') {
          try {
            window[effectName]();
          } catch (e) {
            // 靜默忽略不存在的效果函數
          }
        }
      });
      
      // 通用清理：移除變換覆蓋層和重置容器樣式
      const overlay = document.querySelector('.transformation-overlay');
      if (overlay) {
        overlay.remove();
      }
      
      // 重置gameContainer的樣式
      if (gameContainer) {
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
      }
    }
    
    function unlockForm(form) {
      // 特殊處理：第一章中的蝴蝶形態應該立即顯示
      const isFirstChapterButterfly = (form === 'butterfly' && (gameState.currentChapter === 'prologue' || gameState.currentChapter === 'chapter1'));
      
      // 檢查是否是新章節的物化能力解鎖（但排除第一章的蝴蝶）
      const newChapterForms = ['fish', 'kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      const deferredUnlock = newChapterForms.includes(form) || (form === 'butterfly' && !isFirstChapterButterfly);
      
      // 檢查是否已經解鎖過該形態
      const alreadyUnlocked = gameState.unlockedForms.includes(form);
      
      if (deferredUnlock && !alreadyUnlocked) {
        // 新章節形態首次解鎖：只解鎖，不立即顯示按鈕（延遲到收集場景完成）
          gameState.unlockedForms.push(form);
          console.log(`預備解鎖新形態: ${form}，按鈕將在收集場景後顯示`);
        
        // 確保按鈕保持隱藏狀態
        if (formButtons[form]) {
          formButtons[form].style.visibility = 'hidden';
          formButtons[form].classList.add('hidden');
        }
        
        return; // 不執行下面的立即顯示邏輯
      } else if (alreadyUnlocked) {
        // 已經解鎖的形態：重新進入章節時應該立即顯示按鈕
        console.log(`重新顯示已解鎖形態按鈕: ${form}`);
        if (formButtons[form]) {
          formButtons[form].classList.remove('hidden');
          formButtons[form].style.visibility = 'visible';
        }
        return;
      }
      
      if (!alreadyUnlocked) {
        gameState.unlockedForms.push(form);
        console.log(`解鎖形態並立即顯示按鈕: ${form}`);
        
        // 一般形態處理（包括第一章的蝴蝶）
        // 顯示形態按鈕
        if (formButtons[form]) {
          formButtons[form].classList.remove('hidden');
          formButtons[form].style.visibility = 'visible';
          
          // 添加動畫效果
          formButtons[form].classList.add('animate-pulse');
          setTimeout(() => {
            formButtons[form].classList.remove('animate-pulse');
          }, 2000);
        }
      }
    }
    
    function collectAperture(aperture) {
      if (!gameState.collectedApertures.includes(aperture)) {
        // 創建一個互動式封印場景，讓玩家點擊收集
        createInteractiveApertureScene(aperture);
      }
    }
    
    // 創建互動式收集封印的場景
    function createInteractiveApertureScene(apertureType) {
      // 隱藏繼續按鈕，直到玩家收集封印
      advanceBtn.style.display = 'none';
      
      // 創建一個覆蓋層，增加儀式感
      const overlayEl = document.createElement('div');
      overlayEl.className = 'fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center';
      
      // 創建中央容器
      const containerEl = document.createElement('div');
      containerEl.className = 'relative max-w-md w-full p-8 flex flex-col items-center';
      
      // 創建標題
      const titleEl = document.createElement('h2');
      titleEl.className = 'text-2xl md:text-3xl text-white font-bold mb-8 text-center';
      titleEl.textContent = '混沌七竅封印';
      
      // 創建封印描述
      const descEl = document.createElement('p');
      descEl.className = 'text-white text-center mb-8';
      
      // 根據不同封印顯示不同描述
      switch(apertureType) {
        case 'left-eye':
          descEl.textContent = '你找到了左目之竅的封印！它將封閉你的左眼視覺，讓你不再被外在形象所迷惑，回歸內在的清明無分別。點擊封印將其收集。';
          break;
        case 'right-eye':
          descEl.textContent = '你找到了右目之竅的封印！它將封閉你的右眼分辨，讓你不再執著於大小差別，回歸平等心的本源。點擊封印將其收集。';
          break;
        case 'left-ear':
          descEl.textContent = '你找到了左耳之竅的封印！它將封閉你的左耳聽聞，讓你不再被外聲所擾，回歸內在的純然寧靜。點擊封印將其收集。';
          break;
        case 'right-ear':
          descEl.textContent = '你找到了右耳之竅的封印！它將封閉你的右耳判斷，讓你不再分辨真偽是非，回歸混沌的純真本性。點擊封印將其收集。';
          break;
        case 'left-nose':
          descEl.textContent = '你找到了左鼻之竅的封印！它將封閉你的嗅覺分別，讓你不再追求香臭好惡，回歸無分別的自然狀態。點擊封印將其收集。';
          break;
        case 'right-nose':
          descEl.textContent = '你找到了右鼻之竅的封印！它將封閉你的鼻息執著，讓你不再依賴氣味指引，回歸內在的無為智慧。點擊封印將其收集。';
          break;
        case 'mouth':
          descEl.textContent = '你找到了口之竅的封印！它將封閉你的言語分別，讓你不再用言語區分萬物，回歸無言大道的境界。點擊封印將其收集。';
          break;
        default:
          descEl.textContent = '你找到了一個神秘的封印！它將幫助混沌回歸原初的純真狀態。點擊將其收集。';
      }
      
      // 創建可點擊的封印
      const sealContainer = document.createElement('div');
      sealContainer.className = 'relative mb-8 cursor-pointer transform transition-all duration-500 hover:scale-110';
      sealContainer.style.width = '150px';
      sealContainer.style.height = '150px';
      
      // 創建發光效果背景
      const glowEffect = document.createElement('div');
      glowEffect.className = 'absolute inset-0 rounded-full';
      glowEffect.style.background = 'radial-gradient(circle, rgba(147, 146, 255, 0.7) 0%, rgba(93, 92, 222, 0) 70%)';
      glowEffect.style.filter = 'blur(15px)';
      glowEffect.style.animation = 'pulse-glow 2s infinite ease-in-out';
      
      // 添加脈衝動畫
      if (!document.getElementById('pulse-glow-animation')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'pulse-glow-animation';
        styleEl.textContent = `
          @keyframes pulse-glow {
            0%, 100% { opacity: 0.7; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
          }
          
          @keyframes rotate-seal {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          @keyframes floating-particles {
            0% { transform: translateY(0) rotate(0deg); opacity: 0.8; }
            100% { transform: translateY(-80px) rotate(360deg); opacity: 0; }
          }
          
          @keyframes celebration-ring {
            0% { transform: scale(0.3); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
          }
        `;
        document.head.appendChild(styleEl);
      }
      
      // 創建封印圖案
      const sealEl = document.createElement('div');
      sealEl.className = 'scene-seal absolute inset-0 ' + apertureType;
      sealEl.style.width = '100%';
      sealEl.style.height = '100%';
      sealEl.style.boxShadow = '0 0 20px rgba(93, 92, 222, 0.8), 0 0 40px rgba(93, 92, 222, 0.4) inset';
      
      // 添加浮動粒子
      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full bg-indigo-300';
        
        // 隨機大小和位置
        const size = 3 + Math.random() * 4;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 圍繞封印放置粒子
        const angle = Math.random() * Math.PI * 2;
        const distance = 60 + Math.random() * 20;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.left = `calc(50% + ${x}px)`;
        particle.style.top = `calc(50% + ${y}px)`;
        
        // 添加動畫，延遲不同
        const delay = Math.random() * 2;
        const duration = 2 + Math.random() * 2;
        particle.style.animation = `floating-particles ${duration}s ${delay}s infinite linear`;
        
        sealContainer.appendChild(particle);
      }
      
      // 添加提示文字
      const hintEl = document.createElement('p');
      hintEl.className = 'text-white text-opacity-80 mt-4 text-sm animate-pulse';
      hintEl.textContent = '點擊封印收集';
      
      // 組合元素
      sealContainer.appendChild(glowEffect);
      sealContainer.appendChild(sealEl);
      
      containerEl.appendChild(titleEl);
      containerEl.appendChild(descEl);
      containerEl.appendChild(sealContainer);
      containerEl.appendChild(hintEl);
      
      overlayEl.appendChild(containerEl);
      document.body.appendChild(overlayEl);
      
      // 為封印添加點擊事件
      sealContainer.addEventListener('click', () => {
        // 移除點擊事件
        sealContainer.style.pointerEvents = 'none';
        
        // 收集動畫 - 傳遞containerEl變數
        collectApertureWithAnimation(apertureType, sealEl, overlayEl, containerEl);
        
        // 移除提示
        hintEl.style.display = 'none';
        
        // 更新描述
        descEl.textContent = `你已獲得${getApertureName(apertureType)}的封印！`;
        descEl.className = 'text-white text-center mb-8 font-bold';
      });
    }
    
    // 根據封印類型返回封印名稱
    function getApertureName(apertureType) {
      switch(apertureType) {
        case 'left-eye': return '左目之竅';
        case 'right-eye': return '右目之竅';
        case 'left-ear': return '左耳之竅';
        case 'right-ear': return '右耳之竅';
        case 'left-nose': return '左鼻之竅';
        case 'right-nose': return '右鼻之竅';
        case 'mouth': return '口之竅';
        default: return '神秘';
      }
    }
    
    // 收集封印的動畫
    function collectApertureWithAnimation(apertureType, sealEl, overlayEl, containerEl) {
      // 播放收集動畫（加速）
      sealEl.style.animation = 'rotate-seal 0.8s ease-in-out';
      
      // 創建慶祝效果 - 脈衝環
      for (let i = 0; i < 3; i++) {
        const ring = document.createElement('div');
        ring.className = 'absolute rounded-full border-2 border-indigo-400 top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2';
        ring.style.width = '100%';
        ring.style.height = '100%';
        ring.style.animation = `celebration-ring 0.8s ${i * 0.2}s ease-out forwards`;
        sealEl.parentNode.appendChild(ring);
      }
      
      // 添加慶祝粒子
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full bg-white';
        
        // 隨機大小
        const size = 2 + Math.random() * 3;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 放置在中心
        particle.style.left = '50%';
        particle.style.top = '50%';
        
        // 計算隨機方向
        const angle = Math.random() * Math.PI * 2;
        const speed = 100 + Math.random() * 100;
        const xSpeed = Math.cos(angle) * speed;
        const ySpeed = Math.sin(angle) * speed;
        
        // 設置動畫
        particle.style.transform = 'translate(-50%, -50%)';
        particle.animate([
          { transform: 'translate(-50%, -50%)', opacity: 1 },
          { transform: `translate(calc(-50% + ${xSpeed}px), calc(-50% + ${ySpeed}px))`, opacity: 0 }
        ], {
          duration: 800 + Math.random() * 700,
          easing: 'cubic-bezier(0.1, 0.8, 0.2, 1)',
          fill: 'forwards'
        });
        
        sealEl.parentNode.appendChild(particle);
      }
      
      // 0.8秒後執行飛向七竅容器的動畫
      setTimeout(() => {
        // 獲取七竅容器中目標位置
        const targetAperture = document.querySelector(`.aperture-${apertureType}`);
        
        // 如果找到目標，執行飛行動畫
        if (targetAperture) {
          // 計算位置
          const sealRect = sealEl.getBoundingClientRect();
          const targetRect = targetAperture.getBoundingClientRect();
          
          // 計算封印到目標的向量
          const endX = targetRect.left - sealRect.left + (targetRect.width / 2 - sealRect.width / 2);
          const endY = targetRect.top - sealRect.top + (targetRect.height / 2 - sealRect.height / 2);
          
          // 設置動畫路徑
          sealEl.style.setProperty('--end-x', `${endX}px`);
          sealEl.style.setProperty('--end-y', `${endY}px`);
          sealEl.style.animation = 'seal-path 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
          
          // 路徑動畫結束後
          setTimeout(() => {
            // 將封印添加到已收集列表
            if (!gameState.collectedApertures.includes(apertureType)) {
              gameState.collectedApertures.push(apertureType);
            }
            
            // 在七竅容器中激活目標封印
            targetAperture.classList.add('collecting');
            
            // 添加激活粒子
            createActivationParticles(targetAperture);
            
            // 添加音波效果
            const soundWaveContainer = document.createElement('div');
            soundWaveContainer.className = 'absolute pointer-events-none';
            soundWaveContainer.style.left = `${targetRect.left + targetRect.width / 2}px`;
            soundWaveContainer.style.top = `${targetRect.top + targetRect.height / 2}px`;
            soundWaveContainer.style.zIndex = '60';
            
            for (let i = 0; i < 3; i++) {
              const wave = document.createElement('div');
              wave.className = 'rounded-full absolute';
              wave.style.border = '1px solid rgba(147, 146, 255, 0.8)';
              wave.style.width = '10px';
              wave.style.height = '10px';
              wave.style.left = '-5px';
              wave.style.top = '-5px';
              wave.style.animation = `sound-wave 1s ${i * 0.2}s ease-out`;
              
              soundWaveContainer.appendChild(wave);
            }
            
            document.body.appendChild(soundWaveContainer);
            
            // 添加動畫 keyframes 以實現黑洞慢慢消失的效果
            if (!document.getElementById('aperture-fade-animation')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'aperture-fade-animation';
              styleEl.textContent = `
                @keyframes aperture-fade {
                  0% { 
                    animation: none !important; /* 立即停止流動動畫 */
                    transform: scale(1); 
                    opacity: 1; 
                    background: rgba(0, 0, 0, 0.85);
                    box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
                  }
                  30% { 
                    transform: scale(0.9); 
                    opacity: 0.8; 
                    background: rgba(20, 20, 40, 0.8);
                    box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 15px rgba(93, 92, 222, 0.6);
                  }
                  70% { 
                    transform: scale(0.5); 
                    opacity: 0.4; 
                    background: rgba(40, 40, 80, 0.7);
                    box-shadow: 0 0 8px rgba(0, 0, 0, 0.7) inset, 0 0 20px rgba(93, 92, 222, 0.8);
                  }
                  100% { 
                    transform: scale(0.1); 
                    opacity: 0; 
                    background: rgba(60, 60, 120, 0.3);
                    box-shadow: 0 0 2px rgba(0, 0, 0, 0.5) inset, 0 0 5px rgba(93, 92, 222, 0.2);
                  }
                }
              `;
              document.head.appendChild(styleEl);
            }
            
            // 執行收集動畫結束後（加速）
            setTimeout(() => {
              // 移除收集動畫類
              targetAperture.classList.remove('collecting');
              
              // 由於我們想要有一個平滑消失的動畫，我們不立即加上active類
              // 先設置滿足消失動畫（加速動畫）
              targetAperture.style.animation = 'aperture-fade 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
              
              // 動畫結束後才真正添加active類（加速）
              setTimeout(() => {
                // 添加激活類
                targetAperture.classList.add('active');
                
                // 自動繼續遊戲，不需要用戶點擊額外按鈕
                setTimeout(() => {
                  // 移除遮罩層
                  overlayEl.remove();
                  // 顯示繼續按鈕
                  advanceBtn.style.display = 'block';
                  // 清除音波效果
                  if (soundWaveContainer && soundWaveContainer.parentNode) {
                    soundWaveContainer.remove();
                  }
                  
                  // 檢查是否收集了所有7個封印
                  if (gameState.collectedApertures.length === 7) {
                    console.log('🌟 所有封印已收集完成，創建轉動的太極emoji覆蓋混沌指示器');
                    createTaijiOverlay();
                  }
                  
                  console.log('✅ 封印收集完成，自動繼續遊戲流程');
                }, 1500); // 給玩家1.5秒時間欣賞收集效果
              }, 1000); // 等待aperture-fade動畫完成（加速）
            }, 500); // 加速收集動畫
            
          }, 1000); // 加速路徑動畫
        }
      }, 800); // 加速初始延遲
    }
    
    function createSceneSeal(sealType) {
      // Create a scene seal that floats in the scene
      const sceneSeal = document.createElement('div');
      sceneSeal.className = `scene-seal ${sealType}`;
      
      // Position in the center bottom of the screen initially
      sceneSeal.style.left = '50%';
      sceneSeal.style.top = '70%';
      sceneSeal.style.transform = 'translate(-50%, -50%)';
      sceneSeal.style.zIndex = '50';
      
      // Add to game content
      gameContent.appendChild(sceneSeal);
      
      // Get the target aperture on the tracker
      const targetAperture = document.querySelector(`.aperture-${sealType}`);
      
      // Animate collection after a short delay
      setTimeout(() => {
        // Calculate path to the aperture tracker
        const sealRect = sceneSeal.getBoundingClientRect();
        const targetRect = targetAperture.getBoundingClientRect();
        
        // Calculate the vector from seal to target
        const endX = targetRect.left - sealRect.left + (targetRect.width / 2 - sealRect.width / 2);
        const endY = targetRect.top - sealRect.top + (targetRect.height / 2 - sealRect.height / 2);
        
        // Set animation path variables
        sceneSeal.style.setProperty('--end-x', `${endX}px`);
        sceneSeal.style.setProperty('--end-y', `${endY}px`);
        
        // Apply path animation
        sceneSeal.style.animation = 'seal-path 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
        
        // Add shimmering light effect
        const shimmerEffect = document.createElement('div');
        shimmerEffect.className = 'absolute inset-0 pointer-events-none';
        shimmerEffect.style.background = 'radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)';
        shimmerEffect.style.opacity = '0';
        shimmerEffect.style.animation = 'shimmer 2s ease-in-out';
        
        gameContainer.appendChild(shimmerEffect);
        
        // Remove shimmer after animation
        setTimeout(() => {
          shimmerEffect.remove();
        }, 2000);
        
        // Add keyframes for shimmer effect
        if (!document.getElementById('shimmer-animation')) {
          const styleElement = document.createElement('style');
          styleElement.id = 'shimmer-animation';
          styleElement.textContent = `
            @keyframes shimmer {
              0% { opacity: 0; }
              50% { opacity: 0.5; }
              100% { opacity: 0; }
            }
          `;
          document.head.appendChild(styleElement);
        }
        
        // After path animation completes, animate the target aperture
        setTimeout(() => {
          // Remove the seal from scene
          sceneSeal.remove();
          
          // Add collecting animation to the target aperture
          targetAperture.classList.add('collecting');
          
          // Add activation particles
          createActivationParticles(targetAperture);
          
          // Add sound wave effect
          const soundWaveContainer = document.createElement('div');
          soundWaveContainer.className = 'absolute pointer-events-none';
          soundWaveContainer.style.left = `${targetRect.left + targetRect.width / 2}px`;
          soundWaveContainer.style.top = `${targetRect.top + targetRect.height / 2}px`;
          soundWaveContainer.style.zIndex = '60';
          
          for (let i = 0; i < 3; i++) {
            const wave = document.createElement('div');
            wave.className = 'rounded-full absolute';
            wave.style.border = '1px solid rgba(147, 146, 255, 0.8)';
            wave.style.width = '10px';
            wave.style.height = '10px';
            wave.style.left = '-5px';
            wave.style.top = '-5px';
            wave.style.animation = `sound-wave 1.5s ${i * 0.3}s ease-out`;
            
            soundWaveContainer.appendChild(wave);
          }
          
          document.body.appendChild(soundWaveContainer);
          
          // Add keyframes for sound wave effect
          if (!document.getElementById('wave-animation')) {
            const styleElement = document.createElement('style');
            styleElement.id = 'wave-animation';
            styleElement.textContent = `
              @keyframes sound-wave {
                0% { transform: scale(1); opacity: 1; }
                100% { transform: scale(7); opacity: 0; }
              }
            `;
            document.head.appendChild(styleElement);
          }
          
          // After collecting animation finishes (1.5s), add active class to make aperture disappear
          setTimeout(() => {
            // Remove the collecting animation class
            targetAperture.classList.remove('collecting');
            // Add the active class that makes it disappear
            targetAperture.classList.add('active');
            
            // Create a visual indicator that the aperture is filled
            const filledIndicator = document.createElement('div');
            filledIndicator.className = 'aperture filled';
            filledIndicator.style.position = 'absolute';
            filledIndicator.style.width = '30px';
            filledIndicator.style.height = '30px';
            filledIndicator.style.top = targetAperture.style.top;
            filledIndicator.style.left = targetAperture.style.left;
            filledIndicator.style.borderRadius = '50%';
            filledIndicator.style.background = 'linear-gradient(135deg, rgba(93, 92, 222, 0.8), rgba(147, 146, 255, 0.6))';
            filledIndicator.style.boxShadow = '0 0 15px rgba(93, 92, 222, 0.8)';
            filledIndicator.style.animation = 'seal-glow-pulse 3s ease-in-out infinite';
            filledIndicator.style.zIndex = '1';
            filledIndicator.style.display = 'flex';
            filledIndicator.style.justifyContent = 'center';
            filledIndicator.style.alignItems = 'center';
            filledIndicator.style.color = 'white';
            filledIndicator.innerHTML = '✓'; // Checkmark symbol
            
            // Add filled indicator to aperture tracker
            aperturesTracker.appendChild(filledIndicator);
          }, 2000);
          
          // Remove sound wave after animation
          setTimeout(() => {
            soundWaveContainer.remove();
          }, 2000);
          
        }, 2000);
      }, 1000);
    }
    
    // 創建轉動的太極emoji覆蓋混沌指示器
    function createTaijiOverlay() {
      const aperturesTracker = document.getElementById('apertures-tracker');
      if (!aperturesTracker) return;
      
      // 檢查是否已經創建了太極覆蓋層
      let taijiOverlay = document.getElementById('taiji-overlay');
      if (taijiOverlay) return; // 已經存在，不重複創建
      
      // 創建太極覆蓋層
      taijiOverlay = document.createElement('div');
      taijiOverlay.id = 'taiji-overlay';
      taijiOverlay.className = 'absolute inset-0 flex items-center justify-center';
      taijiOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        pointer-events: none;
      `;
      
      // 創建太極emoji
      const taijiEmoji = document.createElement('div');
      taijiEmoji.className = 'taiji-emoji';
      taijiEmoji.textContent = '☯';
      taijiEmoji.style.cssText = `
        font-size: 80px;
        color: rgba(255, 255, 255, 0.9);
        animation: taiji-rotate-overlay 20s infinite linear;
        filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.4));
        transform-origin: center;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
      `;
      
      taijiOverlay.appendChild(taijiEmoji);
      aperturesTracker.appendChild(taijiOverlay);
      
      // 添加太極轉動動畫（與第七章虛空背景速度一致）
      if (!document.getElementById('taiji-overlay-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'taiji-overlay-animation';
        styleElement.textContent = `
          @keyframes taiji-rotate-overlay {
            0% {
              transform: rotate(0deg);
            }
            100% {
              transform: rotate(-360deg);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      console.log('✨ 太極覆蓋層已創建，開始逆時針轉動');
    }
    
    // Create particles around the activated aperture
    function createActivationParticles(target) {
      const rect = target.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      for (let i = 0; i < 10; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full bg-indigo-400 dark:bg-indigo-300 pointer-events-none';
        
        // Random particle size
        const size = 3 + Math.random() * 4;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Initial position at target center
        particle.style.left = `${centerX}px`;
        particle.style.top = `${centerY}px`;
        
        // Random direction
        const angle = Math.random() * Math.PI * 2;
        const speed = 10 + Math.random() * 20;
        const dx = Math.cos(angle) * speed;
        const dy = Math.sin(angle) * speed;
        
        // Animation properties
        particle.style.animation = `activation-particle 1s ease-out forwards`;
        particle.style.setProperty('--dx', `${dx}px`);
        particle.style.setProperty('--dy', `${dy}px`);
        
        document.body.appendChild(particle);
        
        // Clean up the particle after animation
        setTimeout(() => {
          particle.remove();
        }, 1000);
      }
      
      // Add keyframes for activation particles
      if (!document.getElementById('particle-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'particle-animation';
        styleElement.textContent = `
          @keyframes activation-particle {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--dx), var(--dy)) scale(0); opacity: 0; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create dream effects for the prologue
    function createDreamEffects() {
      // Check if dream effects already exist
      if (document.querySelector('.dream-particles')) {
        return;
      }
      
      // Create dream particles container
      const dreamContainer = document.createElement('div');
      dreamContainer.className = 'dream-particles absolute inset-0 overflow-hidden pointer-events-none';
      dreamContainer.style.zIndex = '1';
      
      // Create floating dream particles
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'dream-particle absolute';
        
        const size = 3 + Math.random() * 8;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.borderRadius = '50%';
        particle.style.background = `rgba(${100 + Math.random() * 155}, ${150 + Math.random() * 105}, ${200 + Math.random() * 55}, ${0.3 + Math.random() * 0.7})`;
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // Add glow effect
        particle.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.5)`;
        
        // Set animation
        particle.style.animation = `dream-float ${8 + Math.random() * 12}s infinite ease-in-out`;
        particle.style.animationDelay = `${Math.random() * 10}s`;
        
        dreamContainer.appendChild(particle);
      }
      
      // Create butterfly silhouettes
      for (let i = 0; i < 3; i++) {
        const butterfly = document.createElement('div');
        butterfly.className = 'dream-butterfly absolute';
        butterfly.innerHTML = '🦋';
        butterfly.style.fontSize = `${20 + Math.random() * 15}px`;
        butterfly.style.left = `${Math.random() * 80 + 10}%`;
        butterfly.style.top = `${Math.random() * 80 + 10}%`;
        butterfly.style.opacity = '0.6';
        butterfly.style.animation = `butterfly-flutter ${15 + Math.random() * 10}s infinite ease-in-out`;
        butterfly.style.animationDelay = `${Math.random() * 8}s`;
        
        dreamContainer.appendChild(butterfly);
      }
      
      // Add to game container
      gameContainer.appendChild(dreamContainer);
      
      // Add CSS animations if not already present
      if (!document.getElementById('dream-effects-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'dream-effects-style';
        styleElement.textContent = `
          @keyframes dream-float {
            0%, 100% { 
              transform: translate(0, 0) scale(1);
              opacity: 0.3;
            }
            25% { 
              transform: translate(10px, -15px) scale(1.2);
              opacity: 0.8;
            }
            50% { 
              transform: translate(-8px, -25px) scale(0.9);
              opacity: 0.5;
            }
            75% { 
              transform: translate(15px, -10px) scale(1.1);
              opacity: 0.9;
            }
          }
          
          @keyframes butterfly-flutter {
            0%, 100% { 
              transform: translate(0, 0) rotate(0deg);
              opacity: 0.4;
            }
            25% { 
              transform: translate(30px, -20px) rotate(5deg);
              opacity: 0.8;
            }
            50% { 
              transform: translate(-20px, -40px) rotate(-3deg);
              opacity: 0.6;
            }
            75% { 
              transform: translate(40px, -15px) rotate(8deg);
              opacity: 0.9;
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create water effects for chapter 1
    function createWaterEffects() {
      // Check if water effects already exist
      if (document.querySelector('.water-ripples')) {
        return;
      }
      
      // Create water effects container
      const waterContainer = document.createElement('div');
      waterContainer.className = 'water-ripples absolute inset-0 overflow-hidden pointer-events-none';
      waterContainer.style.zIndex = '1';
      
      // Create ripple effects
      for (let i = 0; i < 8; i++) {
        const ripple = document.createElement('div');
        ripple.className = 'water-ripple absolute';
        
        const size = 100 + Math.random() * 200;
        ripple.style.width = `${size}px`;
        ripple.style.height = `${size}px`;
        ripple.style.borderRadius = '50%';
        ripple.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        ripple.style.left = `${Math.random() * 80 + 10}%`;
        ripple.style.top = `${Math.random() * 80 + 10}%`;
        
        // Set animation
        ripple.style.animation = `water-ripple ${6 + Math.random() * 8}s infinite ease-out`;
        ripple.style.animationDelay = `${Math.random() * 12}s`;
        
        waterContainer.appendChild(ripple);
      }
      
      // Create floating bubbles
      for (let i = 0; i < 15; i++) {
        const bubble = document.createElement('div');
        bubble.className = 'water-bubble absolute';
        
        const size = 5 + Math.random() * 15;
        bubble.style.width = `${size}px`;
        bubble.style.height = `${size}px`;
        bubble.style.borderRadius = '50%';
        bubble.style.background = 'rgba(255, 255, 255, 0.4)';
        bubble.style.left = `${Math.random() * 100}%`;
        bubble.style.top = `${Math.random() * 100}%`;
        
        // Add subtle glow
        bubble.style.boxShadow = `0 0 ${size}px rgba(255, 255, 255, 0.3)`;
        
        // Set animation
        bubble.style.animation = `bubble-float ${10 + Math.random() * 15}s infinite ease-in-out`;
        bubble.style.animationDelay = `${Math.random() * 10}s`;
        
        waterContainer.appendChild(bubble);
      }
      
      // Create fish silhouettes
      for (let i = 0; i < 4; i++) {
        const fish = document.createElement('div');
        fish.className = 'water-fish absolute';
        fish.innerHTML = '🐟';
        fish.style.fontSize = `${15 + Math.random() * 10}px`;
        fish.style.left = `${Math.random() * 70 + 15}%`;
        fish.style.top = `${Math.random() * 70 + 15}%`;
        fish.style.opacity = '0.5';
        fish.style.animation = `fish-swim ${12 + Math.random() * 8}s infinite ease-in-out`;
        fish.style.animationDelay = `${Math.random() * 6}s`;
        
        waterContainer.appendChild(fish);
      }
      
      // Add to game container
      gameContainer.appendChild(waterContainer);
      
      // Add CSS animations if not already present
      if (!document.getElementById('water-effects-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'water-effects-style';
        styleElement.textContent = `
          @keyframes water-ripple {
            0% { 
              transform: scale(0);
              opacity: 0.8;
            }
            50% { 
              transform: scale(1);
              opacity: 0.4;
            }
            100% { 
              transform: scale(1.5);
              opacity: 0;
            }
          }
          
          @keyframes bubble-float {
            0%, 100% { 
              transform: translateY(0) scale(1);
              opacity: 0.3;
            }
            25% { 
              transform: translateY(-20px) scale(1.2);
              opacity: 0.7;
            }
            50% { 
              transform: translateY(-40px) scale(0.9);
              opacity: 0.5;
            }
            75% { 
              transform: translateY(-15px) scale(1.1);
              opacity: 0.8;
            }
          }
          
          @keyframes fish-swim {
            0%, 100% { 
              transform: translateX(0) scaleX(1);
              opacity: 0.4;
            }
            25% { 
              transform: translateX(50px) scaleX(1);
              opacity: 0.7;
            }
            50% { 
              transform: translateX(100px) scaleX(-1);
              opacity: 0.6;
            }
            75% { 
              transform: translateX(25px) scaleX(-1);
              opacity: 0.8;
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create clouds for the cloud scene
    function createClouds() {
      // Check if clouds already exist
      if (document.querySelector('.background-cloud')) {
        return;
      }
      
      // Create cloud container
      const cloudContainer = document.createElement('div');
      cloudContainer.className = 'absolute inset-0 overflow-hidden pointer-events-none';
      cloudContainer.style.zIndex = '0';
      
      // Create multiple background clouds
      for (let i = 0; i < 15; i++) {
        const cloud = document.createElement('div');
        const size = 100 + Math.random() * 200;
        const opacity = 0.5 + Math.random() * 0.4;
        
        cloud.className = 'background-cloud absolute';
        cloud.style.width = `${size}px`;
        cloud.style.height = `${size * 0.6}px`;
        cloud.style.borderRadius = '50%';
        cloud.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        cloud.style.filter = 'blur(25px)';
        cloud.style.opacity = opacity.toString();
        cloud.style.left = `${Math.random() * 120 - 10}%`;
        cloud.style.top = `${Math.random() * 120 - 10}%`;
        
        // Set random cloud animation parameters
        cloud.style.setProperty('--cloud-dx', `${(Math.random() * 60 - 30)}px`);
        cloud.style.setProperty('--cloud-dy', `${(Math.random() * 20 - 10)}px`);
        cloud.style.animation = `float-cloud ${10 + Math.random() * 15}s infinite ease-in-out alternate`;
        cloud.style.animationDelay = `${Math.random() * 10}s`;
        
        cloudContainer.appendChild(cloud);
      }
      
      // Add to game container
      gameContainer.appendChild(cloudContainer);
    }
    
    function createPerspectiveChallengeScene(scene) {
      const challengeElement = document.createElement('div');
      
      // 检查是否有蜗牛存在，如果有则调整文字位置到上方
      const hasSnail = document.querySelector('.snail-shell');
      if (hasSnail) {
        challengeElement.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-2xl p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-30 border border-indigo-200 dark:border-indigo-700';
      } else {
        challengeElement.className = 'max-w-2xl mx-auto p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-90 dark:bg-opacity-90 rounded-lg';
      }
      
      challengeElement.innerHTML = `
        <p class="text-lg">${scene.text}</p>
      `;
      
      gameContent.appendChild(challengeElement);
      
      // 確保蝸牛和王國已創建
      if (!document.querySelector('.snail-shell')) {
        createSnailAndKingdoms();
      }
      
      // 確保視角縮放功能已啟用
      if (!gameState.scaleEnabled) {
        enableScaleControl();
      }
      
      // 添加两国交互计数
      let visitedTouch = false;
      let visitedSavage = false;
      
      // 显示切换视角提示
      function showScaleHint() {
        const hint = document.createElement('div');
        hint.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-70 text-white p-4 rounded text-left z-50';
        hint.innerHTML = `
          <p>需要切換到微觀視角才能與國家互動</p>
          <p class="text-sm mt-2 text-indigo-300">使用右側的視角控制器向下滑動</p>
        `;
        document.body.appendChild(hint);
        
        setTimeout(() => {
          hint.remove();
        }, 3000);
      }
      
      // 显示国家对话框
      function showKingdomDialog(kingdom) {
        // 移除已有对话框
        document.querySelectorAll('.kingdom-dialog').forEach(el => el.remove());
        
        const dialog = document.createElement('div');
        dialog.className = 'kingdom-dialog fixed z-50 bg-gray-900 bg-opacity-95 p-4 rounded-md text-white max-w-sm';
        dialog.style.top = '50%';
        dialog.style.left = '50%';
        dialog.style.transform = 'translate(-50%, -50%)';
        
        // 根据国家显示不同内容
        if (kingdom === 'touch') {
          dialog.innerHTML = `
            <h3 class="text-lg font-bold text-indigo-300 mb-2">觸氏國國王</h3>
            <p class="mb-4">歡迎來到觸氏國，偉大的蝸牛左角之國！我們是智慧與藝術的民族。</p>
            <p class="mb-4">那些蠻氏國的野蠻人竟敢侵犯我們的邊境，搶奪我們的土地。祖先留下的領土，我們絕不能讓步！</p>
            <p class="mb-4">我們已經打了十五年，這五年是我們的反攻期，我們必將收復失地！</p>
            <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded block ml-auto">關閉</button>
          `;
        } else {
          dialog.innerHTML = `
            <h3 class="text-lg font-bold text-blue-300 mb-2">蠻氏國國王</h3>
            <p class="mb-4">哼！陌生人，這裡是強大的蠻氏國，蝸牛右角的唯一合法政權！</p>
            <p class="mb-4">那些觸氏國的詭計多端的懦夫，明明是他們先侵佔了邊境地帶！那片土地自古以來就是我們的！</p>
            <p class="mb-4">我們已經反擊十五年了，這五年我們要一舉殲滅他們！為了蠻氏國的榮耀！</p>
            <button class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded block ml-auto">關閉</button>
          `;
        }
        
        document.body.appendChild(dialog);
        
        // 关闭按钮事件
        dialog.querySelector('button').addEventListener('click', () => {
          dialog.remove();
        });
      }
      
      // 检查是否访问了两个国家
      function checkVisitedBoth() {
        if (visitedTouch && visitedSavage) {
          // 更新提示内容
          const tipElement = challengeElement.querySelector('.text-sm');
          if (tipElement) {
            tipElement.textContent = '你已經探索了兩個國家！現在可以繼續遊戲了';
            tipElement.classList.remove('animate-pulse');
            tipElement.classList.add('font-bold');
          }
          
          // 显示继续按钮
          advanceBtn.style.display = 'block';
        }
      }
      
      // 等待蝸牛和王國創建完成後再添加事件監聽器
      setTimeout(() => {
        // 在一秒後檢查並添加與國家交互的提示
        if (gameState.viewScale >= 30) {
          const tipElement = document.createElement('div');
          tipElement.className = 'mt-4 text-sm text-indigo-600 dark:text-indigo-300 animate-pulse';
          tipElement.textContent = '使用視角控制器切換到微觀視角探索蝸牛上的王國';
          challengeElement.appendChild(tipElement);
          
          // 為視角控制器添加發光效果
          highlightScaleController();
        } else {
          const tipElement = document.createElement('div');
          tipElement.className = 'mt-4 text-sm text-indigo-600 dark:text-indigo-300 animate-pulse';
          tipElement.textContent = '點擊觸角上的國家圓形或居民人物進行互動';
          challengeElement.appendChild(tipElement);
        }
        
        // 添加点击监听器到国家圆形
        const touchKingdomCircle = document.getElementById('touch-kingdom-circle');
        const savageKingdomCircle = document.getElementById('savage-kingdom-circle');
        
        if (touchKingdomCircle) {
          touchKingdomCircle.style.cursor = 'pointer';
          
          // 移除之前的事件監聽器（如果有）
          touchKingdomCircle.replaceWith(touchKingdomCircle.cloneNode(true));
          const newTouchKingdom = document.getElementById('touch-kingdom-circle');
          
          newTouchKingdom.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameState.viewScale < 30) {
              visitedTouch = true;
              showKingdomDialog('touch');
              checkVisitedBoth();
            } else {
              showScaleHint();
            }
          });
        }
        
        if (savageKingdomCircle) {
          savageKingdomCircle.style.cursor = 'pointer';
          
          // 移除之前的事件監聽器（如果有）
          savageKingdomCircle.replaceWith(savageKingdomCircle.cloneNode(true));
          const newSavageKingdom = document.getElementById('savage-kingdom-circle');
          
          newSavageKingdom.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameState.viewScale < 30) {
              visitedSavage = true;
              showKingdomDialog('savage');
              checkVisitedBoth();
            } else {
              showScaleHint();
            }
          });
        }
      }, 1500);
      
      // 初始不显示继续按钮，需要完成目标才显示
      advanceBtn.style.display = 'none';
    }
    
    // 创建蜗牛角上的居民
    function createCitizens() {
      // 获取两个王国元素作为容器
      const touchKingdom = document.querySelector('.kingdom.left');
      const savageKingdom = document.querySelector('.kingdom.right');
      
      if (!touchKingdom || !savageKingdom) {
        console.log("找不到王國元素，無法創建居民");
        return;
      }
      
      // 创建触氏国居民
      createKingdomCitizens(touchKingdom, 'touch', 3);
      
      // 创建蛮氏国居民
      createKingdomCitizens(savageKingdom, 'savage', 3);
    }
    
    // 为特定王国创建居民
    function createKingdomCitizens(kingdomElement, kingdomId, count) {
      const kingdomRect = kingdomElement.getBoundingClientRect();
      
      // 清除现有居民
      kingdomElement.querySelectorAll('.citizen').forEach(citizen => citizen.remove());
      
      // 创建新居民
      for (let i = 0; i < count; i++) {
        const citizen = document.createElement('div');
        citizen.className = `citizen ${kingdomId}`;
        citizen.setAttribute('data-citizen-id', `${kingdomId}-${i}`);
        
        // 设置居民在王国内的随机位置
        const offsetX = 5 + Math.random() * (kingdomElement.offsetWidth - 10);
        citizen.style.left = `${offsetX}px`;
        
        // 添加到王国元素
        kingdomElement.appendChild(citizen);
        
        // 添加点击事件监听器
        citizen.addEventListener('click', (event) => {
          event.stopPropagation(); // 防止触发王国点击事件
          const citizenId = citizen.getAttribute('data-citizen-id');
          
          // 检查是否在微观视角
          if (gameState.viewScale < 30) {
            // 打开居民对话
            showCitizenDialog(citizenId, citizen, 0);
          } else {
            // 提示需要切换到微观视角
            showScaleHint();
          }
        });
      }
    }
    
    // 显示切换视角提示
    function showScaleHint() {
      const hint = document.createElement('div');
                hint.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-70 text-white p-4 rounded text-left z-50';
      hint.innerHTML = `
        <p>需要切換到微觀視角才能與居民互動</p>
        <p class="text-sm mt-2 text-indigo-300">使用右側的視角控制器向下滑動</p>
      `;
      document.body.appendChild(hint);
      
      setTimeout(() => {
        hint.remove();
      }, 3000);
    }
    
    function createForestBackground() {
      // 检查森林元素是否已存在
      if (document.querySelector('.forest-background')) {
        return;
      }

      // 创建森林容器
      const forestContainer = document.createElement('div');
      forestContainer.className = 'forest-background absolute inset-0 overflow-hidden pointer-events-none';
      forestContainer.style.zIndex = '-1'; // 設置為負值，確保在所有內容之下
      
      // 创建Three.js 2D森林场景
      createThreeJSForestScene(forestContainer);

      // 创建八棵抽象树形 - 重新分佈避免遮擋中心文字區域
      // 左側4棵樹(5-35%)，右側4棵樹(65-95%)，中間(35-65%)留給文字
      const treePositions = [5, 15, 25, 35, 65, 75, 85, 95]; // 中間留出30%空間給文字
      
      for (let i = 0; i < 8; i++) {
        const tree = document.createElement('div');
        tree.className = 'tree';
        
        // 使用預定義的位置陣列
        const position = treePositions[i];
        
        tree.style.left = `${position}%`;
        tree.style.zIndex = '0';
        
        // 简化的树干 - 整體放大1.5-2倍，增加錯落感
        const trunk = document.createElement('div');
        trunk.className = 'tree-trunk';
        // 樹木大小縮放因子：1.5-2倍隨機變化
        const sizeMultiplier = 1.5 + (Math.random() * 0.5) + (i % 3) * 0.15; // 1.5-2.15倍
        const baseHeight = (160 + (i * 20) + Math.sin(i * 0.7) * 35) * sizeMultiplier;
        trunk.style.height = `${baseHeight}px`;
        const baseWidth = (7 + (i % 3) + Math.cos(i * 1.1) * 1.5) * sizeMultiplier;
        trunk.style.width = `${baseWidth}px`;
        trunk.style.left = '50%';
        trunk.style.marginLeft = `-${baseWidth/2}px`; // 動態居中
        trunk.style.background = 'rgba(75, 54, 33, 0.7)'; // 半透明效果
        trunk.style.zIndex = '-1'; // 修復：樹幹應該在樹冠後面
        tree.appendChild(trunk);
        
        // 简化的树冠 - 使用相同的縮放比例
        for (let j = 0; j < 3; j++) {
          const crown = document.createElement('div');
          crown.className = 'tree-crown';
          // 樹冠也使用相同的縮放因子
          const baseCrownSize = (70 + j * 18 + (i % 4) * 8) * sizeMultiplier;
          crown.style.width = `${baseCrownSize}px`;
          crown.style.height = `${baseCrownSize}px`;
          crown.style.left = '50%';
          crown.style.marginLeft = `-${baseCrownSize/2}px`;
          
          // 修復樹冠位置：確保最頂層樹冠高於樹幹頂部，也按比例縮放
          const crownBottomPosition = Math.max(
            (50 + j * 35 + (i % 3) * 10) * sizeMultiplier, // 原始位置縮放
            baseHeight * 0.6 + j * 25 * sizeMultiplier    // 確保在樹幹高度的60%以上
          );
          crown.style.bottom = `${crownBottomPosition}px`;
          
          // 為新樹木提供稍微不同的顏色變化
          const greenVariation = 60 + j * 15 + (i % 5) * 8;
          const lightGreenVariation = 130 + j * 10 + (i % 4) * 12;
          const darkGreenVariation = 40 + j * 10 + (i % 3) * 6;
          crown.style.background = `rgba(${greenVariation}, ${lightGreenVariation}, ${darkGreenVariation}, 0.${6 + j})`;
          crown.style.zIndex = `${1 + j}`; // 修復：樹冠應該在樹幹前面，層次遞增
          
          // 添加微小的动态效果 - 為新樹木提供不同的動畫時間
          const swayDuration = 5 + j + (i % 4) * 0.8;
          crown.style.animation = `leaf-sway-animation ${swayDuration}s infinite ease-in-out`;
          crown.style.animationDelay = `${(j * 0.5) + (i * 0.3)}s`; // 錯開動畫時間
          tree.appendChild(crown);
        }
        
        forestContainer.appendChild(tree);
      }
      
      // 创建少量象征性的落叶 - 不需要太多详细的逻辑
      const leafContainer = document.createElement('div');
      leafContainer.className = 'leaf-container';
      
      // 仅添加几片象征性的落叶，定期更新
      const leafInterval = setInterval(() => {
        // 检查是否还在森林场景中
        if (!document.querySelector('.forest-background')) {
          clearInterval(leafInterval);
          return;
        }
        
        if (document.querySelectorAll('.falling-leaf').length < 5) { // 限制数量
          const leaf = document.createElement('div');
          leaf.className = 'falling-leaf';
          
          // 简化的叶子形状
          const size = 10;
          leaf.style.width = `${size}px`;
          leaf.style.height = `${size}px`;
          leaf.style.left = `${20 + Math.random() * 60}%`; // 控制在可见区域
          leaf.style.backgroundColor = 'rgba(44, 119, 68, 0.6)';
          leaf.style.borderRadius = '50% 20% 50% 20%'; // 简单的象征性形状
          
          // 简化的动画
          leaf.style.animationDuration = '12s';
          
          leafContainer.appendChild(leaf);
          
          // 动画结束后移除
          setTimeout(() => {
            if (leaf && leaf.parentNode) {
              leaf.remove();
            }
          }, 12000);
        }
      }, 3000);
      
      // 将定时器ID存储到容器上，便于清理
      forestContainer.leafInterval = leafInterval;
      
      // 初始添加3片落叶
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          const leaf = document.createElement('div');
          leaf.className = 'falling-leaf';
          
          const size = 10;
          leaf.style.width = `${size}px`;
          leaf.style.height = `${size}px`;
          leaf.style.left = `${20 + Math.random() * 60}%`;
          leaf.style.backgroundColor = 'rgba(44, 119, 68, 0.6)';
          leaf.style.borderRadius = '50% 20% 50% 20%';
          
          leaf.style.animationDuration = '12s';
          leaf.style.animationDelay = `${i}s`;
          
          leafContainer.appendChild(leaf);
          
          setTimeout(() => leaf.remove(), 12000);
        }, i * 1000);
      }
      
      forestContainer.appendChild(leafContainer);
      
      // 创建4個陽光光暈效果 - 沿對角線分佈減少卡頓
      const diagonalPositions = [
        { left: 15, top: 10 },  // 左上
        { left: 35, top: 25 },  // 中左上
        { left: 55, top: 40 },  // 中右下
        { left: 75, top: 55 }   // 右下
      ];
      
      for (let i = 0; i < 4; i++) {
        const light = document.createElement('div');
        light.className = 'forest-sunlight';
        
        // 漸進的光暈大小
        const size = 140 + i * 40;
        light.style.width = `${size}px`;
        light.style.height = `${size}px`;
        
        // 對角線位置分佈
        light.style.left = `${diagonalPositions[i].left}%`;
        light.style.top = `${diagonalPositions[i].top}%`;
        
        // 錯開的動畫時序
        light.style.animationDelay = `${i * 3}s`;
        light.style.animationDuration = `${15 + i * 2}s`;
        
        forestContainer.appendChild(light);
      }
      

      

      
      // 创建树叶摇摆效果（增强现有树冠动画）
      const windContainer = document.createElement('div');
      windContainer.className = 'wind-effects absolute inset-0 pointer-events-none';
      
      // 创建风的粒子效果
      for (let i = 0; i < 8; i++) {
        const windParticle = document.createElement('div');
        windParticle.className = 'wind-particle absolute';
        
        const size = 2 + Math.random() * 4;
        windParticle.style.width = `${size}px`;
        windParticle.style.height = `${size}px`;
        windParticle.style.borderRadius = '50%';
        windParticle.style.background = 'rgba(255, 255, 255, 0.4)';
        windParticle.style.left = `${Math.random() * 100}%`;
        windParticle.style.top = `${Math.random() * 100}%`;
        windParticle.style.animation = `wind-drift ${8 + Math.random() * 12}s infinite ease-in-out`;
        windParticle.style.animationDelay = `${Math.random() * 8}s`;
        
        windContainer.appendChild(windParticle);
      }
      
      forestContainer.appendChild(windContainer);
      
      // 添加到游戏容器
      gameContainer.appendChild(forestContainer);
      
      // 设置简化的CSS样式
      if (!document.getElementById('forest-effects-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'forest-effects-style';
        styleElement.textContent = `
          .forest-scene {
            background: linear-gradient(135deg, #2c7744, #8fc866);
          }
          
          .tree-trunk {
            position: absolute;
            bottom: 0;
            border-radius: 2px;
            z-index: -1; /* 樹幹在樹冠後面 */
          }
          
          .tree-crown {
            position: absolute;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1; /* 樹冠在樹幹前面，基礎層級為1 */
          }
          
          .falling-leaf {
            position: absolute;
            z-index: 1;
            opacity: 0;
            animation: leaf-falling linear forwards;
            transform-origin: center center;
          }
          
          @keyframes leaf-falling {
            0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
            10% { opacity: 0.7; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
          }
          
          @keyframes leaf-sway-animation {
            0%, 100% { transform: rotate(-2deg) translateX(0); }
            50% { transform: rotate(2deg) translateX(5px); }
          }
          
          /* 增強的陽光光暈效果 */
          .forest-sunlight {
            position: absolute;
            background: radial-gradient(circle, 
              rgba(255, 223, 0, 0.6) 0%,     /* 金黃色中心 */
              rgba(255, 140, 0, 0.4) 25%,    /* 橙黃色 */
              rgba(255, 215, 0, 0.3) 50%,    /* 金色 */
              rgba(255, 255, 255, 0.2) 70%,  /* 白色邊緣 */
              transparent 100%
            );
            border-radius: 50%;
            filter: blur(15px);
            pointer-events: none;
            opacity: 0;
            animation: enhanced-sunlight-fade 12s infinite ease-in-out;
            z-index: 4; /* 確保顯示在樹冠之上 */
            box-shadow: 
              0 0 30px rgba(255, 223, 0, 0.4),
              0 0 60px rgba(255, 140, 0, 0.2),
              inset 0 0 20px rgba(255, 255, 255, 0.1);
          }
          

          
          @keyframes enhanced-sunlight-fade {
            0%, 100% { 
              opacity: 0; 
              transform: scale(0.8) rotate(0deg); 
              filter: blur(15px) brightness(1);
            }
            25% { 
              opacity: 0.4; 
              transform: scale(1.1) rotate(5deg); 
              filter: blur(12px) brightness(1.2);
            }
            50% { 
              opacity: 0.7; 
              transform: scale(1.2) rotate(10deg); 
              filter: blur(10px) brightness(1.4);
            }
            75% { 
              opacity: 0.5; 
              transform: scale(1.0) rotate(15deg); 
              filter: blur(13px) brightness(1.1);
            }
          }
          

          

          
          @keyframes wind-drift {
            0%, 100% { 
              transform: translate(0, 0) scale(1);
              opacity: 0.2;
            }
            25% { 
              transform: translate(50px, -20px) scale(1.2);
              opacity: 0.5;
            }
            50% { 
              transform: translate(100px, -10px) scale(0.8);
              opacity: 0.3;
            }
            75% { 
              transform: translate(150px, -30px) scale(1.1);
              opacity: 0.6;
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create Three.js 2D Forest Scene
    function createThreeJSForestScene(container) {
      // 创建Three.js场景
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(
        -window.innerWidth / 2, window.innerWidth / 2,
        window.innerHeight / 2, -window.innerHeight / 2,
        1, 1000
      );
      
      const renderer = new THREE.WebGLRenderer({ 
        alpha: true, 
        antialias: true 
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0); // 透明背景
      
      // 创建canvas容器
      const threeContainer = document.createElement('div');
      threeContainer.className = 'three-forest-scene absolute inset-0';
      threeContainer.style.zIndex = '0';
      threeContainer.appendChild(renderer.domElement);
      container.appendChild(threeContainer);
      
      camera.position.z = 100;
      
      // 存储所有动画对象
      const animatedObjects = [];
      
      // 创建自定义叶子形状
      function createCustomLeafGeometry() {
        const leafShape = new THREE.Shape();
        
        // 创建叶子轮廓 - 使用贝塞尔曲线
        leafShape.moveTo(0, 0); // 叶子底部中心
        
        // 左侧叶片
        leafShape.bezierCurveTo(-3, 2, -5, 8, -2, 12); // 左下到左上
        leafShape.bezierCurveTo(-1, 14, 1, 14, 2, 12);  // 左上到右上
        
        // 右侧叶片
        leafShape.bezierCurveTo(5, 8, 3, 2, 0, 0);      // 右上到底部
        
        return new THREE.ShapeGeometry(leafShape);
      }
      
      // 创建2D叶子粒子系统
      function createCustomLeafParticles() {
        const leafGeometry = createCustomLeafGeometry();
        const leafCount = 25; // 减少数量以保持性能
        
        for (let i = 0; i < leafCount; i++) {
          // 创建叶子材质（使用不同的绿色和黄色调）
          const hue = 0.15 + Math.random() * 0.15; // 黄绿色调
          const saturation = 0.6 + Math.random() * 0.3;
          const lightness = 0.3 + Math.random() * 0.4;
          
          const leafMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(hue, saturation, lightness),
            transparent: true,
            opacity: 0.7 + Math.random() * 0.3,
            side: THREE.DoubleSide // 确保叶子两面都可见
          });
          
          const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
          
          // 随机位置
          leaf.position.x = (Math.random() - 0.5) * window.innerWidth;
          leaf.position.y = window.innerHeight / 2 + Math.random() * 200;
          leaf.position.z = Math.random() * 30;
          
          // 随机初始旋转
          leaf.rotation.x = Math.random() * Math.PI * 2;
          leaf.rotation.y = Math.random() * Math.PI * 2;
          leaf.rotation.z = Math.random() * Math.PI * 2;
          
          // 随机缩放
          const scale = 0.8 + Math.random() * 0.6;
          leaf.scale.setScalar(scale);
          
          // 存储动画属性 - 非常缓慢的速度
          leaf.userData = {
            fallSpeed: 0.1 + Math.random() * 0.2,        // 非常慢的下降速度
            swaySpeed: 0.003 + Math.random() * 0.007,    // 非常慢的摇摆速度
            swayAmount: 15 + Math.random() * 25,         // 摇摆幅度
            rotationSpeedX: 0.002 + Math.random() * 0.008, // X轴旋转速度
            rotationSpeedY: 0.001 + Math.random() * 0.005, // Y轴旋转速度
            rotationSpeedZ: 0.003 + Math.random() * 0.007, // Z轴旋转速度
            initialX: leaf.position.x,
            phase: Math.random() * Math.PI * 2           // 随机相位偏移
          };
          
          scene.add(leaf);
          animatedObjects.push(leaf);
        }
      }
      
      // 创建2D风的粒子效果
      function createWindParticles() {
        const windGeometry = new THREE.PlaneGeometry(3, 3);
        const windCount = 30;
        
        for (let i = 0; i < windCount; i++) {
          const windMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3 + Math.random() * 0.4
          });
          
          const windParticle = new THREE.Mesh(windGeometry, windMaterial);
          
          // 随机位置
          windParticle.position.x = (Math.random() - 0.5) * window.innerWidth;
          windParticle.position.y = (Math.random() - 0.5) * window.innerHeight;
          windParticle.position.z = Math.random() * 30;
          
          // 存储动画属性
          windParticle.userData = {
            driftSpeed: 0.1 + Math.random() * 0.3, // 降低水平漂移速度
            verticalSpeed: 0.05 + Math.random() * 0.15, // 降低垂直波動速度
            resetX: -window.innerWidth / 2 - 50
          };
          
          scene.add(windParticle);
          animatedObjects.push(windParticle);
        }
      }
      
      // 初始化效果
      createCustomLeafParticles();
      createWindParticles();
      
      // 动画循环
      let animationId;
      function animate() {
        animationId = requestAnimationFrame(animate);
        
        const time = Date.now() * 0.001;
        
        animatedObjects.forEach(obj => {
          if (obj.userData.fallSpeed !== undefined) {
            // 自定义叶子动画
            obj.position.y -= obj.userData.fallSpeed;
            
            // 左右摇摆（使用相位偏移让每片叶子不同步）
            obj.position.x = obj.userData.initialX + 
              Math.sin(time * obj.userData.swaySpeed + obj.userData.phase) * obj.userData.swayAmount;
            
            // 多轴旋转，模拟叶子在空中翻滚
            obj.rotation.x += obj.userData.rotationSpeedX;
            obj.rotation.y += obj.userData.rotationSpeedY;
            obj.rotation.z += obj.userData.rotationSpeedZ;
            
            // 重置叶子位置
            if (obj.position.y < -window.innerHeight / 2 - 50) {
              obj.position.y = window.innerHeight / 2 + 50;
              obj.position.x = (Math.random() - 0.5) * window.innerWidth;
              obj.userData.initialX = obj.position.x;
              
              // 重新随机化一些属性，增加变化
              obj.userData.phase = Math.random() * Math.PI * 2;
              obj.rotation.x = Math.random() * Math.PI * 2;
              obj.rotation.y = Math.random() * Math.PI * 2;
              obj.rotation.z = Math.random() * Math.PI * 2;
            }
          } else if (obj.userData.driftSpeed !== undefined) {
            // 风粒子动画
            obj.position.x += obj.userData.driftSpeed;
            obj.position.y += Math.sin(time * 2 + obj.position.x * 0.01) * obj.userData.verticalSpeed;
            
            // 重置风粒子位置
            if (obj.position.x > window.innerWidth / 2 + 50) {
              obj.position.x = obj.userData.resetX;
              obj.position.y = (Math.random() - 0.5) * window.innerHeight;
            }
          }
        });
        
        renderer.render(scene, camera);
      }
      
      animate();
      
      // 窗口大小调整处理
      function handleResize() {
        camera.left = -window.innerWidth / 2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = -window.innerHeight / 2;
        camera.updateProjectionMatrix();
        
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      window.addEventListener('resize', handleResize);
      
      // 存储清理函数
      container.threeCleanup = function() {
        cancelAnimationFrame(animationId);
        window.removeEventListener('resize', handleResize);
        
        // 清理Three.js对象
        animatedObjects.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        
        renderer.dispose();
        threeContainer.remove();
      };
    }
    
    // Initialize the Hunlun aperture positions
    function initializeHunlunApertures() {
      // Set up face pattern
      const facePattern = document.getElementById('face-pattern');
      facePattern.innerHTML = `
        <svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="0.5" stroke-dasharray="2,3" />
          <ellipse cx="50" cy="46" rx="30" ry="36" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.5" stroke-dasharray="1,2" />
          <path d="M35,40 Q50,60 65,40" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.5" stroke-dasharray="1,2" />
        </svg>
      `;
      
      // Initialize aperture positions
      randomizeAperturePositions();
      
      // Set up aperture animation intervals
      setInterval(() => {
        const random = Math.random();
        if (random < 0.3) {
          // 30% chance to show face pattern
          showFacePattern();
        } else {
          // 70% chance to randomize positions
          randomizeAperturePositions();
        }
      }, 8000);
    }
    
    // Physics-based aperture positioning to avoid overlap
    function randomizeAperturePositions() {
      const apertures = document.querySelectorAll('.aperture-random');
      const facePattern = document.getElementById('face-pattern');
      const apertureDiameter = 30; // Aperture size in pixels
      const containerSize = 150; // Container size in pixels
      
      // Skip filled apertures
      const visibleApertures = Array.from(apertures).filter(aperture => 
        !gameState.collectedApertures.includes(aperture.className.match(/aperture-([\w-]+)/)[1])
      );
      
      // Hide face pattern
      facePattern.classList.remove('visible');
      
      // Remove face position class if present
      apertures.forEach(aperture => {
        aperture.classList.remove('face-position');
      });
      
      // Physics-based positioning
      const minDistance = (apertureDiameter * 1.3) / containerSize * 100; // Minimum distance as percentage
      const positions = [];
      
      // Create initial random positions for simulation
      visibleApertures.forEach(() => {
        const randomAngle = Math.random() * Math.PI * 2;
        const randomDistance = 15 + Math.random() * 30; // Range from 15% to 45% from center
        
        const x = 50 + Math.cos(randomAngle) * randomDistance;
        const y = 50 + Math.sin(randomAngle) * randomDistance;
        
        positions.push({ x, y, vx: 0, vy: 0 });
      });
      
      // Run physics simulation to settle positions for visible apertures
      for (let iteration = 0; iteration < 50; iteration++) {
        let stable = true;
        
        // Apply forces between apertures
        for (let i = 0; i < positions.length; i++) {
          for (let j = i + 1; j < positions.length; j++) {
            const dx = positions[j].x - positions[i].x;
            const dy = positions[j].y - positions[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minDistance) {
              stable = false;
              
              // Calculate repulsion force
              const force = 0.5 * (minDistance - distance) / distance;
              const fx = force * dx;
              const fy = force * dy;
              
              // Apply force to both apertures in opposite directions
              positions[i].vx -= fx;
              positions[i].vy -= fy;
              positions[j].vx += fx;
              positions[j].vy += fy;
            }
          }
          
          // Apply boundary constraint - keep within the circle
          const centerDist = Math.sqrt(
            Math.pow(positions[i].x - 50, 2) + 
            Math.pow(positions[i].y - 50, 2)
          );
          
          const maxRadius = 42; // Max distance from center as percentage
          if (centerDist > maxRadius) {
            stable = false;
            // Push back towards center
            const angle = Math.atan2(positions[i].y - 50, positions[i].x - 50);
            const pushback = 0.1 * (centerDist - maxRadius);
            positions[i].vx -= Math.cos(angle) * pushback;
            positions[i].vy -= Math.sin(angle) * pushback;
          }
          
          // Apply velocity with damping
          positions[i].x += positions[i].vx * 0.6;
          positions[i].y += positions[i].vy * 0.6;
          positions[i].vx *= 0.5; // Damping
          positions[i].vy *= 0.5; // Damping
        }
        
        // If system is stable, exit early
        if (stable && iteration > 10) break;
      }
      
      // Apply final positions with smooth transition - only to visible apertures
      visibleApertures.forEach((aperture, i) => {
        aperture.style.left = `${positions[i].x}%`;
        aperture.style.top = `${positions[i].y}%`;
        // Reset any transforms
        aperture.style.transform = '';
      });
    }
    
    // Show face pattern
    function showFacePattern() {
      const apertures = document.querySelectorAll('.aperture-random');
      const facePattern = document.getElementById('face-pattern');
      
      // Show face pattern
      facePattern.classList.add('visible');
      
      // Add face position class
      apertures.forEach(aperture => {
        aperture.classList.add('face-position');
      });
    }
    
    // 根據章節設置必要的前置條件
    function setupChapterPrerequisites(chapter) {
      // 開發者模式標記，用於強制顯示物化按鈕
      const isDevMode = document.documentElement.classList.contains('dev-mode');
      
      // 先清空所有已收集的封印，然後根據章節重新設置
      gameState.collectedApertures = [];
      
      switch (chapter) {
        case 'prologue':
          // 序章特殊處理：重置所有解鎖的形態狀態，只保留人形
          gameState.unlockedForms = ['human'];
          
          // 隱藏所有物化按鈕（除了人形）
          Object.keys(formButtons).forEach(formType => {
            if (formType !== 'human' && formButtons[formType]) {
              formButtons[formType].classList.add('hidden');
              formButtons[formType].style.visibility = 'hidden';
            } else if (formType === 'human' && formButtons[formType]) {
              // 確保人形按鈕始終可見
              formButtons[formType].classList.remove('hidden');
              formButtons[formType].style.visibility = 'visible';
            }
          });
          break;
          
        case 'chapter1':
          // 第一章開始時不解鎖蝴蝶形態，要等到劇情中獲得
          if (isDevMode) forceShowFormButton('butterfly');
          break;
          
        case 'chapter2':
          // 第二章進入時只有第一章已解鎖的蝴蝶形態
          unlockForm('butterfly');
          if (isDevMode) {
            forceShowFormButton('butterfly');
          }
          // 收集左目封印
          if (!gameState.collectedApertures.includes('left-eye')) {
            gameState.collectedApertures.push('left-eye');
          }
          break;
          
        case 'chapter3':
          // 第三章進入時只有前面章節已解鎖的形態：蝴蝶、魚
          unlockForm('butterfly');
          unlockForm('fish');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
          }
          // 收集前面的封印
          if (!gameState.collectedApertures.includes('left-eye')) {
            gameState.collectedApertures.push('left-eye');
          }
          if (!gameState.collectedApertures.includes('right-eye')) {
            gameState.collectedApertures.push('right-eye');
          }
          break;
          
        case 'chapter4':
          // 第四章進入時只有前面章節已解鎖的形態：蝴蝶、魚、鯤、鵬
          unlockForm('butterfly');
          unlockForm('fish');
          unlockForm('kun');
          unlockForm('peng');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            // 開發者模式下直接啟用視角縮放功能
            enableScaleControl();
          }
          // 收集前面所有的封印
          const previousApertures = ['left-eye', 'right-eye', 'left-ear'];
          previousApertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          // 注意：第四章開始時不啟用視角縮放功能，要等到劇情引導
          break;
          
        case 'chapter5':
          // 第五章進入時只有前面章節已解鎖的形態：蝴蝶、魚、鯤、鵬、鵷鶵、鴟鴞
          unlockForm('butterfly');
          unlockForm('fish');
          unlockForm('kun');
          unlockForm('peng');
          unlockForm('yuanchu');
          unlockForm('chixiao');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
          }
          // 收集前面所有的封印
          const chapter5Apertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear'];
          chapter5Apertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
          
        case 'chapter6':
          // 第六章進入時只有前面章節已解鎖的形態：蝴蝶、魚、鯤、鵬、鵷鶵、鴟鴞、蝸牛
          unlockForm('butterfly');
          unlockForm('fish');
          unlockForm('kun');
          unlockForm('peng');
          unlockForm('yuanchu');
          unlockForm('chixiao');
          unlockForm('snail');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
          }
          // 收集前面所有的封印
          const chapter6Apertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear', 'left-nose'];
          chapter6Apertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
          
        case 'chapter7':
          // 第七章進入時只有前面章節已解鎖的形態：蝴蝶、魚、鯤、鵬、鵷鶵、鴟鴞、蝸牛、螻蟻、星辰、朝菌、蟪蛄、大椿
          unlockForm('butterfly');
          unlockForm('fish');
          unlockForm('kun');
          unlockForm('peng');
          unlockForm('yuanchu');
          unlockForm('chixiao');
          unlockForm('snail');
          unlockForm('ant');      // 添加螻蟻形態
          unlockForm('star');     // 添加星辰形態
          unlockForm('morning-fungus');
          unlockForm('cicada');
          unlockForm('great-chun');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
            forceShowFormButton('ant');      // 添加螻蟻按鈕
            forceShowFormButton('star');     // 添加星辰按鈕
            forceShowFormButton('morning-fungus');
            forceShowFormButton('cicada');
            forceShowFormButton('great-chun');
            // 開發者模式下自動完成八卦學習和激活萬物尋氣
            gameState.baguaLearningCompleted = true;
            console.log('開發者模式：自動完成八卦學習');
          }
          // 收集前面所有的封印
          const chapter7Apertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear', 'left-nose', 'right-nose'];
          chapter7Apertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
          
        case 'epilogue':
          // 尾聲章節需要所有形態和封印
          unlockForm('butterfly');
          unlockForm('fish');
          unlockForm('kun');
          unlockForm('peng');
          unlockForm('yuanchu');
          unlockForm('chixiao');
          unlockForm('snail');
          unlockForm('morning-fungus');
          unlockForm('cicada');
          unlockForm('great-chun');
          unlockForm('ant');
          unlockForm('star');
          unlockForm('qi');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
            forceShowFormButton('morning-fungus');
            forceShowFormButton('cicada');
            forceShowFormButton('great-chun');
            forceShowFormButton('ant');
            forceShowFormButton('star');
            forceShowFormButton('qi');
          }
          // 收集所有封印
          const allApertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear', 'left-nose', 'right-nose', 'mouth'];
          allApertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
      }
      
      // 先清除所有七竅指示器的狀態，然後重新設置
      document.querySelectorAll('.aperture').forEach(aperture => {
        aperture.classList.remove('active');
      });
      
      // 移除可能存在的太極覆蓋層
      const existingTaijiOverlay = document.getElementById('taiji-overlay');
      if (existingTaijiOverlay) {
        existingTaijiOverlay.remove();
      }
      
      // 更新已收集封印的視覺狀態
      gameState.collectedApertures.forEach(apertureType => {
        const targetAperture = document.querySelector(`.aperture-${apertureType}`);
        if (targetAperture && !targetAperture.classList.contains('active')) {
          targetAperture.classList.add('active');
        }
      });
      
      // 如果已收集所有7個封印，創建太極覆蓋層
      if (gameState.collectedApertures.length === 7) {
        setTimeout(() => {
          createTaijiOverlay();
        }, 1000); // 延遲1秒確保DOM元素已準備好
      }
    }
    
    // 開發者模式下強制顯示物化按鈕
    function forceShowFormButton(form) {
      if (formButtons[form]) {
        formButtons[form].style.visibility = 'visible';
        formButtons[form].classList.remove('hidden');
        console.log(`開發者模式：強制顯示 ${form} 按鈕`);
      }
    }

    // Initialize the game
    // 開發者工具相關函數
    // 🔍 場景調試函數：檢查第七章場景結構
    function debugChapter7Scenes() {
      console.log('🔍 === 第七章場景結構調試 ===');
      
      const chapter7 = gameChapters.chapter7;
      if (!chapter7) {
        console.error('❌ 第七章配置不存在！');
        return;
      }
      
      console.log('✅ 第七章配置存在');
      console.log('章節標題:', chapter7.title);
      console.log('場景總數:', chapter7.scenes.length);
      
      // 列出所有場景
      chapter7.scenes.forEach((scene, index) => {
        console.log(`場景 ${index}:`, {
          type: scene.type,
          text: scene.text ? scene.text.substring(0, 50) + '...' : 'N/A',
          speaker: scene.speaker || 'N/A'
        });
      });
      
      // 檢查場景39
      if (chapter7.scenes[39]) {
        console.log('✅ 場景39存在:', chapter7.scenes[39]);
      } else {
        console.error('❌ 場景39不存在！最大索引:', chapter7.scenes.length - 1);
      }
      
      // 檢查道的顯現場景
      const daoScenes = chapter7.scenes.filter((scene, index) => {
        return scene.type === 'dao-revelation' || 
               (scene.text && scene.text.includes('道')) ||
               (scene.text && scene.text.includes('顯現'));
      });
      
      console.log('包含"道"或"顯現"的場景:', daoScenes.map((scene, index) => ({
        原索引: chapter7.scenes.indexOf(scene),
        類型: scene.type,
        文字: scene.text ? scene.text.substring(0, 50) + '...' : 'N/A'
      })));
      
      console.log('🔍 === 調試結束 ===');
    }
    
    function initDevTools() {
      // 章節跳轉按鈕
      document.querySelectorAll('.chapter-jump').forEach(button => {
        button.addEventListener('click', () => {
          const chapter = button.getAttribute('data-chapter');
          if (chapter) {
            // 根據章節預設解鎖相應形態
            setupChapterPrerequisites(chapter);
            
            // 關閉主菜單
            mainMenu.style.opacity = 0;
            setTimeout(() => {
              mainMenu.style.display = 'none';
              aperturesTracker.style.opacity = 1;
              gameUI.style.opacity = 1;
              gameContent.style.opacity = 1;
              document.getElementById('current-form-indicator').style.opacity = 1;
              
              // 開始對應章節
              startChapter(chapter);
            }, 500);
          }
        });
      });
      
      // 開發者工具已簡化，只保留章節跳轉功能
      // 其他開發者工具按鈕已移除
    }
    
    // 顯示開發者信息提示
    function showDevMessage(message) {
      // 檢查是否已存在提示
      let toast = document.getElementById('dev-toast');
      
      if (!toast) {
        // 創建新提示
        toast = document.createElement('div');
        toast.id = 'dev-toast';
        toast.className = 'fixed bottom-4 left-4 bg-indigo-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300 opacity-0 transform translate-y-2';
        document.body.appendChild(toast);
      }
      
      // 更新消息
      toast.textContent = message;
      
      // 顯示提示
      setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
        
        // 自動隱藏
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateY(2px)';
          
          // 移除元素
          setTimeout(() => {
            toast.remove();
          }, 300);
        }, 2000);
      }, 10);
    }
    
    // 顯示遊戲消息提示
    function showMessage(message) {
      // 檢查是否已存在提示
      let toast = document.getElementById('game-message-toast');
      
      if (!toast) {
        // 創建新提示
        toast = document.createElement('div');
        toast.id = 'game-message-toast';
        toast.className = 'fixed top-20 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300 opacity-0 translate-y-2';
        document.body.appendChild(toast);
      }
      
      // 更新消息
      toast.textContent = message;
      
      // 顯示提示
      setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateX(-50%) translateY(0)';
        
        // 自動隱藏
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(-50%) translateY(-10px)';
          
          // 移除元素
          setTimeout(() => {
            toast.remove();
          }, 300);
        }, 3000);
      }, 10);
    }
    

    
    // 創建時間效果場景
    function createTimeEffectScene(scene) {
      // 创建全屏时间背景效果
      const timeBackgroundContainer = document.createElement('div');
      timeBackgroundContainer.className = 'time-background-container';
      timeBackgroundContainer.style.position = 'fixed';
      timeBackgroundContainer.style.top = '0';
      timeBackgroundContainer.style.left = '0';
      timeBackgroundContainer.style.width = '100%';
      timeBackgroundContainer.style.height = '100%';
      timeBackgroundContainer.style.pointerEvents = 'none';
      timeBackgroundContainer.style.zIndex = '-1';
      timeBackgroundContainer.style.overflow = 'hidden';
      
      // 创建多层琥珀色光晕效果
      for (let layer = 0; layer < 4; layer++) {
        const amberGlow = document.createElement('div');
        amberGlow.className = 'time-amber-glow';
        amberGlow.style.position = 'absolute';
        amberGlow.style.borderRadius = '50%';
        amberGlow.style.filter = `blur(${20 + layer * 10}px)`;
        
        // 不同大小和位置的光晕
        const size = 300 + layer * 200;
        const posX = 20 + layer * 20;
        const posY = 15 + layer * 15;
        
        amberGlow.style.width = `${size}px`;
        amberGlow.style.height = `${size}px`;
        amberGlow.style.left = `${posX}%`;
        amberGlow.style.top = `${posY}%`;
        amberGlow.style.transform = 'translate(-50%, -50%)';
        
        // 渐变色彩从深到浅
        const opacity = 0.4 - layer * 0.08;
        amberGlow.style.background = `radial-gradient(circle, rgba(255, 191, 0, ${opacity}) 0%, rgba(255, 143, 0, ${opacity * 0.6}) 40%, transparent 70%)`;
        
        // 不同速度的脉动动画
        const duration = 6 + layer * 2;
        amberGlow.style.animation = `amber-pulse-${layer} ${duration}s infinite ease-in-out`;
        
        timeBackgroundContainer.appendChild(amberGlow);
      }
      
      // 创建中央的大椿树 - 位于画面正中心
      const dachunTree = document.createElement('div');
      dachunTree.className = 'dachun-tree-emoji';
      dachunTree.style.position = 'absolute';
      dachunTree.style.left = '50%';
      dachunTree.style.top = '50%';
      dachunTree.style.transform = 'translate(-50%, -50%)';
      dachunTree.style.zIndex = '10';
      dachunTree.style.pointerEvents = 'none';
      dachunTree.style.fontSize = '500px';
      dachunTree.style.filter = `
        drop-shadow(0 0 40px rgba(139, 69, 19, 0.8))
        drop-shadow(0 0 80px rgba(255, 191, 0, 0.5))
        opacity(0.9)
        contrast(1.3)
        sepia(0.4)
      `;
      dachunTree.style.animation = 'dachun-dreamlike 20s infinite ease-in-out';
      dachunTree.textContent = '🌳';
      
      // 添加多層光暈效果
      const glowLayers = document.createElement('div');
      glowLayers.style.position = 'absolute';
      glowLayers.style.left = '50%';
      glowLayers.style.top = '50%';
      glowLayers.style.transform = 'translate(-50%, -50%)';
      glowLayers.style.pointerEvents = 'none';
      
      for (let i = 0; i < 3; i++) {
        const glow = document.createElement('div');
        glow.style.position = 'absolute';
        glow.style.width = `${500 + i * 200}px`;
        glow.style.height = `${400 + i * 160}px`;
        glow.style.borderRadius = '50%';
        glow.style.background = `radial-gradient(circle, rgba(139, 69, 19, ${0.3 - i * 0.08}) 0%, transparent 70%)`;
        glow.style.filter = `blur(${30 + i * 20}px)`;
        glow.style.left = '50%';
        glow.style.top = '50%';
        glow.style.transform = 'translate(-50%, -50%)';
        glow.style.animation = `glow-pulse-${i} ${15 + i * 5}s infinite ease-in-out`;
        glowLayers.appendChild(glow);
      }
      
      dachunTree.appendChild(glowLayers);
      timeBackgroundContainer.appendChild(dachunTree);
      
      // 在大椿脚下创建朝菌群落 - 使用emoji，位于画面中心大椿根部
      for (let i = 0; i < 15; i++) {
        const morningFungus = document.createElement('div');
        morningFungus.className = 'morning-fungus-emoji';
        morningFungus.style.position = 'absolute';
        morningFungus.style.fontSize = `${15 + Math.random() * 25}px`;
        morningFungus.style.filter = `
          drop-shadow(0 0 8px rgba(255, 228, 181, 0.6))
          opacity(${0.7 + Math.random() * 0.3})
          sepia(0.2)
        `;
        
        // 围绕画面中心的大椿树根部分布
        const angle = (i / 15) * Math.PI * 2;
        const distance = 120 + Math.random() * 160; // 距离中心的像素距离，增大兩倍
        const x = 50 + Math.cos(angle) * (distance / 8); // 转换为百分比，缩小分布范围
        const y = 50 + Math.sin(angle) * (distance / 12) + 8; // 在中心稍下方分布
        
        morningFungus.style.left = `${x}%`;
        morningFungus.style.top = `${y}%`;
        morningFungus.style.transform = 'translate(-50%, -50%)';
        morningFungus.textContent = '🍄';
        
        // 朝菌的快速生长动画
        morningFungus.style.animation = `fungus-lifecycle ${2 + Math.random() * 3}s infinite ease-in-out`;
        morningFungus.style.animationDelay = `${Math.random() * 2}s`;
        
        timeBackgroundContainer.appendChild(morningFungus);
      }
      
      // 创建飞舞的蟪蛄
      for (let i = 0; i < 8; i++) {
        const flyingCicada = document.createElement('div');
        flyingCicada.className = 'flying-cicada';
        flyingCicada.style.position = 'absolute';
        flyingCicada.style.width = '20px';
        flyingCicada.style.height = '12px';
        flyingCicada.style.left = `${20 + Math.random() * 60}%`;
        flyingCicada.style.top = `${20 + Math.random() * 40}%`;
        flyingCicada.style.pointerEvents = 'none';
        
        // 蟪蛄身体
        const body = document.createElement('div');
        body.style.position = 'absolute';
        body.style.width = '16px';
        body.style.height = '8px';
        body.style.background = 'linear-gradient(90deg, rgba(139, 90, 43, 0.9), rgba(160, 100, 50, 0.8))';
        body.style.borderRadius = '8px 8px 3px 3px';
        body.style.left = '2px';
        body.style.top = '2px';
        
        // 蟪蛄翅膀
        const leftWing = document.createElement('div');
        leftWing.style.position = 'absolute';
        leftWing.style.width = '18px';
        leftWing.style.height = '10px';
        leftWing.style.background = 'rgba(255, 255, 255, 0.4)';
        leftWing.style.borderRadius = '50% 20% 50% 20%';
        leftWing.style.left = '-2px';
        leftWing.style.top = '1px';
        leftWing.style.transformOrigin = '80% 50%';
        leftWing.dataset.originalWingDuration = '0.3';
        leftWing.style.animation = 'cicada-wing-left 0.3s infinite ease-in-out';
        
        const rightWing = document.createElement('div');
        rightWing.style.position = 'absolute';
        rightWing.style.width = '18px';
        rightWing.style.height = '10px';
        rightWing.style.background = 'rgba(255, 255, 255, 0.4)';
        rightWing.style.borderRadius = '20% 50% 20% 50%';
        rightWing.style.right = '-2px';
        rightWing.style.top = '1px';
        rightWing.style.transformOrigin = '20% 50%';
        rightWing.dataset.originalWingDuration = '0.3';
        rightWing.style.animation = 'cicada-wing-right 0.3s infinite ease-in-out';
        
        flyingCicada.appendChild(body);
        flyingCicada.appendChild(leftWing);
        flyingCicada.appendChild(rightWing);
        
        // 飞行路径动画
        const flightDuration = 15 + Math.random() * 20;
        const flightDelay = Math.random() * 10;
        
        // 保存原始動畫參數作為數據屬性
        flyingCicada.dataset.originalFlightDuration = flightDuration;
        flyingCicada.dataset.flightDelay = flightDelay;
        
        flyingCicada.style.animation = `cicada-flight ${flightDuration}s ${flightDelay}s infinite linear`;
        
        timeBackgroundContainer.appendChild(flyingCicada);
      }
      

      
      // 创建时间粒子效果 - 增加数量并覆盖全屏
      for (let i = 0; i < 40; i++) {
        const particle = document.createElement('div');
        particle.className = 'time-particle-global';
        
        const size = 3 + Math.random() * 8;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.position = 'absolute';
        particle.style.borderRadius = '50%';
        particle.style.pointerEvents = 'none';
        
        // 琥珀色粒子的多种变化
        const colorVariant = Math.random();
        if (colorVariant < 0.3) {
          particle.style.backgroundColor = `rgba(255, 191, 0, ${0.6 + Math.random() * 0.4})`;
          particle.style.boxShadow = '0 0 8px rgba(255, 191, 0, 0.8)';
        } else if (colorVariant < 0.6) {
          particle.style.backgroundColor = `rgba(245, 158, 11, ${0.5 + Math.random() * 0.4})`;
          particle.style.boxShadow = '0 0 6px rgba(245, 158, 11, 0.7)';
        } else {
          particle.style.backgroundColor = `rgba(217, 119, 6, ${0.4 + Math.random() * 0.4})`;
          particle.style.boxShadow = '0 0 10px rgba(217, 119, 6, 0.6)';
        }
        
        // 随机位置覆盖全屏
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // 多种时间流动模式
        const flowType = Math.floor(Math.random() * 3);
        const duration = 15 + Math.random() * 25;
        const delay = Math.random() * 15;
        
        // 保存原始動畫參數作為數據屬性
        particle.dataset.originalDuration = duration;
        particle.dataset.delay = delay;
        
        if (flowType === 0) {
          particle.style.animation = `time-flow-up ${duration}s ${delay}s infinite linear`;
          particle.dataset.animationType = 'time-flow-up';
          particle.dataset.easing = 'linear';
        } else if (flowType === 1) {
          particle.style.animation = `time-flow-spiral ${duration}s ${delay}s infinite linear`;
          particle.dataset.animationType = 'time-flow-spiral';
          particle.dataset.easing = 'linear';
        } else {
          particle.style.animation = `time-flow-drift ${duration}s ${delay}s infinite ease-in-out`;
          particle.dataset.animationType = 'time-flow-drift';
          particle.dataset.easing = 'ease-in-out';
        }
        
        timeBackgroundContainer.appendChild(particle);
      }
      
      // 将背景效果添加到游戏容器
      gameContainer.appendChild(timeBackgroundContainer);
      
      // 添加时间动画样式
      if (!document.getElementById('time-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'time-animations';
        styleElement.textContent = `
          /* 多层琥珀光晕脉动 */
          @keyframes amber-pulse-0 {
            0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
          }
          
          @keyframes amber-pulse-1 {
            0%, 100% { opacity: 0.32; transform: translate(-50%, -50%) scale(0.95); }
            50% { opacity: 0.48; transform: translate(-50%, -50%) scale(1.05); }
          }
          
          @keyframes amber-pulse-2 {
            0%, 100% { opacity: 0.24; transform: translate(-50%, -50%) scale(1.05); }
            50% { opacity: 0.36; transform: translate(-50%, -50%) scale(0.9); }
          }
          
          @keyframes amber-pulse-3 {
            0%, 100% { opacity: 0.16; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 0.24; transform: translate(-50%, -50%) scale(1.15); }
          }
          
          /* 树木生长阶段动画 */
          @keyframes seedling-growth {
            0%, 100% { transform: scaleY(0.8) rotate(-1deg); }
            50% { transform: scaleY(1.2) rotate(1deg); }
          }
          
          @keyframes mature-sway {
            0%, 100% { transform: rotate(-2deg) scaleY(1); }
            50% { transform: rotate(2deg) scaleY(1.05); }
          }
          
          @keyframes ancient-stillness {
            0%, 100% { transform: rotate(-0.5deg) scaleY(1); }
            50% { transform: rotate(0.5deg) scaleY(1.02); }
          }
          
          /* 时间粒子流动动画 */
          @keyframes time-flow-up {
            0% { transform: translateY(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-120vh) rotate(180deg); opacity: 0; }
          }
          
          @keyframes time-flow-spiral {
            0% { transform: rotate(0deg) translateX(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.6; }
            100% { transform: rotate(720deg) translateX(100px) rotate(-720deg); opacity: 0; }
          }
          
          @keyframes time-flow-drift {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
            25% { transform: translate(20px, -30px) rotate(90deg); opacity: 0.8; }
            50% { transform: translate(-20px, -60px) rotate(180deg); opacity: 0.9; }
            75% { transform: translate(30px, -90px) rotate(270deg); opacity: 0.7; }
            100% { transform: translate(0, -120px) rotate(360deg); opacity: 0; }
          }
          
          /* 文字发光效果 */
          .time-text {
            color: #d97706;
            text-shadow: 0 0 10px rgba(217, 119, 6, 0.5);
            animation: text-glow-amber 4s infinite ease-in-out;
            background: rgba(0, 0, 0, 0.7);
            padding: 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 191, 0, 0.3);
          }
          
          @keyframes text-glow-amber {
            0%, 100% { text-shadow: 0 0 10px rgba(217, 119, 6, 0.5); }
            50% { text-shadow: 0 0 20px rgba(217, 119, 6, 0.8), 0 0 30px rgba(255, 191, 0, 0.4); }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      // 创建文本容器
      const timeEffectElement = document.createElement('div');
      timeEffectElement.className = 'max-w-2xl mx-auto p-6 text-left relative z-10';
      
      // 添加文本
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed time-text';
      textElement.textContent = scene.text;
      timeEffectElement.appendChild(textElement);
      
      gameContent.appendChild(timeEffectElement);
      advanceBtn.style.display = 'block';
    }
    
    // 創建時間體驗場景
    // 創建物化體驗場景（帶打字機效果）
    function createTransformationExperienceScene(scene) {
      // 進入新的物化場景時，清除螻蟻視覺效果
      removeAntVisionEffect();
      
      // 如果是氣形態，進行徹底的視覺清理
      if (scene.formType === 'qi') {
        // 清理所有可能的視覺殘留
        const existingOverlay = document.querySelector('.transformation-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // 清理萬物尋氣引導界面
        const wanwuGuideContainer = document.querySelector('.max-w-2xl.mx-auto.p-6.text-center.fixed');
        if (wanwuGuideContainer) {
          wanwuGuideContainer.remove();
        }
        
        // 清理萬物尋氣相關的狀態
        gameState.wanwuXunqiActive = false;
        gameState.handleFormSequenceClick = null;
        gameState.wanwuXunqiGuideContainer = null;
        
        // 移除所有物化按鈕的高亮效果
        Object.values(formButtons).forEach(btn => {
          if (btn) {
            btn.style.boxShadow = '';
            btn.style.animation = '';
          }
        });
        
        // 重置gameContainer的樣式
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
        gameContainer.style.background = '';
        
        console.log('氣形態物化體驗：已清理所有視覺殘留');
      }
      
      // 隱藏底部日常物化按鈕，避免在打字機體驗中的混亂
      hideFormButtons();
      
      const experienceElement = document.createElement('div');
      experienceElement.className = 'max-w-2xl mx-auto p-6 text-left relative z-10';
      
      // 根據不同的形態創建不同的視覺效果
      const formType = scene.formType || 'default';
      let backgroundColor, particleColor, particleCount;
      
      switch (formType) {
        case 'butterfly':
          backgroundColor = 'rgba(147, 51, 234, 0.15)'; // 紫色，代表夢境
          particleColor = 'rgba(147, 51, 234, 0.8)';
          particleCount = 15;
          break;
        case 'fish':
          backgroundColor = 'rgba(59, 130, 246, 0.15)'; // 藍色，代表水中
          particleColor = 'rgba(59, 130, 246, 0.8)';
          particleCount = 20;
          break;
        case 'kun':
          backgroundColor = 'rgba(30, 64, 175, 0.15)'; // 深藍色，代表深海
          particleColor = 'rgba(30, 64, 175, 0.8)';
          particleCount = 25;
          break;
        case 'peng':
          backgroundColor = 'rgba(14, 165, 233, 0.15)'; // 天藍色，代表高空
          particleColor = 'rgba(14, 165, 233, 0.8)';
          particleCount = 30;
          break;
        case 'yuanchu':
          backgroundColor = 'rgba(255, 215, 0, 0.15)'; // 金色，代表聖潔
          particleColor = 'rgba(255, 215, 0, 0.8)';
          particleCount = 20;
          break;
        case 'chixiao':
          backgroundColor = 'rgba(75, 0, 130, 0.15)'; // 紫色，代表夜晚
          particleColor = 'rgba(255, 215, 0, 0.6)';
          particleCount = 16;
          break;
        case 'snail':
          backgroundColor = 'rgba(168, 85, 247, 0.15)'; // 紫色，代表螺旋
          particleColor = 'rgba(168, 85, 247, 0.8)';
          particleCount = 12;
          break;
        case 'morning-fungus':
          backgroundColor = 'rgba(255, 230, 153, 0.2)'; // 淺黃色，代表晨光
          particleColor = 'rgba(255, 255, 0, 0.8)';
          particleCount = 30;
          break;
        case 'cicada':
          backgroundColor = 'rgba(34, 197, 94, 0.2)'; // 綠色，代表夏日
          particleColor = 'rgba(34, 197, 94, 0.8)';
          particleCount = 20;
          break;
        case 'great-chun':
          backgroundColor = 'rgba(120, 53, 15, 0.2)'; // 棕色，代表古老
          particleColor = 'rgba(120, 53, 15, 0.8)';
          particleCount = 10;
          break;
        case 'ant':
          backgroundColor = 'rgba(50, 50, 50, 0.3)'; // 深灰色，代表螻蟻的黑白視覺
          particleColor = 'rgba(100, 100, 100, 0.6)';
          particleCount = 12;
          break;
        case 'star':
          backgroundColor = 'rgba(25, 25, 112, 0.2)'; // 深藍色，代表宇宙
          particleColor = 'rgba(255, 215, 0, 0.8)';
          particleCount = 20;
          break;
        case 'qi':
          backgroundColor = 'rgba(255, 255, 255, 0.1)'; // 半透明白色，代表氣的純淨
          particleColor = 'rgba(0, 0, 0, 0.6)'; // 黑色粒子，符合陰陽概念
          particleCount = 18;
          break;
        default:
          backgroundColor = 'rgba(255, 191, 0, 0.2)';
          particleColor = 'rgba(255, 191, 0, 0.8)';
          particleCount = 15;
      }
      
      // 創建體驗背景
      const experienceBackground = document.createElement('div');
      experienceBackground.className = 'fixed inset-0 pointer-events-none z-0';
      experienceBackground.style.background = backgroundColor;
      experienceBackground.style.animation = 'transformation-experience-fade 4s infinite ease-in-out';
      document.body.appendChild(experienceBackground);
      
      // 創建粒子效果
      const particleContainer = document.createElement('div');
      particleContainer.className = 'absolute inset-0 pointer-events-none';
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'transformation-particle';
        
        const size = 4 + Math.random() * 8;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.backgroundColor = particleColor;
        particle.style.borderRadius = '50%';
        particle.style.position = 'absolute';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        const duration = 8 + Math.random() * 12;
        const delay = Math.random() * duration;
        particle.style.animation = `transformation-float ${duration}s ${delay}s infinite ease-in-out`;
        
        particleContainer.appendChild(particle);
      }
      
      // 添加動畫樣式
      if (!document.getElementById('transformation-experience-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'transformation-experience-animations';
        styleElement.textContent = `
          @keyframes transformation-experience-fade {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.3; }
          }
          
          @keyframes transformation-float {
            0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.6; }
            25% { transform: translateY(-20px) rotate(90deg); opacity: 1; }
            50% { transform: translateY(0) rotate(180deg); opacity: 0.8; }
            75% { transform: translateY(20px) rotate(270deg); opacity: 0.6; }
          }
          
          .transformation-experience-text {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            text-align: left;
          }
          
          .typewriter-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background-color: currentColor;
            animation: cursor-blink 1s infinite;
            margin-left: 2px;
          }
          
          @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      experienceElement.appendChild(particleContainer);
      
      // 添加文本容器
      const textContainer = document.createElement('div');
      textContainer.className = 'transformation-experience-text relative z-20 text-left';
      
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed text-left';
      
      textContainer.appendChild(textElement);
      experienceElement.appendChild(textContainer);
      
      gameContent.appendChild(experienceElement);
      
      // 開始打字機效果
      startTypewriterEffect(textElement, scene.text, () => {
        // 如果是蝸牛形態，激活蝸牛視角效果
        if (formType === 'snail') {
          createSnailPerspectiveEffect();
        }
        
        // 如果是氣形態，激活氣視覺效果
        if (formType === 'qi') {
          addQiVisionEffect();
        }
        
        // 打字完成後顯示繼續按鈕
        advanceBtn.style.display = 'block';
        // 移除背景效果
        setTimeout(() => {
        experienceBackground.remove();
        }, 1000);
      });
    }
    
    // 打字機效果函數
    function startTypewriterEffect(element, text, onComplete) {
      let index = 0;
      const speed = 100; // 打字速度（毫秒）- 降低兩倍速度
      let typewriterActive = true; // 添加狀態標記
      
      // 創建光標
      const cursor = document.createElement('span');
      cursor.className = 'typewriter-cursor';
      element.appendChild(cursor);
      
      // 存儲到全局變量以便清理
      window.currentTypewriterState = {
        active: true,
        element: element,
        cursor: cursor,
        stop: () => {
          typewriterActive = false;
          if (cursor && cursor.parentNode) {
            cursor.remove();
          }
          // 清空元素內容，移除所有文本節點
          if (element) {
            element.innerHTML = '';
          }
        }
      };
      
      function typeNextCharacter() {
        if (!typewriterActive || index >= text.length) {
          // 打字完成或被停止
          setTimeout(() => {
            if (cursor && cursor.parentNode) {
              cursor.remove();
            }
            if (typewriterActive && onComplete) onComplete();
            window.currentTypewriterState = null;
          }, 500);
          return;
        }
        
        // 在光標前插入字符
        const textNode = document.createTextNode(text[index]);
        element.insertBefore(textNode, cursor);
        index++;
        setTimeout(typeNextCharacter, speed);
      }
      
      typeNextCharacter();
    }
    
    function createTransformationRequiredScene(scene) {
      const transformationElement = document.createElement('div');
      transformationElement.className = 'max-w-2xl mx-auto p-6 text-left fixed top-8 left-1/2 transform -translate-x-1/2 bg-yellow-100 dark:bg-yellow-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-20 border-2 border-yellow-400 dark:border-yellow-600';
      
      transformationElement.innerHTML = `
        <div class="flex items-center justify-center mb-4">
          <div class="w-8 h-8 bg-yellow-500 rounded-full flex items-center justify-center mr-3">
            <span class="text-white font-bold">!</span>
          </div>
          <h3 class="text-xl font-bold text-yellow-800 dark:text-yellow-200">需要物化形態</h3>
        </div>
        <p class="text-lg leading-relaxed text-yellow-800 dark:text-yellow-200">${scene.text}</p>
        <div class="mt-4 p-3 bg-yellow-200 dark:bg-yellow-800 rounded-lg">
          <p class="text-sm text-yellow-700 dark:text-yellow-300">
            請使用底部的物化按鈕切換到所需形態後，場景將自動繼續。
          </p>
        </div>
      `;
      
      gameContent.appendChild(transformationElement);
      
      // 設置當前需要的物化形態
      gameState.transformationInProgress = scene.requiredForm;
      
      // 隱藏繼續按鈕，直到玩家切換到正確形態
      advanceBtn.style.display = 'none';
      
      // 監聽形態變化
      checkTransformationProgress();
    }
    
    function checkTransformationProgress() {
      if (gameState.transformationInProgress && gameState.currentForm === gameState.transformationInProgress) {
        // 移除所有按鈕的高亮效果
        Object.values(formButtons).forEach(btn => {
          btn.classList.remove('form-button-highlight', 'animate-pulse');
          btn.style.animation = '';
          btn.style.boxShadow = '';
        });
        
        // 檢查是否是初次物化
        if (gameState.firstTimeUnlockInProgress && gameState.pendingFormUnlock) {
          // 初次物化完成，先進入物化體驗場景
          showFirstTimeTransformationExperience(gameState.pendingFormUnlock);
        } else {
          // 常規物化完成，直接進入下一場景
          gameState.transformationInProgress = null;
          setTimeout(() => {
            advanceScene();
          }, 1000);
        }
      }
    }
    
    function createFormUnlockGuideScene(scene) {
      // 立即強制隱藏繼續按鈕，避免時序問題
      advanceBtn.style.display = 'none';
      
      // 隱藏底部日常物化按鈕，避免初次物化流程中的混亂
      hideFormButtons();
      
      const guideElement = document.createElement('div');
      guideElement.className = 'max-w-2xl mx-auto p-6 text-center fixed top-8 left-1/2 transform -translate-x-1/2 bg-gradient-to-br from-amber-50 to-orange-100 dark:from-amber-900 dark:to-orange-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-20 border-2 border-amber-400 dark:border-amber-600';
      
      guideElement.innerHTML = `
        <div class="flex items-center justify-center mb-4">
          <div class="w-10 h-10 bg-amber-500 rounded-full flex items-center justify-center mr-3 animate-pulse">
            <span class="text-white font-bold text-lg">✨</span>
          </div>
          <h3 class="text-xl font-bold text-amber-800 dark:text-amber-200">新的物化能力已解鎖！</h3>
        </div>
        <p class="text-lg leading-relaxed text-amber-800 dark:text-amber-200 mb-4 text-left">${scene.text}</p>
        <div class="mt-4 p-3 bg-amber-200 dark:bg-amber-800 rounded-lg">
          <p class="text-sm text-amber-700 dark:text-amber-300 flex items-center justify-center">
            <span class="animate-bounce mr-2">👇</span>
            點擊下方按鈕體驗新的物化能力
            <span class="animate-bounce ml-2">👇</span>
          </p>
        </div>
      `;
      
      gameContent.appendChild(guideElement);
      
      // 再次確保隱藏底部的繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 設置初次物化狀態
      gameState.firstTimeUnlockInProgress = true;
      gameState.pendingFormUnlock = scene.highlightForm;
      
      // 創建初次物化按鈕（替代繼續按鈕的位置）
      createFirstTimeTransformationButton(scene.highlightForm);
      
      // 設置持續監控，確保當場景中有新物化按鈕時，繼續按鈕保持隱藏
      const hideAdvanceBtnInterval = setInterval(() => {
        const firstTimeButton = document.getElementById('first-time-transform-btn');
        if (firstTimeButton) {
          // 當新物化按鈕存在時，強制隱藏繼續按鈕
          if (advanceBtn.style.display !== 'none') {
            advanceBtn.style.display = 'none';
            console.log('檢測到新物化按鈕存在，強制隱藏繼續按鈕');
          }
        } else if (gameState.firstTimeUnlockInProgress === false) {
          // 當初次物化流程完成且新物化按鈕不存在時，停止監控
          clearInterval(hideAdvanceBtnInterval);
          console.log('初次物化流程完成，停止繼續按鈕監控');
        }
      }, 50);
      
      // 保存監控器ID到gameState，以便在需要時可以手動清理
      gameState.advanceBtnHideInterval = hideAdvanceBtnInterval;
      
      // 添加延遲檢查，確保繼續按鈕保持隱藏
      setTimeout(() => {
        if (gameState.firstTimeUnlockInProgress) {
          advanceBtn.style.display = 'none';
          console.log('延遲檢查：確保繼續按鈕在初次物化引導期間保持隱藏');
        }
      }, 100);
    }
    
    // 創建初次物化按鈕（在繼續按鈕位置）
    function createFirstTimeTransformationButton(formType) {
      // 移除已存在的初次物化按鈕
      const existingButton = document.getElementById('first-time-transform-btn');
      if (existingButton) {
        existingButton.remove();
      }
      
      // 獲取形態的中文名稱
      const formNames = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰',
        qi: '氣'
      };
      
      const formName = formNames[formType] || formType;
      
      // 創建初次物化按鈕
      const firstTimeButton = document.createElement('button');
      firstTimeButton.id = 'first-time-transform-btn';
      firstTimeButton.className = 'first-time-transform-button';
      
      // 設置位置和樣式（不使用cssText避免覆蓋）
      firstTimeButton.style.position = 'fixed';
      firstTimeButton.style.top = '50%';
      firstTimeButton.style.left = '50%';
      firstTimeButton.style.transform = 'translate(-50%, -50%)';
      firstTimeButton.style.marginTop = '100px'; // 微調位置，避免與引導窗口重疊
      firstTimeButton.style.zIndex = '30';
      firstTimeButton.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
      firstTimeButton.style.color = 'white';
      firstTimeButton.style.fontWeight = 'bold';
      firstTimeButton.style.fontSize = '1.1rem';
      firstTimeButton.style.padding = '12px 32px';
      firstTimeButton.style.borderRadius = '50px';
      firstTimeButton.style.border = '3px solid #fcd34d';
      firstTimeButton.style.boxShadow = '0 0 20px rgba(251, 191, 36, 0.6), 0 0 40px rgba(251, 191, 36, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2)';
      firstTimeButton.style.cursor = 'pointer';
      firstTimeButton.style.transition = 'all 0.3s ease';
      firstTimeButton.style.animation = 'first-time-button-glow 2s infinite ease-in-out';
      firstTimeButton.style.overflow = 'hidden';
      
      firstTimeButton.innerHTML = `
        <span class="relative z-10 flex items-center">
          <span class="mr-2 text-xl">✨</span>
          化身為${formName}
          <span class="ml-2 text-xl">✨</span>
        </span>
      `;
      
      // 添加點擊事件
      firstTimeButton.addEventListener('click', () => handleFirstTimeTransformation(formType));
      
      // 添加懸停效果
      firstTimeButton.addEventListener('mouseenter', () => {
        firstTimeButton.style.transform = 'translate(-50%, -50%) scale(1.05)';
        firstTimeButton.style.boxShadow = `
          0 0 30px rgba(251, 191, 36, 0.8),
          0 0 60px rgba(251, 191, 36, 0.4),
          0 6px 20px rgba(0, 0, 0, 0.3)
        `;
      });
      
      firstTimeButton.addEventListener('mouseleave', () => {
        firstTimeButton.style.transform = 'translate(-50%, -50%) scale(1)';
        firstTimeButton.style.boxShadow = `
          0 0 20px rgba(251, 191, 36, 0.6),
          0 0 40px rgba(251, 191, 36, 0.3),
          0 4px 15px rgba(0, 0, 0, 0.2)
        `;
      });
      
      document.body.appendChild(firstTimeButton);
      
      // 添加初次物化按鈕的動畫樣式
      if (!document.getElementById('first-time-button-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'first-time-button-styles';
        styleElement.textContent = `
          @keyframes first-time-button-glow {
            0%, 100% {
              box-shadow: 
                0 0 20px rgba(251, 191, 36, 0.6),
                0 0 40px rgba(251, 191, 36, 0.3),
                0 4px 15px rgba(0, 0, 0, 0.2);
            }
            50% {
              box-shadow: 
                0 0 30px rgba(251, 191, 36, 0.8),
                0 0 60px rgba(251, 191, 36, 0.5),
                0 4px 15px rgba(0, 0, 0, 0.2);
            }
          }
          
          .first-time-transform-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: first-time-button-shine 3s infinite;
          }
          
          @keyframes first-time-button-shine {
            0% { left: -100%; }
            100% { left: 100%; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 處理初次物化
    function handleFirstTimeTransformation(formType) {
      // 執行物化（明確標記為初次物化）
      transformTo(formType, true);
      
      // 移除初次物化按鈕
      const firstTimeButton = document.getElementById('first-time-transform-btn');
      if (firstTimeButton) {
        firstTimeButton.remove();
      }
      
      // 設置物化狀態
      gameState.transformationInProgress = formType;
      
      // 監聽形態變化完成
      checkTransformationProgress();
    }
    
    // 顯示初次物化體驗場景
    function showFirstTimeTransformationExperience(formType) {
      // 獲取對應的物化體驗文本
      const transformationTexts = {
        butterfly: '你化身為蝴蝶，感受到了前所未有的輕盈和自由。世界變得色彩斑斕，每一朵花都散發著誘人的香氣。你的翅膀輕輕扇動，就能在空中自由飛舞。在這夢幻般的體驗中，你開始懷疑：到底是莊周夢見了蝴蝶，還是蝴蝶夢見了莊周？現實與夢境的界限變得模糊，你體會到了什麼叫做「物我兩忘」——在這一刻，你既是人，也是蝶，或者說，你超越了人與蝶的分別。',
        fish: '你化身為儵魚，潛入濠水之中。水下世界與陸地截然不同，所有聲音變得沉悶而遙遠，光線也變得朦朧柔和。水流輕撫著你的魚鰭，你能感受到每一絲水波的律動。在這寧靜的水中世界，時間彷彿變得緩慢而悠長，你終於理解了什麼是真正的「魚之樂」。',
        kun: '你的身體開始膨脹，化為千里之鯤。巨大的魚身讓你能夠感受到海水的每一處細節。你游入漩渦，在北冥的深處暢遊，感受著前所未有的自由。作為鯤，整個海洋都是你的領域，千里之距不過是一個轉身。你體會到了什麼叫做真正的「大」——不是體積的大，而是心境的無限廣闊。',
        peng: '突然，你感到身體劇烈變化，羽翼伸展開來，化身為九萬里大鵬。你騰空而起，風在你的翅膀下咆哮，大地在你腳下快速縮小。你飛得越來越高，直到雲海都在你的下方翻滾。在這無盡的天空中，你感受到了真正的自由——超越一切束縛的自由。你明白了，真正的逍遙不是逃避現實，而是超越現實的局限。',
        yuanchu: '你化身為美麗的鵷鶵，潔白的羽毛在陽光下閃閃發光。你飛翔在清朝的天空中，每一陣風都帶著花香，每一片雲都純淨無瑕。在這聖潔的視角中，你看到了世界最美好的一面。你體會到什麼是真正的純潔與高貴——不是外在的裝飾，而是內在的清明。',
        chixiao: '夜幕降臨，你化身為鴟鴞，在黑暗中翱翔。你的眼睛在夜色中閃閃發光，能夠看清黑暗中的一切。在這靜謐的夜晚，你感受到了不同於白日的寧靜與智慧。你明白了，黑暗並不可怕，它只是另一種光明。在鴟鴞的視角中，夜晚充滿了神秘的美。',
        snail: '你慢慢縮小，化身為一隻蝸牛。世界突然變得巨大無比，每一片葉子都如房屋般寬廣，每一滴露珠都如湖泊般深邃。你背著螺旋狀的殼，緩慢而堅定地前行。在這慢節奏的世界裡，你體會到了什麼叫做真正的耐心與堅持。',
        'morning-fungus': '你化身為朝菌，體驗著短暫而燦爛的生命。從黎明到日落，就是你的一生。在這短暫的時光中，你感受到了生命的珍貴與美好。你明白了，生命的意義不在於長短，而在於是否活得充實與精彩。',
        cicada: '你化身為蟪蛄，感受著夏日的熱情。你的歌聲響徹樹林，每一聲鳴叫都是對生命的讚美。雖然生命短暫，但你活得熱烈而真實。你體會到了什麼叫做活在當下，珍惜每一刻的美好。',
        'great-chun': '你的意識擴展，化身為大椿樹，感受著千年的時光流逝。你看著四季更替，看著世間變遷，心中充滿了古老的智慧。作為大椿，你體會到了什麼叫做永恆與包容——不是拒絕變化，而是包容一切變化。',
        ant: '你縮小為螻蟻，在大地上行走。世界變得黑白分明，你專注於尋找食物和建造家園。在這簡單而專注的生活中，你體會到了什麼叫做踏實與勤勞。螻蟻的世界雖然渺小，但每一步都走得堅實。',
        star: '你的意識升華，化身為夜空中的星辰。從這無限高遠的視角俯瞰大地，一切都顯得如此渺小而美麗。你感受到了宇宙的廣闊與神秘，體會到了什麼叫做超脫與永恆。在星辰的視角中，你明白了生命的本質是光明。',
        qi: '你化身為氣，身體變得半透明，如雲霧般飄逸。在這超越具象的狀態下，你感受到前所未有的自由。世界在你眼中徹底改變：所有色彩消退，只留下陰陽二氣的純粹對立與統一。每個生命都散發著獨特的氣息，你能感知到它們內在的能量流動。你體會到了「氣者，生之本也」——萬物皆由氣聚散而成，而你已經觸及了存在的根本奧秘。'
      };
      
      const experienceText = transformationTexts[formType] || '你體驗到了全新的物化感受，超越了原有的認知界限。';
      
      // 創建模擬的transformation-experience場景對象
      const experienceScene = {
        type: 'transformation-experience',
        formType: formType,
        text: experienceText
      };
      
      // 清空當前內容並創建物化體驗場景
      gameContent.innerHTML = '';
      advanceBtn.style.display = 'none';
      
      // 隱藏底部日常物化按鈕，避免在體驗打字機效果時的混亂
      hideFormButtons();
      
      // 創建物化體驗場景
      createTransformationExperienceScene(experienceScene);
      
      // 監聽繼續按鈕點擊，結束體驗進入收集場景
      const originalAdvanceHandler = advanceBtn.onclick;
      advanceBtn.onclick = function() {
        // 0. 首先強制停止所有打字機效果
        if (window.currentTypewriterState && window.currentTypewriterState.active) {
          window.currentTypewriterState.stop();
          window.currentTypewriterState = null;
        }
        
        // 1. 移除所有打字機相關元素和背景效果
        const typewriterElements = document.querySelectorAll('.transformation-experience-text, .typewriter-cursor, .transformation-particle');
        typewriterElements.forEach(el => {
          // 清空元素內容以移除文本節點
          if (el.classList.contains('transformation-experience-text')) {
            el.innerHTML = '';
          }
          el.remove();
        });
        
        // 2. 移除物化體驗的背景效果
        const experienceBackgrounds = document.querySelectorAll('.fixed.inset-0.pointer-events-none');
        experienceBackgrounds.forEach(bg => {
          // 只清理物化體驗的背景（包含rgba色彩）
          if ((bg.style.background && bg.style.background.includes('rgba')) || 
              (bg.style.backgroundColor && bg.style.backgroundColor.includes('rgba'))) {
            bg.remove();
            console.log('清理了物化體驗背景');
          }
        });
        
        // 3. 移除包含transformation-particle的容器
        const particleContainers = document.querySelectorAll('.absolute.inset-0.pointer-events-none');
        particleContainers.forEach(container => {
          // 檢查是否真的包含transformation-particle元素
          if (container.querySelector('.transformation-particle')) {
            container.remove();
            console.log('清理了粒子容器');
          }
        });
        
        // 4. 最後清空gameContent，確保所有內容都被移除
        gameContent.innerHTML = '';
        
        // 5. 重置繼續按鈕
        advanceBtn.style.display = 'none';
        advanceBtn.textContent = '繼續';
        
        // 6. 恢復原始的advance處理器
        advanceBtn.onclick = originalAdvanceHandler;
        
        // 7. 立即進入收集場景，不使用requestAnimationFrame避免延遲
        handleFirstTimeTransformationComplete(formType);
      };
    }
    
    // 處理初次物化完成後的效果
    function handleFirstTimeTransformationComplete(formType) {
      // 立即隱藏底部日常物化按鈕，避免在300ms延遲期間閃現
      hideFormButtons();
      
      // 記住收集的形態類型
      gameState.collectedFormType = formType;
      
      // 清除初次物化狀態，但記住當前形態以備日常物化使用
      gameState.firstTimeUnlockInProgress = false;
      gameState.pendingFormUnlock = null;
      gameState.transformationInProgress = null;
      
      // 清理繼續按鈕隱藏監控器
      if (gameState.advanceBtnHideInterval) {
        clearInterval(gameState.advanceBtnHideInterval);
        gameState.advanceBtnHideInterval = null;
        console.log('清理繼續按鈕隱藏監控器');
      }
      
      console.log(`初次物化完成，當前形態: ${gameState.currentForm}，進入物化收集場景`);
      
      // 確保新按鈕在此時還是隱藏的
      const targetButton = formButtons[formType];
      if (targetButton) {
        targetButton.style.visibility = 'hidden';
        targetButton.classList.add('hidden');
      }
      
      // 延遲足夠時間確保所有清理和DOM操作完成，然後創建獨立的物化能力收集場景
      setTimeout(() => {
        console.log('延遲後開始創建收集場景');
        showFormCollectionScene(formType);
      }, 300);
    }
    
    // 顯示物化能力收集場景（作為獨立場景）
    function showFormCollectionScene(formType) {
      const formNames = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰',
        qi: '氣'
      };
      
      const emojiFormMap = {
                    human: '🧘',
        butterfly: '🦋',
        fish: '🐟',
        kun: '🐋',
        peng: '🦅',
        yuanchu: '🦚',
        chixiao: '🦉',
        bird: '🦅',
        snail: '🐌',
        'morning-fungus': '🍄',
        cicada: '🦗',
        'great-chun': '🌳',
        ant: '🐜',
        star: '⭐',
        qi: '💨'
      };
      
      const formName = formNames[formType] || formType;
      const formEmoji = emojiFormMap[formType] || '🌟';
      
      // 強化清理邏輯，確保沒有打字機文字殘留
      console.log('開始創建物化收集場景');
      
      // 確保打字機狀態已停止
      if (window.currentTypewriterState && window.currentTypewriterState.active) {
        window.currentTypewriterState.stop();
        window.currentTypewriterState = null;
      }
      
      // 再次清理可能殘留的打字機元素
      const remainingTypewriterElements = document.querySelectorAll('.transformation-experience-text, .typewriter-cursor');
      remainingTypewriterElements.forEach(el => {
        // 清空元素內容以移除文本節點
        if (el.classList.contains('transformation-experience-text')) {
          el.innerHTML = '';
        }
          el.remove();
      });
      
      // 強制清空gameContent確保完全乾淨
      gameContent.innerHTML = '';
      
      // 隱藏底部繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 隱藏segment按鈕
      if (document.getElementById('segment-buttons')) {
        document.getElementById('segment-buttons').style.display = 'none';
      }
      
      // 隱藏底部日常物化按鈕，避免在收集場景中的混亂
      hideFormButtons();
      
      // 注意：不再清空gameContent，因為前面已經精確清理了打字機元素
      
      // 創建物化能力收集場景內容
      const collectionElement = document.createElement('div');
      collectionElement.className = 'max-w-2xl mx-auto p-6 text-left';
      collectionElement.id = 'form-collection-scene'; // 添加ID便於識別
      
      collectionElement.innerHTML = `
        <div class="bg-gradient-to-br from-green-50 to-emerald-100 dark:from-green-900 dark:to-emerald-900 
                    border-2 border-green-400 dark:border-green-600 rounded-2xl p-8 shadow-2xl
                    text-center">
          <!-- 頂部圖標區域 -->
          <div class="mb-6">
            <div class="w-20 h-20 mx-auto bg-gradient-to-br from-green-400 to-emerald-500 rounded-full flex items-center justify-center shadow-lg animate-bounce">
              <span class="text-3xl">${formEmoji}</span>
            </div>
          </div>
          
          <!-- 標題 -->
          <h1 class="text-2xl font-bold text-green-800 dark:text-green-200 mb-4">
            🎉 物化能力已收集！🎉
          </h1>
          
          <!-- 形態名稱 -->
          <div class="mb-6">
            <div class="inline-block bg-gradient-to-r from-green-500 to-emerald-500 text-white px-6 py-3 rounded-full font-bold text-lg shadow-lg">
              ${formName}
            </div>
          </div>
          
          <!-- 描述文字 -->
          <p class="text-lg text-green-700 dark:text-green-300 mb-6 leading-relaxed">
            <span class="font-bold">${formName}</span> 的物化能力已成功加入你的日常物化選單！<br>
            從現在開始，你可以隨時體驗這種生物的獨特視角。
          </p>
          
          <!-- 裝飾元素 -->
          <div class="flex justify-center items-center space-x-4 mb-6 text-xl">
            <span class="animate-pulse">✨</span>
            <span class="animate-bounce">🌟</span>
            <span class="animate-pulse delay-75">💫</span>
            <span class="animate-bounce delay-150">⭐</span>
            <span class="animate-pulse delay-300">✨</span>
          </div>
        </div>
      `;
      
      gameContent.appendChild(collectionElement);
      console.log('收集場景已創建');
      
      // 顯示特殊的繼續按鈕
      advanceBtn.style.display = 'block';
      advanceBtn.textContent = '繼續';
      
             // 重新綁定繼續按鈕事件
       const originalAdvanceHandler = advanceBtn.onclick;
       advanceBtn.onclick = function() {
         // 恢復遊戲內容區域和按鈕
         if (document.getElementById('segment-buttons')) {
           document.getElementById('segment-buttons').style.display = 'block';
         }
         
         // 檢查是否為氣形態：氣形態收集完成後不恢復日常物化按鈕
         if (formType !== 'qi') {
           showFormButtons();
         } else {
           console.log('氣形態收集完成，保持日常物化按鈕隱藏');
         }
         
         // 確保新形態在解鎖列表中（可能在 unlockForm 中已添加）
         if (!gameState.unlockedForms.includes(formType)) {
           gameState.unlockedForms.push(formType);
           console.log(`形態 ${formType} 已添加到解鎖列表`);
         } else {
           console.log(`形態 ${formType} 已在解鎖列表中，現在激活按鈕顯示`);
         }
         
         // 強制顯示新解鎖的按鈕，確保鴟鴞等新形態按鈕能正確顯示
         if (formButtons[formType]) {
           formButtons[formType].classList.remove('hidden');
           formButtons[formType].style.visibility = 'visible';
           formButtons[formType].style.display = 'block';
           console.log(`強制顯示 ${formType} 按鈕`);
         }
         
         // 執行簡化的按鈕出現動畫
         animateSimpleButtonAppearance(formType);
         
         // 恢復原始的advance處理器，讓玩家可以手動繼續
         advanceBtn.onclick = originalAdvanceHandler;
         
         // 顯示繼續按鈕，讓玩家手動控制進度
         setTimeout(() => {
           advanceBtn.style.display = 'block';
           advanceBtn.textContent = '繼續';
         }, 2000); // 按鈕動畫完成後顯示繼續按鈕
       };
    }
    

    
    // 簡化的按鈕出現動畫（淡入+發光效果）
    function animateSimpleButtonAppearance(formType) {
      // 確保目標按鈕存在
      const targetButton = formButtons[formType];
      if (!targetButton) return;
      
      // 確保按鈕初始是隱藏的
      targetButton.style.visibility = 'hidden';
      targetButton.classList.add('hidden');
      
      // 顯示按鈕並添加淡入效果
      targetButton.classList.remove('hidden');
      targetButton.style.visibility = 'visible';
      targetButton.style.opacity = '0';
      targetButton.style.transition = 'all 1s ease-in-out';
      
      // 延遲一點開始淡入
          setTimeout(() => {
        targetButton.style.opacity = '1';
        
        // 添加發光效果
        targetButton.style.boxShadow = '0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3)';
        targetButton.style.animation = 'simple-form-glow 3s ease-in-out';
        
        // 3秒後重置特效
        setTimeout(() => {
          targetButton.style.boxShadow = '';
          targetButton.style.animation = '';
          targetButton.style.transition = '';
        }, 3000);
        
      }, 100);
      
      // 添加簡化的發光動畫樣式
      if (!document.getElementById('simple-form-glow-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'simple-form-glow-styles';
        styleElement.textContent = `
          @keyframes simple-form-glow {
            0% { 
              box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3);
            }
            50% { 
              box-shadow: 0 0 30px rgba(34, 197, 94, 0.8), 0 0 60px rgba(34, 197, 94, 0.5);
            }
            100% {
              box-shadow: 0 0 15px rgba(34, 197, 94, 0.4), 0 0 30px rgba(34, 197, 94, 0.2);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 執行按鈕飛入動畫
    function animateButtonFlyIn(formType) {
      // 獲取目標底部按鈕
      const targetButton = formButtons[formType];
      if (!targetButton) return;
      
      // 顯示目標按鈕（如果隱藏的話）
      targetButton.classList.remove('hidden');
      targetButton.style.visibility = 'visible';
      
      // 創建飛行的按鈕副本
      const flyingButton = targetButton.cloneNode(true);
      flyingButton.id = 'flying-button-' + formType;
      flyingButton.style.position = 'fixed';
      flyingButton.style.zIndex = '100';
      flyingButton.style.pointerEvents = 'none';
      
      // 設置起始位置（屏幕中央）
      const startRect = { left: window.innerWidth / 2 - 50, top: window.innerHeight / 2 - 20 };
      flyingButton.style.left = startRect.left + 'px';
      flyingButton.style.top = startRect.top + 'px';
      
      // 添加特殊的飛行效果
      flyingButton.style.boxShadow = '0 0 30px rgba(59, 130, 246, 0.8), 0 0 60px rgba(59, 130, 246, 0.4)';
      flyingButton.style.transform = 'scale(1.2)';
      
      document.body.appendChild(flyingButton);
      
      // 獲取目標位置
      const targetRect = targetButton.getBoundingClientRect();
      
      // 執行飛行動畫
      setTimeout(() => {
        flyingButton.style.transition = 'all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        flyingButton.style.left = targetRect.left + 'px';
        flyingButton.style.top = targetRect.top + 'px';
        flyingButton.style.transform = 'scale(1)';
        flyingButton.style.boxShadow = '0 0 15px rgba(59, 130, 246, 0.4)';
        
        // 動畫完成後移除飛行按鈕並突出顯示目標按鈕
        setTimeout(() => {
          flyingButton.remove();
          
          // 突出顯示目標按鈕
          targetButton.style.animation = 'new-form-highlight 2s ease-in-out';
          targetButton.style.boxShadow = '0 0 20px rgba(34, 197, 94, 0.8)';
          
          // 重置按鈕樣式
          setTimeout(() => {
            targetButton.style.animation = '';
            targetButton.style.boxShadow = '';
          }, 2000);
        }, 1500);
      }, 100);
      
      // 添加新形態突出顯示動畫
      if (!document.getElementById('new-form-highlight-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'new-form-highlight-styles';
        styleElement.textContent = `
          @keyframes new-form-highlight {
            0%, 100% { 
              transform: scale(1); 
              box-shadow: 0 0 20px rgba(34, 197, 94, 0.8);
            }
            50% { 
              transform: scale(1.1); 
              box-shadow: 0 0 30px rgba(34, 197, 94, 1), 0 0 60px rgba(34, 197, 94, 0.6);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建退出視角按鈕（日常物化用）
    function createExitTransformationButton() {
      // 移除已存在的退出按鈕
      const existingButton = document.getElementById('exit-transformation-btn');
      if (existingButton) {
        existingButton.remove();
      }
      
      // 創建退出視角按鈕
      const exitButton = document.createElement('button');
      exitButton.id = 'exit-transformation-btn';
      exitButton.className = 'fixed bottom-8 left-1/2 transform -translate-x-1/2 z-30';
      
      // 使用與繼續按鈕相同的樣式和位置
      exitButton.style.cssText = `
        background: linear-gradient(135deg, #6366f1, #4f46e5);
        color: white;
        font-weight: bold;
        font-size: 1rem;
        padding: 10px 24px;
        border-radius: 25px;
        border: 2px solid #818cf8;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        cursor: pointer;
        transition: all 0.3s ease;
      `;
      
      exitButton.innerHTML = '退出視角';
      
      // 添加點擊事件
      exitButton.addEventListener('click', exitDailyTransformation);
      
      // 添加懸停效果
      exitButton.addEventListener('mouseenter', () => {
        exitButton.style.transform = 'translateX(-50%) scale(1.05)';
        exitButton.style.boxShadow = '0 6px 16px rgba(99, 102, 241, 0.4)';
      });
      
      exitButton.addEventListener('mouseleave', () => {
        exitButton.style.transform = 'translateX(-50%) scale(1)';
        exitButton.style.boxShadow = '0 4px 12px rgba(99, 102, 241, 0.3)';
      });
      
      document.body.appendChild(exitButton);
    }
    
    // 退出日常物化
    function exitDailyTransformation() {
      if (!gameState.isInDailyTransformation) {
        return;
      }
      
      // 獲取應該恢復的形態：直接使用保存的前一形態
      let targetForm = gameState.dailyTransformationPreviousForm || 'human';
      
      console.log(`日常物化退出：從 ${gameState.currentForm} 恢復到 ${targetForm}`);
      
      // 執行返回動畫
      showTransformationTransition(gameState.currentForm, targetForm);
      
      // 移除退出按鈕
      const exitButton = document.getElementById('exit-transformation-btn');
      if (exitButton) {
        exitButton.remove();
      }
      
      // 延遲後恢復狀態
      setTimeout(() => {
        // 恢復之前的形態
        gameState.currentForm = targetForm;
        updateFormView(targetForm);
        
        // 重新激活底部按鈕
        Object.values(formButtons).forEach(button => {
          button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
          button.classList.add('bg-gray-500');
        });
        
        // 高亮當前形態按鈕
        if (formButtons[targetForm]) {
          formButtons[targetForm].classList.remove('bg-gray-500');
          formButtons[targetForm].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }
        
        // 智能恢復繼續按鈕的顯示狀態
        restoreAdvanceBtnAfterDailyTransformation();
        
        // 清除日常物化狀態
        gameState.isInDailyTransformation = false;
        gameState.dailyTransformationPreviousForm = null;
        gameState.dailyTransformationAdvanceBtnVisible = false;
        
        console.log(`日常物化退出完成，恢復到形態: ${targetForm}`);
      }, 1500);
    }
    
    // 智能恢復"繼續"按鈕的顯示狀態
    function restoreAdvanceBtnAfterDailyTransformation() {
      if (!advanceBtn) return;
      
      const currentChapter = gameChapters[gameState.currentChapter];
      if (!currentChapter) return;
      
      const currentScene = currentChapter.scenes[gameState.currentScene];
      if (!currentScene) return;
      
      // 定義哪些場景類型應該顯示"繼續"按鈕
      const sceneTypesThatShowAdvanceBtn = [
        'narrative',
        'cloud-effect', 
        'spiral-effect',
        'time-effect',
        'heaven-earth-effect'
      ];
      
      // 特殊場景類型的處理
      const sceneTypesThatMayShowAdvanceBtn = [
        'dialog' // 對話場景取決於是否有選項
      ];
      
      // 檢查當前場景是否應該顯示"繼續"按鈕
      let shouldShowAdvanceBtn = false;
      
      if (sceneTypesThatShowAdvanceBtn.includes(currentScene.type)) {
        // 這些場景類型通常顯示"繼續"按鈕
        shouldShowAdvanceBtn = true;
      } else if (currentScene.type === 'dialog') {
        // 對話場景：如果沒有選項，顯示"繼續"按鈕
        shouldShowAdvanceBtn = !currentScene.options || currentScene.options.length === 0;
      } else if (currentScene.type === 'segmentation-puzzle') {
        // 斷句挑戰：如果已完成，應該顯示"繼續"按鈕
        shouldShowAdvanceBtn = gameState.segmentationPuzzleState.solved;
      } else {
        // 其他場景類型：檢查是否原本就有"繼續"按鈕
        shouldShowAdvanceBtn = gameState.dailyTransformationAdvanceBtnVisible;
      }
      
      // 根據判斷結果顯示或隱藏按鈕
      if (shouldShowAdvanceBtn) {
        advanceBtn.style.display = 'block';
        console.log(`恢復"繼續"按鈕顯示 - 場景類型: ${currentScene.type}`);
      } else {
        advanceBtn.style.display = 'none';
        console.log(`保持"繼續"按鈕隱藏 - 場景類型: ${currentScene.type}`);
      }
    }
    
    function highlightFormButton(formName) {
      const button = formButtons[formName];
      if (!button) return;
      
      // 移除其他按鈕的高亮效果
      Object.values(formButtons).forEach(btn => {
        btn.classList.remove('form-button-highlight', 'animate-pulse');
        btn.style.animation = '';
        btn.style.boxShadow = '';
      });
      
      // 為指定按鈕添加強烈的高亮效果
      button.classList.add('form-button-highlight');
      
      // 添加呼吸動畫
      button.style.animation = 'form-button-breathe 1.5s infinite ease-in-out';
      
      // 添加發光效果
      button.style.boxShadow = '0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4)';
      
      // 添加CSS動畫樣式（如果還沒有的話）
      if (!document.getElementById('form-highlight-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'form-highlight-animations';
        styleElement.textContent = `
          .form-button-highlight {
            position: relative;
            z-index: 100;
          }
          
          @keyframes form-button-breathe {
            0%, 100% { 
              transform: scale(1); 
              box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4);
            }
            50% { 
              transform: scale(1.1); 
              box-shadow: 0 0 30px rgba(59, 130, 246, 1), 0 0 60px rgba(59, 130, 246, 0.6);
            }
          }
          
          .form-button-highlight::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #3b82f6);
            border-radius: 12px;
            z-index: -1;
            animation: form-button-glow 2s infinite linear;
          }
          
          @keyframes form-button-glow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建天地特效場景
    function createHeavenEarthEffectScene(scene) {
      const heavenEarthElement = document.createElement('div');
      heavenEarthElement.className = 'max-w-2xl mx-auto p-6 text-left fixed left-1/2 transform -translate-x-1/2 bg-gradient-to-br from-yellow-50 to-blue-100 dark:from-yellow-900 dark:to-blue-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border-2 border-yellow-400 dark:border-yellow-600';
      heavenEarthElement.style.top = '1rem'; // 上移文字框位置
      heavenEarthElement.style.zIndex = '70'; // 提高z-index確保在所有背景元素之上
      
      heavenEarthElement.innerHTML = `
        <p class="text-lg md:text-xl leading-relaxed text-yellow-800 dark:text-yellow-200">${scene.text}</p>
      `;
      
      gameContent.appendChild(heavenEarthElement);
      
      // 創建浮現的古老文字效果
      createFloatingAncientText();
      
      // 創建天地背景特效
      createHeavenEarthBackground();
      
        advanceBtn.style.display = 'block';
    }
    
    // 創建浮現的古老文字效果
    function createFloatingAncientText() {
      // 如果第六章斷句挑戰已經出現過，則不再創建浮動文字
      if (gameState.chapter6FloatingTextDisabled) {
        return;
      }
      
      // 清理之前的古老文字
      document.querySelectorAll('.floating-ancient-text').forEach(el => el.remove());
      
      const ancientTextContainer = document.createElement('div');
      ancientTextContainer.className = 'floating-ancient-text';
      ancientTextContainer.style.position = 'fixed';
      ancientTextContainer.style.top = '0';
      ancientTextContainer.style.left = '0';
      ancientTextContainer.style.width = '100%';
      ancientTextContainer.style.height = '100%';
      ancientTextContainer.style.pointerEvents = 'none';
      ancientTextContainer.style.zIndex = '8'; // 在半圓場景上方，但在文字框下方
      ancientTextContainer.style.overflow = 'hidden';
      
      // 古老文字內容 - 莊子的經典語句
      const ancientTexts = [
        '天地為棺槨', '日月為連璧', '星辰為珠璣', '萬物為齎送',
        '在上為烏鳶食', '在下為螻蟻食', '奪彼與此', '何其偏也',
        '生死一如', '物我兩忘', '逍遙自在', '無為而治',
        '道法自然', '齊物論', '莊周夢蝶', '天人合一'
      ];
      
      // 創建多個浮現的文字
      for (let i = 0; i < 12; i++) {
        const textElement = document.createElement('div');
        textElement.className = 'ancient-text-particle';
        
        // 隨機選擇文字
        const text = ancientTexts[Math.floor(Math.random() * ancientTexts.length)];
        textElement.textContent = text;
        
        // 樣式設置
        textElement.style.position = 'absolute';
        textElement.style.fontSize = `${16 + Math.random() * 12}px`; // 16-28px
        textElement.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
        textElement.style.fontWeight = '500';
        textElement.style.color = 'rgba(255, 215, 0, 0.8)'; // 金色，如星光
        textElement.style.textShadow = `
          0 0 10px rgba(255, 215, 0, 0.6),
          0 0 20px rgba(255, 215, 0, 0.4),
          0 0 30px rgba(255, 215, 0, 0.2)
        `;
        textElement.style.whiteSpace = 'nowrap';
        
        // 隨機位置
        textElement.style.left = `${Math.random() * 80 + 10}%`; // 10%-90%
        textElement.style.top = `${Math.random() * 80 + 10}%`; // 10%-90%
        
        // 動畫設置
        textElement.style.opacity = '0';
        textElement.style.transform = 'scale(0.5) translateY(20px)';
        textElement.style.animation = `ancient-text-appear ${4 + Math.random() * 3}s ease-out infinite`;
        textElement.style.animationDelay = `${Math.random() * 5}s`;
        
        ancientTextContainer.appendChild(textElement);
      }
      
      document.body.appendChild(ancientTextContainer);
      
      // 添加古老文字動畫樣式
      if (!document.getElementById('ancient-text-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'ancient-text-animations';
        styleElement.textContent = `
          @keyframes ancient-text-appear {
            0% {
              opacity: 0;
              transform: scale(0.5) translateY(20px);
            }
            20% {
              opacity: 1;
              transform: scale(1) translateY(0);
            }
            80% {
              opacity: 1;
              transform: scale(1) translateY(-10px);
            }
            100% {
              opacity: 0;
              transform: scale(0.8) translateY(-30px);
            }
          }
          
          .ancient-text-particle {
            background: linear-gradient(45deg, 
              rgba(255, 215, 0, 0.1) 0%, 
              rgba(255, 215, 0, 0.05) 50%, 
              rgba(255, 215, 0, 0.1) 100%);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(2px);
          }
        `;
        document.head.appendChild(styleElement);
      }
    }

    function createHeavenEarthBackground() {
      // 清理之前的背景容器
      document.querySelectorAll('.heaven-earth-background-container').forEach(el => el.remove());
      
              // 創建外太空星空
        createSpaceStarfield();
        
        // 創建大氣層粒子
        createAtmosphereParticles();
      
      // 等待半圓形場景類被添加
      setTimeout(() => {
        // 創建日月星辰容器 - 與天空區域完全對應
        const celestialContainer = document.createElement('div');
        celestialContainer.className = 'heaven-earth-celestial-container';
      
      // 創建日月 - 向下移動以配合半圓形的位置調整
      const sun = document.createElement('div');
      sun.style.position = 'absolute';
      sun.style.fontSize = '80px';
              sun.style.left = '20%';
        sun.style.top = '10%'; // 確保在半圓上半部分
        sun.style.animation = 'sun-glow 6s infinite ease-in-out';
        sun.style.zIndex = '20'; // 確保在半圓內顯示
        sun.textContent = '☀️';
        
        const moon = document.createElement('div');
        moon.style.position = 'absolute';
        moon.style.fontSize = '70px';
        moon.style.right = '20%';
        moon.style.top = '15%'; // 確保在半圓上半部分
        moon.style.animation = 'moon-glow 8s infinite ease-in-out';
        moon.style.zIndex = '20'; // 確保在半圓內顯示
        moon.textContent = '🌙';
      
      // 創建星辰 - 向下移動以配合半圓形的位置調整
      for (let i = 0; i < 20; i++) {
        const star = document.createElement('div');
        star.style.position = 'absolute';
        star.style.fontSize = `${8 + Math.random() * 12}px`; // 縮小星星大小：8-20px
        star.style.left = `${Math.random() * 100}%`;
                  star.style.top = `${Math.random() * 50}%`; // 限制在半圓上半部分
          star.style.animation = `star-twinkle ${2 + Math.random() * 3}s infinite ease-in-out`;
          star.style.animationDelay = `${Math.random() * 2}s`;
          star.style.zIndex = '20'; // 確保在半圓內顯示
          star.textContent = '⭐';
        celestialContainer.appendChild(star);
      }
      
              // 創建地面植物容器 - 位於地平線上，限制在半圓範圍內
        const earthContainer = document.createElement('div');
        earthContainer.className = 'earth-elements-container';
        earthContainer.style.position = 'absolute';
        earthContainer.style.bottom = '0px'; // 貼合地平線
        earthContainer.style.left = '50%';
        earthContainer.style.transform = 'translateX(-50%)';
        earthContainer.style.width = '67vw'; // 與半圓寬度相同
        earthContainer.style.height = '50px';
        earthContainer.style.zIndex = '30';
        earthContainer.style.pointerEvents = 'none';
        earthContainer.style.clipPath = 'ellipse(50% 100% at 50% 100%)'; // 限制在半圓範圍內
        

        
        // 創建草原 - 水平方向擺滿麥穗
        for (let i = 0; i < 25; i++) {
          const grass = document.createElement('div');
          grass.style.position = 'absolute';
          grass.style.fontSize = `${18 + Math.random() * 12}px`; // 18-30px隨機大小
          grass.style.left = `${(i * 4) + Math.random() * 3}%`; // 水平均勻分佈，稍加隨機
          grass.style.bottom = '0px'; // 貼合地平線
          grass.style.animation = `earth-sway ${2 + Math.random() * 3}s infinite ease-in-out`;
          grass.style.animationDelay = `${Math.random() * 2}s`;
          grass.style.filter = 'drop-shadow(0 1px 3px rgba(0,0,0,0.2))';
          grass.style.zIndex = '20'; // 在山脈之下
          grass.textContent = '🌾';
          earthContainer.appendChild(grass);
        }
      
      celestialContainer.appendChild(sun);
      celestialContainer.appendChild(moon);
      
      // 添加動畫樣式
      if (!document.getElementById('heaven-earth-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'heaven-earth-animations';
        styleElement.textContent = `
          @keyframes sun-glow {
            0%, 100% { 
              filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
              transform: scale(1);
            }
            50% { 
              filter: drop-shadow(0 0 40px rgba(255, 215, 0, 1));
              transform: scale(1.1);
            }
          }
          
          @keyframes moon-glow {
            0%, 100% { 
              filter: drop-shadow(0 0 15px rgba(192, 192, 192, 0.8));
              transform: scale(1);
            }
            50% { 
              filter: drop-shadow(0 0 30px rgba(192, 192, 192, 1));
              transform: scale(1.05);
            }
          }
          
          @keyframes star-twinkle {
            0%, 100% { 
              opacity: 0.6;
              transform: scale(1);
            }
            50% { 
              opacity: 1;
              transform: scale(1.2);
            }
          }
          
          @keyframes earth-sway {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
              // 將容器添加到半圓形場景中
        const heavenEarthScene = document.querySelector('.heaven-earth-scene');
        if (heavenEarthScene) {
          heavenEarthScene.appendChild(celestialContainer);
          // 地面容器添加到日月星辰容器中，確保在半圓範圍內
          celestialContainer.appendChild(earthContainer);
        } else {
          gameContainer.appendChild(celestialContainer);
          celestialContainer.appendChild(earthContainer);
        }
      }, 100); // 延遲100ms確保場景類已被添加
    }
    
    // 創建外太空星空粒子動畫
    function createSpaceStarfield() {
      // 清理之前的星空
      document.querySelectorAll('.space-starfield').forEach(el => el.remove());
      
      const starfield = document.createElement('div');
      starfield.className = 'space-starfield';
      
      // 創建不同顏色和大小的星星粒子
      const colors = ['yellow', 'blue', 'white'];
      const starCount = 150; // 星星數量
      
      for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        star.className = `space-star ${colors[Math.floor(Math.random() * colors.length)]}`;
        
        // 隨機大小 (1-4px)
        const size = Math.random() * 3 + 1;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        
        // 隨機位置
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        
        // 隨機閃爍延遲
        star.style.animationDelay = `${Math.random() * 3}s`;
        
        // 隨機閃爍持續時間
        star.style.animationDuration = `${2 + Math.random() * 4}s`;
        
        starfield.appendChild(star);
      }
      
      document.body.appendChild(starfield);
      
      // 創建大氣層粒子效果
      createAtmosphereParticles();
    }
    
    // 創建大氣層粒子效果
    function createAtmosphereParticles() {
      // 清理之前的大氣層粒子
      document.querySelectorAll('.atmosphere-particles').forEach(el => el.remove());
      
      const atmosphereContainer = document.createElement('div');
      atmosphereContainer.className = 'atmosphere-particles';
      atmosphereContainer.style.position = 'fixed';
      atmosphereContainer.style.top = '0';
      atmosphereContainer.style.left = '0';
      atmosphereContainer.style.width = '100%';
      atmosphereContainer.style.height = '100%';
      atmosphereContainer.style.zIndex = '4'; // 在半圓場景下面，但在外太空背景上面
      atmosphereContainer.style.pointerEvents = 'none';
      atmosphereContainer.style.overflow = 'hidden';
      
      // 創建大氣層粒子
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'atmosphere-particle';
        
        // 隨機大小和位置
        const size = Math.random() * 3 + 1;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.position = 'absolute';
        particle.style.borderRadius = '50%';
        particle.style.background = `rgba(135, 206, 235, ${0.3 + Math.random() * 0.4})`;
        particle.style.boxShadow = `0 0 ${size * 2}px rgba(135, 206, 235, 0.5)`;
        
        // 隨機位置（集中在半圓邊緣附近）
        const angle = Math.random() * Math.PI; // 0 到 π 弧度（半圓）
        const radius = 45 + Math.random() * 10; // 在半圓邊緣附近
        const centerX = 50; // 頁面中心
        const centerY = 50; // 調整到合適的垂直位置
        
        const x = centerX + radius * Math.cos(angle);
        const y = centerY - radius * Math.sin(angle) * 0.5; // 壓縮Y軸以匹配橢圓
        
        particle.style.left = `${x}%`;
        particle.style.top = `${y}%`;
        
        // 隨機動畫
        particle.style.animation = `atmosphere-particle-float ${3 + Math.random() * 4}s ease-in-out infinite`;
        particle.style.animationDelay = `${Math.random() * 3}s`;
        
        atmosphereContainer.appendChild(particle);
      }
      
      document.body.appendChild(atmosphereContainer);
    }
    
    // 創建虛空場景
    function createVoidScene() {
      // 清理之前的虛空場景元素
              document.querySelectorAll('.void-particles, .chaos-form, .taiji-container, .bagua-symbols, .bagua-floating-text').forEach(el => el.remove());
      
      // 創建虛空粒子系統
      createVoidParticles();
      
      // 創建八卦符號系統
      createBaguaSymbols();
      
      // 創建八卦中文字懸浮效果
      createBaguaFloatingText();
      
      // 創建中央虛空殿
      createVoidPalace();
      
      // 創建太極符號
      createTaijiSymbol();
    }
    
    // 創建虛空粒子系統
    function createVoidParticles() {
      const particleContainer = document.createElement('div');
      particleContainer.className = 'void-particles';
      
      // 前六章的主色調
      const chapterColors = [
        '#5D5CDE', // 序章 - 靛藍
        '#40BAD5', // 第一章 - 青
        '#2C7744', // 第二章 - 綠  
        '#8B4513', // 第三章 - 棕
        '#DAA520', // 第四章 - 琥珀
        '#DC143C'  // 第五章 - 紅
      ];
      
      // 創建50個粒子
      for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'void-particle';
        
        // 隨機大小
        const size = Math.random() * 4 + 2;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 隨機位置
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // 隨機顏色（前六章色調）
        const color = chapterColors[Math.floor(Math.random() * chapterColors.length)];
        particle.style.background = color;
        particle.style.boxShadow = `0 0 ${size * 2}px ${color}`;
        
        // 隨機動畫延遲
        particle.style.animationDelay = `${Math.random() * 15}s`;
        particle.style.animationDuration = `${10 + Math.random() * 10}s`;
        
        particleContainer.appendChild(particle);
      }
      
      gameContainer.appendChild(particleContainer);
    }
    
    // 創建中央渾沌形體
    function createVoidPalace() {
      // 直接創建渾沌形體，不需要宮殿容器
      const chaosForm = document.createElement('div');
      chaosForm.className = 'chaos-form';
      chaosForm.title = '點擊觸摸渾沌，感受往事的記憶';
      chaosForm.style.position = 'absolute';
      chaosForm.style.top = '50%';
      chaosForm.style.left = '50%';
      chaosForm.style.transform = 'translate(-50%, -50%)';
      chaosForm.style.zIndex = '10';
      
      gameContainer.appendChild(chaosForm);
    }
    
    // 創建太極符號（只有轉動的太極符號，不包含游動的陰陽魚）
    function createTaijiSymbol() {
      const taijiContainer = document.createElement('div');
      taijiContainer.className = 'taiji-container';
      // 初始時隱藏太極符號，等待太極拼圖完成後顯示
      taijiContainer.style.display = 'none';
      
      const yinYangEmoji = document.createElement('div');
      yinYangEmoji.className = 'yin-yang-emoji';
      yinYangEmoji.textContent = '☯︎';
      
      taijiContainer.appendChild(yinYangEmoji);
      gameContainer.appendChild(taijiContainer);
    }
    
    // 顯示太極符號（太極拼圖完成後調用）
    function showTaijiSymbol() {
      const taijiContainer = document.querySelector('.taiji-container');
      if (taijiContainer) {
        // 創建顯現動畫效果
        taijiContainer.style.display = 'block';
        taijiContainer.style.opacity = '0';
        taijiContainer.style.transform = 'translateX(-50%) scale(0.3)';
        taijiContainer.style.transition = 'all 2s ease-out';
        
        // 延遲一下再開始動畫，讓玩家注意到
        setTimeout(() => {
          taijiContainer.style.opacity = '1';
          taijiContainer.style.transform = 'translateX(-50%) scale(1)';
        }, 100);
        
        // 動畫完成後移除transition，恢復正常的旋轉動畫
        setTimeout(() => {
          taijiContainer.style.transition = '';
        }, 2100);
      }
    }
    
    // 創建八卦符號系統
    function createBaguaSymbols() {
      const baguaContainer = document.createElement('div');
      baguaContainer.className = 'bagua-symbols';
      
      // 八卦符號數據
      const baguaData = [
        { symbol: '☰', name: 'qian', title: '乾-天', element: '天' },
        { symbol: '☱', name: 'dui', title: '兌-澤', element: '澤' },
        { symbol: '☲', name: 'li', title: '離-火', element: '火' },
        { symbol: '☳', name: 'zhen', title: '震-雷', element: '雷' },
        { symbol: '☴', name: 'xun', title: '巽-風', element: '風' },
        { symbol: '☵', name: 'kan', title: '坎-水', element: '水' },
        { symbol: '☶', name: 'gen', title: '艮-山', element: '山' },
        { symbol: '☷', name: 'kun', title: '坤-地', element: '地' }
      ];
      
      // 檢查是否處於萬物尋氣模式
      const isWanwuXunqiMode = gameState.wanwuXunqiActive;
      
      // 創建定期生成八卦符號的函數
      function createBaguaSymbol() {
        let selectedBagua;
        if (isWanwuXunqiMode && gameState.currentBaguaCollection) {
          const neededBagua = gameState.currentBaguaCollection.neededBagua;
          const collected = gameState.currentBaguaCollection.collected || [];
          const stillNeed = neededBagua.filter(element => !collected.includes(element));
          if (stillNeed.length > 0 && Math.random() < 0.7) {
            const neededElement = stillNeed[Math.floor(Math.random() * stillNeed.length)];
            selectedBagua = baguaData.find(bagua => bagua.element === neededElement);
          } else {
            selectedBagua = baguaData[Math.floor(Math.random() * baguaData.length)];
          }
        } else {
          selectedBagua = baguaData[Math.floor(Math.random() * baguaData.length)];
        }
        const symbol = document.createElement('div');
        symbol.className = `bagua-symbol bagua-${selectedBagua.name}`;
        symbol.textContent = selectedBagua.symbol;
        symbol.title = selectedBagua.title;
        
        // 存儲八卦數據到元素上
        symbol.baguaData = selectedBagua;
        
        // 隨機水平位置
        symbol.style.left = `${Math.random() * 100}%`;
        symbol.style.top = `${Math.random() * 100}%`;
        
        // 隨機動畫延遲和持續時間
        const duration = 20 + Math.random() * 10; // 20-30秒
        const delay = Math.random() * 5; // 0-5秒延遲
        symbol.style.animationDuration = `${duration}s`;
        symbol.style.animationDelay = `${delay}s`;
        
        // 如果是萬物尋氣模式，讓符號可點擊
        if (isWanwuXunqiMode) {
          symbol.style.pointerEvents = 'auto';
          symbol.style.cursor = 'pointer';
          symbol.style.zIndex = '15'; // 確保在其他元素之上
          
          // 添加點擊事件
          symbol.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('八卦符號被點擊:', this.baguaData);
            
            // 顯示元素字彈出效果
            showElementPopup(this, this.baguaData.element);
            
            // 處理點擊邏輯
            handleBaguaSymbolClick(this);
          });
          
          // 添加懸停效果
          symbol.addEventListener('mouseenter', function() {
            this.style.transform += ' scale(1.3)';
            this.style.filter += ' brightness(1.5)';
          });
          
          symbol.addEventListener('mouseleave', function() {
            this.style.transform = this.style.transform.replace(' scale(1.3)', '');
            this.style.filter = this.style.filter.replace(' brightness(1.5)', '');
          });
        }
        
        baguaContainer.appendChild(symbol);
        
        // 動畫結束後移除元素
        setTimeout(() => {
          if (symbol.parentNode) {
            symbol.remove();
          }
        }, (duration + delay) * 1000);
      }
      
      // 初始創建一些八卦符號
      for (let i = 0; i < 3; i++) {
        setTimeout(() => createBaguaSymbol(), i * 2000);
      }
      
      // 定期創建新的八卦符號
      const baguaInterval = setInterval(() => {
        // 檢查容器是否還存在
        if (document.contains(baguaContainer)) {
          // 限制同時存在的符號數量
          const existingSymbols = baguaContainer.querySelectorAll('.bagua-symbol');
          if (existingSymbols.length < 6) {
            createBaguaSymbol();
          }
        } else {
          // 如果容器被移除，清除定時器
          clearInterval(baguaInterval);
        }
      }, 2000); // 每2秒嘗試創建一個新符號
      
      // 將定時器ID存儲到容器上，以便清理
      baguaContainer.baguaInterval = baguaInterval;
      
      gameContainer.appendChild(baguaContainer);
    }
    
    // 處理八卦符號點擊事件
    function handleBaguaSymbolClick(symbolElement) {
      console.log('handleBaguaSymbolClick 被調用，wanwuXunqiActive:', gameState.wanwuXunqiActive);
      if (!gameState.wanwuXunqiActive) {
        console.log('萬物尋氣模式未啟動');
        return;
      }
      
      const baguaData = symbolElement.baguaData;
      const currentForm = gameState.currentForm;
      
      // 檢查當前物化形態是否需要這個八卦符號
      const currentCollection = gameState.currentBaguaCollection;
      if (!currentCollection || !currentCollection.neededBagua) {
        showMessage('請先進入物化視野開始收集！');
        return;
      }
      
      // 檢查是否是需要的八卦符號
      const neededBagua = currentCollection.neededBagua;
      const alreadyCollected = currentCollection.collected || [];
      
      if (neededBagua.includes(baguaData.element)) {
        // 檢查是否已經收集過這種氣
        if (alreadyCollected.includes(baguaData.element)) {
          showMessage(`${baguaData.element} 之氣已經收集過了！`);
          return;
        }
        // 收集成功
        collectBaguaSymbol(baguaData, symbolElement);
      } else {
        // 收集錯誤
        showBaguaCollectionError(baguaData, neededBagua);
      }
    }
    
    // 收集八卦符號
    function collectBaguaSymbol(baguaData, symbolElement) {
      // 創建收集動畫
      createBaguaCollectionAnimation(symbolElement, baguaData);
      
      // 更新收集狀態
      if (!gameState.currentBaguaCollection.collected) {
        gameState.currentBaguaCollection.collected = [];
      }
      gameState.currentBaguaCollection.collected.push(baguaData.element);
      gameState.baguaCollectionCount++;
      
      // 移除符號元素
      symbolElement.remove();
      
      // 更新詩意謎題窗口中的進度顯示
      updateRiddleCollectionProgress();
      
      // 檢查是否收集完成
      const collected = gameState.currentBaguaCollection.collected;
      const needed = gameState.currentBaguaCollection.neededBagua;
      
      if (collected.length >= 3) {
        // 完成當前物化形態的收集
        setTimeout(() => {
          completeBaguaCollection();
        }, 1000);
      } else {
        // 顯示進度
        showBaguaCollectionProgress(collected, needed);
      }
    }
    
    // 創建八卦收集動畫
    function createBaguaCollectionAnimation(symbolElement, baguaData) {
      // 創建收集效果
      const collectEffect = document.createElement('div');
      collectEffect.className = 'bagua-collect-effect';
      collectEffect.style.position = 'fixed';
      collectEffect.style.left = symbolElement.getBoundingClientRect().left + 'px';
      collectEffect.style.top = symbolElement.getBoundingClientRect().top + 'px';
      collectEffect.style.fontSize = '48px';
      collectEffect.style.color = symbolElement.style.color || '#FFD700';
      collectEffect.style.textShadow = symbolElement.style.textShadow;
      collectEffect.style.zIndex = '9999';
      collectEffect.style.pointerEvents = 'none';
      collectEffect.textContent = baguaData.symbol;
      
      document.body.appendChild(collectEffect);
      
      // 動畫效果
      collectEffect.style.animation = 'bagua-collect 1.5s ease-out forwards';
      
      // 添加收集動畫樣式
      if (!document.getElementById('bagua-collect-animation')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'bagua-collect-animation';
        styleEl.textContent = `
          @keyframes bagua-collect {
            0% {
              transform: scale(1) rotate(0deg);
              opacity: 1;
            }
            50% {
              transform: scale(1.5) rotate(180deg);
              opacity: 0.8;
            }
            100% {
              transform: scale(0.3) rotate(360deg) translateY(-100px);
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(styleEl);
      }
      
      // 清理動畫元素
      setTimeout(() => {
        collectEffect.remove();
      }, 1500);
      
      // 顯示收集提示
      showMessage(`收集到 ${baguaData.element} 之氣！`);
    }
    
    // 顯示八卦收集錯誤
    function showBaguaCollectionError(baguaData, neededBagua) {
      showMessage(`這不是當前需要的氣。需要：${neededBagua.join('、')}`);
    }
    
    // 顯示八卦收集進度
    function showBaguaCollectionProgress(collected, needed) {
      const remaining = 3 - collected.length;
      showMessage(`已收集 ${collected.length}/3 個氣，還需 ${remaining} 個`);
    }
    
    // 完成八卦收集
    function completeBaguaCollection() {
      const formName = getFormName(gameState.currentBaguaCollection.formType);
      showMessage(`恭喜！已收集完成${formName}的三氣！`);
      
      // 清理可能存在的收集狀態界面
      const statusUI = document.getElementById('collection-status-ui');
      if (statusUI) statusUI.remove();
      
      // 移除詩意謎題窗口
      if (gameState.baguaCollectionGuideOverlay) {
        gameState.baguaCollectionGuideOverlay.remove();
        gameState.baguaCollectionGuideOverlay = null;
      }
      
      // 更新萬物尋氣進度
      if (!gameState.wanwuXunqiProgress) {
        gameState.wanwuXunqiProgress = [];
      }
      gameState.wanwuXunqiProgress.push(gameState.currentBaguaCollection.formType);
      
      // 重置當前收集狀態
      gameState.currentBaguaCollection = null;
      
      // 更新萬物尋氣引導界面進度
      if (gameState.updateWanwuXunqiProgress) {
        gameState.updateWanwuXunqiProgress();
      }
      
      // 檢查是否完成所有收集
      if (gameState.wanwuXunqiProgress.length >= 12) {
        // 完成萬物尋氣，解鎖氣形態
        completeWanwuXunqi();
      } else {
        // 繼續下一個物化形態
        setTimeout(() => {
          // 回到人形
          if (gameState.currentForm !== 'human') {
            gameState.currentForm = 'human';
            updateFormView('human');
            
            // 更新按鈕狀態
            Object.values(formButtons).forEach(button => {
              if (button) {
                button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                button.classList.add('bg-gray-500');
              }
            });
            
            if (formButtons['human']) {
              formButtons['human'].classList.remove('bg-gray-500');
              formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
          }
          
          // 重新顯示物化按鈕，讓用戶可以繼續點擊下一個形態
          const formSelector = document.querySelector('.form-selector');
          if (formSelector) {
            formSelector.style.display = 'flex';
            console.log('回到指引階段：已重新顯示物化按鈕');
          }
          
          // 重新顯示萬物尋氣引導窗口
          if (gameState.wanwuXunqiGuideContainer) {
            gameState.wanwuXunqiGuideContainer.style.display = 'block';
          }
          
          showMessage('請繼續點擊下一個物化形態進行尋氣！');
        }, 2000);
      }
    }
    
    // 完成萬物尋氣
    function completeWanwuXunqi() {
      gameState.wanwuXunqiActive = false;
      
      // 重新顯示物化按鈕
      const formSelector = document.querySelector('.form-selector');
      if (formSelector) {
        formSelector.style.display = 'flex';
        console.log('萬物尋氣完成：已重新顯示物化按鈕');
      }
      
      // 移除直接解鎖氣形態的邏輯，讓標準流程處理
      // unlockForm('qi'); // ❌ 刪除此行
      
      showMessage('萬物尋氣完成！萬物之氣已聚，準備解鎖終極物化形態...');
      
      setTimeout(() => {
        advanceBtn.style.display = 'block';
        advanceBtn.textContent = '獲得氣之力量';
      }, 3000);
    }
    
    // 開始八卦收集
    function startBaguaCollection(formType) {
      console.log('startBaguaCollection 被調用，formType:', formType);
      
      // 12個物化形態的八卦收集配置
      const baguaCollectionConfig = {
        butterfly: {
          riddle: '隨氣流起舞花間，追光如炽不倦，翩跹直上雲端。',
          neededBagua: ['風', '火', '天'],
          hint: '蝴蝶象徵變化與自由，需要風的輕盈、火的光明、天的高遠'
        },
        fish: {
          riddle: '游於清波，棲於深潭，依土而安。',
          neededBagua: ['水', '澤', '地'],
          hint: '魚兒生活在水中，需要水的滋養、澤的降臨、地的承載'
        },
        kun: {
          riddle: '潛於滄海，伏於海底，重如峰巒。',
          neededBagua: ['水', '地', '山'],
          hint: '鯤在深海中，需要水的深邃、地的厚重、山的穩固'
        },
        peng: {
          riddle: '翱翔九霄，乘氣流萬里，振翅如轟鳴。',
          neededBagua: ['天', '風', '雷'],
          hint: '鵬鳥飛翔天際，需要天的廣闊、風的助力、雷的威勢'
        },
        yuanchu: {
          riddle: '聖潔如霄，光明似炬，高潔如峰。',
          neededBagua: ['天', '火', '山'],
          hint: '鵷鶵聖潔高貴，需要天的純淨、火的光明、山的正直'
        },
        chixiao: {
          riddle: '夜獵濕處，月下臨流，棲於平野。',
          neededBagua: ['澤', '水', '地'],
          hint: '鴟鴞夜間活動，需要澤的滋潤、水的靈動、地的穩定'
        },
        snail: {
          riddle: '行於厚土，堅如磐石，晨露相伴。',
          neededBagua: ['地', '山', '水'],
          hint: '蝸牛緩慢而堅韌，需要地的承載、山的堅固、水的滋潤'
        },
        'morning-fungus': {
          riddle: '雨後方生，隨氣流搖曳，聞轟響而發。',
          neededBagua: ['澤', '風', '雷'],
          hint: '朝菌生命短暫，需要澤的滋養、風的輕柔、雷的生機'
        },
        cicada: {
          riddle: '應轟鳴而出，借氣流傳聲，聲如烈焰。',
          neededBagua: ['雷', '風', '火'],
          hint: '蟪蛄善鳴，需要雷的震動、風的傳播、火的熱情'
        },
        'great-chun': {
          riddle: '參穹蒼而立，根深厚土，穩若高嶺。',
          neededBagua: ['天', '地', '山'],
          hint: '大椿長壽，需要天的永恆、地的穩固、山的長久'
        },
        ant: {
          riddle: '勤於土下，聚如小丘，共享甘露。',
          neededBagua: ['地', '山', '澤'],
          hint: '螻蟻勤勞團結，需要地的根基、山的堅實、澤的甘露'
        },
        star: {
          riddle: '懸於穹蒼，光如明燭，隨氣流飄搖。',
          neededBagua: ['天', '火', '風'],
          hint: '星辰高遠明亮，需要天的廣闊、火的光芒、風的清新'
        }
      };
      
      const config = baguaCollectionConfig[formType];
      if (!config) {
        console.error('未找到物化形態的八卦配置:', formType);
        return;
      }
      
      // 設置當前收集狀態
      gameState.currentBaguaCollection = {
        formType: formType,
        neededBagua: config.neededBagua,
        collected: [],
        riddle: config.riddle,
        hint: config.hint
      };
      
      // 初始化收集計數器
      if (!gameState.baguaCollectionCount) {
        gameState.baguaCollectionCount = 0;
      }
      
      // 顯示收集引導界面
      showBaguaCollectionGuide(config, formType);
    }
    
    // 顯示八卦收集引導界面
    function showBaguaCollectionGuide(config, formType) {
      // 隱藏物化按鈕，避免在具體尋氣收集階段切換形態造成邏輯混亂
      const formSelector = document.querySelector('.form-selector');
      if (formSelector) {
        formSelector.style.display = 'none';
        console.log('進入尋氣收集階段：已隱藏物化按鈕');
      }
      
      // 創建收集引導窗口（不是覆蓋層，而是頂部固定窗口）
      const guideOverlay = document.createElement('div');
      guideOverlay.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 max-w-lg w-full mx-4';
      guideOverlay.style.zIndex = '80'; // 確保在萬物尋氣引導窗口之上
      guideOverlay.style.pointerEvents = 'none'; // 允許點擊穿透到下方的八卦符號
      guideOverlay.id = 'bagua-collection-guide';
      
      const guideContainer = document.createElement('div');
      guideContainer.className = 'w-full p-4 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-xl border border-indigo-200 dark:border-indigo-700';
      guideContainer.style.pointerEvents = 'auto'; // 只有容器本身可以接收點擊
      
      const formNames = {
        butterfly: '蝴蝶',
        fish: '儵魚', 
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      
      // 八卦元素颜色配置
      const baguaColors = {
        '天': '#FFD700',
        '澤': '#C0C0C0', 
        '火': '#FF6347',
        '雷': '#32CD32',
        '風': '#87CEEB',
        '水': '#4169E1',
        '山': '#8B4513',
        '地': '#DAA520'
      };
      
      // 八卦符号配置
      const baguaSymbols = {
        '天': '☰',
        '澤': '☱',
        '火': '☲', 
        '雷': '☳',
        '風': '☴',
        '水': '☵',
        '山': '☶',
        '地': '☷'
      };

      guideContainer.innerHTML = `
        <div class="text-center mb-4">
          <h3 class="text-xl font-bold text-indigo-600 dark:text-indigo-400 mb-3">${formNames[formType]} 尋氣</h3>
          <p class="text-base text-gray-600 dark:text-gray-400 mb-2">解讀謎語，點擊飄浮的八卦符號收集所需之氣</p>
        </div>
        
        <div class="riddle-section mb-4 p-4 bg-indigo-50 dark:bg-indigo-900 rounded-lg">
          <p class="text-gray-700 dark:text-gray-300 leading-relaxed text-center text-base">${config.riddle}</p>
        </div>
        
        <div class="bagua-hints mb-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
          <div class="flex justify-center gap-6 text-sm">
            ${Object.keys(baguaColors).map(element => `
              <span style="color: ${baguaColors[element]}; text-shadow: 0 0 5px ${baguaColors[element]}; font-weight: 600;">
                ${baguaSymbols[element]} ${element}
              </span>
            `).join('')}
          </div>
        </div>
        
        <div class="collection-status p-4 bg-blue-50 dark:bg-blue-900 rounded-lg" id="riddle-collection-status">
          <div class="progress-display flex justify-center gap-3 mb-3">
            ${config.neededBagua.map((element, index) => `
              <div class="answer-circle w-10 h-10 rounded-full flex items-center justify-center text-sm font-bold bg-gray-200 dark:bg-gray-600 relative" 
                   data-element="${element}" data-index="${index}">
                <div class="front-side absolute inset-0 rounded-full bg-gray-200 dark:bg-gray-600 transition-transform duration-500"></div>
                <div class="back-side absolute inset-0 rounded-full flex items-center justify-center text-sm font-bold transition-transform duration-500 transform rotateY-180" 
                     style="color: ${baguaColors[element]}; background: linear-gradient(135deg, ${baguaColors[element]}20, ${baguaColors[element]}40); backface-visibility: hidden;">
                  ${element}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="progress-text text-sm text-blue-600 dark:text-blue-400 text-center">
            已收集：0 / 3
          </div>
        </div>
      `;
      
      guideOverlay.appendChild(guideContainer);
      document.body.appendChild(guideOverlay);
      
      // 移除了提示按鈕，不需要事件處理
      
      // 保存詩意謎題窗口引用到gameState，以便後續控制
      gameState.baguaCollectionGuideOverlay = guideOverlay;
      
      // 直接進入物化視野並開始收集（不需要點擊開始收集按鈕）
      enterFormVision(formType);
    }
    
    // 進入物化視野
    function enterFormVision(formType) {
      // 執行物化轉換
      if (gameState.currentForm !== formType) {
        gameState.currentForm = formType;
        updateFormView(formType);
        
        // 更新按鈕狀態
        Object.values(formButtons).forEach(button => {
          if (button) {
            button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            button.classList.add('bg-gray-500');
          }
        });
        
        if (formButtons[formType]) {
          formButtons[formType].classList.remove('bg-gray-500');
          formButtons[formType].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }
      }
      
      // 不再顯示右上角的收集狀態界面，因為詩意謎題窗口中已經有了
      // showCollectionStatusUI();
      
      // 重新創建八卦符號（現在它們將是可點擊的）
      document.querySelectorAll('.bagua-symbols').forEach(el => el.remove());
      createBaguaSymbols();
      
      showMessage(`已進入${getFormName(formType)}視野，開始尋找所需的氣！點擊飄浮的八卦符號進行收集。`);
    }
    
    // 顯示收集狀態界面
    function showCollectionStatusUI() {
      // 移除舊的狀態界面
      const oldStatus = document.getElementById('collection-status-ui');
      if (oldStatus) oldStatus.remove();
      
      const currentCollection = gameState.currentBaguaCollection;
      if (!currentCollection) return;
      
      // 確保collected數組存在
      if (!currentCollection.collected) {
        currentCollection.collected = [];
      }
      
      const statusUI = document.createElement('div');
      statusUI.id = 'collection-status-ui';
      statusUI.className = 'fixed top-4 right-4 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 p-4 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700 z-40';
      
      statusUI.innerHTML = `
        <h4 class="font-semibold text-indigo-600 dark:text-indigo-400 mb-2">收集進度</h4>
        <div class="needed-items mb-2">
          <div class="text-sm text-gray-600 dark:text-gray-400 mb-1">需要的氣：</div>
          <div class="flex gap-2">
            ${currentCollection.neededBagua.map(element => {
              const isCollected = currentCollection.collected.includes(element);
              return `
                <div class="w-8 h-8 rounded-full flex items-center justify-center text-xs font-bold ${
                  isCollected 
                    ? 'bg-green-500 text-white' 
                    : 'bg-gray-200 dark:bg-gray-600 text-gray-600 dark:text-gray-400'
                }">
                  ${element}
                </div>
              `;
            }).join('')}
          </div>
        </div>
        <div class="progress-text text-sm text-gray-600 dark:text-gray-400">
          已收集：${currentCollection.collected.length} / 3
        </div>
      `;
      
      document.body.appendChild(statusUI);
    }
    
    // 顯示元素字彈出效果
    function showElementPopup(symbolElement, elementText) {
      const rect = symbolElement.getBoundingClientRect();
      
      const popup = document.createElement('div');
      popup.className = 'element-popup';
      popup.textContent = elementText;
      
      // 設置樣式
      popup.style.position = 'fixed';
      popup.style.left = (rect.left + rect.width / 2) + 'px';
      popup.style.top = (rect.top - 10) + 'px';
      popup.style.transform = 'translateX(-50%) translateY(-100%)';
      popup.style.fontSize = '24px';
      popup.style.fontWeight = 'bold';
      popup.style.color = '#FFD700';
      popup.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 215, 0, 0.4)';
      popup.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
      popup.style.zIndex = '9999';
      popup.style.pointerEvents = 'none';
      popup.style.opacity = '0';
      popup.style.transition = 'all 0.3s ease-out';
      
      document.body.appendChild(popup);
      
      // 觸發動畫
      requestAnimationFrame(() => {
        popup.style.opacity = '1';
        popup.style.transform = 'translateX(-50%) translateY(-120%)';
      });
      
      // 1.5秒後開始消失動畫
      setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(-140%)';
        
        // 動畫結束後移除元素
        setTimeout(() => {
          popup.remove();
        }, 300);
      }, 1500);
    }
    
    // 更新詩意謎題窗口中的收集進度
    function updateRiddleCollectionProgress() {
      const riddleStatus = document.getElementById('riddle-collection-status');
      if (!riddleStatus || !gameState.currentBaguaCollection) return;
      
      const collected = gameState.currentBaguaCollection.collected || [];
      const needed = gameState.currentBaguaCollection.neededBagua;
      
      // 檢查新收集的元素
      const progressCircles = riddleStatus.querySelectorAll('.answer-circle');
      progressCircles.forEach(circle => {
        const element = circle.getAttribute('data-element');
        const wasFlipped = circle.classList.contains('flipped');
        const shouldBeFlipped = collected.includes(element);
        
        if (shouldBeFlipped && !wasFlipped) {
          // 觸發翻轉動畫
          setTimeout(() => {
            circle.classList.add('flipped');
          }, 300); // 延遲一點時間讓收集動畫完成
        }
      });
      
      // 更新進度文字
      const progressText = riddleStatus.querySelector('.progress-text');
      if (progressText) {
        progressText.textContent = `已收集：${collected.length} / 3`;
      }
    }
    
    // 獲取物化形態中文名稱
    function getFormName(formType) {
      const names = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤', 
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      return names[formType] || formType;
    }
    
    // 創建八卦中文字懸浮效果
    function createBaguaFloatingText() {
      // 清理之前的八卦文字
      document.querySelectorAll('.bagua-floating-text').forEach(el => el.remove());
      
      const baguaTextContainer = document.createElement('div');
      baguaTextContainer.className = 'bagua-floating-text';
      baguaTextContainer.style.position = 'fixed';
      baguaTextContainer.style.top = '0';
      baguaTextContainer.style.left = '0';
      baguaTextContainer.style.width = '100%';
      baguaTextContainer.style.height = '100%';
      baguaTextContainer.style.pointerEvents = 'none';
      baguaTextContainer.style.zIndex = '12'; // 在虛空粒子之上，八卦符號之下
      baguaTextContainer.style.overflow = 'hidden';
      
      // 八卦文字內容
      const baguaTexts = [
        { text: '乾', color: '#FFD700', element: '天' },
        { text: '兌', color: '#C0C0C0', element: '澤' },
        { text: '離', color: '#FF6347', element: '火' },
        { text: '震', color: '#32CD32', element: '雷' },
        { text: '巽', color: '#87CEEB', element: '風' },
        { text: '坎', color: '#4169E1', element: '水' },
        { text: '艮', color: '#8B4513', element: '山' },
        { text: '坤', color: '#DAA520', element: '地' }
      ];
      
      // 創建多個浮現的八卦文字
      for (let i = 0; i < 12; i++) {
        const textElement = document.createElement('div');
        textElement.className = 'bagua-text-particle';
        
        // 隨機選擇八卦文字
        const baguaText = baguaTexts[Math.floor(Math.random() * baguaTexts.length)];
        
        // 隨機決定顯示卦名還是自然象徵
        const displayText = Math.random() > 0.5 ? baguaText.text : baguaText.element;
        textElement.textContent = displayText;
        
        // 樣式設置
        textElement.style.position = 'absolute';
        textElement.style.fontSize = `${20 + Math.random() * 16}px`; // 20-36px
        textElement.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
        textElement.style.fontWeight = '600';
        textElement.style.color = baguaText.color;
        textElement.style.textShadow = `
          0 0 15px ${baguaText.color},
          0 0 30px ${baguaText.color}80,
          0 0 45px ${baguaText.color}40
        `;
        textElement.style.whiteSpace = 'nowrap';
        
        // 隨機位置
        textElement.style.left = `${Math.random() * 85 + 7.5}%`; // 7.5%-92.5%
        textElement.style.top = `${Math.random() * 85 + 7.5}%`; // 7.5%-92.5%
        
        // 動畫設置
        textElement.style.opacity = '0';
        textElement.style.transform = 'scale(0.3) translateY(30px)';
        textElement.style.animation = `bagua-text-float ${5 + Math.random() * 4}s ease-in-out infinite`;
        textElement.style.animationDelay = `${Math.random() * 6}s`;
        
        baguaTextContainer.appendChild(textElement);
      }
      
      document.body.appendChild(baguaTextContainer);
      
      // 添加八卦文字動畫樣式
      if (!document.getElementById('bagua-text-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'bagua-text-animations';
        styleElement.textContent = `
          @keyframes bagua-text-float {
            0% {
              opacity: 0;
              transform: scale(0.3) translateY(30px) rotate(-5deg);
            }
            25% {
              opacity: 0.9;
              transform: scale(1.1) translateY(-5px) rotate(2deg);
            }
            50% {
              opacity: 1;
              transform: scale(1) translateY(-15px) rotate(0deg);
            }
            75% {
              opacity: 0.9;
              transform: scale(1.05) translateY(-10px) rotate(-2deg);
            }
            100% {
              opacity: 0;
              transform: scale(0.5) translateY(-40px) rotate(5deg);
            }
          }
          
          .bagua-text-particle {
            /* 移除背景框，只保留純文字效果 */
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    

    

    
    // 第七章新場景函數實現
    
    // 創建太極轉動挑戰
    function createTaijiPuzzle(scene) {
      const rotationContainer = document.createElement('div');
      rotationContainer.className = 'max-w-3xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      rotationContainer.style.top = '2rem';
      rotationContainer.style.zIndex = '9999';
      
      rotationContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4 text-gray-900 dark:text-gray-100">${scene.text}</h3>
        <div class="taiji-rotation-area mb-4" style="position: relative; width: 300px; height: 300px; margin: 0 auto; border: 2px dashed #ccc; border-radius: 50%; background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(99,102,241,0.05));">
          <div class="rotation-taiji" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 200px; cursor: grab; user-select: none; transition: transform 0.1s ease;">☯︎</div>
        </div>
                 <p class="text-sm text-gray-800 dark:text-gray-200 mb-4">點住太極符號，順時針轉動三圈，讓陰陽魚開始遊動</p>
         <div class="rotation-status text-lg font-semibold text-blue-600 dark:text-blue-400">準備順時針轉動太極...</div>
        <div class="rotation-progress mt-3">
          <div class="text-sm text-gray-500 dark:text-gray-400">轉動進度：<span id="rotation-progress">0</span> / 3 圈</div>
          <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 mt-2">
            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" id="progress-bar" style="width: 0%;"></div>
          </div>
        </div>
      `;
      
      document.body.appendChild(rotationContainer);
      
      // 轉動邏輯
      const taijiElement = rotationContainer.querySelector('.rotation-taiji');
      const statusElement = rotationContainer.querySelector('.rotation-status');
      const progressElement = rotationContainer.querySelector('#rotation-progress');
      const progressBar = rotationContainer.querySelector('#progress-bar');
      const rotationArea = rotationContainer.querySelector('.taiji-rotation-area');
      
      let isRotating = false;
      let startAngle = 0;
      let currentRotation = 0;
      let totalRotation = 0;
      let completedCircles = 0;
      let lastAngle = 0;
      
      // 獲取鼠標相對於太極中心的角度
      function getAngle(e, element) {
        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const deltaX = e.clientX - centerX;
        const deltaY = e.clientY - centerY;
        return Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      }
      
      // 鼠標按下事件
      taijiElement.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isRotating = true;
        startAngle = getAngle(e, taijiElement);
        lastAngle = startAngle;
        taijiElement.style.cursor = 'grabbing';
                 statusElement.textContent = '開始轉動...跟隨鼠標順時針轉動太極！';
        
        // 添加轉動區域發光效果
        rotationArea.style.boxShadow = '0 0 30px rgba(99, 102, 241, 0.3)';
      });
      
             // 鼠標移動事件
       document.addEventListener('mousemove', (e) => {
         if (!isRotating) return;
         
         const currentAngle = getAngle(e, taijiElement);
         let angleDiff = currentAngle - lastAngle;
         
         // 處理角度跨越-180到180的情況
         if (angleDiff > 180) angleDiff -= 360;
         if (angleDiff < -180) angleDiff += 360;
         
         // 只計算順時針旋轉（正值）
         if (angleDiff > 0) {
           totalRotation += angleDiff;
           currentRotation += angleDiff;
         } else {
           // 逆時針旋轉時給予提示
           if (Math.abs(angleDiff) > 5) { // 避免微小抖動觸發提示
             statusElement.textContent = '請順時針旋轉太極，就像背景中的太極符號一樣！';
             rotationArea.style.borderColor = '#ef4444'; // 紅色邊框提示
             setTimeout(() => {
               rotationArea.style.borderColor = '#ccc';
               if (completedCircles < 3) {
                 statusElement.textContent = completedCircles === 0 ? 
                   '開始轉動...跟隨鼠標順時針轉動太極！' : 
                   `很好！繼續順時針轉動...（${completedCircles}/3 圈）`;
               }
             }, 1000);
           }
         }
         
         lastAngle = currentAngle;
         
         // 更新太極符號的旋轉（總是跟隨鼠標，但只有順時針計數）
         taijiElement.style.transform = `translate(-50%, -50%) rotate(${totalRotation}deg)`;
         
         // 檢查是否完成一圈（360度順時針）
         if (currentRotation >= 360) {
           completedCircles++;
           currentRotation = currentRotation % 360;
           
           // 更新進度
           progressElement.textContent = Math.min(completedCircles, 3);
           progressBar.style.width = `${(completedCircles / 3) * 100}%`;
           
           if (completedCircles >= 3) {
             // 完成三圈順時針轉動
             completeRotation();
           } else {
             statusElement.textContent = `很好！繼續順時針轉動...（${completedCircles}/3 圈）`;
           }
         }
       });
      
      // 鼠標抬起事件
      document.addEventListener('mouseup', () => {
        if (isRotating) {
          isRotating = false;
          taijiElement.style.cursor = 'grab';
          rotationArea.style.boxShadow = 'none';
          
                     if (completedCircles < 3) {
             statusElement.textContent = `已順時針轉動 ${completedCircles} 圈，繼續順時針轉動完成挑戰！`;
           }
        }
      });
      
      // 完成轉動挑戰
      function completeRotation() {
        isRotating = false;
        taijiElement.style.cursor = 'default';
        rotationArea.style.boxShadow = 'none';
        statusElement.textContent = '完美！陰陽魚開始遊動，太極循環重新啟動！';
        
        // 添加完成效果
        taijiElement.style.filter = 'drop-shadow(0 0 20px rgba(99, 102, 241, 0.8))';
        rotationArea.style.background = 'radial-gradient(circle, rgba(99,102,241,0.2), rgba(99,102,241,0.05))';
        
        // 太極轉動完成後，顯示虛空場景中的太極符號
        setTimeout(() => {
          showTaijiSymbol();
        }, 1000);
        
        setTimeout(() => {
          rotationContainer.remove();
          advanceBtn.style.display = 'block';
        }, 1500);
      }
      
      // 防止拖拽和選擇
      taijiElement.addEventListener('dragstart', (e) => e.preventDefault());
      taijiElement.addEventListener('selectstart', (e) => e.preventDefault());
    }
    
    // 創建八卦理論解釋場景（莊子的哲學花園）- 優化版
    function createBaguaTheoryExplanationScene(scene) {
      const gardenContainer = document.createElement('div');
      gardenContainer.className = 'mx-auto p-4 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      gardenContainer.style.top = '2rem';
      gardenContainer.style.zIndex = '70';
      gardenContainer.style.width = '600px'; // 固定寬度（原900px的三分之二）
      gardenContainer.style.height = 'auto'; // 自適應高度
      gardenContainer.style.overflow = 'visible';
      gardenContainer.style.minWidth = '600px'; // 最小寬度
      gardenContainer.style.maxWidth = '600px'; // 最大寬度
      gardenContainer.style.minHeight = 'auto'; // 最小高度自適應
      gardenContainer.style.maxHeight = 'none'; // 無最大高度限制
      
      const storyStages = [
        {
          dialogue: '來，隨我進入這座神秘的花園。這裡有一顆種子，蘊含著宇宙生成的奧秘...',
          visual: '<div class="text-9xl">⚫</div>',
          title: '混沌種子',
          description: '看這黑暗的種子，它是無極，無形無象，就像渾沌未死之前的完美狀態。',
          button: '種下種子'
        },
        {
          dialogue: '水滴落下...種子裂開了！陰陽二氣從中湧出，這便是太極的誕生！',
          visual: '<div class="text-9xl">☯</div>',
          title: '太極初現',
          description: '一分為二，陰陽開始分離，就像黑夜白晝、寒暑冷熱。',
          button: '滴下甘露'
        },
        {
          dialogue: '陰陽各自分化...看，兩儀出現了！這些線條叫做"爻"，實線是陽爻，虛線是陰爻。',
          visual: '<div class="flex justify-center gap-8"><div class="text-red-600 text-center"><div class="text-6xl mb-2">⚊</div><div class="text-base">陽爻</div></div><div class="text-blue-600 text-center"><div class="text-6xl mb-2">⚋</div><div class="text-base">陰爻</div></div></div>',
          title: '兩儀誕生',
          description: '⚊ 陽爻代表動、剛、熱，⚋ 陰爻代表靜、柔、冷。',
          button: '灑下陽光'
        },
        {
          dialogue: '陰陽再分...四象綻放！',
          visual: `<div class="flex flex-col items-center gap-6">
            <div class="grid grid-cols-4 gap-4 w-full px-2">
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front spring-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚎</div>
                    <div class="text-xs font-bold">少陽</div>
                  </div>
                  <div class="card-back spring-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">🌸</div>
                    <div class="text-xs font-bold">春</div>
                  </div>
                </div>
              </div>
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front summer-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚌</div>
                    <div class="text-xs font-bold">老陽</div>
                  </div>
                  <div class="card-back summer-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">☀️</div>
                    <div class="text-xs font-bold">夏</div>
                  </div>
                </div>
              </div>
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front autumn-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚍</div>
                    <div class="text-xs font-bold">少陰</div>
                  </div>
                  <div class="card-back autumn-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">🍂</div>
                    <div class="text-xs font-bold">秋</div>
                  </div>
                </div>
              </div>
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front winter-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚏</div>
                    <div class="text-xs font-bold">老陰</div>
                  </div>
                  <div class="card-back winter-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">❄️</div>
                    <div class="text-xs font-bold">冬</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <style>
            .spring-card { background: linear-gradient(135deg, #c3f0ca, #e8f8e8); }
            .summer-card { background: linear-gradient(135deg, #ffe066, #fff3cd); }
            .autumn-card { background: linear-gradient(135deg, #ffa500, #ffe4b5); }
            .winter-card { background: linear-gradient(135deg, #add8e6, #e6f3ff); }
            
            /* 四象卡片3D翻轉動畫樣式 */
            .perspective-1000 {
              perspective: 1000px;
            }
            
            .transform-style-preserve-3d {
              transform-style: preserve-3d;
            }
            
            .backface-hidden {
              backface-visibility: hidden;
              -webkit-backface-visibility: hidden;
            }
            
            .rotateY-180 {
              transform: rotateY(180deg);
            }
            
            .four-flip-card-inner.flipped {
              transform: rotateY(180deg);
            }
            
            .four-flip-card:hover {
              transform: scale(1.05);
              transition: transform 0.2s ease;
            }
            
            .four-flip-card .card-front,
            .four-flip-card .card-back {
              transition: all 0.3s ease;
            }
          </style>`,
          title: '四象成形',
          description: '陰陽組合產生四種變化：少陽⚎、老陽⚌、少陰⚍、老陰⚏，對應春夏秋冬四季輪回。點擊卡片查看四象與季節的對應關係！',
          button: '催生四象'
        },
        {
          dialogue: '四象再分，八卦生成...這宇宙生成的奧秘就此揭開！接下來，讓我們仔細學習每個八卦符號的深層含義。',
          visual: '✨',
          title: '八卦奧秘',
          description: '現在你已了解宇宙生成的過程：無極→太極→兩儀→四象→八卦。讓我們進入下一步，詳細學習八卦符號！',
          button: '學習八卦'
        }
      ];
      
      let currentStage = 0;
      
      // 添加卡片翻轉函數到全局
      window.flipCard = function(cardElement) {
        // 檢查是否為四象卡片（有3D翻轉結構）
        const flipCardInner = cardElement.querySelector('.four-flip-card-inner');
        
        if (flipCardInner) {
          // 四象卡片使用3D翻轉動畫
          flipCardInner.classList.toggle('flipped');
        } else {
          // 原有邏輯（兼容性保留）
          const front = cardElement.querySelector('.card-front');
          const back = cardElement.querySelector('.card-back');
          
          if (front && back) {
            front.classList.toggle('hidden');
            back.classList.toggle('hidden');
          }
        }
      };
      
      function createStageContent(stage) {
        return `
          <div class="garden-display flex flex-col items-center" style="padding: 20px 0;">
            <div class="visual-element mb-2">${stage.visual}</div>
            <h3 class="text-xl font-bold mb-2 text-emerald-600 dark:text-emerald-400">${stage.title}</h3>
            <div class="zhuangzi-dialogue p-3 bg-indigo-50 dark:bg-indigo-900 rounded-lg max-w-lg border border-indigo-200 dark:border-indigo-700">
              <p class="text-sm italic leading-relaxed text-indigo-900 dark:text-indigo-100">
                <span class="font-semibold text-indigo-800 dark:text-indigo-200">莊子：</span>${stage.description}
              </p>
            </div>
          </div>
          <div class="garden-controls flex justify-center mt-4 mb-4">
            <button class="stage-button px-8 py-3 bg-emerald-500 hover:bg-emerald-600 text-white rounded-lg font-semibold transition-colors shadow-lg">
              🌱 ${stage.button}
            </button>
          </div>
        `;
      }
      
      gardenContainer.innerHTML = `
        <div class="relative h-full">
          <h3 class="text-lg font-bold mb-3 text-indigo-600 dark:text-indigo-400">莊子的哲學花園</h3>
          <div id="stage-content">${createStageContent(storyStages[0])}</div>
          <div class="progress-indicator flex justify-center pb-2 text-sm text-gray-500 dark:text-gray-400">
            第 <span id="current-stage-num">1</span> 步 / ${storyStages.length}
          </div>
        </div>
      `;
      
      document.body.appendChild(gardenContainer);
      
      function nextStage() {
        currentStage++;
        if (currentStage < storyStages.length) {
          // 更新內容
          const stageContent = gardenContainer.querySelector('#stage-content');
          const stageNum = gardenContainer.querySelector('#current-stage-num');
          
          stageContent.style.opacity = '0';
          setTimeout(() => {
            stageContent.innerHTML = createStageContent(storyStages[currentStage]);
            stageNum.textContent = currentStage + 1;
            stageContent.style.opacity = '1';
            
            // 重新綁定按鈕事件
            const newButton = stageContent.querySelector('.stage-button');
            newButton.addEventListener('click', handleButtonClick);
          }, 300);
        } else {
          // 完成所有階段
          gardenContainer.remove();
          // 清理全局函數
          delete window.flipCard;
          advanceBtn.style.display = 'block';
        }
      }
      
      function handleButtonClick() {
        nextStage();
      }
      
      // 初始化按鈕事件
      const initialButton = gardenContainer.querySelector('.stage-button');
      initialButton.addEventListener('click', handleButtonClick);
      
      // 添加過渡效果
      const stageContent = gardenContainer.querySelector('#stage-content');
      stageContent.style.transition = 'opacity 0.3s ease';
    }
    
    // 創建八卦符號演示場景（翻轉卡片）
    function createBaguaSymbolsDemonstrationScene(scene) {
      const cardContainer = document.createElement('div');
      cardContainer.className = 'max-w-6xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      cardContainer.style.top = '1rem';
      cardContainer.style.zIndex = '70';
      cardContainer.style.height = 'auto';
      cardContainer.style.overflow = 'visible';
      
             // 基於正確八卦理論的通俗解釋
       const baguaCards = [
        { 
          symbol: '☰', 
          name: '乾', 
          pinyin: 'qián',
          element: '天', 
          emoji: '☁️',
          explanation: '三個陽爻，全部都是動的，像天體不停轉動。',
          color: '#FFD700',
          reason: '天地定位：古人認為天在上地在下，天動地靜。三條實線表示完全動。'
        },
        { 
          symbol: '☷', 
          name: '坤', 
          pinyin: 'kūn',
          element: '地', 
          emoji: '🌍',
          explanation: '三個陰爻，全部都是靜的，像大地穩穩不動。',
          color: '#8B4513',
          reason: '天地定位：與天相對，三條虛線表示完全靜，大地安穩承載。'
        },
        { 
          symbol: '☶', 
          name: '艮', 
          pinyin: 'gèn',
          element: '山', 
          emoji: '⛰️',
          explanation: '上面動，下面靜，像山峰聳立大地上。',
          color: '#A0522D',
          reason: '山澤通氣：上爻動（山氣上升），中下爻靜，山氣往上飄。'
        },
        { 
          symbol: '☱', 
          name: '兌', 
          pinyin: 'duì',
          element: '澤', 
          emoji: '🌧️',
          explanation: '上面靜，下面動，像雨水從天空降下。',
          color: '#40E0D0',
          reason: '山澤通氣：上爻靜，中下爻動，表示降雨的樣子。'
        },
        { 
          symbol: '☳', 
          name: '震', 
          pinyin: 'zhèn',
          element: '雷', 
          emoji: '⚡',
          explanation: '下面動，上面靜，像雷聲從地底下冒出來。',
          color: '#9400D3',
          reason: '雷風相薄：古人認為雷從地中起，下爻動，中上爻靜。'
        },
        { 
          symbol: '☴', 
          name: '巽', 
          pinyin: 'xùn',
          element: '風', 
          emoji: '💨',
          explanation: '上面動，下面靜，像風從天上吹下來。',
          color: '#32CD32',
          reason: '雷風相薄：古人認為風起天上，下爻靜，中上爻動。'
        },
        { 
          symbol: '☵', 
          name: '坎', 
          pinyin: 'kǎn',
          element: '水', 
          emoji: '💧',
          explanation: '中間動，周圍靜，像水在固定河道中流動。',
          color: '#1E90FF',
          reason: '水火不相射：中爻動，上下爻靜，周邊靜中間動。又象徵月亮。'
        },
        { 
          symbol: '☲', 
          name: '離', 
          pinyin: 'lí',
          element: '火', 
          emoji: '🔥',
          explanation: '周圍動，中間靜，像火焰外面跳動內心空虛。',
          color: '#FF4500',
          reason: '水火不相射：中爻靜，上下爻動，周邊動中間靜。又象徵太陽。'
        }
      ];
      
      let flippedCards = 0;
      
      cardContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4 text-indigo-600 dark:text-indigo-400">八卦學習卡片</h3>
        <p class="text-base text-gray-800 dark:text-gray-200 mb-6">點擊卡片翻轉查看解釋（已翻轉：<span id="flipped-count">0</span>/${baguaCards.length}）</p>
        <div class="cards-grid grid grid-cols-4 gap-4 p-4">
          ${baguaCards.map((card, index) => `
            <div class="flip-card w-32 h-40 perspective-1000" data-index="${index}">
              <div class="flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d cursor-pointer">
                <div class="flip-card-front absolute w-full h-full bg-gradient-to-br from-blue-400 to-purple-500 rounded-lg shadow-lg flex flex-col items-center justify-center backface-hidden">
                  <div class="text-4xl mb-2" style="color: ${card.color};">${card.symbol}</div>
                  <div class="text-white font-bold text-lg">${card.name}</div>
                  <div class="text-sm text-blue-100 opacity-90">${card.pinyin}</div>
                </div>
                <div class="flip-card-back absolute w-full h-full bg-gradient-to-br from-amber-50 to-orange-100 dark:from-gray-800 dark:to-gray-900 rounded-lg shadow-lg p-3 backface-hidden transform rotateY-180 border-2 border-amber-200 dark:border-gray-600">
                  <div class="text-2xl font-bold mb-1 text-amber-800 dark:text-amber-200 text-center" style="color: ${card.color}; text-shadow: 0 0 4px rgba(0,0,0,0.3);">${card.element}</div>
                  <div class="text-2xl mb-2 text-center">${card.emoji}</div>
                  <div class="text-xs text-gray-800 dark:text-gray-200 leading-tight mb-2 font-medium text-left">${card.explanation}</div>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
        <div class="continue-section mt-4">
          <button id="continue-btn" class="px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold hidden transition-colors">
            ✨ 繼續學習
          </button>
        </div>
      `;
      
      document.body.appendChild(cardContainer);
      
      // 添加CSS樣式
      const style = document.createElement('style');
      style.textContent = `
        .perspective-1000 {
          perspective: 1000px;
        }
        .transform-style-preserve-3d {
          transform-style: preserve-3d;
        }
        .backface-hidden {
          backface-visibility: hidden;
        }
        .rotateY-180 {
          transform: rotateY(180deg);
        }
        .flip-card-inner.flipped {
          transform: rotateY(180deg);
        }
      `;
      document.head.appendChild(style);
      
      // 綁定卡片點擊事件
      const cards = cardContainer.querySelectorAll('.flip-card');
      const flippedCountSpan = cardContainer.querySelector('#flipped-count');
      const continueBtn = cardContainer.querySelector('#continue-btn');
      
      cards.forEach((card, index) => {
        let hasBeenFlippedOnce = false; // 追蹤是否曾經翻轉過
        
        card.addEventListener('click', () => {
          const inner = card.querySelector('.flip-card-inner');
          
          // 切換翻轉狀態
          inner.classList.toggle('flipped');
          
          // 只在第一次翻轉時計數
          if (!hasBeenFlippedOnce && inner.classList.contains('flipped')) {
            hasBeenFlippedOnce = true;
            flippedCards++;
            flippedCountSpan.textContent = flippedCards;
            
            // 當所有卡片都翻轉過後顯示繼續按鈕
            if (flippedCards === baguaCards.length) {
              setTimeout(() => {
                continueBtn.classList.remove('hidden');
              }, 600);
            }
          }
        });
      });
      
      // 繼續按鈕事件
      continueBtn.addEventListener('click', () => {
        cardContainer.remove();
        style.remove();
        advanceBtn.style.display = 'block';
      });
    }
    
    // 創建八卦學習挑戰場景（優化版）
    function createBaguaLearningChallengeScene(scene) {
      const learningContainer = document.createElement('div');
      learningContainer.className = 'max-w-5xl mx-auto p-4 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      learningContainer.style.top = '1rem';
      learningContainer.style.zIndex = '70';
      learningContainer.style.maxHeight = '95vh';
      learningContainer.style.overflow = 'auto';
      
      learningContainer.innerHTML = `
        <h3 class="text-lg font-bold mb-2 text-gray-900 dark:text-gray-100">${scene.text}</h3>
        <div class="challenge-header flex justify-between items-center mb-2 p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
          <div class="timer-display text-lg font-bold text-blue-600 dark:text-blue-400">
            ⏱️ <span id="timer-display">00:00</span>
          </div>
          <div class="challenge-info text-sm text-gray-800 dark:text-gray-200">
            <div>最佳記錄: <span id="best-time">--:--</span></div>
            <div>嘗試次數: <span id="attempt-count">1</span></div>
          </div>
        </div>
        <div class="learning-area flex justify-between mb-2">
          <div class="bagua-symbols-area w-1/2 p-2 border-r border-gray-300 dark:border-gray-600">
            <h4 class="text-base font-semibold mb-2 text-indigo-600 dark:text-indigo-400">八卦符號</h4>
            <div class="bagua-symbols-grid grid grid-cols-4 gap-2 justify-items-center"></div>
          </div>
          <div class="bagua-elements-area w-1/2 p-2">
            <h4 class="text-base font-semibold mb-2 text-emerald-600 dark:text-emerald-400">對應元素</h4>
            <div class="bagua-elements-grid grid grid-cols-4 gap-2 justify-items-center"></div>
          </div>
        </div>
        <div class="status-section mb-2">
          <div class="learning-status text-base font-semibold text-blue-600 dark:text-blue-400 mb-1">點擊八卦符號，再點擊對應的元素文字進行配對</div>
          <div class="learning-progress text-sm text-gray-800 dark:text-gray-200">已配對：<span id="matched-count">0</span> / 8</div>
        </div>
        <div class="challenge-controls flex justify-center gap-4 pb-2" style="display: none;" id="challenge-controls">
          <button class="retry-btn px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg font-semibold transition-colors">
            🔄 再次挑戰
          </button>
          <button class="continue-btn px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold transition-colors">
            ✅ 繼續遊戲
          </button>
        </div>
      `;
      
      document.body.appendChild(learningContainer);
      
      // 八卦數據
      const baguaData = [
        { symbol: '☰', name: 'qian', element: '天', color: '#FFD700' },
        { symbol: '☱', name: 'dui', element: '澤', color: '#C0C0C0' },
        { symbol: '☲', name: 'li', element: '火', color: '#FF6347' },
        { symbol: '☳', name: 'zhen', element: '雷', color: '#32CD32' },
        { symbol: '☴', name: 'xun', element: '風', color: '#87CEEB' },
        { symbol: '☵', name: 'kan', element: '水', color: '#4169E1' },
        { symbol: '☶', name: 'gen', element: '山', color: '#8B4513' },
        { symbol: '☷', name: 'kun', element: '地', color: '#DAA520' }
      ];
      
      // 遊戲狀態
      let selectedSymbol = null;
      let matchedPairs = 0;
      let startTime = null;
      let timerInterval = null;
      let attemptCount = parseInt(localStorage.getItem('baguaAttemptCount') || '1');
      let bestTime = localStorage.getItem('baguaBestTime') || null;
      let challengeCompleted = false;
      
      // UI元素
      const symbolsGrid = learningContainer.querySelector('.bagua-symbols-grid');
      const elementsGrid = learningContainer.querySelector('.bagua-elements-grid');
      const statusText = learningContainer.querySelector('.learning-status');
      const matchedCount = learningContainer.querySelector('#matched-count');
      const timerDisplay = learningContainer.querySelector('#timer-display');
      const bestTimeDisplay = learningContainer.querySelector('#best-time');
      const attemptCountDisplay = learningContainer.querySelector('#attempt-count');
      const challengeControls = learningContainer.querySelector('#challenge-controls');
      const retryBtn = learningContainer.querySelector('.retry-btn');
      const continueBtn = learningContainer.querySelector('.continue-btn');
      
      // 初始化顯示
      attemptCountDisplay.textContent = attemptCount;
      if (bestTime) {
        bestTimeDisplay.textContent = bestTime;
      }
      
      // 計時器函數
      function startTimer() {
        startTime = Date.now();
        timerInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 100);
      }
      
      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        return startTime ? Date.now() - startTime : 0;
      }
      
      function formatTime(milliseconds) {
        const minutes = Math.floor(milliseconds / 60000);
        const seconds = Math.floor((milliseconds % 60000) / 1000);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      // 重置遊戲函數
      function resetGame() {
        selectedSymbol = null;
        matchedPairs = 0;
        challengeCompleted = false;
        matchedCount.textContent = '0';
        statusText.textContent = '點擊八卦符號，再點擊對應的元素文字進行配對';
        challengeControls.style.display = 'none';
        
        // 清空網格
        symbolsGrid.innerHTML = '';
        elementsGrid.innerHTML = '';
        
        // 重新創建遊戲元素
        createGameElements();
        
        // 重置並開始計時器
        stopTimer();
        timerDisplay.textContent = '00:00';
        startTimer();
      }
      
      // 創建遊戲元素函數
      function createGameElements() {
        // 打亂元素順序
        const shuffledElements = [...baguaData].sort(() => Math.random() - 0.5);
      
      // 創建八卦符號
      baguaData.forEach((bagua, index) => {
        const symbolElement = document.createElement('div');
          symbolElement.className = 'bagua-symbol-learning cursor-pointer transition-all duration-300 p-3 rounded-lg border-2 border-transparent hover:border-indigo-400 hover:shadow-lg flex items-center justify-center';
          symbolElement.style.minHeight = '60px';
          symbolElement.style.minWidth = '60px';
        symbolElement.dataset.name = bagua.name;
        symbolElement.innerHTML = `
            <div class="text-3xl" style="color: ${bagua.color}; text-shadow: 0 0 8px ${bagua.color};">${bagua.symbol}</div>
        `;
        
        symbolElement.addEventListener('click', () => {
            if (symbolElement.classList.contains('matched') || challengeCompleted) return;
            
            // 開始計時（首次點擊時）
            if (!startTime) {
              startTimer();
            }
          
          // 清除之前的選中狀態
          document.querySelectorAll('.bagua-symbol-learning').forEach(el => {
            el.classList.remove('selected');
            el.style.backgroundColor = '';
          });
          
          // 選中當前符號
          selectedSymbol = bagua.name;
          symbolElement.classList.add('selected');
          symbolElement.style.backgroundColor = 'rgba(99, 102, 241, 0.2)';
          statusText.textContent = '';
        });
        
        symbolsGrid.appendChild(symbolElement);
      });
      
      // 創建元素文字
      shuffledElements.forEach((bagua, index) => {
        const elementElement = document.createElement('div');
          elementElement.className = 'bagua-element-learning cursor-pointer transition-all duration-300 p-3 rounded-lg border-2 border-transparent hover:border-emerald-400 hover:shadow-lg flex items-center justify-center';
          elementElement.style.minHeight = '60px';
          elementElement.style.minWidth = '60px';
        elementElement.dataset.name = bagua.name;
        elementElement.innerHTML = `
            <div class="text-3xl font-bold text-gray-700 dark:text-gray-300">${bagua.element}</div>
        `;
        
        elementElement.addEventListener('click', () => {
            if (elementElement.classList.contains('matched') || challengeCompleted) return;
          
          if (!selectedSymbol) {
            statusText.textContent = '請先選擇一個八卦符號';
            elementElement.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => {
              elementElement.style.animation = '';
            }, 500);
            return;
          }
          
          if (selectedSymbol === bagua.name) {
            // 配對成功
            const symbolEl = document.querySelector(`.bagua-symbol-learning[data-name="${selectedSymbol}"]`);
            symbolEl.classList.add('matched');
            symbolEl.style.backgroundColor = 'rgba(34, 197, 94, 0.3)';
            symbolEl.style.pointerEvents = 'none';
            
            elementElement.classList.add('matched');
            elementElement.style.backgroundColor = 'rgba(34, 197, 94, 0.3)';
            elementElement.style.pointerEvents = 'none';
            
            // 成功動畫
            [symbolEl, elementElement].forEach(el => {
              el.style.animation = 'bagua-match-success 1s ease-in-out';
            });
            
            matchedPairs++;
            matchedCount.textContent = matchedPairs;
            selectedSymbol = null;
            
            if (matchedPairs === 8) {
                // 挑戰完成
                challengeCompleted = true;
                const completionTime = stopTimer();
                const formattedTime = formatTime(completionTime);
                
                // 更新最佳記錄
                if (!bestTime || completionTime < parseInt(localStorage.getItem('baguaBestTimeMs') || '999999999')) {
                  bestTime = formattedTime;
                  localStorage.setItem('baguaBestTime', bestTime);
                  localStorage.setItem('baguaBestTimeMs', completionTime.toString());
                  bestTimeDisplay.textContent = bestTime;
                  statusText.innerHTML = `🎉 恭喜！新記錄：${formattedTime}！你已經掌握了八卦與元素的對應關係`;
                } else {
                  statusText.innerHTML = `✅ 完成！用時：${formattedTime}。你已經掌握了八卦與元素的對應關係`;
                }
                
                // 顯示控制按鈕
                challengeControls.style.display = 'flex';
              gameState.baguaLearningCompleted = true;
            } else {
              statusText.textContent = '配對成功！請繼續選擇下一組';
            }
          } else {
            // 配對錯誤
            statusText.textContent = '配對錯誤，請重新選擇';
            elementElement.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => {
              elementElement.style.animation = '';
              statusText.textContent = '點擊八卦符號，再點擊對應的元素文字進行配對';
            }, 1000);
          }
        });
        
        elementsGrid.appendChild(elementElement);
      });
      }
      
      // 事件監聽器
      retryBtn.addEventListener('click', () => {
        attemptCount++;
        localStorage.setItem('baguaAttemptCount', attemptCount.toString());
        attemptCountDisplay.textContent = attemptCount;
        resetGame();
      });
      
      continueBtn.addEventListener('click', () => {
        learningContainer.remove();
        advanceBtn.style.display = 'block';
      });
      
      // 初始化遊戲
      createGameElements();
      
      // 添加動畫樣式
      if (!document.getElementById('bagua-learning-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'bagua-learning-animations';
        styleElement.textContent = `
          @keyframes bagua-match-success {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
          }
          
          @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
          }
          
          .bagua-symbol-learning, .bagua-element-learning {
            transition: all 0.3s ease;
          }
          
          .bagua-symbol-learning.selected {
            transform: scale(1.1);
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建萬物尋氣引導
    function createWanwuXunqiGuide(scene) {
      const guideContainer = document.createElement('div');
      guideContainer.className = 'max-w-2xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      guideContainer.style.top = '2rem';
      guideContainer.style.zIndex = '70';
      guideContainer.id = 'wanwu-xunqi-guide'; // 添加ID以便控制
      
      const sequence = scene.sequence || ['butterfly', 'fish', 'kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star'];
      let currentIndex = 0;
      
      // 保存引導窗口引用到gameState
      gameState.wanwuXunqiGuideContainer = guideContainer;
      
      // 設置萬物尋氣模式標記
      gameState.wanwuXunqiActive = true;
      gameState.wanwuXunqiCurrentFormIndex = 0;
      gameState.wanwuXunqiProgress = [];
      
      // 重新創建八卦符號以啟用點擊功能
      document.querySelectorAll('.bagua-symbols').forEach(el => el.remove());
      createBaguaSymbols();
      
      const formNames = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      
      guideContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4 text-gray-900 dark:text-gray-100">${scene.text}</h3>
        <div class="sequence-progress mb-4">
          <div class="current-form text-2xl font-bold text-blue-600 dark:text-blue-400" id="current-form-name">請點擊：${formNames[sequence[0]]}</div>
          <div class="progress-bar mt-2 bg-gray-200 dark:bg-gray-700 rounded-full h-2">
            <div class="progress-fill bg-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
          </div>
          <div class="progress-text text-sm text-gray-800 dark:text-gray-200 mt-2">0 / ${sequence.length}</div>
        </div>
        <p class="text-sm text-gray-800 dark:text-gray-200 mb-4">進入每個物化視野，尋找並收集對應的氣（每種需收集3個）</p>
        ${scene.showSkipButton && gameState.devMode ? '<button id="skip-wanwu-xunqi-btn" class="bg-orange-500 hover:bg-orange-600 text-white font-bold py-2 px-4 rounded text-sm" style="/* DEV_TEST_BUTTON */">⚡ 跳過萬物尋氣（開發測試）</button>' : ''}
      `;
      
      document.body.appendChild(guideContainer);
      
      const currentFormName = guideContainer.querySelector('#current-form-name');
      const progressFill = guideContainer.querySelector('.progress-fill');
      const progressText = guideContainer.querySelector('.progress-text');
      
      // 高亮當前需要點擊的按鈕
      function highlightCurrentForm() {
        // 移除所有高亮
        Object.values(formButtons).forEach(btn => {
          if (btn) {
            btn.style.boxShadow = '';
            btn.style.animation = '';
          }
        });
        
        // 高亮當前按鈕
        const currentForm = sequence[currentIndex];
        const currentButton = formButtons[currentForm];
        if (currentButton) {
          currentButton.style.boxShadow = '0 0 20px #3B82F6';
          currentButton.style.animation = 'pulse 2s infinite';
        }
      }
      
      // 處理萬物尋氣中的物化點擊
      gameState.handleFormSequenceClick = function(clickedForm) {
        console.log('萬物尋氣點擊處理:', clickedForm, '期望:', sequence[currentIndex]);
        if (clickedForm === sequence[currentIndex]) {
          // 隱藏萬物尋氣引導窗口
          if (gameState.wanwuXunqiGuideContainer) {
            gameState.wanwuXunqiGuideContainer.style.display = 'none';
          }
          
          // 進入八卦收集模式
          console.log('開始八卦收集:', clickedForm);
          startBaguaCollection(clickedForm);
          return true; // 表示已處理
        } else {
          console.log('點擊的不是當前需要的物化形態');
          showMessage(`請點擊 ${formNames[sequence[currentIndex]]}！`);
          return false; // 表示未處理
        }
      };
      
      // 更新進度的函數
      gameState.updateWanwuXunqiProgress = function() {
        currentIndex++;
        const progress = (currentIndex / sequence.length) * 100;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `${currentIndex} / ${sequence.length}`;
        
        if (currentIndex < sequence.length) {
          currentFormName.textContent = `請點擊：${formNames[sequence[currentIndex]]}`;
          gameState.wanwuXunqiCurrentFormIndex = currentIndex;
          highlightCurrentForm();
        } else {
          currentFormName.textContent = '完成！萬物之氣已聚';
          // 移除所有高亮
          Object.values(formButtons).forEach(btn => {
            if (btn) {
              btn.style.boxShadow = '';
              btn.style.animation = '';
            }
          });
          // 清理萬物尋氣模式
          gameState.wanwuXunqiActive = false;
          gameState.handleFormSequenceClick = null;
          gameState.wanwuXunqiGuideContainer = null;
          
          // 重新顯示物化按鈕
          const formSelector = document.querySelector('.form-selector');
          if (formSelector) {
            formSelector.style.display = 'flex';
            console.log('萬物尋氣完成：已重新顯示物化按鈕');
          }
          
          setTimeout(() => {
            guideContainer.remove();
            advanceBtn.style.display = 'block';
          }, 2000);
        }
      };
      
      // 初始高亮
      highlightCurrentForm();
      
      // 開發測試：添加跳過按鈕事件監聽器 /* DEV_TEST_FEATURE */
      const skipButton = document.getElementById('skip-wanwu-xunqi-btn');
      if (skipButton) {
        skipButton.addEventListener('click', () => {
          // 清理萬物尋氣模式
          gameState.wanwuXunqiActive = false;
          gameState.handleFormSequenceClick = null;
          gameState.wanwuXunqiGuideContainer = null;
          
          // 移除所有高亮
          Object.values(formButtons).forEach(btn => {
            if (btn) {
              btn.style.boxShadow = '';
              btn.style.animation = '';
            }
          });
          
          // 重新顯示物化按鈕
          const formSelector = document.querySelector('.form-selector');
          if (formSelector) {
            formSelector.style.display = 'flex';
          }
          
          // 解鎖氣形態
          unlockForm('qi');
          
          // 設置相關狀態（模擬完成）
          gameState.baguaLearningCompleted = true;
          gameState.wanwuXunqiProgress = sequence; // 標記所有形態已完成
          
          // 移除引導界面
          guideContainer.remove();
          
          // 顯示跳過消息
          showMessage('已跳過萬物尋氣！氣形態已解鎖。');
          
          // 顯示繼續按鈕，進入下一場景
          setTimeout(() => {
            advanceBtn.style.display = 'block';
            advanceBtn.textContent = '進入氣化體驗';
          }, 2000);
        });
      }
    }
    
    // 創建萬物回響引導
    function createFormSequenceGuide(scene) {
      const guideContainer = document.createElement('div');
      guideContainer.className = 'max-w-2xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      guideContainer.style.top = '2rem';
      guideContainer.style.zIndex = '70';
      
      const sequence = scene.sequence || ['butterfly', 'fish', 'tree', 'bird', 'snail', 'ant'];
      let currentIndex = 0;
      
      // 設置萬物回響模式標記
      gameState.formSequenceGuideActive = true;
      
      const formNames = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      
      guideContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4">${scene.text}</h3>
        <div class="sequence-progress mb-4">
          <div class="current-form text-2xl font-bold text-blue-600 dark:text-blue-400" id="current-form-name">請點擊：${formNames[sequence[0]]}</div>
          <div class="progress-bar mt-2 bg-gray-200 dark:bg-gray-700 rounded-full h-2">
            <div class="progress-fill bg-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
          </div>
          <div class="progress-text text-sm text-gray-600 dark:text-gray-400 mt-2">0 / ${sequence.length}</div>
        </div>
        <p class="text-sm text-gray-600 dark:text-gray-400">按照你的旅程順序，依次點擊每個物化形態按鈕</p>
      `;
      
      document.body.appendChild(guideContainer);
      
      const currentFormName = guideContainer.querySelector('#current-form-name');
      const progressFill = guideContainer.querySelector('.progress-fill');
      const progressText = guideContainer.querySelector('.progress-text');
      
      // 高亮當前需要點擊的按鈕
      function highlightCurrentForm() {
        // 移除所有高亮
        Object.values(formButtons).forEach(btn => {
          if (btn) {
            btn.style.boxShadow = '';
            btn.style.animation = '';
          }
        });
        
        // 高亮當前按鈕
        const currentForm = sequence[currentIndex];
        const currentButton = formButtons[currentForm];
        if (currentButton) {
          currentButton.style.boxShadow = '0 0 20px #3B82F6';
          currentButton.style.animation = 'pulse 2s infinite';
        }
      }
      
      // 處理萬物回響中的物化點擊
      gameState.handleFormSequenceClick = function(clickedForm) {
        if (clickedForm === sequence[currentIndex]) {
          // 執行物化動畫但不改變遊戲狀態
          showTransformationTransition(gameState.currentForm, clickedForm);
          
          currentIndex++;
          const progress = (currentIndex / sequence.length) * 100;
          progressFill.style.width = `${progress}%`;
          progressText.textContent = `${currentIndex} / ${sequence.length}`;
          
          if (currentIndex < sequence.length) {
            currentFormName.textContent = `請點擊：${formNames[sequence[currentIndex]]}`;
            highlightCurrentForm();
          } else {
            currentFormName.textContent = '完成！萬物已回響';
            // 移除所有高亮
            Object.values(formButtons).forEach(btn => {
              if (btn) {
                btn.style.boxShadow = '';
                btn.style.animation = '';
              }
            });
            // 清理萬物回響模式
            gameState.formSequenceGuideActive = false;
            gameState.handleFormSequenceClick = null;
            setTimeout(() => {
              guideContainer.remove();
              advanceBtn.style.display = 'block';
            }, 2000);
          }
          return true; // 表示已處理
        }
        return false; // 表示未處理
      };
      
      // 初始高亮
      highlightCurrentForm();
    }
    

    

    
    // 創建混沌呼吸調息引導場景
    function createChaosBreathingGuide(scene) {
      // 獲取現有的混沌圖形
      const chaosForm = document.querySelector('.chaos-form');
      if (!chaosForm) {
        console.error('未找到混沌圖形');
        return;
      }
      
      // 為混沌圖形添加呼吸模式
      chaosForm.classList.add('breathing-mode');
      
      // 創建呼吸引導文字容器
      const breathingGuide = document.createElement('div');
      breathingGuide.className = 'breathing-guide-overlay';
      breathingGuide.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 15;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      `;
      
      breathingGuide.innerHTML = `
        <div class="breathing-phase-text" style="
          position: absolute;
          top: 65%;
          left: 50%;
          transform: translateX(-50%);
          font-size: 2rem;
          font-weight: bold;
          color: rgba(255, 255, 255, 0.9);
          text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
          transition: all 0.5s ease;
          text-align: center;
        ">準備開始...</div>
        
        <div class="breathing-progress" style="
          position: absolute;
          bottom: 10%;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          padding: 1.5rem 2rem;
          border-radius: 12px;
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.3);
          text-align: center;
          color: white;
          min-width: 400px;
        ">
          <div class="cycle-info" style="font-size: 0.9rem; margin-bottom: 0.5rem; opacity: 0.8;">跟隨混沌的節奏，體驗天人合一</div>
          <div class="progress-bar" style="
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 0 auto;
          ">
            <div class="progress-fill" style="
              height: 100%;
              background: linear-gradient(90deg, #6366f1, #8b5cf6);
              border-radius: 5px;
              width: 0%;
              transition: width 0.3s ease;
            "></div>
          </div>
          <div class="cycle-counter" style="font-size: 0.8rem; opacity: 0.7; margin-top: 0.5rem;">第 1 / 6 個週期</div>
        </div>
      `;
      
      document.body.appendChild(breathingGuide);
      
      const phaseText = breathingGuide.querySelector('.breathing-phase-text');
      const progressFill = breathingGuide.querySelector('.progress-fill');
      const cycleCounter = breathingGuide.querySelector('.cycle-counter');
      
      startGuidedBreathing(phaseText, progressFill, cycleCounter, () => {
        // 完成後清理
        chaosForm.classList.remove('breathing-mode');
        breathingGuide.remove();
        setTimeout(() => {
          advanceBtn.style.display = 'block';
        }, 1000);
      });
    }
    
    // 開始引導呼吸循環
    function startGuidedBreathing(textElement, progressFill, cycleCounter, onComplete) {
      let currentTime = 0;
      const totalTime = 60000; // 60秒
      const cycleTime = 10000; // 10秒一個週期 (4秒吸氣 + 6秒呼氣)
      const totalCycles = 6; // 總共6個週期
      
      const breathingInterval = setInterval(() => {
        const cycleProgress = (currentTime % cycleTime) / cycleTime;
        const currentCycle = Math.floor(currentTime / cycleTime) + 1;
        
        if (cycleProgress < 0.4) { // 吸氣階段 (4秒)
          showGuidedBreathingText(textElement, 'inhale');
        } else { // 呼氣階段 (6秒)
          showGuidedBreathingText(textElement, 'exhale');
        }
        
        // 更新進度
        const overallProgress = (currentTime / totalTime) * 100;
        progressFill.style.width = `${overallProgress}%`;
        cycleCounter.textContent = `第 ${Math.min(currentCycle, totalCycles)} / ${totalCycles} 個週期`;
        
        currentTime += 100;
        
        if (currentTime >= totalTime) {
          clearInterval(breathingInterval);
          showGuidedBreathingText(textElement, 'complete');
          onComplete();
        }
      }, 100);
    }
    
    // 顯示引導呼吸文字
    function showGuidedBreathingText(textElement, phase) {
      switch (phase) {
        case 'inhale':
          textElement.textContent = '用鼻吸氣...';
          textElement.style.color = 'rgba(255, 255, 255, 0.9)';
          textElement.style.transform = 'translateX(-50%) scale(1.1)';
          break;
          
        case 'exhale':
          textElement.textContent = '用嘴呼氣...';
          textElement.style.color = 'rgba(147, 146, 255, 0.9)';
          textElement.style.transform = 'translateX(-50%) scale(0.9)';
          break;
          
        case 'complete':
          textElement.textContent = '天人合一，調息完成';
          textElement.style.color = '#10b981';
          textElement.style.transform = 'translateX(-50%) scale(1)';
          break;
      }
    }
    
    // 創建氣注入儀式場景
    function createQiInfusionRitual(scene) {
      // 獲取現有的混沌圖形
      const chaosForm = document.querySelector('.chaos-form');
      if (!chaosForm) {
        console.error('未找到混沌圖形');
        return;
      }
      
      // 移除呼吸模式，恢復正常狀態
      chaosForm.classList.remove('breathing-mode');
      
      // 創建儀式引導界面
      const ritualGuide = document.createElement('div');
      ritualGuide.className = 'ritual-guide-overlay';
      ritualGuide.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 15;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      `;
      
      ritualGuide.innerHTML = `
        <div class="ritual-status" style="
          position: absolute;
          bottom: 10%;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          padding: 1.5rem 2rem;
          border-radius: 12px;
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.3);
          text-align: center;
          color: white;
          transition: opacity 0.5s ease;
          min-width: 450px;
        ">
          <div class="main-instruction" style="font-size: 1.1rem; margin-bottom: 1rem; opacity: 0.9;">${scene.text}</div>
          <div class="interaction-hint" style="font-size: 0.9rem; margin-bottom: 0.5rem; opacity: 0.8; color: #ffeb3b;"><strong>⚠️ 重要：長按混沌形體不要鬆開，否則儀式會暫停</strong></div>
          <div class="status-text" style="font-size: 1rem; margin-bottom: 0.5rem;">準備注入萬物之氣</div>
          <div class="phase-indicator" style="font-size: 0.9rem; margin-bottom: 0.5rem;">點按混沌開始儀式，按住不放直到完成</div>
          <div class="progress-indicator" style="
            width: 350px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 0 auto;
          ">
            <div class="progress-bar" style="
              height: 100%;
              background: linear-gradient(90deg, #ffffff, #cccccc, #999999, #000000);
              border-radius: 5px;
              width: 0%;
              transition: width 0.3s ease;
            "></div>
          </div>
        </div>
      `;
      
      document.body.appendChild(ritualGuide);
      
      // 啟用混沌圖形的長按功能
      chaosForm.style.pointerEvents = 'auto';
      chaosForm.style.cursor = 'pointer';
      
      const statusText = ritualGuide.querySelector('.status-text');
      const phaseIndicator = ritualGuide.querySelector('.phase-indicator');
      const progressBar = ritualGuide.querySelector('.progress-bar');
      
      handleSynchronizedInjection(chaosForm, statusText, phaseIndicator, progressBar, () => {
        // 注入完成後的回調
                  console.log('🔥 氣注入儀式完成！準備進入道的顯現場景');
        console.log('當前狀態:', {
          currentChapter: gameState.currentChapter,
          currentScene: gameState.currentScene,
          targetScene: 38
        });
        
        ritualGuide.remove();
        console.log('已移除儀式引導界面');
        
        // 直接進入道的顯現場景
        setTimeout(() => {
          console.log('開始跳轉到道的顯現場景...');
          
          // 添加場景存在性檢查
          const chapter = gameChapters[gameState.currentChapter];
          if (!chapter) {
            console.error('❌ 錯誤：找不到當前章節配置', gameState.currentChapter);
            return;
          }
          
          console.log('章節場景總數:', chapter.scenes.length);
          
          if (!chapter.scenes[38]) {
            console.error('❌ 錯誤：場景38不存在！當前章節場景數量:', chapter.scenes.length);
            console.log('現有場景索引範圍: 0 -', chapter.scenes.length - 1);
            // 嘗試跳轉到最後一個場景
            console.log('嘗試跳轉到最後一個場景:', chapter.scenes.length - 1);
            gameState.currentScene = chapter.scenes.length - 1;
          } else {
            console.log('✅ 場景38存在，開始跳轉');
            gameState.currentScene = 38; // 跳到道的顯現場景（正確的索引）
          }
          
          console.log('最終跳轉到場景:', gameState.currentScene);
          
          try {
            loadScene();
            console.log('✅ 場景加載成功');
          } catch (error) {
            console.error('❌ 場景加載失敗:', error);
            console.log('錯誤詳情:', error.stack);
          }
        }, 1000);
      });
    }
    
    // 處理同步的氣注入過程（點按後立即開始粒子動畫和進度條）
    function handleSynchronizedInjection(element, statusText, phaseIndicator, progressBar, onComplete) {
      let isInjecting = false;
      let isPaused = false;
      let injectionTimer = null;
      let currentPhase = 0;
      let phaseProgress = 0;
      
      // 四個階段的配置（氣形態視野下的黑白效果）
      const phases = [
        { name: '語言歸復', duration: 5000, description: '語言歸復，萬物之名回歸本源...' },
        { name: '八卦歸復', duration: 5000, description: '八卦歸復，天地之理回歸本源...' },
        { name: '陰陽歸復', duration: 4000, description: '陰陽歸復，對立統一回歸本源...' },
        { name: '太極歸復', duration: 3000, description: '太極歸復，一切回歸無極之道...' }
      ];
      
      const totalDuration = phases.reduce((sum, phase) => sum + phase.duration, 0); // 13秒總時長
      
      const startInjection = () => {
        if (isInjecting && !isPaused) return;
        
        isInjecting = true;
        isPaused = false;
        statusText.textContent = '正在注入萬物之氣...請保持按住不放';
        
        // 只在初次開始時觸發粒子動畫，繼續時不重新觸發
        if (phaseProgress === 0) {
        triggerSynchronizedParticleSequence();
        }
        
        // 開始進度條和階段指示器更新
        injectionTimer = setInterval(() => {
          phaseProgress += 100; // 每100ms更新一次
          
          // 計算當前階段
          let accumulatedTime = 0;
          let newPhase = 0;
          for (let i = 0; i < phases.length; i++) {
            if (phaseProgress <= accumulatedTime + phases[i].duration) {
              newPhase = i;
              break;
            }
            accumulatedTime += phases[i].duration;
          }
          
          // 更新階段指示器（氣形態視野下保持黑白效果）
          if (newPhase !== currentPhase) {
            currentPhase = newPhase;
            if (currentPhase < phases.length) {
              phaseIndicator.textContent = phases[currentPhase].description;
              // 氣形態視野下不設置額外顏色，保持黑白濾鏡效果
            }
          }
          
          // 更新進度條
          const progress = Math.min(100, (phaseProgress / totalDuration) * 100);
          progressBar.style.width = `${progress}%`;
          
          // 檢查是否完成
          if (phaseProgress >= totalDuration) {
            clearInterval(injectionTimer);
            statusText.textContent = '萬物歸道，氣注入完成！';
            phaseIndicator.textContent = '道生一，一生二，二生三，三生萬物';
            // 氣形態視野下不設置額外顏色，保持黑白濾鏡效果
            setTimeout(onComplete, 1000);
          }
        }, 100);
      };
      
      const pauseInjection = () => {
        if (injectionTimer) {
          clearInterval(injectionTimer);
          injectionTimer = null;
        }
        
        // 標記為暫停狀態，但保留進度
        isInjecting = false;
        isPaused = true;
        
        // 更新狀態提示
        if (phaseProgress > 0 && phaseProgress < totalDuration) {
          statusText.textContent = '儀式已暫停 - 再次點按混沌繼續注入';
          phaseIndicator.textContent = '點按混沌繼續儀式，記住要按住不放';
        } else if (phaseProgress === 0) {
        statusText.textContent = '準備注入萬物之氣';
          phaseIndicator.textContent = '點按混沌開始儀式，按住不放直到完成';
        }
      };
      
      // 鼠標事件
      element.addEventListener('mousedown', startInjection);
      element.addEventListener('mouseup', pauseInjection);
      element.addEventListener('mouseleave', pauseInjection);
      
      // 觸摸事件（移動設備）
      element.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startInjection();
      });
      element.addEventListener('touchend', (e) => {
        e.preventDefault();
        pauseInjection();
      });
      element.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        pauseInjection();
      });
    }

    // 同步的粒子序列動畫（與進度條同步）
    function triggerSynchronizedParticleSequence() {
      let sequenceStep = 0;
      
      // 階段式粒子注入系統（與進度條同步）
      const injectionPhases = [
        {
          name: 'bagua-text',
          duration: 5000,
          existing: '.bagua-text-particle',
          generationRate: 500,
          particlesPerGeneration: 2,
          containerClass: 'bagua-floating-text'
        },
        {
          name: 'bagua-symbols', 
          duration: 5000,
          existing: '.bagua-symbol',
          generationRate: 300,
          particlesPerGeneration: 3,
          containerClass: 'bagua-symbols'
        },
        {
          name: 'void-particles',
          duration: 4000,
          existing: '.void-particle',
          generationRate: null,
          particlesPerGeneration: 0,
          containerClass: 'void-particles'
        },
        {
          name: 'taiji-symbols',
          duration: 3000,
          existing: '.yin-yang-emoji',
          generationRate: null,
          particlesPerGeneration: 0,
          containerClass: 'taiji-container'
        }
      ];
      
      const executePhase = () => {
        if (sequenceStep < injectionPhases.length) {
          const phase = injectionPhases[sequenceStep];
          console.log(`開始第${sequenceStep + 1}階段：${phase.name}`);
          
          // 執行增強的粒子動畫
          animateEnhancedParticles(phase, () => {
            sequenceStep++;
            if (sequenceStep < injectionPhases.length) {
              // 立即開始下一階段，不等待
              executePhase();
            } else {
              // 所有階段完成，開始清空UI
              setTimeout(() => {
                clearAllUIElements(() => {
                  // UI清空完成後，什麼都不做，等待進度條完成
                });
              }, 500);
            }
          });
        }
      };
      
      executePhase();
    }

    // 創建道的顯現場景（三行文字依次顯示）
    function createDaoRevelationScene(scene) {
      console.log('🌟 createDaoRevelationScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      try {
        // 清空所有內容，創建純白背景
        console.log('清空遊戲內容...');
        gameContent.innerHTML = '';
        
        console.log('設置純白背景...');
        gameContainer.style.background = '#ffffff';
        gameContainer.style.transition = 'background 2s ease';
        
        // 重要：移除氣形態的黑白濾鏡效果，確保文字正常顯示
        console.log('移除氣形態濾鏡效果...');
        removeQiVisionEffect();
        console.log('✅ 氣形態濾鏡已移除');
      } catch (error) {
        console.error('❌ createDaoRevelationScene 初始化失敗:', error);
        console.log('錯誤堆棧:', error.stack);
      }
      
      // 隱藏繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 創建三行文字容器
      const revelationContainer = document.createElement('div');
      revelationContainer.className = 'dao-revelation-container';
      revelationContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 20;
        width: 90%;
        max-width: 600px;
      `;
      
      // 三行文字內容
      const revelationTexts = [
        '道可道，非常道。',
        '道生一，一生二，二生三，三生萬物。',
        '道法自然。' 
      ];
      
      // 創建三行文字元素
      const textElements = revelationTexts.map((text, index) => {
        const textEl = document.createElement('div');
        textEl.className = 'dao-text-line';
        textEl.style.cssText = `
          font-size: 2rem;
          font-family: "Noto Serif SC", "Source Han Serif SC", serif;
          font-weight: 600;
          color: #000000;
          margin: 2rem 0;
          opacity: 0;
          transform: translateY(20px);
          transition: all 1.5s ease;
        `;
        textEl.textContent = text;
        return textEl;
      });
      
      // 添加文字元素到容器
      textElements.forEach(el => revelationContainer.appendChild(el));
      document.body.appendChild(revelationContainer);
      
      // 依次顯示三行文字
      let currentLine = 0;
      const showNextLine = () => {
        if (currentLine < textElements.length) {
          const currentEl = textElements[currentLine];
          setTimeout(() => {
            currentEl.style.opacity = '1';
            currentEl.style.transform = 'translateY(0)';
            currentLine++;
            setTimeout(showNextLine, 3000); // 每行間隔3秒（恢復原來的設計）
          }, 800); // 延長每行顯示前的等待時間（恢復原來的設計）
        } else {
          // 所有文字顯示完畢，創建繼續按鈕
          setTimeout(() => {
            createDaoRevelationContinueButton(revelationContainer);
        }, 2000);
        }
      };
      
      // 開始顯示文字
      setTimeout(showNextLine, 1500); // 延遲1.5秒開始（恢復原來的設計）
    }
    
    // 創建道的顯現場景的繼續按鈕
    function createDaoRevelationContinueButton(container) {
      const continueButton = document.createElement('button');
      continueButton.className = 'dao-continue-button';
      continueButton.style.cssText = `
        position: absolute;
        bottom: -120px;
        left: 50%;
        transform: translateX(-50%) translateY(20px);
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #000000, #333333);
        color: white;
        border: 2px solid #666666;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        opacity: 0;
        z-index: 21;
      `;
      continueButton.textContent = '繼續';
      
      // 添加按鈕到容器
      container.appendChild(continueButton);
      
      // 顯示按鈕動畫
      setTimeout(() => {
        continueButton.style.opacity = '1';
        continueButton.style.transform = 'translateX(-50%) translateY(0)';
      }, 100);
      
      // 懸停效果
      continueButton.addEventListener('mouseenter', () => {
        continueButton.style.background = 'linear-gradient(135deg, #333333, #555555)';
        continueButton.style.transform = 'translateX(-50%) translateY(-2px)';
        continueButton.style.boxShadow = '0 4px 12px rgba(0, 0, 0, 0.3)';
      });
      
      continueButton.addEventListener('mouseleave', () => {
        continueButton.style.background = 'linear-gradient(135deg, #000000, #333333)';
        continueButton.style.transform = 'translateX(-50%) translateY(0)';
        continueButton.style.boxShadow = 'none';
      });
      
      // 點擊事件
      continueButton.addEventListener('click', () => {
        console.log('🌟 道的顯現場景 - 繼續按鈕被點擊');
        console.log('當前狀態:', {
          currentChapter: gameState.currentChapter,
          currentScene: gameState.currentScene
        });
        
        // 檢查當前場景配置
        const currentChapter = gameChapters[gameState.currentChapter];
        if (currentChapter) {
          const currentScene = currentChapter.scenes[gameState.currentScene];
          console.log('當前場景配置:', currentScene);
          console.log('下一個場景ID:', currentScene ? currentScene.nextScene : '未找到場景');
        } else {
          console.error('❌ 找不到當前章節配置');
        }
        
        try {
          // 清理道的顯現場景
          console.log('清理道的顯現場景容器...');
          container.remove();
          

          
          // 恢復遊戲背景
          console.log('恢復遊戲背景...');
          gameContainer.style.background = '';
          gameContainer.style.transition = '';
          
          // 進入下一個場景
          console.log('準備進入下一個場景...');
          console.log('即將調用 advanceScene()');
          
          // 添加額外調試：檢查advanceScene函數是否存在
          if (typeof advanceScene === 'function') {
            console.log('✅ advanceScene函數存在，開始調用');
            advanceScene();
            console.log('✅ advanceScene調用完成');
          } else {
            console.error('❌ advanceScene函數不存在！');
          }
        } catch (error) {
          console.error('❌ 道的顯現場景繼續按鈕點擊處理失敗:', error);
          console.log('錯誤堆棧:', error.stack);
        }
      });
    }
    
    // 顯示尾聲章節標題
    function showEpilogueTitle() {
      console.log('🌟 顯示尾聲章節標題');
      
      // 創建標題容器
      const titleContainer = document.createElement('div');
      titleContainer.className = 'epilogue-title-container';
      titleContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 20;
        width: 90%;
        max-width: 600px;
      `;
      
      // 創建標題元素
      const titleElement = document.createElement('div');
      titleElement.className = 'epilogue-title';
      titleElement.style.cssText = `
        font-size: 3rem;
        font-family: "Noto Serif SC", "Source Han Serif SC", serif;
        font-weight: 700;
        color: #000000;
        margin-bottom: 1rem;
        opacity: 0;
        transform: translateY(30px);
        transition: all 2s ease;
      `;
      titleElement.textContent = '尾聲：逍遙遊';
      
      // 創建副標題元素
      const subtitleElement = document.createElement('div');
      subtitleElement.className = 'epilogue-subtitle';
      subtitleElement.style.cssText = `
        font-size: 1.5rem;
        font-family: "Noto Serif SC", "Source Han Serif SC", serif;
        font-weight: 400;
        color: #666666;
        margin-bottom: 3rem;
        opacity: 0;
        transform: translateY(20px);
        transition: all 2s ease;
        transition-delay: 1s;
      `;
      subtitleElement.textContent = '無用有什麼用？';
      
      titleContainer.appendChild(titleElement);
      titleContainer.appendChild(subtitleElement);
      document.body.appendChild(titleContainer);
      
      // 顯示標題動畫
      setTimeout(() => {
        titleElement.style.opacity = '1';
        titleElement.style.transform = 'translateY(0)';
      }, 500);
      
      // 顯示副標題動畫
      setTimeout(() => {
        subtitleElement.style.opacity = '1';
        subtitleElement.style.transform = 'translateY(0)';
      }, 1500);
      
      // 5秒後自動進入尾聲章節（增加延遲確保動畫完成）
      setTimeout(() => {
        console.log('🌟 自動進入尾聲章節');
        console.log('當前章節狀態:', gameState.currentChapter);
        console.log('當前場景狀態:', gameState.currentScene);
        
        // 清理標題容器
        titleContainer.remove();
        
        // 清理可能殘留的document.body元素
        const chapter7Elements = document.querySelectorAll('.fade-in-container, .dao-revelation-container');
        chapter7Elements.forEach(el => {
          if (el.parentNode === document.body) {
            console.log('清理殘留的document.body元素:', el);
            el.remove();
          }
        });
        
        // 確保gameContent可見且正確設置
        console.log('確保gameContent正確設置...');
        gameContent.style.display = 'block';
        gameContent.style.opacity = '1';
        gameContent.style.visibility = 'visible';
        
        // 重置gameContainer樣式
        gameContainer.style.background = '#ffffff';
        gameContainer.style.backgroundImage = 'none';
        gameContainer.style.filter = 'none';
        gameContainer.style.animation = 'none';
        gameContainer.style.transition = 'none';
        
        // 使用標準章節轉換流程
        console.log('🌟 使用標準章節轉換流程進入尾聲章節');
        startChapter('epilogue');
      }, 5000);
    }
    
    // 觸發增強的粒子序列（按照哲學順序：萬物歸道）
    function triggerExistingParticleSequence(onComplete) {
      let sequenceStep = 0;
      
      // 階段式粒子注入系統（按照用戶要求的順序）
      const injectionPhases = [
        {
          name: 'bagua-text',
          duration: 4000,           // 4秒持續時間
          existing: '.bagua-text-particle',
          generationRate: 500,      // 每0.5秒生成新粒子
          particlesPerGeneration: 2, // 每次生成2個
          containerClass: 'bagua-floating-text'
        },
        {
          name: 'bagua-symbols', 
          duration: 4000,
          existing: '.bagua-symbol',
          generationRate: 800,      // 每0.8秒生成新粒子
          particlesPerGeneration: 1,
          containerClass: 'bagua-symbols'
        },
        {
          name: 'void-particles',
          duration: 3000,
          existing: '.void-particle',
          generationRate: null,     // 不額外生成，50個已足夠
          particlesPerGeneration: 0,
          containerClass: 'void-particles'
        },
        {
          name: 'taiji-symbols',
          duration: 2000,
          existing: '.yin-yang-emoji',
          generationRate: null,     // 太極符號只有1個
          particlesPerGeneration: 0,
          containerClass: 'taiji-container'
        }
      ];
      
      const executePhase = () => {
        if (sequenceStep < injectionPhases.length) {
          const phase = injectionPhases[sequenceStep];
          console.log(`開始第${sequenceStep + 1}階段：${phase.name}`);
          
          // 執行增強的粒子動畫
          animateEnhancedParticles(phase, () => {
            sequenceStep++;
            setTimeout(executePhase, 800); // 每波間隔0.8秒
          });
        } else {
          // 所有粒子序列完成，開始清空UI
          clearAllUIElements(onComplete);
        }
      };
      
      executePhase();
    }
    
    // 增強的粒子動畫系統（支持動態生成和現有粒子）
    function animateEnhancedParticles(phase, onComplete) {
      const chaosForm = document.querySelector('.chaos-form');
      const container = document.querySelector(`.${phase.containerClass}`);
      
      if (!chaosForm) {
        console.log('未找到混沌圖形');
        onComplete();
        return;
      }
      
      const chaosRect = chaosForm.getBoundingClientRect();
      const chaosCenterX = chaosRect.left + chaosRect.width / 2;
      const chaosCenterY = chaosRect.top + chaosRect.height / 2;
      
      // 獲取現有粒子 - 改進選擇邏輯，覆蓋更廣範圍
      let existingParticles = [];
        if (phase.existing === '.bagua-text-particle') {
        // 從整個文檔中查找，不限於特定容器
        existingParticles = document.querySelectorAll('.bagua-text-particle');
        } else if (phase.existing === '.bagua-symbol') {
        // 查找所有八卦符號，包括容器內和容器外的
        existingParticles = document.querySelectorAll('.bagua-symbol');
        } else if (phase.existing === '.void-particle') {
        // 查找所有虛空粒子
        existingParticles = document.querySelectorAll('.void-particle');
        } else if (phase.existing === '.yin-yang-emoji') {
        // 查找所有太極符號
        existingParticles = document.querySelectorAll('.yin-yang-emoji');
      }
      
      // 過濾掉已經在動畫中的粒子
      existingParticles = Array.from(existingParticles).filter(particle => {
        return particle && 
               !particle.classList.contains('animating-to-center') && 
               !particle.classList.contains('injection-particle');
      });
      
      console.log(`${phase.name} 階段：找到 ${existingParticles.length} 個現有粒子`);
      
      // 立即開始動畫現有粒子
      if (existingParticles.length > 0) {
        animateParticlesToCenter(existingParticles, chaosCenterX, chaosCenterY);
      }
      
      // 如果需要動態生成新粒子
      if (phase.generationRate && phase.particlesPerGeneration > 0) {
        startDynamicParticleGeneration(phase, chaosCenterX, chaosCenterY, container);
      }
      
      // 在階段持續時間結束後完成
      setTimeout(() => {
        // 停止動態生成（如果有的話）
        if (phase.generationInterval) {
          clearInterval(phase.generationInterval);
        }
        
        // 移除容器（如果需要的話）
        if (container && phase.name !== 'void-particles') {
          // 保留虛空粒子容器，因為其他階段可能還需要
          setTimeout(() => {
            if (document.contains(container)) {
              container.remove();
            }
          }, 2000);
        }
        
        onComplete();
      }, phase.duration);
    }
    
    // 讓粒子飛向混沌中心
    function animateParticlesToCenter(particles, centerX, centerY) {
      particles.forEach((particle, index) => {
        if (particle) {
          // 標記粒子為動畫中，避免重複選擇
          particle.classList.add('animating-to-center');
          
          // 停止現有動畫
          particle.style.animation = 'none';
          
          // 特殊處理太極符號
          if (particle.classList.contains('yin-yang-emoji') || particle.className.includes('yin-yang-emoji')) {
            particle.style.transition = 'all 2.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            particle.style.zIndex = '30';
            
            setTimeout(() => {
              particle.style.position = 'fixed';
              particle.style.left = `${centerX}px`;
              particle.style.top = `${centerY}px`;
              particle.style.opacity = '0';
              particle.style.transform = 'translate(-50%, -50%) scale(0.1) rotate(720deg)';
              particle.style.filter = 'blur(5px)';
            }, index * 100);
          } else {
            // 其他粒子的正常處理
            particle.style.transition = 'all 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            particle.style.zIndex = '25';
            
            setTimeout(() => {
              particle.style.position = 'fixed';
              particle.style.left = `${centerX}px`;
              particle.style.top = `${centerY}px`;
              particle.style.opacity = '0';
              particle.style.transform = 'translate(-50%, -50%) scale(0.3)';
            }, index * 80);
          }
        }
      });
    }
    
    // 動態生成新粒子並讓它們飛向中心
    function startDynamicParticleGeneration(phase, centerX, centerY, container) {
      if (!container) return;
      
      // 初始化全局間隔跟蹤
      if (!window.currentInjectionIntervals) {
        window.currentInjectionIntervals = [];
      }
      
      let generationCount = 0;
      const maxGenerations = Math.floor(phase.duration / phase.generationRate);
      
      phase.generationInterval = setInterval(() => {
        if (generationCount >= maxGenerations) {
          clearInterval(phase.generationInterval);
          // 從跟蹤列表中移除
          const index = window.currentInjectionIntervals.indexOf(phase.generationInterval);
          if (index > -1) {
            window.currentInjectionIntervals.splice(index, 1);
          }
          return;
        }
        
        // 生成新粒子
        for (let i = 0; i < phase.particlesPerGeneration; i++) {
          const newParticle = createInjectionParticle(phase.name);
          if (newParticle) {
            container.appendChild(newParticle);
            
            // 立即讓新粒子飛向中心
            setTimeout(() => {
              animateParticlesToCenter([newParticle], centerX, centerY);
            }, 100);
          }
        }
        
        generationCount++;
      }, phase.generationRate);
      
      // 跟蹤這個間隔，以便在重置時清理
      window.currentInjectionIntervals.push(phase.generationInterval);
    }
    
    // 創建注入專用粒子
    function createInjectionParticle(particleType) {
      let particle;
      
      if (particleType === 'bagua-text') {
        particle = document.createElement('div');
        particle.className = 'bagua-text-particle injection-particle';
        
        // 八卦文字內容
        const baguaTexts = [
          { text: '乾', color: '#FFD700' }, { text: '兌', color: '#C0C0C0' },
          { text: '離', color: '#FF6347' }, { text: '震', color: '#32CD32' },
          { text: '巽', color: '#87CEEB' }, { text: '坎', color: '#4169E1' },
          { text: '艮', color: '#8B4513' }, { text: '坤', color: '#DAA520' },
          { text: '天', color: '#FFD700' }, { text: '澤', color: '#C0C0C0' },
          { text: '火', color: '#FF6347' }, { text: '雷', color: '#32CD32' },
          { text: '風', color: '#87CEEB' }, { text: '水', color: '#4169E1' },
          { text: '山', color: '#8B4513' }, { text: '地', color: '#DAA520' }
        ];
        
        const randomText = baguaTexts[Math.floor(Math.random() * baguaTexts.length)];
        particle.textContent = randomText.text;
        
        // 樣式設置
        particle.style.position = 'absolute';
        particle.style.fontSize = `${20 + Math.random() * 16}px`;
        particle.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
        particle.style.fontWeight = '600';
        particle.style.color = randomText.color;
        particle.style.textShadow = `0 0 15px ${randomText.color}, 0 0 30px ${randomText.color}80`;
        particle.style.left = `${Math.random() * 85 + 7.5}%`;
        particle.style.top = `${Math.random() * 85 + 7.5}%`;
        particle.style.zIndex = '12';
        
      } else if (particleType === 'bagua-symbols') {
        particle = document.createElement('div');
        particle.className = 'bagua-symbol injection-particle';
        
        const baguaSymbols = ['☰', '☱', '☲', '☳', '☴', '☵', '☶', '☷'];
        particle.textContent = baguaSymbols[Math.floor(Math.random() * baguaSymbols.length)];
        
        particle.style.position = 'absolute';
        particle.style.fontSize = '24px';
        particle.style.left = `${Math.random() * 90 + 5}%`;
        particle.style.top = `${Math.random() * 90 + 5}%`;
        particle.style.zIndex = '13';
        particle.style.color = '#ffffff';
        particle.style.textShadow = '0 0 10px rgba(255,255,255,0.8)';
      }
      
      return particle;
    }
    
    // 清空所有UI元素
    function clearAllUIElements(onComplete) {
      const elementsToFade = document.querySelectorAll('body > *:not(script)');
      
      elementsToFade.forEach(element => {
        if (element.tagName !== 'SCRIPT') {
          element.style.transition = 'opacity 2s ease-out';
          element.style.opacity = '0';
        }
      });
      
      // 2秒後設置純白背景
      setTimeout(() => {
        document.body.style.background = '#ffffff';
        document.body.style.transition = 'background 1s ease';
        
        // 移除所有可見元素
        elementsToFade.forEach(element => {
          if (element.tagName !== 'SCRIPT') {
            element.style.display = 'none';
          }
        });
        
        onComplete();
      }, 2000);
    }

    // 創建製作人員名單場景
    function createCreditsScene(scene) {
      console.log('🎬 createCreditsScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 設置漸變背景
      gameContainer.style.background = 'linear-gradient(135deg, #1a1a2e, #16213e, #0f3460)';
      gameContainer.style.transition = 'background 2s ease';
      
      // 隱藏繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 創建製作人員名單容器
      const creditsContainer = document.createElement('div');
      creditsContainer.className = 'credits-container';
      creditsContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 20;
        width: 90%;
        max-width: 500px;
        color: #ffffff;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
      `;
      
      // 添加遊戲標題
      const titleElement = document.createElement('h1');
      titleElement.className = 'credits-title';
      titleElement.style.cssText = `
        font-size: 3rem;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        font-weight: 700;
        color: #FFD700;
        margin-bottom: 2rem;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        opacity: 0;
        transform: translateY(-30px);
        transition: all 2s ease;
      `;
      titleElement.textContent = scene.title || '萬物逍遙';
      creditsContainer.appendChild(titleElement);
      
      // 添加製作人員名單
      const creditsListElement = document.createElement('div');
      creditsListElement.className = 'credits-list';
      creditsListElement.style.cssText = `
        opacity: 0;
        transform: translateY(30px);
        transition: all 2s ease 1s;
      `;
      
      // 處理製作人員名單
      if (scene.credits && Array.isArray(scene.credits)) {
        scene.credits.forEach((credit, index) => {
          const creditLine = document.createElement('div');
          creditLine.className = 'credit-line';
          creditLine.style.cssText = `
            font-size: ${credit === '' ? '0.5rem' : '1.2rem'};
            font-family: "LXGW WenKai", "Noto Serif TC", serif;
            font-weight: ${credit.includes('開發者') ? '600' : '400'};
            color: ${credit.includes('開發者') ? '#87CEEB' : '#ffffff'};
            margin: ${credit === '' ? '0.5rem 0' : '0.8rem 0'};
            line-height: 1.6;
          `;
          creditLine.textContent = credit === '' ? ' ' : credit;
          creditsListElement.appendChild(creditLine);
        });
      }
      
      creditsContainer.appendChild(creditsListElement);
      
      // 添加感謝文字
      const thanksElement = document.createElement('div');
      thanksElement.className = 'credits-thanks';
      thanksElement.style.cssText = `
        font-size: 1rem;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        color: #C0C0C0;
        margin-top: 2rem;
        opacity: 0;
        transform: translateY(20px);
        transition: all 2s ease 3s;
      `;
      thanksElement.textContent = '感謝您的遊玩';
      creditsContainer.appendChild(thanksElement);
      
      // 添加到頁面
      document.body.appendChild(creditsContainer);
      
      // 啟動動畫序列
      setTimeout(() => {
        // 顯示標題
        titleElement.style.opacity = '1';
        titleElement.style.transform = 'translateY(0)';
      }, 500);
      
      setTimeout(() => {
        // 顯示製作人員名單
        creditsListElement.style.opacity = '1';
        creditsListElement.style.transform = 'translateY(0)';
      }, 1500);
      
      setTimeout(() => {
        // 顯示感謝文字
        thanksElement.style.opacity = '1';
        thanksElement.style.transform = 'translateY(0)';
      }, 3500);
      
      // 5秒後創建AI報告按鈕和結束按鈕
      setTimeout(() => {
        createAIReportButton(creditsContainer);
        createCreditsEndButton(creditsContainer);
      }, 5000);
    }
    
    // 創建AI個性化報告按鈕
    function createAIReportButton(container) {
      const reportButton = document.createElement('button');
      reportButton.className = 'ai-report-button';
      reportButton.style.cssText = `
        margin: 2rem 0 1rem 0;
        padding: 1.2rem 2.5rem;
        background: linear-gradient(135deg, #4F46E5, #7C3AED);
        color: #ffffff;
        border: none;
        border-radius: 12px;
        font-size: 1.2rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.4s ease;
        opacity: 0;
        transform: translateY(20px);
        box-shadow: 0 4px 20px rgba(79, 70, 229, 0.4);
        position: relative;
        overflow: hidden;
        display: block;
        width: 100%;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
      `;
      reportButton.innerHTML = '🎁 神秘禮物';
      
      // 添加呼吸動畫效果
      const breathingAnimation = `
        @keyframes breathing-glow {
          0%, 100% { 
            box-shadow: 0 4px 20px rgba(79, 70, 229, 0.4);
            transform: translateY(0) scale(1);
          }
          50% { 
            box-shadow: 0 8px 30px rgba(79, 70, 229, 0.8);
            transform: translateY(-2px) scale(1.02);
          }
        }
      `;
      
      if (!document.getElementById('breathing-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'breathing-animation';
        styleElement.textContent = breathingAnimation;
        document.head.appendChild(styleElement);
      }
      
      // 添加按鈕到容器
      container.appendChild(reportButton);
      
      // 顯示按鈕動畫
      setTimeout(() => {
        reportButton.style.opacity = '1';
        reportButton.style.transform = 'translateY(0)';
        reportButton.style.animation = 'breathing-glow 3s ease-in-out infinite';
      }, 100);
      
      // 懸停效果
      reportButton.addEventListener('mouseenter', () => {
        reportButton.style.background = 'linear-gradient(135deg, #7C3AED, #A855F7)';
        reportButton.style.transform = 'translateY(-3px) scale(1.05)';
        reportButton.style.boxShadow = '0 8px 30px rgba(124, 58, 237, 0.8)';
        reportButton.style.animation = 'none';
      });
      
      reportButton.addEventListener('mouseleave', () => {
        reportButton.style.background = 'linear-gradient(135deg, #4F46E5, #7C3AED)';
        reportButton.style.transform = 'translateY(0) scale(1)';
        reportButton.style.boxShadow = '0 4px 20px rgba(79, 70, 229, 0.4)';
        reportButton.style.animation = 'breathing-glow 3s ease-in-out infinite';
      });
      
      // 點擊事件 - 生成莊子的神秘禮物
      reportButton.addEventListener('click', () => {
        console.log('🎁 神秘禮物按鈕被點擊');
        
        // 切換到神秘禮物專用音樂
        switchToMysteriousGiftMusic();
        
        generateAIPersonalizedReport();
      });
    }
    
    // 生成莊子的神秘禮物
    function generateAIPersonalizedReport() {
      console.log('🎁 開始生成莊子的神秘禮物');
      
      // 獲取完整的玩家數據
      const playerData = getCompletePlayerData();
      console.log('📊 玩家數據:', playerData);
      
      // 構建AI提示詞
      const prompt = buildAIReportPrompt(playerData);
      
      // 顯示加載狀態
      showReportLoadingModal();
      
      // 調用AI生成莊子的信
      zhuangziAI.generatePersonalizedReport(prompt)
        .then(report => {
          console.log('✅ 莊子的信生成成功:', report);
          showAIReportModal(report);
        })
        .catch(error => {
          console.error('❌ 莊子的信生成失敗:', error);
          showReportErrorModal();
        });
    }
    
    // 構建莊子信的提示詞
    function buildAIReportPrompt(playerData) {
      const totalPlayTime = Math.round(playerData.totalPlayTime / 1000 / 60); // 轉換為分鐘
      const avgSceneTime = Math.round(playerData.averageSceneDwellTime / 1000); // 轉換為秒
      
      // 構建選擇歷史摘要
      const choiceSummary = playerData.choiceHistory.length > 0 ? 
        playerData.choiceHistory.slice(-10).map((choice, index) => 
          `${index + 1}. [${choice.chapter}] ${choice.choiceText} (思考時間: ${Math.round(choice.thinkingTime / 1000)}秒)`
        ).join('\n') : '無選擇記錄';
      
      return `你是莊子本人，現在要穿越時空，為一位剛剛完成《莊子：萬物逍遙》遊戲的現代玩家寫一封親筆信。

遊戲名稱：《莊子：萬物逍遙》

這位玩家的遊戲數據：
1. 遊戲總時長：${totalPlayTime}分鐘
2. 平均場景停留時間：${avgSceneTime}秒
3. 總選擇次數：${playerData.totalChoices}次
4. 物化體驗：使用過${playerData.transformationData.totalTransformations}次物化，偏好形態：${playerData.transformationData.transformationPatterns.preferredForms.join('、')}
5. 斷句挑戰：完成${playerData.segmentationPuzzleData.totalPuzzles}個挑戰，平均準確率${(playerData.segmentationPuzzleData.averageAccuracy * 100).toFixed(1)}%，平均完成時間${Math.round(playerData.segmentationPuzzleData.averageCompletionTime / 1000)}秒

這位玩家的哲學傾向：
- 同理心：${playerData.philosophicalTraits.compassion}/100
- 超脫性：${playerData.philosophicalTraits.detachment}/100
- 求知欲：${playerData.philosophicalTraits.curiosity}/100
- 接納度：${playerData.philosophicalTraits.acceptance}/100
- 美學傾向：${playerData.philosophicalTraits.aesthetic}/100
- 和諧追求：${playerData.philosophicalTraits.harmony}/100

這位玩家的MBTI傾向：
- 外向性(E)/內向性(I)：${playerData.mbtiTraits.extraversion || 0}/100
- 感覺(S)/直覺(N)：${playerData.mbtiTraits.sensing || 0}/100
- 思考(T)/情感(F)：${playerData.mbtiTraits.thinking || 0}/100
- 判斷(J)/知覺(P)：${playerData.mbtiTraits.judging || 0}/100

這位玩家的故事特質：
- 冒險精神：${playerData.storyTraits.adventure_spirit || 0}/100
- 探索驅動力：${playerData.storyTraits.exploration_drive || 0}/100
- 哲學深度：${playerData.storyTraits.philosophical_depth || 0}/100
- 和諧追求：${playerData.storyTraits.harmony_seeking || 0}/100
- 想像力投入：${playerData.storyTraits.imaginative_engagement || 0}/100
- 美學敏感性：${playerData.storyTraits.aesthetic_sensitivity || 0}/100

這位玩家的關鍵選擇記錄（最近10個）：
${choiceSummary}

請以莊子的身份，寫一封800-1000字的親筆信，包含：

1. **開場問候**：以莊子的身份，穿越時空向這位現代朋友問候，表達對他們完成遊戲的祝賀
2. **個性洞察**：基於遊戲數據和選擇記錄，深入分析這位朋友的個性特點、思考模式和決策風格，讓他們感受到被深度理解。特別關注：
   - 他們在不同情境下的選擇傾向（如面對未知時的態度、與他人互動的方式、解決問題的思維模式）
   - 思考時間反映的決策風格（快速決斷vs深思熟慮）
   - 哲學傾向與實際選擇的一致性
   - MBTI傾向如何影響他們的決策和互動方式
   - 故事特質如何體現在他們的冒險精神和價值觀中
3. **生活啟示**：針對他們的個性特點和選擇模式，給出具體的生活建議和人生啟示
4. **情感連結**：建立莊子與這位現代朋友之間的情感連結，讓他們感受到莊子的關懷
5. **未來指引**：針對他們的未來生活、人生發展給出溫暖而智慧的指導
6. **結語祝福**：以莊子的智慧，給出鼓勵性的結語和美好祝福

寫作要求：
- **身份定位**：你就是莊子本人，用第一人稱"我"來寫，就像真的莊子在和這位朋友對話
- **情感基調**：溫暖、親切、充滿關懷，像長輩對晚輩的慈愛指導
- **語言風格**：繁體中文，親切自然，避免文言文，但要有莊子的智慧深度
- **啟示性**：重點在於給出對個性和生活的啟示，讓讀者有所感悟
- **感動性**：要有情感衝擊力，讓讀者讀完後感到溫暖、感動、有所啟發
- **實用性**：給出具體的生活建議，不只是抽象的哲學討論

這封信應該讓讀者感受到：莊子真的穿越時空來關心他們，理解他們，並為他們的人生提供智慧的指引。

**重要：請使用繁體中文書寫整封信件內容。**`;
    }
    
    // 顯示報告加載模態框
    function showReportLoadingModal() {
      const modal = document.createElement('div');
      modal.id = 'report-loading-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 20px;
        padding: 3rem;
        text-align: center;
        color: white;
        max-width: 400px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      `;
      
      content.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 1rem;">🎁</div>
        <h2 style="font-family: 'LXGW WenKai', serif; margin-bottom: 1rem;">莊子正在為您寫信...</h2>
        <p style="color: #87CEEB; margin-bottom: 2rem;">穿越時空的智慧正在凝聚</p>
        <div class="loading-spinner" style="
          width: 40px;
          height: 40px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid #4F46E5;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto;
        "></div>
      `;
      
      // 添加旋轉動畫
      const spinAnimation = `
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      
      if (!document.getElementById('spin-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'spin-animation';
        styleElement.textContent = spinAnimation;
        document.head.appendChild(styleElement);
      }
      
      modal.appendChild(content);
      document.body.appendChild(modal);
    }
    
    // 顯示AI報告模態框
    function showAIReportModal(report) {
      // 移除加載模態框
      const loadingModal = document.getElementById('report-loading-modal');
      if (loadingModal) {
        loadingModal.remove();
      }
      
      const modal = document.createElement('div');
      modal.id = 'ai-report-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
        padding: 2rem;
        box-sizing: border-box;
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 20px;
        padding: 2rem;
        color: white;
        max-width: 800px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        position: relative;
      `;
      
              content.innerHTML = `
          <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">🎁</div>
            <h1 style="font-family: 'LXGW WenKai', serif; color: #FFD700; margin-bottom: 0.5rem;">莊子給您的信</h1>
            <p style="color: #87CEEB; font-size: 1.1rem;">穿越時空的智慧與關懷</p>
          </div>
        <div style="
          background: rgba(255, 255, 255, 0.05);
          border-radius: 15px;
          padding: 2rem;
          margin-bottom: 2rem;
          border-left: 4px solid #4F46E5;
        ">
          <div style="white-space: pre-wrap; line-height: 1.8; font-family: 'LXGW WenKai', serif; font-size: 1.1rem;">
            ${report}
          </div>
        </div>
        <div style="text-align: center;">
          <button id="download-report-btn" style="
            background: linear-gradient(135deg, #4F46E5, #7C3AED);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            margin-right: 1rem;
            transition: all 0.3s ease;
          ">📥 下載信件</button>
          <button id="close-report-btn" style="
            background: linear-gradient(135deg, #6B7280, #4B5563);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
          ">關閉</button>
        </div>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // 添加按鈕事件
      document.getElementById('download-report-btn').addEventListener('click', async () => {
        await downloadReportAsImage(report);
      });
      
      document.getElementById('close-report-btn').addEventListener('click', () => {
        modal.remove();
      });
      
      // 點擊背景關閉
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }
    
    // 顯示報告錯誤模態框
    function showReportErrorModal() {
      const loadingModal = document.getElementById('report-loading-modal');
      if (loadingModal) {
        loadingModal.remove();
      }
      
      const modal = document.createElement('div');
      modal.id = 'report-error-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 20px;
        padding: 3rem;
        text-align: center;
        color: white;
        max-width: 400px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      `;
      
      content.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 1rem;">⚠️</div>
        <h2 style="font-family: 'LXGW WenKai', serif; margin-bottom: 1rem;">莊子的信生成失敗</h2>
        <p style="color: #FCA5A5; margin-bottom: 2rem;">網路連接問題，請稍後再試</p>
        <button id="retry-report-btn" style="
          background: linear-gradient(135deg, #4F46E5, #7C3AED);
          color: white;
          border: none;
          border-radius: 10px;
          padding: 1rem 2rem;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
        ">重試</button>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      document.getElementById('retry-report-btn').addEventListener('click', () => {
        modal.remove();
        generateAIPersonalizedReport();
      });
    }
    
    // 下載莊子的信為圖片
    async function downloadReportAsImage(report) {
      // 預載logo圖片
      const logoImg = new Image();
      logoImg.crossOrigin = 'anonymous';
      
      // 等待logo圖片加載完成
      await new Promise((resolve, reject) => {
        logoImg.onload = resolve;
        logoImg.onerror = () => {
          console.warn('Logo圖片加載失敗，將繼續生成不含logo的信件');
          resolve(); // 即使失敗也繼續執行
        };
        logoImg.src = 'https://raw.githubusercontent.com/chineseclassics/chineseclassics.github.io/main/images/cclogo.png';
      });
      
      // 創建畫布
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // 獲取設備像素比，提高清晰度
      const devicePixelRatio = window.devicePixelRatio || 1;
      const scaleFactor = Math.max(devicePixelRatio, 2); // 至少2倍清晰度
      
      // 設置高分辨率畫布尺寸 (加長版，確保能容納完整信件)
      const baseWidth = 800;
      const baseHeight = 1600; // 增加高度以容納更多內容
      canvas.width = baseWidth * scaleFactor;
      canvas.height = baseHeight * scaleFactor;
      
      // 設置CSS尺寸保持原始比例
      canvas.style.width = baseWidth + 'px';
      canvas.style.height = baseHeight + 'px';
      
      // 縮放上下文以匹配設備像素比
      ctx.scale(scaleFactor, scaleFactor);
      
      // 啟用高質量文字渲染
      ctx.textRenderingOptimization = 'optimizeQuality';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // 設置古風暖色調背景
      const gradient = ctx.createLinearGradient(0, 0, 0, baseHeight);
      gradient.addColorStop(0, '#8B4513'); // 深褐色
      gradient.addColorStop(0.5, '#A0522D'); // 赭石色
      gradient.addColorStop(1, '#654321'); // 深棕色
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, baseWidth, baseHeight);
      
      // 添加米黃色宣紙質感背景（擴大區域）
      const paperGradient = ctx.createLinearGradient(0, 0, 0, baseHeight);
      paperGradient.addColorStop(0, '#F5F5DC'); // 米色
      paperGradient.addColorStop(0.3, '#FFF8DC'); // 玉米絲色
      paperGradient.addColorStop(0.7, '#FFFACD'); // 檸檬雪紡色
      paperGradient.addColorStop(1, '#F0E68C'); // 卡其色
      ctx.fillStyle = paperGradient;
      ctx.fillRect(30, 50, baseWidth - 60, baseHeight - 100);
      
      // 添加古風邊框
      ctx.strokeStyle = '#8B4513'; // 深褐色邊框
      ctx.lineWidth = 3;
      ctx.strokeRect(30, 50, baseWidth - 60, baseHeight - 100);
      
      // 添加內側細邊框
      ctx.strokeStyle = '#CD853F'; // 秘魯色
      ctx.lineWidth = 1;
      ctx.strokeRect(40, 60, baseWidth - 80, baseHeight - 120);
      
      // 設置文字樣式 - 使用黑體思源宋體標題
      ctx.fillStyle = '#000000'; // 黑色標題
      ctx.font = 'bold 36px "Noto Serif SC", "Noto Serif TC", serif';
      ctx.textAlign = 'center';
      
      // 繪製標題
      ctx.fillText('莊子給你的信', baseWidth / 2, 120);
      
      // 繪製分隔線
      ctx.strokeStyle = '#D2691E'; // 巧克力色分隔線
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(70, 160);
      ctx.lineTo(baseWidth - 70, 160);
      ctx.stroke();
      
      // 繪製信件內容
      ctx.fillStyle = '#654321'; // 深棕色正文
      ctx.font = '18px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'left';
      
      // 處理文字換行（調整邊距）
      const lines = wrapText(ctx, report, baseWidth - 120, 18);
      const lineHeight = 26; // 增大行高以配合更大字體
      let y = 190; // 從更靠上的位置開始
      
      // 計算所需的總高度
      const contentHeight = lines.length * lineHeight;
      const minRequiredHeight = 190 + contentHeight + 160; // 內容開始位置 + 內容高度 + 底部空間（增加空間容納logo和底部文字）
      
      // 如果需要更多空間，動態調整畫布高度
      let actualHeight = baseHeight;
      if (minRequiredHeight > baseHeight) {
        actualHeight = minRequiredHeight;
        
        // 重新設置畫布高度
        canvas.height = actualHeight * scaleFactor;
        canvas.style.height = actualHeight + 'px';
        
        // 重新繪製古風暖色調背景（因為高度改變了）
        const newGradient = ctx.createLinearGradient(0, 0, 0, actualHeight);
        newGradient.addColorStop(0, '#8B4513'); // 深褐色
        newGradient.addColorStop(0.5, '#A0522D'); // 赭石色
        newGradient.addColorStop(1, '#654321'); // 深棕色
        ctx.fillStyle = newGradient;
        ctx.fillRect(0, 0, baseWidth, actualHeight);
        
        // 重新繪製米黃色宣紙背景
        const newPaperGradient = ctx.createLinearGradient(0, 0, 0, actualHeight);
        newPaperGradient.addColorStop(0, '#F5F5DC'); // 米色
        newPaperGradient.addColorStop(0.3, '#FFF8DC'); // 玉米絲色
        newPaperGradient.addColorStop(0.7, '#FFFACD'); // 檸檬雪紡色
        newPaperGradient.addColorStop(1, '#F0E68C'); // 卡其色
        ctx.fillStyle = newPaperGradient;
        ctx.fillRect(30, 50, baseWidth - 60, actualHeight - 100);
        
        // 重新繪製古風邊框
        ctx.strokeStyle = '#8B4513'; // 深褐色邊框
        ctx.lineWidth = 3;
        ctx.strokeRect(30, 50, baseWidth - 60, actualHeight - 100);
        
        // 重新繪製內側細邊框
        ctx.strokeStyle = '#CD853F'; // 秘魯色
        ctx.lineWidth = 1;
        ctx.strokeRect(40, 60, baseWidth - 80, actualHeight - 120);
        
        // 重新繪製標題區域
        ctx.fillStyle = '#000000'; // 黑色標題
        ctx.font = 'bold 36px "Noto Serif SC", "Noto Serif TC", serif';
        ctx.textAlign = 'center';
        ctx.fillText('莊子給你的信', baseWidth / 2, 120);
        
        ctx.strokeStyle = '#D2691E'; // 巧克力色分隔線
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(70, 160);
        ctx.lineTo(baseWidth - 70, 160);
        ctx.stroke();
        
        // 重新設置信件內容樣式
        ctx.fillStyle = '#654321'; // 深棕色正文
        ctx.font = '18px "LXGW WenKai", "Noto Serif TC", serif';
        ctx.textAlign = 'left';
      }
      
      // 繪製所有行，不再截斷
      lines.forEach((line, index) => {
        ctx.fillText(line, 60, y);
        y += lineHeight;
      });
      
      // 繪製logo - 右對齊，底部與米色區域邊線保持間距
      if (logoImg.complete && logoImg.naturalWidth > 0) {
        // 計算logo的原始比例
        const originalWidth = logoImg.naturalWidth;
        const originalHeight = logoImg.naturalHeight;
        const aspectRatio = originalWidth / originalHeight;
        
        // 設置logo的目標寬度，並根據比例計算高度
        const logoWidth = 100; // logo寬度
        const logoHeight = logoWidth / aspectRatio; // 保持原始比例
        
        const logoX = baseWidth - logoWidth - 60; // 右對齊，距離右邊60像素
        const logoY = actualHeight - 70 - logoHeight; // logo底部與米色區域邊線保持20像素間距
        
        ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
      }
      
      // 繪製底部信息 - 向上移動，與日期保持舒適間距
      ctx.fillStyle = '#4A4A4A'; // 深灰色底部信息
      ctx.font = '14px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'center';
      ctx.fillText('此信件由游戲《萬物逍遙》生成，基於你的游戲歷程數據', baseWidth / 2, actualHeight - 100);
      
      // 添加日期 - 居中對齊，向上移動
      const now = new Date();
      const dateStr = `${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日`;
      ctx.fillStyle = '#2F4F4F'; // 深石板灰色日期
      ctx.font = '12px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'center';
      ctx.fillText(dateStr, baseWidth / 2, actualHeight - 75);
      
      // 下載圖片 - 使用高質量PNG
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `莊子的信_${dateStr}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showToast('📥 莊子的信已下載完成！高清版本已保存');
      }, 'image/png', 1.0); // 最高質量
    }
    
    // 文字換行輔助函數
    function wrapText(ctx, text, maxWidth, fontSize) {
      const lines = [];
      const paragraphs = text.split('\n');
      
      paragraphs.forEach(paragraph => {
        if (paragraph.trim() === '') {
          lines.push('');
          return;
        }
        
        // 對於中文文字，按字符分割而不是按單詞
        const chars = paragraph.split('');
        let currentLine = '';
        
        for (let i = 0; i < chars.length; i++) {
          const testLine = currentLine + chars[i];
          const metrics = ctx.measureText(testLine);
          
          if (metrics.width > maxWidth && currentLine !== '') {
            lines.push(currentLine);
            currentLine = chars[i];
        } else {
            currentLine = testLine;
          }
        }
        
        if (currentLine !== '') {
          lines.push(currentLine);
        }
      });
      
      return lines;
    }
    
    // 複製到剪貼板
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('莊子的信已複製到剪貼板！');
      }).catch(() => {
        showToast('複製失敗，請手動複製');
      });
    }
    
    // 顯示提示信息
    function showToast(message) {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #4F46E5, #7C3AED);
        color: white;
        padding: 1rem 2rem;
        border-radius: 10px;
        font-weight: 600;
        z-index: 10001;
        animation: slideIn 0.3s ease;
      `;
      toast.textContent = message;
      
      const slideInAnimation = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      
      if (!document.getElementById('slide-in-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'slide-in-animation';
        styleElement.textContent = slideInAnimation;
        document.head.appendChild(styleElement);
      }
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }
    
    // 創建製作人員名單的結束按鈕
    function createCreditsEndButton(container) {
      const endButton = document.createElement('button');
      endButton.className = 'credits-end-button';
      endButton.style.cssText = `
        margin: 1rem 0 2rem 0;
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #FFD700, #FFA500);
        color: #000000;
        border: none;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(20px);
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        display: block;
        width: 100%;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
      `;
      endButton.textContent = '重新開始遊戲';
      
      // 添加按鈕到容器
      container.appendChild(endButton);
      
      // 顯示按鈕動畫
      setTimeout(() => {
        endButton.style.opacity = '1';
        endButton.style.transform = 'translateY(0)';
      }, 100);
      
      // 懸停效果
      endButton.addEventListener('mouseenter', () => {
        endButton.style.background = 'linear-gradient(135deg, #FFA500, #FF8C00)';
        endButton.style.transform = 'translateY(-2px)';
        endButton.style.boxShadow = '0 6px 20px rgba(255, 215, 0, 0.6)';
      });
      
      endButton.addEventListener('mouseleave', () => {
        endButton.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
        endButton.style.transform = 'translateY(0)';
        endButton.style.boxShadow = '0 4px 15px rgba(255, 215, 0, 0.4)';
      });
      
      // 點擊事件 - 重新開始遊戲
      endButton.addEventListener('click', () => {
        console.log('🎬 製作人員名單 - 重新開始遊戲按鈕被點擊');
        
        // 清理製作人員名單場景
        container.remove();
        
        // 恢復遊戲背景
        gameContainer.style.background = '';
        gameContainer.style.transition = '';
        
        // 重新開始遊戲
        location.reload();
      });
    }

    // 創建空白浮現場景
    function createBlankEmergenceScene(scene) {
      console.log('🌟 createBlankEmergenceScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 檢查是否還有白色覆蓋層殘留
      const existingOverlay = document.getElementById('white-transition-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      // 清理可能殘留的document.body元素（從第七章場景38、39過渡）
      const chapter7Elements = document.querySelectorAll('.fade-in-container, .dao-revelation-container, .epilogue-title-container');
      chapter7Elements.forEach(el => {
        if (el.parentNode === document.body) {
          console.log('清理殘留的document.body元素:', el);
          el.remove();
        }
      });
      
      // 確保gameContent可見且正確設置
      console.log('確保gameContent正確設置...');
      gameContent.style.display = 'block';
      gameContent.style.opacity = '1';
      gameContent.style.visibility = 'visible';
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 清除所有背景样式，确保白色背景
      gameContainer.classList.remove('epilogue-scene', 'void-scene', 'dream-scene', 'water-scene', 'cloud-scene', 'forest-scene', 'spiral-scene', 'time-scene', 'heaven-earth-scene');
      gameContainer.classList.add('blank-emergence-scene');
      
      // 强制设置白色背景，清除任何内联样式
      gameContainer.style.background = '#ffffff';
      gameContainer.style.backgroundImage = 'none';
      gameContainer.style.filter = 'none';
      gameContainer.style.animation = 'none';
      gameContainer.style.transition = 'none';
      
      // 確保gameContainer可見
      gameContainer.style.display = 'block';
      gameContainer.style.opacity = '1';
      gameContainer.style.visibility = 'visible';
      
      console.log('🌟 gameContainer樣式已重置為白色背景');
      
      // 隱藏繼續按鈕，稍後會顯示
      advanceBtn.style.display = 'none';
      
      // 隱藏物化按鈕
      gameUI.style.opacity = 0;
      
      // 創建浮現文字容器
      const textContainer = document.createElement('div');
      textContainer.className = 'blank-emergence-text';
      textContainer.textContent = scene.text;
      textContainer.style.zIndex = '100';
      textContainer.style.position = 'absolute';
      textContainer.style.color = '#333333';
      
      // 添加到遊戲內容
      gameContent.appendChild(textContainer);
      
      // 強制重繪確保樣式生效
      gameContainer.offsetHeight;
      textContainer.offsetHeight;
      
      // 3秒後顯示繼續按鈕
      setTimeout(() => {
        console.log('🌟 空白浮現場景：顯示繼續按鈕');
        advanceBtn.style.display = 'block';
        advanceBtn.style.opacity = '0';
        advanceBtn.style.transition = 'opacity 1s ease';
        
        setTimeout(() => {
          advanceBtn.style.opacity = '1';
          console.log('🌟 空白浮現場景：繼續按鈕動畫完成');
        }, 100);
      }, 3000);
    }

    // 創建最終冥想場景
    function createFinalMeditationScene(scene) {
      console.log('🧘 createFinalMeditationScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 隱藏繼續按鈕，稍後顯示
      advanceBtn.style.display = 'none';
      
      // 創建冥想文字容器
      const meditationContainer = document.createElement('div');
      meditationContainer.className = 'final-meditation-container';
      meditationContainer.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 800px;
        text-align: center;
        z-index: 10;
      `;
      
      // 創建文字顯示區域
      const textDisplay = document.createElement('div');
      textDisplay.className = 'meditation-text';
      textDisplay.style.cssText = `
        font-size: 1.4rem;
        line-height: 1.8;
        color: #7c3aed;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        text-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);
        letter-spacing: 0.5px;
        text-align: center;
        opacity: 0;
        transform: translateY(20px);
        transition: all 1s ease;
        white-space: pre-line;
      `;
      
      meditationContainer.appendChild(textDisplay);
      gameContent.appendChild(meditationContainer);
      
      // 顯示容器
      setTimeout(() => {
        textDisplay.style.opacity = '1';
        textDisplay.style.transform = 'translateY(0)';
      }, 500);
      
      // 開始緩慢的打字機效果
      setTimeout(() => {
        startSlowTypewriter(textDisplay, scene.text, () => {
          // 打字機效果完成後，等待5秒再顯示繼續按鈕
          setTimeout(() => {
            // 添加輕微的呼吸光效
            textDisplay.style.animation = 'gentle-breathing 6s ease-in-out infinite';
            
            // 顯示繼續按鈕
            advanceBtn.style.display = 'block';
            advanceBtn.style.opacity = '0';
            advanceBtn.style.transform = 'translateY(20px)';
            advanceBtn.style.transition = 'all 1s ease';
            
            setTimeout(() => {
              advanceBtn.style.opacity = '1';
              advanceBtn.style.transform = 'translateY(0)';
            }, 100);
          }, 5000); // 從3秒延長到5秒
        });
      }, 1000);
    }
    
    // 緩慢打字機效果函數（優化版：分段顯示、重點字詞高亮）
    function startSlowTypewriter(element, text, callback) {
      element.innerHTML = '';
      const speed = 180; // 每個字符180毫秒
      
      // 完整文本，使用換行符分段
      const fullText = `微風從身邊吹過，你的心變得無比輕鬆。

夢境和現實，已經沒有什麼區別了。

你靠著大樹，看著雲朵來來去去，聽著風聲和鳥鳴。

你的身體、你的心，都在這裡。

在這個自由自在的地方，在這片廣闊的原野上，你終於得到了真正的

逍遙。`;
      
      let i = 0;
      let isInHighlight = false;
      
      function typeNextChar() {
        if (i < fullText.length) {
          const char = fullText.charAt(i);
          
          // 檢查是否到達"逍遙"二字
          if (i === fullText.indexOf('逍遙') && !isInHighlight) {
            // 開始高亮標籤
            element.innerHTML += '<span style="color: #8b5cf6; font-weight: bold; text-shadow: 0 0 12px rgba(139, 92, 246, 0.8); display: inline-block;">';
            isInHighlight = true;
          }
          
          if (char === '\n') {
            // 換行符轉換為<br>
            element.innerHTML += '<br>';
          } else {
            element.innerHTML += char;
          }
          
          // 檢查是否完成"逍遙"二字
          if (isInHighlight && i === fullText.indexOf('逍遙') + 1) {
            element.innerHTML += '</span>';
            isInHighlight = false;
          }
          
          i++;
          
          // 在句號、感嘆號、問號後增加額外停頓
          let nextDelay = speed;
          
          if (char === '。' || char === '！' || char === '？') {
            nextDelay = speed * 3; // 句子結束後停頓3倍時間
          } else if (char === '，' || char === '、') {
            nextDelay = speed * 1.8; // 逗號後停頓1.8倍時間
          } else if (char === '\n') {
            nextDelay = speed * 5; // 段落間停頓5倍時間
          }
          
          setTimeout(typeNextChar, nextDelay);
        } else {
          // 所有文字完成
          if (callback) callback();
        }
      }
      
      typeNextChar();
    }

    // 創建照片顯影場景
    function createPhotoDevelopScene(scene) {
      console.log('📸 createPhotoDevelopScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 在開始時清理所有可能的白色覆蓋層
      const whiteOverlay = document.getElementById('white-transition-overlay');
      if (whiteOverlay) {
        console.log('📸 開始時移除白色過渡層');
        whiteOverlay.remove();
      }
      
      // 清理其他可能的白色覆蓋層
      const whiteOverlays = document.querySelectorAll('[id*="white"], [class*="white"], [style*="background: white"], [style*="background: #fff"], [style*="background: #ffffff"]');
      whiteOverlays.forEach(overlay => {
        if (overlay.style.position === 'fixed' || overlay.style.position === 'absolute') {
          console.log('📸 開始時移除白色覆蓋層:', overlay);
          overlay.remove();
        }
      });
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 設置照片顯影背景
      gameContainer.classList.remove('blank-emergence-scene');
      gameContainer.classList.add('photo-develop-scene');
      
      // 隱藏繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 創建顯影覆蓋層
      const developOverlay = document.createElement('div');
      developOverlay.className = 'photo-develop-overlay';
      
      // 創建文字容器
      const textContainer = document.createElement('div');
      textContainer.className = 'photo-develop-text';
      textContainer.textContent = scene.text;
      textContainer.style.textAlign = 'left';
      
      // 添加到遊戲內容
      gameContent.appendChild(developOverlay);
      gameContent.appendChild(textContainer);
      
      // 4秒後（顯影動畫完成）立即處理
      setTimeout(() => {
        console.log('📸 照片顯影動畫完成，開始清理和設置背景');
        
        // 徹底清理所有可能的白色覆蓋層和殘留元素
        const whiteOverlay = document.getElementById('white-transition-overlay');
        if (whiteOverlay) {
          console.log('📸 移除白色過渡層');
          whiteOverlay.remove();
        }
        
        // 清理其他可能的白色覆蓋層
        const whiteOverlays = document.querySelectorAll('[id*="white"], [class*="white"], [style*="background: white"], [style*="background: #fff"], [style*="background: #ffffff"]');
        whiteOverlays.forEach(overlay => {
          if (overlay.style.position === 'fixed' || overlay.style.position === 'absolute') {
            console.log('📸 移除白色覆蓋層:', overlay);
            overlay.remove();
          }
        });
        
        // 立即移除顯影覆蓋層，避免樣式衝突
        const developOverlay = document.querySelector('.photo-develop-overlay');
        if (developOverlay) {
          console.log('📸 移除照片顯影覆蓋層');
          developOverlay.remove();
        }
        
        // 移除照片顯影樣式
        gameContainer.classList.remove('photo-develop-scene');
        
        // 清除任何現有的transition和樣式，避免動畫衝突
        gameContainer.style.transition = 'none';
        gameContainer.style.background = 'none';
        gameContainer.style.backgroundColor = 'transparent';
        
        // 強制重繪，確保清理生效
        gameContainer.offsetHeight;
        
        // 直接設置尾聲背景圖片和濾鏡，無動畫
        gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
        gameContainer.style.filter = 'sepia(0.15) saturate(1.2) brightness(1.1)';
        
        // 再次強制重繪，確保背景圖片立即生效
        gameContainer.offsetHeight;
        
        // 確保gameContent不會覆蓋背景
        gameContent.style.background = 'transparent';
        gameContent.style.backgroundColor = 'transparent';
        
        // 保持物化按鈕隱藏
        gameUI.style.opacity = 0;
        
        // 立即顯示繼續按鈕
        advanceBtn.style.display = 'block';
        advanceBtn.style.opacity = '1';
        advanceBtn.style.transition = 'opacity 0.5s ease';
        
        console.log('📸 照片顯影完成，背景已設置，繼續按鈕已顯示');
        console.log('📸 gameContainer背景樣式:', gameContainer.style.background);
        console.log('📸 gameContent背景樣式:', gameContent.style.background);
      }, 4000);
      
      console.log('📸 照片顯影場景創建完成');
    }


    // Start the game
    function init() {
      // Pre-show the main menu
      mainMenu.style.opacity = 1;
      
      // Initialize Hunlun apertures
      initializeHunlunApertures();
      
      // 恢復遊戲進度
      const savedProgress = loadGameProgress();
      if (savedProgress) {
        // 恢復最高章節記錄
        gameState.maxReachedChapter = savedProgress.maxReachedChapter;
        // 恢復已收集的封印
        if (savedProgress.collectedApertures) {
          gameState.collectedApertures = savedProgress.collectedApertures;
        }
        console.log('📖 恢復遊戲進度，最高章節:', gameState.maxReachedChapter);
        console.log('📖 恢復已收集封印:', gameState.collectedApertures);
      }
      
      // 初始化默認形態
      updateFormView('human');
      
      // 根據保存的進度更新七竅指示器的顯示狀態
      if (gameState.collectedApertures && gameState.collectedApertures.length > 0) {
        gameState.collectedApertures.forEach(apertureType => {
          const targetAperture = document.querySelector(`.aperture-${apertureType}`);
          if (targetAperture) {
            targetAperture.classList.add('active');
          }
        });
        
        // 如果已收集所有7個封印，創建太極覆蓋層
        if (gameState.collectedApertures.length === 7) {
          setTimeout(() => {
            createTaijiOverlay();
            console.log('🌟 主菜單初始化：檢測到所有封印已收集，創建太極覆蓋層');
          }, 1000);
        }
      }
      
      // Initialize audio controls
      initAudioControls();
      
      // 🔍 自動運行第七章場景調試
      console.log('🔍 遊戲初始化完成，自動運行第七章場景調試...');
      setTimeout(() => {
        debugChapter7Scenes();
      }, 1000);
      
      // 暴露調試函數到全域，方便控制台調用
      window.debugChapter7Scenes = debugChapter7Scenes;
      console.log('💡 提示：可在控制台輸入 debugChapter7Scenes() 重新運行調試');
    }
    
    init();

    // ===== Three.js虛空場景增強效果系統 =====


  </script>















</body></html>
</body></html>
</body></html>
