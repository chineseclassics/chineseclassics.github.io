<!DOCTYPE html><html lang="zh-TW"><head><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com https://chineseclassics.github.io https://*.github.io https://*.githubusercontent.com https://api.deepseek.com; connect-src 'self' https://api.deepseek.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
      <title>萬物逍遙</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+TC:wght@400;600;700&amp;display=swap" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css" rel="stylesheet">
  <link href="https://fonts.googleapis.com/css2?family=Noto+Serif+SC:wght@400;700;900&display=swap" rel="stylesheet">
  <script>
    tailwind.config = {
      darkMode: 'class',
      theme: {
        extend: {
          fontFamily: {
            'lxgw': ['"LXGW WenKai"', 'serif'],
            'noto-serif': ['"Noto Serif SC"', 'serif'],
          },
        },
      },
    }
  </script>
  <style>
    @keyframes float {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-10px); }
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    @keyframes wave {
      0% { transform: translateY(0) rotate(0deg); }
      25% { transform: translateY(-5px) rotate(2deg); }
      50% { transform: translateY(0) rotate(0deg); }
      75% { transform: translateY(5px) rotate(-2deg); }
      100% { transform: translateY(0) rotate(0deg); }
    }
    
    @keyframes cloud-drift {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(20px); }
    }
    
    /* Form indicator icon animations */
    @keyframes flutter-icon-left {
      0%, 100% { transform: translate(0, -50%) rotate(-10deg); }
      50% { transform: translate(0, -50%) rotate(-20deg); }
    }
    
    @keyframes flutter-icon-right {
      0%, 100% { transform: translate(0, -50%) rotate(10deg); }
      50% { transform: translate(0, -50%) rotate(20deg); }
    }
    
    @keyframes fish-icon-swim {
      0%, 100% { transform: translateX(0); }
      50% { transform: translateX(3px); }
    }
    
    @keyframes fish-icon-tail {
      0%, 100% { transform: translateY(-50%) rotate(0deg); }
      50% { transform: translateY(-50%) rotate(15deg); }
    }
    

    
    @keyframes butterfly {
      0%, 100% { transform: rotate(-5deg); }
      50% { transform: rotate(5deg); }
    }
    
    @keyframes fishSwim {
      0% { transform: translateX(0) translateY(0) rotate(0deg); }
      25% { transform: translateX(10px) translateY(-5px) rotate(2deg); }
      50% { transform: translateX(20px) translateY(0) rotate(0deg); }
      75% { transform: translateX(10px) translateY(5px) rotate(-2deg); }
      100% { transform: translateX(0) translateY(0) rotate(0deg); }
    }
    
    .text-char {
      display: inline-block;
      position: relative;
      cursor: pointer;
      transition: all 0.3s ease;
    }
    
    .text-char:hover {
      transform: scale(1.2);
    }
    
    .butterfly-form {
      animation: butterfly 2s infinite ease-in-out;
      transition: all 0.5s ease;
    }
    
    .fish-form {
      animation: fishSwim 4s infinite ease-in-out;
      transition: all 0.5s ease;
    }
    

    
    .dream-text {
      animation: pulse 3s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    .water-text {
      animation: wave 4s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    .cloud-text {
      animation: cloud-drift 6s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    .leaf-text {
      animation: leaf-sway 4s infinite ease-in-out;
      transition: all 0.3s ease;
    }
    
    @keyframes leaf-sway {
      0% { transform: rotate(0deg) translateY(0); }
      25% { transform: rotate(1deg) translateY(-2px); }
      50% { transform: rotate(0deg) translateY(0); }
      75% { transform: rotate(-1deg) translateY(2px); }
      100% { transform: rotate(0deg) translateY(0); }
    }
    
    .heaven-earth-text {
      /* 整體發光和呼吸效果 - 極其緩慢柔和 */
      color: #FFD700;
      animation: text-glow-breathe 180s infinite ease-in-out;
    }
    
    @keyframes text-glow-breathe {
      0%, 100% { 
        text-shadow: 0 0 6px rgba(255, 215, 0, 0.3), 0 0 12px rgba(255, 215, 0, 0.2);
        color: #FFD700;
        transform: scale(1);
      }
      50% { 
        text-shadow: 0 0 8px rgba(255, 215, 0, 0.4), 0 0 16px rgba(255, 215, 0, 0.3), 0 0 24px rgba(255, 215, 0, 0.2);
        color: #FFED4E;
        transform: scale(1.01);
      }
    }

    /* 章節過渡動畫效果 */
    @keyframes chapter-transition-fade {
      0% { opacity: 0; backdrop-filter: blur(0px); }
      100% { opacity: 1; backdrop-filter: blur(10px); }
    }

    @keyframes chapter-title-emerge {
      0% { 
        opacity: 0; 
        transform: translateY(30px) scale(0.9);
        text-shadow: 0 0 0px rgba(255, 255, 255, 0);
      }
      100% { 
        opacity: 1; 
        transform: translateY(0) scale(1);
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
      }
    }

    @keyframes typewriter-cursor {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0; }
    }

    /* 第七章到尾聲章節的白色過渡動畫 */
    @keyframes white-transition-fade {
      0% { opacity: 0; }
      100% { opacity: 1; }
    }

    @keyframes epilogue-title-emerge {
      0% { 
        opacity: 0; 
        transform: translateY(20px) scale(0.95);
        text-shadow: 0 0 0px rgba(0, 0, 0, 0);
      }
      100% { 
        opacity: 1; 
        transform: translateY(0) scale(1);
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      }
    }
    
    @keyframes gentle-breathing {
      0%, 100% { 
        opacity: 1;
        text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
      }
      50% { 
        opacity: 0.85;
        text-shadow: 0 1px 8px rgba(0, 0, 0, 0.15);
      }
    }
    
    /* 萬物尋氣強化高亮動畫 */
    @keyframes wanwu-highlight {
      0% { 
        transform: scale(1);
        box-shadow: 0 0 30px rgba(59, 130, 246, 0.8), 0 0 60px rgba(59, 130, 246, 0.4);
        border: 3px solid rgba(59, 130, 246, 0.8);
      }
      25% { 
        transform: scale(1.05);
        box-shadow: 0 0 40px rgba(59, 130, 246, 1), 0 0 80px rgba(59, 130, 246, 0.6);
        border: 3px solid rgba(59, 130, 246, 1);
      }
      50% { 
        transform: scale(1.08);
        box-shadow: 0 0 50px rgba(59, 130, 246, 1), 0 0 100px rgba(59, 130, 246, 0.7), 0 0 150px rgba(59, 130, 246, 0.3);
        border: 3px solid rgba(255, 255, 255, 0.8);
      }
      75% { 
        transform: scale(1.05);
        box-shadow: 0 0 40px rgba(59, 130, 246, 1), 0 0 80px rgba(59, 130, 246, 0.6);
        border: 3px solid rgba(59, 130, 246, 1);
      }
      100% { 
        transform: scale(1);
        box-shadow: 0 0 30px rgba(59, 130, 246, 0.8), 0 0 60px rgba(59, 130, 246, 0.4);
        border: 3px solid rgba(59, 130, 246, 0.8);
      }
    }

    /* 氣注入儀式所需的動畫 */
    @keyframes fade-in {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    @keyframes float-glow {
      0%, 100% { 
        transform: translateY(0) scale(1);
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6);
      }
      50% { 
        transform: translateY(-10px) scale(1.05);
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 30px rgba(255, 255, 255, 0.7);
      }
    }

    @keyframes particle-to-center {
      0% { 
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      50% { 
        transform: scale(1.2) rotate(180deg);
        opacity: 0.8;
      }
      100% { 
        transform: scale(0.3) rotate(360deg);
        opacity: 0;
      }
    }

    /* 清空所有UI元素的動畫 */
    @keyframes ui-fade-to-white {
      0% { opacity: 1; color: inherit; }
      100% { opacity: 0; color: white; }
    }

    @keyframes background-to-white {
      0% { background-color: transparent; }
      100% { background-color: white; }
    }

    /* 氣注入儀式所需的動畫 */
    @keyframes fade-in {
      0% { opacity: 0; transform: translateY(20px); }
      100% { opacity: 1; transform: translateY(0); }
    }

    @keyframes float-glow {
      0%, 100% { 
        transform: translateY(0) scale(1);
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 255, 255, 0.6);
      }
      50% { 
        transform: translateY(-10px) scale(1.05);
        text-shadow: 0 0 15px rgba(255, 255, 255, 0.9), 0 0 30px rgba(255, 255, 255, 0.7);
      }
    }

    @keyframes particle-to-center {
      0% { 
        transform: scale(1) rotate(0deg);
        opacity: 1;
      }
      50% { 
        transform: scale(1.2) rotate(180deg);
        opacity: 0.8;
      }
      100% { 
        transform: scale(0.3) rotate(360deg);
        opacity: 0;
      }
    }

    /* 清空所有UI元素的動畫 */
    @keyframes ui-fade-to-white {
      0% { opacity: 1; color: inherit; }
      100% { opacity: 0; color: white; }
    }

    @keyframes background-to-white {
      0% { background-color: transparent; }
      100% { background-color: white; }
    }
    
    /* Hunlun (Chaos) design and seven apertures */
    .aperture-container {
      position: relative;
      width: 150px;
      height: 150px;
      background: radial-gradient(circle, rgba(80, 80, 120, 0.6) 0%, rgba(50, 50, 80, 0.4) 70%);
      border-radius: 50%;
      padding: 10px;
      box-shadow: 
        0 0 15px rgba(93, 92, 222, 0.4),
        0 0 25px rgba(0, 0, 0, 0.3) inset;
      backdrop-filter: blur(2px);
      overflow: hidden;
    }
    
    .dark .aperture-container {
      background: radial-gradient(circle, rgba(90, 90, 130, 0.5) 0%, rgba(60, 60, 100, 0.4) 70%);
    }
    
    /* Chaos energy field */
    .aperture-container::before {
      content: '';
      position: absolute;
      top: -10%;
      left: -10%;
      right: -10%;
      bottom: -10%;
      border-radius: 50%;
      background: url("data:image/svg+xml,%3Csvg width='100' height='100' viewBox='0 0 100 100' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.65' numOctaves='3' stitchTiles='stitch'/%3E%3CfeColorMatrix type='matrix' values='1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0'/%3E%3C/filter%3E%3Crect width='100' height='100' fill='%235D5CDE' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E");
      opacity: 0.5;
      mix-blend-mode: overlay;
      animation: chaos-noise 8s linear infinite;
      z-index: 0;
    }
    
    @keyframes chaos-noise {
      0% { transform: rotate(0deg) scale(1); }
      33% { transform: rotate(120deg) scale(1.05); }
      66% { transform: rotate(240deg) scale(0.95); }
      100% { transform: rotate(360deg) scale(1); }
    }
    
    /* Face pattern - subtle face outline */
    .face-pattern {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: opacity 3s ease-in-out;
      z-index: 0;
    }
    
    .face-pattern.visible {
      opacity: 0.2;
    }
    
    /* Individual aperture */
    .aperture {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: rgba(0, 0, 0, 0.85);
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 
        0 0 4px rgba(0, 0, 0, 0.7) inset,
        0 0 3px rgba(93, 92, 222, 0.2);
      transition: all 1.2s cubic-bezier(0.34, 1.56, 0.64, 1);
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 18px; /* Size for emojis */
      overflow: hidden;
      z-index: 2;
    }
    
    /* Aperture filled state - what happens when collected */
    .aperture.active {
      animation: none !important; /* 停止流動動畫 */
      transform: scale(0.1);
      opacity: 0;
      transition: all 0.7s cubic-bezier(0.34, 1.56, 0.64, 1);
    }
    
    /* Aperture filled state */
    .aperture.filled {
      background: linear-gradient(135deg, rgba(93, 92, 222, 0.8), rgba(147, 146, 255, 0.6));
      border-color: rgba(255, 255, 255, 0.5);
      box-shadow: 
        0 0 10px rgba(93, 92, 222, 0.4),
        0 0 5px rgba(255, 255, 255, 0.2) inset;
    }
    
    /* Aperture random positions - each aperture moves independently */
    

    .aperture-random {
      transition: all 3s cubic-bezier(0.34, 0.56, 0.64, 1);
    }
    
    /* 七竅流動動畫系統 - 模擬在混沌形體上的能量流動 */
    .aperture-left-eye {
      animation: aperture-flow-1 8s infinite ease-in-out;
    }
    
    .aperture-right-eye {
      animation: aperture-flow-2 9s infinite ease-in-out 1s;
    }
    
    .aperture-left-ear {
      animation: aperture-flow-3 10s infinite ease-in-out 2s;
    }
    
    .aperture-right-ear {
      animation: aperture-flow-4 11s infinite ease-in-out 3s;
    }
    
    .aperture-left-nose {
      animation: aperture-flow-5 12s infinite ease-in-out 4s;
    }
    
    .aperture-right-nose {
      animation: aperture-flow-6 13s infinite ease-in-out 5s;
    }
    
    .aperture-mouth {
      animation: aperture-flow-7 14s infinite ease-in-out 6s;
    }
    
    /* 七竅流動動畫 - 在150px容器內自由流動 */
    @keyframes aperture-flow-1 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(-5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      25% { 
        transform: translate(60px, 20px) scale(1.05) rotate(-3deg); /* 向右移動 */
        opacity: 1; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 12px rgba(93, 92, 222, 0.5);
      }
      50% { 
        transform: translate(30px, 70px) scale(0.95) rotate(-7deg); /* 向下移動 */
        opacity: 0.9; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 10px rgba(93, 92, 222, 0.4);
      }
      75% { 
        transform: translate(-15px, 35px) scale(1.02) rotate(-2deg); /* 向左移動 */
        opacity: 1; 
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.7) inset, 0 0 14px rgba(93, 92, 222, 0.6);
      }
    }
    
    @keyframes aperture-flow-2 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      30% { 
        transform: translate(-75px, 15px) scale(1.03) rotate(8deg); /* 向左移動 */
        opacity: 1; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 12px rgba(93, 92, 222, 0.5);
      }
      60% { 
        transform: translate(-25px, 60px) scale(0.97) rotate(2deg); /* 向左下移動 */
        opacity: 0.9; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 10px rgba(93, 92, 222, 0.4);
      }
    }
    
        @keyframes aperture-flow-3 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(-15deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      40% { 
        transform: translate(85px, 35px) scale(1.04) rotate(-12deg); /* 向右下移動 */
        opacity: 1; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 15px rgba(93, 92, 222, 0.6);
      }
      80% { 
        transform: translate(45px, -35px) scale(0.96) rotate(-18deg); /* 向右上移動 */
        opacity: 0.85; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 9px rgba(93, 92, 222, 0.4);
      }
    }

    @keyframes aperture-flow-4 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(15deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      35% { 
        transform: translate(-95px, -10px) scale(1.06) rotate(12deg); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 7px rgba(0, 0, 0, 0.7) inset, 0 0 16px rgba(93, 92, 222, 0.7);
      }
      70% { 
        transform: translate(-40px, 25px) scale(0.94) rotate(18deg); /* 向左下移動 */
        opacity: 0.9; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 11px rgba(93, 92, 222, 0.45);
      }
    }
    
        @keyframes aperture-flow-5 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(-5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      20% { 
        transform: translate(50px, -60px) scale(1.02) rotate(-3deg); /* 向右上移動 */
        opacity: 0.95; 
        box-shadow: 0 0 5px rgba(0, 0, 0, 0.7) inset, 0 0 10px rgba(93, 92, 222, 0.4);
      }
      45% { 
        transform: translate(-20px, -45px) scale(1.07) rotate(-8deg); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 8px rgba(0, 0, 0, 0.7) inset, 0 0 18px rgba(93, 92, 222, 0.8);
      }
      85% { 
        transform: translate(55px, 15px) scale(0.93) rotate(-2deg); /* 向右中移動 */
        opacity: 0.85; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 9px rgba(93, 92, 222, 0.35);
      }
    }

    @keyframes aperture-flow-6 {
      0%, 100% { 
        transform: translate(0, 0) scale(1) rotate(5deg); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      50% { 
        transform: translate(-70px, -55px) scale(1.08) rotate(8deg); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 9px rgba(0, 0, 0, 0.7) inset, 0 0 20px rgba(93, 92, 222, 0.9);
      }
    }

    @keyframes aperture-flow-7 {
      0%, 100% { 
        transform: translate(0, 0) scale(1); 
        opacity: 0.8; 
        box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
      }
      33% { 
        transform: translate(25px, -80px) scale(1.03); /* 向上移動 */
        opacity: 0.95; 
        box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 13px rgba(93, 92, 222, 0.55);
      }
      66% { 
        transform: translate(-45px, -65px) scale(1.09); /* 向左上移動 */
        opacity: 1; 
        box-shadow: 0 0 10px rgba(0, 0, 0, 0.7) inset, 0 0 22px rgba(93, 92, 222, 1);
      }
    }
    
    /* 七竅在150px容器內的初始位置 - 使用絕對定位相對於aperture-container */
    .aperture-left-eye { top: 20px; left: 20px; }  /* 左上象限 */
    .aperture-right-eye { top: 20px; left: 100px; }  /* 右上象限 */
    .aperture-left-ear { top: 60px; left: 5px; }   /* 左邊緣 */
    .aperture-right-ear { top: 60px; left: 115px; } /* 右邊緣 */
    .aperture-left-nose { top: 100px; left: 25px; } /* 左下象限 */
    .aperture-right-nose { top: 100px; left: 95px; } /* 右下象限 */
    .aperture-mouth { top: 115px; left: 60px; } /* 底部中央 */
    
    /* Left-right distinction for paired apertures */
    .aperture-left-eye::after, 
    .aperture-left-ear::after,
    .aperture-left-nose::after {
      content: '';
      position: absolute;
      bottom: 2px;
      right: 2px;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(255, 100, 100, 0.5);
    }
    
    .aperture-right-eye::after,
    .aperture-right-ear::after,
    .aperture-right-nose::after {
      content: '';
      position: absolute;
      bottom: 2px;
      left: 2px;
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(100, 100, 255, 0.5);
    }
    
    /* Seal collection animation */
    @keyframes seal-collection {
      0% { transform: scale(0.3) rotate(0deg); opacity: 0; }
      20% { transform: scale(1.5) rotate(180deg); opacity: 1; }
      40% { transform: scale(1.2) rotate(360deg); opacity: 1; }
      70% { transform: scale(1) rotate(720deg); opacity: 1; }
      80% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }
    
    @keyframes seal-glow-pulse {
      0%, 100% { box-shadow: 0 0 10px rgba(93, 92, 222, 0.6), 0 0 20px rgba(93, 92, 222, 0.3); }
      50% { box-shadow: 0 0 20px rgba(93, 92, 222, 0.8), 0 0 30px rgba(93, 92, 222, 0.5); }
    }
    
    .aperture.collecting {
      animation: 
        seal-collection 1.5s cubic-bezier(0.34, 1.56, 0.64, 1) forwards,
        seal-glow-pulse 2s ease-in-out infinite 1.5s !important; /* 覆蓋流動動畫 */
      z-index: 10;
    }
    
    /* Floating seal in scene */
    .scene-seal {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(147, 146, 255, 0.8), rgba(93, 92, 222, 0.8));
      box-shadow: 
        0 0 10px rgba(93, 92, 222, 0.6),
        0 0 20px rgba(93, 92, 222, 0.3);
      animation: seal-float 3s ease-in-out infinite;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    .scene-seal::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background-size: 150% 150%;
      background-position: center;
      opacity: 0.8;
    }
    
    /* 神秘封印符號設計 - 左目之竅：洞察之眼 */
    .scene-seal.left-eye::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Ccircle cx='12' cy='12' r='6'/%3E%3Ccircle cx='12' cy='12' r='3'/%3E%3Ccircle cx='12' cy='12' r='1' fill='white'/%3E%3Cpath d='M6 12 L2 8 M18 12 L22 8 M12 6 L12 2' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 右目之竅：真察之眼 */
    .scene-seal.right-eye::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Ccircle cx='12' cy='12' r='6'/%3E%3Ccircle cx='12' cy='12' r='3'/%3E%3Ccircle cx='12' cy='12' r='1' fill='white'/%3E%3Cpath d='M6 12 L2 16 M18 12 L22 16 M12 18 L12 22' stroke-width='1'/%3E%3Cpolygon points='12,9 10.5,10.5 13.5,10.5' fill='white'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 左耳之竅：聆聽螺紋 */
    .scene-seal.left-ear::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpath d='M12 4 Q16 8 12 12 Q8 16 12 20' fill='none'/%3E%3Cpath d='M8 6 Q12 9 8 12 Q4 15 8 18' fill='none'/%3E%3Cpath d='M16 6 Q20 9 16 12 Q12 15 16 18' fill='none'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3Cpath d='M2 12 L6 8 M2 12 L6 16' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 右耳之竅：辨析波紋 */
    .scene-seal.right-ear::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpath d='M12 4 Q8 8 12 12 Q16 16 12 20' fill='none'/%3E%3Cpath d='M16 6 Q12 9 16 12 Q20 15 16 18' fill='none'/%3E%3Cpath d='M8 6 Q4 9 8 12 Q12 15 8 18' fill='none'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3Cpath d='M22 12 L18 8 M22 12 L18 16' stroke-width='1'/%3E%3Cpath d='M12 8 L14 10 M12 16 L14 14' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 左鼻之竅：感知三角 */
    .scene-seal.left-nose::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpolygon points='12,4 6,16 18,16' fill='none'/%3E%3Cpolygon points='12,8 9,14 15,14' fill='none'/%3E%3Ccircle cx='12' cy='12' r='1.5' fill='white'/%3E%3Cpath d='M12 20 L8 22 M12 20 L16 22' stroke-width='1'/%3E%3Cpath d='M6 10 L3 7 M18 10 L21 7' stroke-width='1'/%3E%3Cpath d='M10 6 L8 3 M14 6 L16 3' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 右鼻之竅：辨氣菱形 */
    .scene-seal.right-nose::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpolygon points='12,2 20,12 12,22 4,12' fill='none'/%3E%3Cpolygon points='12,6 16,12 12,18 8,12' fill='none'/%3E%3Ccircle cx='12' cy='12' r='2' fill='white'/%3E%3Cpath d='M12 22 L8 20 M12 22 L16 20' stroke-width='1'/%3E%3Cpath d='M4 8 L1 5 M20 8 L23 5' stroke-width='1'/%3E%3Cpath d='M4 16 L1 19 M20 16 L23 19' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    /* 神秘封印符號設計 - 口之竅：表達符文 */
    .scene-seal.mouth::before {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='1.5'%3E%3Cpath d='M4 12 Q12 6 20 12 Q12 18 4 12' fill='none'/%3E%3Cpath d='M6 12 Q12 9 18 12 Q12 15 6 12' fill='none'/%3E%3Ccircle cx='8' cy='12' r='1' fill='white'/%3E%3Ccircle cx='16' cy='12' r='1' fill='white'/%3E%3Cpath d='M12 4 L10 2 M12 4 L14 2' stroke-width='1'/%3E%3Cpath d='M12 20 L10 22 M12 20 L14 22' stroke-width='1'/%3E%3Cpath d='M2 8 L4 6 M22 8 L20 6 M2 16 L4 18 M22 16 L20 18' stroke-width='1'/%3E%3C/svg%3E");
    }
    
    @keyframes seal-float {
      0%, 100% { transform: translateY(0) rotate(0deg); box-shadow: 0 0 10px rgba(93, 92, 222, 0.6), 0 0 20px rgba(93, 92, 222, 0.3); }
      50% { transform: translateY(-10px) rotate(5deg); box-shadow: 0 0 15px rgba(93, 92, 222, 0.7), 0 0 30px rgba(93, 92, 222, 0.4); }
    }
    
    /* Collection path animation */
    @keyframes seal-path {
      0% { transform: translate(0, 0) scale(1); }
      70% { transform: translate(var(--end-x), var(--end-y)) scale(0.5); opacity: 1; }
      90%, 100% { transform: translate(var(--end-x), var(--end-y)) scale(0); opacity: 0; }
    }
    
    /* ===== 统一Emoji物化角色系统 ===== */
    
    /* 基础emoji容器样式 */
    .emoji-form-icon {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      position: relative;
      font-size: 72px;
      line-height: 1;
      user-select: none;
    }
    
    /* 统一的emoji视觉效果 */
    .emoji-unified {
      position: relative;
      z-index: 2;
      filter: sepia(0.15) saturate(1.2) contrast(1.1) brightness(0.98);
      text-shadow: 0 2px 4px rgba(0,0,0,0.15);
      transition: all 0.3s ease;
      transform-origin: center;
    }
    
    .emoji-unified:hover {
      filter: sepia(0.1) saturate(1.4) contrast(1.2) brightness(1.05);
      transform: scale(1.05);
      text-shadow: 0 3px 6px rgba(0,0,0,0.2);
    }
    
    /* 状态指示器中的emoji特效 */
    .form-icon-container .emoji-unified {
      font-size: 64px;
      animation: emoji-breathe 4s infinite ease-in-out;
    }
    
    @keyframes emoji-breathe {
      0%, 100% { 
        transform: scale(1) rotate(0deg);
        filter: sepia(0.15) saturate(1.2) contrast(1.1) brightness(0.98);
      }
      50% { 
        transform: scale(1.02) rotate(1deg);
        filter: sepia(0.1) saturate(1.3) contrast(1.15) brightness(1.02);
      }
    }
    
    /* 变身动画中的emoji特效 - 优化性能版本 */
    .transformation-emoji {
      font-size: 120px;
      animation: transformation-spin 2s ease-in-out;
      will-change: transform, opacity;
      backface-visibility: hidden;
    }
    
    @keyframes transformation-spin {
      0% { transform: scale(0.3) rotate(0deg); opacity: 0; filter: drop-shadow(0 0 25px rgba(255,255,255,0.9)); }
      2.5% { transform: scale(0.35) rotate(9deg); opacity: 0.08; filter: drop-shadow(0 0 24px rgba(255,255,255,0.85)); }
      5% { transform: scale(0.4) rotate(18deg); opacity: 0.15; filter: drop-shadow(0 0 23px rgba(255,255,255,0.8)); }
      7.5% { transform: scale(0.45) rotate(27deg); opacity: 0.23; filter: drop-shadow(0 0 22px rgba(255,255,255,0.75)); }
      10% { transform: scale(0.5) rotate(36deg); opacity: 0.3; filter: drop-shadow(0 0 21px rgba(255,255,255,0.7)); }
      12.5% { transform: scale(0.55) rotate(45deg); opacity: 0.35; filter: drop-shadow(0 0 20px rgba(255,255,255,0.7)); }
      15% { transform: scale(0.6) rotate(54deg); opacity: 0.4; filter: drop-shadow(0 0 19px rgba(255,255,255,0.7)); }
      17.5% { transform: scale(0.65) rotate(63deg); opacity: 0.45; filter: drop-shadow(0 0 18px rgba(255,255,255,0.7)); }
      20% { transform: scale(0.7) rotate(72deg); opacity: 0.5; filter: drop-shadow(0 0 17px rgba(255,255,255,0.7)); }
      22.5% { transform: scale(0.75) rotate(81deg); opacity: 0.55; filter: drop-shadow(0 0 16px rgba(255,255,255,0.7)); }
      25% { transform: scale(0.8) rotate(90deg); opacity: 0.6; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      27.5% { transform: scale(0.85) rotate(99deg); opacity: 0.65; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      30% { transform: scale(0.9) rotate(108deg); opacity: 0.7; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      32.5% { transform: scale(0.95) rotate(117deg); opacity: 0.75; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      35% { transform: scale(1.0) rotate(126deg); opacity: 0.8; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      37.5% { transform: scale(1.05) rotate(135deg); opacity: 0.83; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      40% { transform: scale(1.1) rotate(144deg); opacity: 0.85; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      42.5% { transform: scale(1.13) rotate(153deg); opacity: 0.88; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      45% { transform: scale(1.15) rotate(162deg); opacity: 0.9; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      47.5% { transform: scale(1.18) rotate(171deg); opacity: 0.95; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      50% { transform: scale(1.2) rotate(180deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      52.5% { transform: scale(1.19) rotate(189deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      55% { transform: scale(1.18) rotate(198deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      57.5% { transform: scale(1.17) rotate(207deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      60% { transform: scale(1.15) rotate(216deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      62.5% { transform: scale(1.14) rotate(225deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      65% { transform: scale(1.13) rotate(234deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      67.5% { transform: scale(1.12) rotate(243deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      70% { transform: scale(1.1) rotate(252deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      72.5% { transform: scale(1.09) rotate(261deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      75% { transform: scale(1.08) rotate(270deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      77.5% { transform: scale(1.07) rotate(279deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      80% { transform: scale(1.05) rotate(288deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      82.5% { transform: scale(1.04) rotate(297deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      85% { transform: scale(1.03) rotate(306deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      87.5% { transform: scale(1.025) rotate(315deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      90% { transform: scale(1.02) rotate(324deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      92.5% { transform: scale(1.015) rotate(333deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      95% { transform: scale(1.01) rotate(342deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      97.5% { transform: scale(1.005) rotate(351deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
      100% { transform: scale(1) rotate(360deg); opacity: 1; filter: drop-shadow(0 0 15px rgba(255,255,255,0.7)); }
    }
    
    /* 背景光效 */
    .emoji-glow-bg {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 100px;
      height: 100px;
      border-radius: 50%;
      opacity: 0.6;
      z-index: 1;
      animation: glow-pulse 3s infinite ease-in-out;
    }
    
    @keyframes glow-pulse {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(0.8);
        opacity: 0.4;
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1);
        opacity: 0.7;
      }
    }
    
    /* 特定物化形态的背景色彩 */
    .emoji-glow-human { background: radial-gradient(circle, rgba(147, 146, 255, 0.3), transparent 70%); }
    .emoji-glow-butterfly { background: radial-gradient(circle, rgba(147, 51, 234, 0.3), transparent 70%); }
    .emoji-glow-fish { background: radial-gradient(circle, rgba(59, 130, 246, 0.3), transparent 70%); }
    .emoji-glow-kun { background: radial-gradient(circle, rgba(6, 182, 212, 0.3), transparent 70%); }
    .emoji-glow-peng { background: radial-gradient(circle, rgba(14, 165, 233, 0.3), transparent 70%); }
    .emoji-glow-yuanchu { background: radial-gradient(circle, rgba(255, 215, 0, 0.3), transparent 70%); }
    .emoji-glow-chixiao { background: radial-gradient(circle, rgba(139, 69, 19, 0.3), transparent 70%); }
    .emoji-glow-snail { background: radial-gradient(circle, rgba(147, 50, 158, 0.3), transparent 70%); }
    .emoji-glow-fungus { background: radial-gradient(circle, rgba(245, 158, 11, 0.3), transparent 70%); }
    .emoji-glow-cicada { background: radial-gradient(circle, rgba(34, 197, 94, 0.3), transparent 70%); }
    .emoji-glow-tree { background: radial-gradient(circle, rgba(22, 163, 74, 0.3), transparent 70%); }
    .emoji-glow-ant { background: radial-gradient(circle, rgba(120, 53, 15, 0.3), transparent 70%); }
    .emoji-glow-star { background: radial-gradient(circle, rgba(255, 215, 0, 0.4), transparent 70%); }
    
    /* Leaf effects for forest scene */
    .leaf {
      position: absolute;
      background-color: rgba(44, 119, 68, 0.7);
      border-radius: 50% 5% 50% 5%;
      filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.2));
      z-index: 1;
      transition: all 0.3s ease;
      transform-origin: center bottom;
    }
    
    @keyframes leaf-falling {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0.7; }
    }
    
    @keyframes leaf-sway-animation {
      0%, 100% { transform: rotate(-5deg) translateX(0); }
      50% { transform: rotate(5deg) translateX(10px); }
    }
    
    /* Character transformation effects */
    .transformation-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
      display: flex;
      justify-content: center;
      align-items: center;
      overflow: hidden;
    }
    
    .transformation-circle {
      position: absolute;
      width: 300px;
      height: 300px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(93, 92, 222, 0.2) 0%, rgba(93, 92, 222, 0.8) 70%, rgba(93, 92, 222, 0.2) 100%);
      box-shadow: 0 0 80px rgba(93, 92, 222, 0.6);
      opacity: 0;
      transform: scale(0.2);
      transition: all 0.5s ease-in-out;
    }
    
    .transform-active .transformation-circle {
      opacity: 0.8;
      transform: scale(1);
    }
    
    .particle-container {
      position: absolute;
      width: 100%;
      height: 100%;
      transform-style: preserve-3d;
    }
    
    .particle {
      position: absolute;
      width: 8px;
      height: 8px;
      background-color: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      transform: translate(-50%, -50%);
      opacity: 0;
    }
    
    /* Human transformation */
    .human-symbol {
      position: absolute;
      width: 120px;
      height: 120px;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.5s ease-in-out 0.2s;
      filter: drop-shadow(0 0 10px rgba(255, 255, 255, 0.7));
    }
    
    .human-symbol svg {
      width: 100%;
      height: 100%;
    }
    
    .transform-active .human-symbol {
      opacity: 1;
      transform: scale(1);
    }
    
    /* Butterfly transformation */
    .butterfly-wings {
      position: absolute;
      width: 0;
      height: 0;
    }
    
    .butterfly-wing {
      position: absolute;
      width: 60px;
      height: 80px;
      background: linear-gradient(135deg, rgba(93, 92, 222, 0.9), rgba(147, 146, 255, 0.6));
      border-radius: 50% 50% 50% 50% / 80% 80% 20% 20%;
      opacity: 0;
      transform-origin: bottom center;
    }
    
    .butterfly-wing.left {
      transform: rotate(-30deg) translate(-30px, 0) scaleX(-1);
    }
    
    .butterfly-wing.right {
      transform: rotate(30deg) translate(30px, 0);
    }
    
    .transform-active .butterfly-wing {
      opacity: 0.9;
      animation: flutter 2.5s infinite alternate ease-in-out;
    }
    
    .transform-active .butterfly-wing.left {
      animation-delay: 0.1s;
    }
    
    @keyframes flutter {
      0%, 100% { transform: rotate(-20deg) translate(-30px, 0) scaleX(-1); }
      50% { transform: rotate(-40deg) translate(-40px, -10px) scaleX(-1); }
    }
    
    @keyframes flutter-right {
      0%, 100% { transform: rotate(20deg) translate(30px, 0); }
      50% { transform: rotate(40deg) translate(40px, -10px); }
    }
    
    /* Bird transformation */
    .bird-body {
      position: absolute;
      width: 120px;
      height: 80px;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.5s ease-in-out 0.2s;
    }
    
    .swan-shape, .owl-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      transition: all 0.5s ease-in-out;
    }
    
    .swan-shape {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.9), rgba(255, 182, 193, 0.8), rgba(173, 216, 230, 0.7));
      border-radius: 70% 40% 70% 40%;
      z-index: 1;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.5);
    }
    
    .owl-shape {
      background: linear-gradient(135deg, rgba(139, 69, 19, 0.9), rgba(101, 67, 33, 0.8), rgba(75, 0, 130, 0.6));
      border-radius: 80% 80% 60% 60%;
      z-index: 0;
      opacity: 0;
      box-shadow: 0 0 15px rgba(255, 215, 0, 0.4);
    }
    
    .bird-head {
      position: absolute;
      border-radius: 50%;
      z-index: 2;
    }
    
    .swan-head {
      width: 35px;
      height: 40px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(240, 240, 250, 0.7));
      left: 5px;
      top: 15px;
    }
    
    .owl-head {
      width: 40px;
      height: 45px;
      background: linear-gradient(135deg, rgba(90, 70, 50, 0.9), rgba(70, 50, 40, 0.8));
      left: 5px;
      top: 10px;
      opacity: 0;
    }
    
    .swan-beak {
      position: absolute;
      width: 25px;
      height: 10px;
      background: rgba(255, 196, 0, 0.9);
      border-radius: 50% 80% 20% 50%;
      left: 0;
      top: 25px;
      z-index: 3;
    }
    
    .owl-beak {
      position: absolute;
      width: 18px;
      height: 12px;
      background: rgba(210, 170, 0, 0.9);
      border-radius: 40% 40% 80% 80%;
      left: 17px;
      top: 35px;
      transform: rotate(10deg);
      z-index: 3;
      opacity: 0;
    }
    
    .bird-wing {
      position: absolute;
      z-index: 1;
    }
    
    .swan-wing {
      width: 60px;
      height: 40px;
      background: linear-gradient(135deg, rgba(255, 255, 255, 0.9), rgba(240, 240, 250, 0.7));
      border-radius: 80% 70% 60% 90%;
      right: 10px;
      top: 20px;
      transform-origin: left center;
    }
    
    .owl-wing {
      width: 55px;
      height: 45px;
      background: linear-gradient(135deg, rgba(110, 80, 50, 0.9), rgba(80, 60, 40, 0.8));
      border-radius: 70% 60% 80% 70%;
      right: 15px;
      top: 15px;
      transform-origin: left center;
      opacity: 0;
    }
    
    .bird-eye {
      position: absolute;
      border-radius: 50%;
      z-index: 4;
    }
    
    .swan-eye {
      width: 8px;
      height: 8px;
      background: rgba(255, 255, 255, 0.9);
      border: 1px solid rgba(255, 215, 0, 0.6);
      left: 30px;
      top: 25px;
      box-shadow: 0 0 5px rgba(255, 255, 255, 0.8);
    }
    
    .owl-eye {
      width: 14px;
      height: 14px;
      background: rgba(255, 215, 0, 0.9);
      border: 2px solid rgba(101, 67, 33, 0.8);
      left: 20px;
      top: 20px;
      opacity: 0;
      box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
    }
    
    .owl-eye::after {
      content: '';
      position: absolute;
      width: 6px;
      height: 6px;
      background: #000;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
    
    .transform-active .bird-body {
      opacity: 1;
      transform: scale(1);
    }
    
    @keyframes bird-wing-flap {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(-20deg); }
    }
    
    .transform-swan .swan-shape,
    .transform-swan .swan-head,
    .transform-swan .swan-beak,
    .transform-swan .swan-wing,
    .transform-swan .swan-eye {
      opacity: 1;
    }
    
    .transform-swan .owl-shape,
    .transform-swan .owl-head,
    .transform-swan .owl-beak,
    .transform-swan .owl-wing,
    .transform-swan .owl-eye {
      opacity: 0;
    }
    
    .transform-owl .swan-shape,
    .transform-owl .swan-head,
    .transform-owl .swan-beak,
    .transform-owl .swan-wing,
    .transform-owl .swan-eye {
      opacity: 0;
    }
    
    .transform-owl .owl-shape,
    .transform-owl .owl-head,
    .transform-owl .owl-beak,
    .transform-owl .owl-wing,
    .transform-owl .owl-eye {
      opacity: 1;
    }
    
    .transform-active .swan-wing {
      animation: bird-wing-flap 4s infinite ease-in-out;
    }
    
    .transform-active .owl-wing {
      animation: bird-wing-flap 3s infinite ease-in-out;
    }
    
    /* Bird form icon for the form indicator */
    #bird-icon {
      position: absolute;
      width: 28px;
      height: 28px;
      transition: all 0.5s ease-in-out;
      opacity: 0;
      transform: scale(0);
    }
    
    /* Leaf effects for forest scene */
    .leaf-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: hidden;
      z-index: 0;
    }
    
    .tree {
      position: absolute;
      bottom: 0;
      z-index: 1;
    }
    
    .tree-trunk {
      position: absolute;
      bottom: 0;
      width: 25px;
      background: linear-gradient(to right, #4b3621 10%, #6b4423 50%, #4b3621 90%);
      border-radius: 5px;
      z-index: 1;
    }
    
    .tree-crown {
      position: absolute;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 40%, rgba(100, 170, 80, 0.8) 0%, rgba(60, 130, 40, 0.9) 100%);
      box-shadow: inset 3px 3px 5px rgba(255, 255, 255, 0.2), 
                  inset -3px -3px 5px rgba(0, 0, 0, 0.2);
      z-index: 0;
    }
    
    .tree-branch {
      position: absolute;
      height: 8px;
      background: linear-gradient(to bottom, #6b4423, #4b3621);
      border-radius: 3px;
      transform-origin: 0 50%;
      z-index: 0;
    }
    
    .falling-leaf {
      position: absolute;
      background-color: rgba(44, 119, 68, 0.7);
      border-radius: 50% 5% 50% 5%;
      filter: drop-shadow(0 0 2px rgba(0, 0, 0, 0.2));
      z-index: 2;
      opacity: 0;
      animation: leaf-falling linear forwards;
    }
    
    @keyframes leaf-falling {
      0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
      10% { opacity: 0.7; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }
    
    @keyframes leaf-sway-animation {
      0%, 100% { transform: rotate(-5deg) translateX(0); }
      50% { transform: rotate(5deg) translateX(10px); }
    }
    
    .forest-light {
      position: absolute;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0) 70%);
      border-radius: 50%;
      filter: blur(8px);
      pointer-events: none;
      opacity: 0;
      animation: forest-light-fade 8s infinite ease-in-out;
      z-index: 1;
    }
    
    @keyframes forest-light-fade {
      0%, 100% { opacity: 0; transform: scale(0.8) translate(0, 0); }
      50% { opacity: 0.5; transform: scale(1.1) translate(10px, -10px); }
    }
    
    /* Fish transformation */
    .fish-body {
      position: absolute;
      width: 120px;
      height: 60px;
      opacity: 0;
      transform: scale(0.5);
      transition: all 0.5s ease-in-out 0.2s;
    }
    
    .fish-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50% 50% 50% 50% / 70% 70% 30% 30%;
      background: linear-gradient(135deg, rgba(93, 92, 222, 0.9), rgba(147, 146, 255, 0.7));
      overflow: hidden;
    }
    
    .fish-tail {
      position: absolute;
      right: -20px;
      top: 15px;
      width: 40px;
      height: 30px;
      border-radius: 0 0 50% 0;
      background: rgba(93, 92, 222, 0.8);
      transform-origin: left center;
    }
    
    .fish-eye {
      position: absolute;
      width: 10px;
      height: 10px;
      background: white;
      border-radius: 50%;
      top: 22px;
      left: 15px;
      box-shadow: 0 0 5px rgba(0, 0, 0, 0.3);
    }
    
    .fish-fin {
      position: absolute;
      width: 20px;
      height: 15px;
      background: rgba(93, 92, 222, 0.8);
      border-radius: 50% 50% 0 50%;
      top: 5px;
      left: 40px;
      transform-origin: bottom center;
      transform: rotate(-20deg);
    }
    
    .fish-fin.bottom {
      top: auto;
      bottom: 5px;
      transform: rotate(20deg) scaleY(-1);
    }
    
    .transform-active .fish-body {
      opacity: 1;
      transform: scale(1);
      animation: fish-swim 3s infinite ease-in-out;
    }
    
    .transform-active .fish-tail {
      animation: fish-tail 1.5s infinite ease-in-out;
    }
    
    .transform-active .fish-fin {
      animation: fish-fin 2s infinite ease-in-out;
    }
    
    .transform-active .fish-fin.bottom {
      animation: fish-fin 2s infinite ease-in-out reverse;
    }
    
    /* Kun-Peng Transformation - 已分離為獨立的kun和peng形態 */
    
    .kun-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50% 50% 50% 50% / 70% 70% 30% 30%;
      background: linear-gradient(135deg, rgba(64, 186, 213, 0.9), rgba(103, 200, 208, 0.7));
      overflow: hidden;
      transition: all 1.5s ease-in-out;
    }
    
    .peng-shape {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      transition: all 1.5s ease-in-out;
    }
    
    .peng-wing {
      position: absolute;
      background: linear-gradient(135deg, rgba(64, 186, 213, 0.9), rgba(103, 200, 208, 0.7));
      border-radius: 50% 20% 50% 20%;
      transform-origin: center top;
    }
    
    .peng-wing.left {
      width: 100px;
      height: 130px;
      left: -50px;
      top: 20px;
      transform: rotate(-25deg);
    }
    
    .peng-wing.right {
      width: 100px;
      height: 130px;
      right: -50px;
      top: 20px;
      transform: rotate(25deg);
    }
    
    .peng-body {
      position: absolute;
      width: 40px;
      height: 120px;
      background: linear-gradient(to bottom, rgba(64, 186, 213, 0.9), rgba(103, 200, 208, 0.7));
      border-radius: 50% 50% 30% 30%;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .peng-head {
      position: absolute;
      width: 30px;
      height: 35px;
      background: rgba(64, 186, 213, 0.9);
      border-radius: 50% 50% 40% 40%;
      left: 50%;
      top: -5px;
      transform: translateX(-50%);
    }
    
    .peng-beak {
      position: absolute;
      width: 15px;
      height: 10px;
      background: rgba(255, 196, 0, 0.9);
      border-radius: 40% 40% 80% 80%;
      left: 50%;
      top: 20px;
      transform: translateX(-50%);
    }
    

    
    .transform-kun .kun-shape {
      opacity: 1;
      animation: kun-swim 5s infinite ease-in-out;
    }
    
    .transform-kun .peng-shape {
      opacity: 0;
    }
    
    .transform-peng .kun-shape {
      opacity: 0;
    }
    
    .transform-peng .peng-shape {
      opacity: 1;
    }
    
    .transform-peng .peng-wing {
      animation: peng-wing-flap 6s infinite ease-in-out;
    }
    
    .transform-peng .peng-wing.right {
      animation-delay: 0.3s;
    }
    
    @keyframes fish-swim {
      0%, 100% { transform: translateX(0) rotate(0deg); }
      25% { transform: translateX(10px) rotate(2deg); }
      75% { transform: translateX(-10px) rotate(-2deg); }
    }
    
    @keyframes fish-tail {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(15deg); }
    }
    
    @keyframes fish-fin {
      0%, 100% { transform: rotate(-20deg); }
      50% { transform: rotate(-10deg); }
    }
    
    /* 鯤（鯨魚）游動動畫 - 改進為更自然的鯨魚游動 */
    @keyframes kun-swim {
      0%, 100% { transform: translateX(0) rotate(0deg) translateY(0); }
      25% { transform: translateX(15px) rotate(1deg) translateY(-5px); }
      75% { transform: translateX(-15px) rotate(-1deg) translateY(5px); }
    }
    
    /* 鯨魚尾鰭擺動 */
    @keyframes whale-tail {
      0%, 100% { transform: rotate(0deg); }
      50% { transform: rotate(15deg); }
    }
    
    /* 鯨魚噴水動畫 */
    @keyframes water-spray {
      0%, 80%, 100% { opacity: 0; height: 0; }
      85%, 87% { opacity: 0.7; height: 15px; }
    }
    
    /* 鵬（巨鳥）的翅膀拍動 - 改進為更自然的鳥類翅膀動作 */
    @keyframes peng-wing-flap {
      0%, 100% { transform: rotate(-25deg) scaleY(1); }
      50% { transform: rotate(-40deg) scaleY(0.9); }
    }
    
    @keyframes peng-wing-flap-right {
      0%, 100% { transform: rotate(25deg) scaleY(1); }
      50% { transform: rotate(40deg) scaleY(0.9); }
    }
    
    /* 羽毛閃爍動畫 */
    @keyframes feather-shimmer {
      0% { opacity: 0.5; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.05); }
      100% { opacity: 0.5; transform: scale(1); }
    }
    
    /* Particles animation */
    @keyframes particle-float {
      0% { transform: translate(-50%, -50%) translateY(0) scale(1); opacity: 0; }
      20% { opacity: 0.8; }
      100% { transform: translate(-50%, -50%) translateY(-100px) scale(0); opacity: 0; }
    }
    
    /* Fade out animation for transformation container */
    @keyframes fade-out {
      0% { opacity: 1; }
      100% { opacity: 0; }
    }
    
    .fade-out {
      animation: fade-out 0.8s forwards ease-in-out;
    }
    
    /* Game container base styles */
    .game-container {
      background: linear-gradient(to bottom, #ffffff, #f3f4f6);
    }
    
    /* Dark mode styles */
    .dark .game-container {
      background: linear-gradient(to bottom, #181818, #2d2d2d);
      color: #f1f1f1;
    }
    
    .dark .aperture {
      border-color: rgba(93, 92, 222, 0.4);
    }
    
    .dark .aperture.active {
      background-color: rgba(93, 92, 222, 0.8);
      box-shadow: 0 0 15px rgba(93, 92, 222, 0.8);
    }
    
    /* Segmentation puzzle styles - Enhanced and Improved */
    .text-segment-container {
      line-height: 2.8; /* Increased line height */
      letter-spacing: 14px; /* Increased letter spacing significantly */
      font-size: 1.75rem;
      font-weight: 500;
      margin: 1.5rem 0;
      position: relative;
      text-align: left; /* Revert to left-aligned for better character positioning */
      padding: 0 1.5rem; /* Add some padding for better display */
      word-spacing: 8px; /* Added word spacing for more room between characters */
    }
    
    .segment-gap {
      width: 8px; /* Slightly larger dot for better visibility */
      height: 8px; /* Same width and height for a circle */
      background-color: #4F46E5 !important; /* Force background color */
      display: inline-block;
      margin: 0;
      vertical-align: middle;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      border-radius: 50%; /* Make it a perfect circle */
      position: absolute;
      opacity: 0; /* Hide by default - will become visible when active */
      box-shadow: 0 0 4px rgba(93, 92, 222, 0.6);
      /* Position the dot in absolute center */
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 5;
    }
    
    /* Create a semi-transparent indicator on hover for better visibility */
    .segment-gap::before {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 0;
      right: 0;
      background-color: rgba(93, 92, 222, 0);
      border-radius: 50%; /* Match the parent circle */
      transition: all 0.2s ease-out;
    }
    
    /* Create extended clickable area between characters */
    .segment-clickable-area {
      position: absolute;
      width: 30px; /* Much wider clickable area */
      height: 2.8rem; /* Match the increased line height */
      margin: 0;
      left: 50%;
      transform: translateX(-50%);
      top: 0;
      z-index: 10;
      cursor: pointer;
      opacity: 0;
    }
    
    /* Always show the active segments, and show on hover over the extended area or the character */
    .text-char:hover ~ .segment-gap,
    .segment-gap:hover,
    .segment-clickable-area:hover ~ .segment-gap,
    .segment-gap.active {
      opacity: 1;
    }
    
    .segment-gap:hover::before {
      background-color: rgba(93, 92, 222, 0.6);
      box-shadow: 0 0 12px rgba(93, 92, 222, 0.4);
    }
    
    .segment-gap:active::before {
      transform: scaleY(0.8);
    }
    
    /* Active segment - high contrast with light background */
    .segment-gap.active {
      opacity: 1;
      background-color: transparent;
    }
    
    .segment-gap.active::before {
      background-color: #4F46E5; /* More vivid indigo */
      box-shadow: 0 0 8px rgba(93, 92, 222, 0.7);
      transform: scale(1.2); /* Slightly larger when active */
    }
    
    /* Active segment - high contrast with dark background */
    .dark .segment-gap.active::before {
      background-color: #818CF8; /* Lighter indigo for dark mode */
      box-shadow: 0 0 10px rgba(129, 140, 248, 0.8);
      transform: scale(1.2); /* Slightly larger when active */
    }
    
    /* Glowing effect for active segments */
    .segment-gap.active::after {
      content: '';
      position: absolute;
      top: -1px;
      left: -1px;
      right: -1px;
      bottom: -1px;
      border-radius: 5px;
      box-shadow: 0 0 8px 2px rgba(93, 92, 222, 0.7);
      opacity: 0;
      animation: segment-pulse 2s infinite ease-in-out;
    }
    
    .dark .segment-gap.active::after {
      box-shadow: 0 0 8px 2px rgba(129, 140, 248, 0.8);
    }
    
    @keyframes segment-pulse {
      0%, 100% { opacity: 0.3; }
      50% { opacity: 0.8; }
    }
    
    /* Scene backgrounds */
    /* 序章 - 夢境場景：增強夢幻效果 */
    .dream-scene {
      background: 
        radial-gradient(ellipse at 20% 30%, rgba(33, 169, 175, 0.4) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(23, 42, 116, 0.5) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(72, 61, 139, 0.3) 0%, transparent 60%),
        linear-gradient(135deg, #172a74, #21a9af);
      position: relative;
      overflow: hidden;
      animation: dream-atmosphere 12s ease-in-out infinite;
    }

    @keyframes dream-atmosphere {
      0%, 100% { 
        filter: brightness(1) saturate(1.2) hue-rotate(0deg);
      }
      33% { 
        filter: brightness(1.1) saturate(1.4) hue-rotate(5deg);
      }
      66% { 
        filter: brightness(0.95) saturate(1.1) hue-rotate(-3deg);
      }
    }

    /* 序章夢境粒子效果 */
    .dream-scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.1) 1px, transparent 1px),
        radial-gradient(circle at 75% 75%, rgba(33, 169, 175, 0.15) 1px, transparent 1px),
        radial-gradient(circle at 50% 80%, rgba(23, 42, 116, 0.12) 1px, transparent 1px);
      background-size: 150px 150px, 200px 200px, 120px 120px;
      animation: dream-particles-float 20s linear infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes dream-particles-float {
      0% { 
        background-position: 0% 0%, 0% 0%, 0% 0%;
        opacity: 0.6;
      }
      50% { 
        background-position: 100% 50%, -50% 100%, 150% 25%;
        opacity: 0.9;
      }
      100% { 
        background-position: 200% 100%, -100% 200%, 300% 50%;
        opacity: 0.6;
      }
    }

    /* 序章夢境光暈效果 */
    .dream-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at 60% 40%, 
        rgba(255, 255, 255, 0.08) 0%, 
        rgba(33, 169, 175, 0.05) 40%,
        transparent 70%
      );
      animation: dream-glow-shift 15s ease-in-out infinite;
      pointer-events: none;
      z-index: 2;
    }

    @keyframes dream-glow-shift {
      0% { 
        transform: translate(0, 0) scale(1);
        opacity: 0.7;
      }
      25% { 
        transform: translate(-10px, 5px) scale(1.1);
        opacity: 0.9;
      }
      50% { 
        transform: translate(15px, -8px) scale(0.95);
        opacity: 0.8;
      }
      75% { 
        transform: translate(-5px, 10px) scale(1.05);
        opacity: 1.0;
      }
      100% { 
        transform: translate(0, 0) scale(1);
        opacity: 0.7;
      }
    }
    
    .water-scene {
      background: linear-gradient(135deg, #1e5799, #7db9e8);
    }
    
    /* 第二章 - 雲海場景：增強雲朵動態效果 */
    .cloud-scene {
      background: 
        radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3) 0%, transparent 50%),
        radial-gradient(ellipse at 70% 60%, rgba(103, 200, 208, 0.4) 0%, transparent 60%),
        radial-gradient(ellipse at 50% 80%, rgba(64, 186, 213, 0.3) 0%, transparent 40%),
        linear-gradient(135deg, #40bad5, #67c8d0);
      position: relative;
      overflow: hidden;
      animation: cloud-sky-breathe 10s ease-in-out infinite;
    }

    @keyframes cloud-sky-breathe {
      0%, 100% { 
        filter: brightness(1) saturate(1.1);
      }
      50% { 
        filter: brightness(1.15) saturate(1.3);
      }
    }

    /* 第二章雲朵層效果 */
    .cloud-scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse 200px 100px at 20% 30%, rgba(255, 255, 255, 0.6) 0%, transparent 50%),
        radial-gradient(ellipse 300px 150px at 60% 20%, rgba(255, 255, 255, 0.4) 0%, transparent 60%),
        radial-gradient(ellipse 250px 120px at 80% 50%, rgba(255, 255, 255, 0.5) 0%, transparent 55%),
        radial-gradient(ellipse 180px 90px at 40% 70%, rgba(255, 255, 255, 0.7) 0%, transparent 45%);
      animation: cloud-float 18s ease-in-out infinite;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes cloud-float {
      0%, 100% { 
        transform: scale(1) translateY(0);
        opacity: 0.8;
      }
      25% { 
        transform: scale(1.1) translateY(-8px);
        opacity: 0.9;
      }
      50% { 
        transform: scale(0.95) translateY(5px);
        opacity: 0.7;
      }
      75% { 
        transform: scale(1.05) translateY(-3px);
        opacity: 0.85;
      }
    }

    /* 第二章雲霧漂浮效果 */
    .cloud-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        radial-gradient(ellipse 400px 200px at 30% 60%, rgba(255, 255, 255, 0.2) 0%, transparent 70%),
        radial-gradient(ellipse 350px 180px at 70% 80%, rgba(255, 255, 255, 0.15) 0%, transparent 65%);
      animation: cloud-mist-pulse 22s ease-in-out infinite;
      pointer-events: none;
      z-index: 2;
    }

    @keyframes cloud-mist-pulse {
      0%, 100% { 
        transform: scale(1) translateY(0);
        opacity: 0.5;
      }
      30% { 
        transform: scale(1.15) translateY(-10px);
        opacity: 0.7;
      }
      60% { 
        transform: scale(0.9) translateY(8px);
        opacity: 0.4;
      }
      80% { 
        transform: scale(1.08) translateY(-5px);
        opacity: 0.6;
      }
    }
    
    .forest-scene {
      background: linear-gradient(135deg, #2c7744, #8fc866);
    }
    
    .spiral-scene {
      background: linear-gradient(135deg, #271c51, #4b3a6d);
    }
    
    /* 第五章 - 時間森林場景：簡化背景 */
    .time-scene {
      background: linear-gradient(135deg, #8B4513, #DAA520);
      position: relative;
      overflow: hidden;
    }




    
    .heaven-earth-scene {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 5;
      pointer-events: none; /* 讓點擊事件穿透到下層 */
    }
    
    /* 日月星辰容器 - 與天空區域完全對應 */
    .heaven-earth-celestial-container {
      position: absolute;
      top: 20vh; /* 進一步抬高地平線，與繼續按鈕保持合適間距 */
      left: 50%;
      transform: translateX(-50%);
      width: 67vw; /* 增加約三分之一：50vw * 4/3 ≈ 67vw */
      height: 33.5vw; /* 高度正好是寬度的一半，形成完美半圓 */
      clip-path: ellipse(50% 100% at 50% 100%); /* 確保只在半圓內顯示 */
      z-index: 20; /* 在天空背景之上 */
      pointer-events: none;
      overflow: hidden;
    }
    
    /* 天空區域 - 半圓形 */
    .heaven-earth-scene::before {
      content: '';
      position: absolute;
      top: 20vh; /* 進一步抬高地平線，與繼續按鈕保持合適間距 */
      left: 50%;
      transform: translateX(-50%);
      width: 67vw; /* 增加約三分之一：50vw * 4/3 ≈ 67vw */
      height: 33.5vw; /* 高度正好是寬度的一半，形成完美半圓 */
      background: radial-gradient(ellipse at center bottom, 
        #4A3728 0%,     /* 溫暖褐色大地 */
        #2D1B69 25%,    /* 深紫夜色 */
        #1E3A8A 50%,    /* 深藍夜空 */
        #1E1B4B 75%,    /* 深夜藍 */
        #0F172A 100%    /* 深藍黑夜空 */
      );
      clip-path: ellipse(50% 100% at 50% 100%);
      z-index: 6;
      
      /* 地平線 */
      border-bottom: 4px solid #4A3728;
      box-shadow: 0 4px 0 0 #2D1B1B, 0 8px 0 0 #1A1010;
      
      /* 大氣層發光效果 - 增強圓弧邊緣發光 */
      box-shadow: 
        /* 內層發光 - 藍白色大氣層 */
        inset 0 0 30px rgba(135, 206, 235, 0.4),
        inset 0 0 60px rgba(100, 149, 237, 0.3),
        /* 外層發光 - 模擬大氣層散射 */
        0 0 40px rgba(135, 206, 235, 0.8),
        0 0 80px rgba(100, 149, 237, 0.6),
        0 0 120px rgba(65, 105, 225, 0.4),
        0 0 160px rgba(30, 144, 255, 0.3),
        0 0 200px rgba(0, 100, 255, 0.2),
        /* 地平線陰影 */
        0 4px 0 0 #2D1B1B, 
        0 8px 0 0 #1A1010;
      
      animation: atmosphere-glow 8s ease-in-out infinite;
    }

    /* 大氣層邊緣漸變效果 */
    .chapter6-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      border-radius: 50% 50% 0 0;
      background: radial-gradient(
        ellipse at center bottom,
        transparent 85%,
        rgba(135, 206, 235, 0.3) 90%,
        rgba(100, 149, 237, 0.4) 95%,
        rgba(65, 105, 225, 0.5) 98%,
        rgba(30, 144, 255, 0.6) 100%
      );
      pointer-events: none;
      z-index: 7;
      animation: edge-glow 6s ease-in-out infinite;
    }

    /* 邊緣發光動畫 */
    @keyframes edge-glow {
      0%, 100% {
        opacity: 0.8;
      }
      50% {
        opacity: 1.0;
      }
    }
    
    /* 地面區域 - 透明，顯示外太空背景 */
    .heaven-earth-scene::after {
      content: '';
      position: absolute;
      top: calc(20vh + 33.5vw); /* 天空區域下方 */
      left: 0;
      width: 100vw;
      height: calc(100vh - 20vh - 33.5vw - 4px); /* 剩餘高度，減去地平線厚度 */
      background: transparent; /* 透明，顯示外太空星空 */
      z-index: 4; /* 在星空上方，但在天空下方 */
      pointer-events: auto; /* 允許點擊事件，用於按鈕交互 */
    }
    
    /* 為不支持clip-path的瀏覽器提供border-radius fallback */
    @supports not (clip-path: ellipse(50% 100% at 50% 100%)) {
      .heaven-earth-scene::before {
        border-radius: 33.5vw 33.5vw 0 0; /* 使用與寬度一半相同的圓角半徑 */
        clip-path: none;
      }
      
      .heaven-earth-celestial-container {
        border-radius: 33.5vw 33.5vw 0 0; /* 確保日月星辰容器也使用相同的圓角 */
        clip-path: none;
      }
    }
    
    /* 第六章天地場景下的UI調整 - 確保按鈕在地面區域（地平線以下） */
    .heaven-earth-scene #game-ui {
      position: fixed !important;
      bottom: 1.5rem !important; /* 位於地面區域底部 */
      left: 0 !important;
      right: 0 !important;
      z-index: 10003 !important; /* 使用超高z-index確保在所有元素上方 */
    }
    
    /* 繼續按鈕也移到地面區域 */
    .heaven-earth-scene .fixed[style*="top: 78%"] {
      top: auto !important;
      bottom: 6rem !important; /* 在物化按鈕上方，適應縮小的地面區域 */
      position: fixed !important;
      z-index: 10002 !important; /* 使用超高z-index確保在所有元素之上 */
    }
    
    /* 第六章天地場景下，將物化指示器和七竅追蹤器移到半圓外的空間 */
    .heaven-earth-scene #current-form-indicator {
      position: fixed !important;
      top: 1rem !important; /* 移到頁面最上方 */
      left: 1rem !important;
      z-index: 100 !important; /* 確保在所有元素上方顯示 */
      opacity: 1 !important; /* 強制顯示 */
    }
    
    .heaven-earth-scene #apertures-tracker {
      position: fixed !important;
      top: 1rem !important; /* 移到頁面最上方 */
      right: 1rem !important;
      z-index: 100 !important; /* 確保在所有元素上方顯示 */
      opacity: 1 !important; /* 強制顯示 */
    }
    
    /* 為第六章添加頁面背景 - 外太空黑色 */
    body:has(.heaven-earth-scene) {
      background: #000000 !important; /* 外太空黑色 */
    }
    
    /* 確保遊戲容器在第六章時有黑色背景 */
    .heaven-earth-scene {
      background-color: #000000; /* 先設置黑色背景 */
    }
    
    /* 移除第六章時遊戲容器的灰色漸變背景，讓星空透過 */
    body:has(.heaven-earth-scene) #game-container {
      background: transparent !important; /* 設置為透明，讓星空背景透過 */
    }

    /* 扁平化繼續按鈕設計 */
    #advance-btn {
      /* 簡潔的半透明背景 */
      background: rgba(99, 102, 241, 0.75) !important;
      backdrop-filter: blur(12px) !important;
      -webkit-backdrop-filter: blur(12px) !important;
      
      /* 簡潔邊框，無陰影 */
      border: 1px solid rgba(255, 255, 255, 0.3) !important;
      box-shadow: none !important;
      
      /* 清晰文字 */
      color: #ffffff !important;
      font-weight: 600 !important;
      letter-spacing: 0.5px !important;
      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5) !important;
      
      /* 圓角和尺寸 */
      border-radius: 12px !important;
      padding: 12px 24px !important;
      min-width: 120px !important;
      
      /* 簡單過渡 */
      transition: all 0.2s ease !important;
      
      /* 確保按鈕層級 */
      position: relative !important;
      z-index: 1000 !important;
    }

    /* 桌面端樣式 */
    @media (min-width: 768px) {
      #advance-btn {
        padding: 14px 28px !important;
        font-size: 16px !important;
        min-width: 130px !important;
      }
    }

    /* 簡潔的懸停效果 */
    #advance-btn:hover {
      background: rgba(99, 102, 241, 0.9) !important;
      border-color: rgba(255, 255, 255, 0.4) !important;
      transform: translateY(-1px) !important;
    }

    /* 簡潔的按下效果 */
    #advance-btn:active {
      background: rgba(99, 102, 241, 0.8) !important;
      transform: translateY(0) !important;
    }

    /* 氣視覺效果下的處理 */
    body.qi-vision #advance-btn {
      background: rgba(255, 255, 255, 0.3) !important;
      color: #ffffff !important;
      border-color: rgba(255, 255, 255, 0.5) !important;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8) !important;
    }

    body.qi-vision #advance-btn:hover {
      background: rgba(255, 255, 255, 0.4) !important;
      border-color: rgba(255, 255, 255, 0.6) !important;
    }

    /* 氣物化視角下的混沌呼吸挑戰引導文字強化 - 保持低調設計 */
    body.qi-vision .breathing-guide-overlay .breathing-phase-text,
    body.qi-vision .breathing-guide-overlay .cycle-counter,
    body.qi-vision .breathing-guide-overlay .cycle-info,
    body.qi-vision .breathing-guide-overlay .breathing-progress {
      color: #fff !important;
      text-shadow: 0 1px 2px rgba(0,0,0,0.8), 0 0 4px rgba(0,0,0,0.6) !important;
    }

    /* 尾聲章節美觀紫色文字設計 */
    .epilogue-scene #game-content p,
    .epilogue-scene .max-w-2xl p,
    .epilogue-scene .narrative p,
    .epilogue-scene p,
    body:has(.epilogue-scene) #game-content p,
    body:has(.epilogue-scene) .max-w-2xl p {
      color: #6d28d9 !important; /* 美觀的深紫色 */
      text-shadow: 
        0 1px 3px rgba(255, 255, 255, 0.9),
        0 0 8px rgba(109, 40, 217, 0.3),
        0 0 15px rgba(255, 255, 255, 0.6) !important; /* 紫色光暈 + 白色陰影 */
      font-weight: 500 !important; /* 加粗字體增加可讀性 */
    }

    /* 暗色模式下的尾聲章節紫色文字 */
    .dark .epilogue-scene #game-content p,
    .dark .epilogue-scene .max-w-2xl p,
    .dark .epilogue-scene .narrative p,
    .dark .epilogue-scene p,
    body.dark:has(.epilogue-scene) #game-content p,
    body.dark:has(.epilogue-scene) .max-w-2xl p {
      color: #a855f7 !important; /* 亮紫色在暗色背景下 */
      text-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.8),
        0 0 10px rgba(168, 85, 247, 0.4) !important; /* 紫色光暈 */
      font-weight: 500 !important;
    }

    /* 額外保障：直接針對尾聲章節所有文字元素 */
    .epilogue-scene * {
      color: #6d28d9 !important; /* 美觀紫色 */
      text-shadow: 
        0 1px 3px rgba(255, 255, 255, 0.9),
        0 0 8px rgba(109, 40, 217, 0.3),
        0 0 15px rgba(255, 255, 255, 0.6) !important;
    }

    .dark .epilogue-scene * {
      color: #a855f7 !important; /* 暗色模式亮紫色 */
      text-shadow: 
        0 1px 3px rgba(0, 0, 0, 0.8),
        0 0 10px rgba(168, 85, 247, 0.4) !important;
    }

    /* 尾聲章節專用深色文字 - 超高對比度 */
    .epilogue-text-purple {
      color: #000000 !important; /* 純黑色，在淺米色背景上最突出 */
      text-shadow: none !important; /* 移除所有陰影效果 */
      font-weight: 800 !important; /* 超粗字體確保突出 */
    }

    /* 暗色模式下的尾聲章節文字（同樣淺米色背景） */
    .dark .epilogue-text-purple {
      color: #000000 !important; /* 暗色模式也使用純黑色，因為背景圖片相同 */
      text-shadow: none !important; /* 移除所有陰影效果 */
      font-weight: 800 !important;
    }
    
    /* 尾聲章節背景樣式 */
    .epilogue-scene {
      background-image: url('https://chineseclassics.github.io/images/zhuangzi.png') !important;
      background-size: cover !important;
      background-position: center !important;
      background-repeat: no-repeat !important;
      filter: sepia(0.15) saturate(1.2) brightness(1.1) !important;
      animation: epilogue-breathe 20s infinite ease-in-out !important;
      position: relative;
      overflow: hidden;
    }

    /* 增強的背景呼吸動畫 - 移除transform避免與物化縮放衝突 */
    @keyframes epilogue-breathe {
      0%, 100% { 
        filter: sepia(0.15) saturate(1.2) brightness(1.1) contrast(1.05);
      }
      25% { 
        filter: sepia(0.2) saturate(1.3) brightness(1.15) contrast(1.1);
      }
      50% { 
        filter: sepia(0.25) saturate(1.4) brightness(1.2) contrast(1.15);
      }
      75% { 
        filter: sepia(0.2) saturate(1.3) brightness(1.15) contrast(1.1);
      }
          }

      /* 尾聲章節動態效果層 */
      .epilogue-scene::before {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: radial-gradient(
          ellipse at 30% 20%, 
          rgba(255, 255, 255, 0.25) 0%, 
          rgba(255, 235, 150, 0.18) 30%,
          rgba(255, 215, 0, 0.12) 50%,
          transparent 75%
        );
        animation: sunlight-dance 30s infinite ease-in-out;
        z-index: 1;
        pointer-events: none;
      }

      @keyframes sunlight-dance {
        0% { 
          background-position: 30% 20%; 
          opacity: 0.6;
          transform: rotate(0deg) scale(1);
        }
        25% { 
          background-position: 60% 15%; 
          opacity: 0.9;
          transform: rotate(1deg) scale(1.1);
        }
        50% { 
          background-position: 80% 30%; 
          opacity: 0.7;
          transform: rotate(0deg) scale(1.05);
        }
        75% { 
          background-position: 40% 40%; 
          opacity: 1.0;
          transform: rotate(-1deg) scale(1.15);
        }
        100% { 
          background-position: 30% 20%; 
          opacity: 0.6;
          transform: rotate(0deg) scale(1);
        }
      }

      /* 最終場景輕微呼吸光效 */
      @keyframes gentle-breathing {
        0% { 
          text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          transform: scale(1);
          opacity: 0.95;
        }
        50% { 
          text-shadow: 0 2px 8px rgba(139, 69, 19, 0.15), 0 0 12px rgba(139, 69, 19, 0.08);
          transform: scale(1.002);
          opacity: 1;
        }
        100% { 
          text-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
          transform: scale(1);
          opacity: 0.95;
        }
      }

      /* 樹影搖擺效果 */
      .epilogue-scene::after {
        content: '';
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: linear-gradient(
          135deg,
          transparent 0%,
          rgba(0, 0, 0, 0.08) 50%,
          rgba(0, 0, 0, 0.12) 70%,
          transparent 100%
        );
        animation: tree-shadow-sway 25s infinite ease-in-out;
        z-index: 2;
        pointer-events: none;
      }

      @keyframes tree-shadow-sway {
        0%, 100% { 
          transform: skewX(0deg) translateX(0); 
          opacity: 0.3; 
        }
        30% { 
          transform: skewX(-1deg) translateX(5px); 
          opacity: 0.5; 
        }
        70% { 
          transform: skewX(1deg) translateX(-3px); 
          opacity: 0.4; 
        }
      }

      /* 智慧光點粒子系統 */
      .wisdom-particles {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 3;
      }

      .wisdom-particle {
        position: absolute;
        width: 3px;
        height: 3px;
        background: radial-gradient(circle, rgba(255, 255, 255, 0.9), rgba(255, 235, 150, 0.8));
        border-radius: 50%;
        box-shadow: 0 0 10px rgba(255, 255, 255, 0.8), 0 0 20px rgba(255, 235, 150, 0.6), 0 0 30px rgba(255, 215, 0, 0.4);
        animation: wisdom-float 15s infinite linear;
      }

      @keyframes wisdom-float {
        0% { 
          transform: translateY(100vh) translateX(0) scale(0.3); 
          opacity: 0; 
        }
        10% { 
          opacity: 0.8; 
        }
        50% { 
          transform: translateY(50vh) translateX(20px) scale(1);
          opacity: 1;
        }
        90% { 
          opacity: 0.6; 
        }
        100% { 
          transform: translateY(-20px) translateX(-10px) scale(0.5); 
          opacity: 0; 
        }
      }

      /* 飄落樹葉效果 */
      .ancient-leaves {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
        overflow: hidden;
      }

      .ancient-leaf {
        position: absolute;
        width: 8px;
        height: 12px;
        background: rgba(139, 69, 19, 0.7);
        border-radius: 50% 10% 50% 10%;
        animation: leaf-gentle-fall 20s infinite linear;
      }

      @keyframes leaf-gentle-fall {
        0% { 
          transform: translateY(-300px) rotate(0deg) translateX(0); 
          opacity: 0; 
        }
        3% { 
          transform: translateY(-250px) rotate(9deg) translateX(2px); 
          opacity: 0.1; 
        }
        8% { 
          transform: translateY(-180px) rotate(18deg) translateX(5px); 
          opacity: 0.3; 
        }
        15% { 
          opacity: 0.8; 
        }
        50% {
          transform: translateY(50vh) rotate(180deg) translateX(30px);
          opacity: 0.6;
        }
        90% { 
          opacity: 0.4; 
        }
        100% { 
          transform: translateY(calc(100vh + 100px)) rotate(360deg) translateX(-20px); 
          opacity: 0; 
        }
      }




      
      /* 為物化效果創建覆蓋層系統 */
    .transformation-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
      transition: all 0.3s ease;
    }

    @keyframes background-breathe {
      0%, 100% { 
        filter: sepia(0.1) saturate(1.1) brightness(1.05); 
        transform: scale(1);
      }
      50% { 
        filter: sepia(0.15) saturate(1.2) brightness(1.1); 
        transform: scale(1.02);
      }
    }

    /* 陽光移動效果 */
    .epilogue-scene::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(
        ellipse at 30% 20%, 
        rgba(255, 215, 0, 0.15) 0%, 
        rgba(255, 215, 0, 0.05) 40%,
        transparent 70%
      );
      animation: sunlight-shift 25s infinite ease-in-out;
      z-index: 1;
      pointer-events: none;
    }

    @keyframes sunlight-shift {
      0% { background-position: 30% 20%; opacity: 0.3; }
      25% { background-position: 50% 15%; opacity: 0.5; }
      50% { background-position: 70% 25%; opacity: 0.4; }
      75% { background-position: 40% 30%; opacity: 0.6; }
      100% { background-position: 30% 20%; opacity: 0.3; }
    }

    /* 樹影變化效果 */
    .epilogue-scene::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(
        135deg,
        transparent 0%,
        rgba(0, 0, 0, 0.1) 60%,
        rgba(0, 0, 0, 0.15) 80%,
        transparent 100%
      );
      animation: shadow-dance 30s infinite ease-in-out;
      z-index: 2;
      pointer-events: none;
    }

    @keyframes shadow-dance {
      0%, 100% { transform: skewX(0deg) translateX(0); opacity: 0.4; }
      50% { transform: skewX(-2deg) translateX(10px); opacity: 0.6; }
    }

    /* 空白浮現場景樣式 */
    .blank-emergence-scene {
      background: #ffffff !important;
      transition: background-color 1s ease-in-out;
    }

    .blank-emergence-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 1.5rem;
      color: #333;
      text-align: center;
      opacity: 0;
      animation: text-emergence 3s ease-in-out forwards;
      z-index: 10;
      font-weight: 500;
      line-height: 1.6;
      max-width: 80%;
    }

    @keyframes text-emergence {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      30% {
        opacity: 0.3;
        transform: translate(-50%, -50%) scale(0.9);
      }
      60% {
        opacity: 0.7;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* 照片顯影場景樣式 */
    .photo-develop-scene {
      background: #ffffff !important;
      position: relative;
      overflow: hidden;
    }

    .photo-develop-overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-image: url('https://chineseclassics.github.io/images/zhuangzi.png');
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      opacity: 0;
      animation: photo-develop 4s ease-in-out forwards;
      z-index: 1;
    }

    @keyframes photo-develop {
      0% {
        opacity: 0;
        filter: brightness(2) contrast(0.5) blur(5px);
      }
      25% {
        opacity: 0.3;
        filter: brightness(1.8) contrast(0.7) blur(3px);
      }
      50% {
        opacity: 0.6;
        filter: brightness(1.5) contrast(0.9) blur(2px);
      }
      75% {
        opacity: 0.8;
        filter: brightness(1.2) contrast(1.1) blur(1px);
      }
      100% {
        opacity: 1;
        filter: sepia(0.15) saturate(1.2) brightness(1.1);
      }
    }

    .photo-develop-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(255, 255, 255, 0.95);
      padding: 2rem;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
      font-size: 1.2rem;
      color: #333;
      text-align: center;
      opacity: 0;
      animation: text-fade-in 2s ease-in-out 1s forwards;
      z-index: 10;
      max-width: 80%;
      line-height: 1.6;
      backdrop-filter: blur(10px);
    }

    @keyframes text-fade-in {
      0% {
        opacity: 0;
        transform: translate(-50%, -50%) translateY(20px);
      }
      100% {
        opacity: 1;
        transform: translate(-50%, -50%) translateY(0);
      }
    }
    
    /* 第七章虛空場景樣式 */
    .void-scene {
      background: radial-gradient(ellipse at center, #1a1a2e 0%, #16213e 30%, #0f0f23 100%);
      position: relative;
      overflow: hidden;
      min-height: 100vh;
    }
    
    /* 虛空粒子系統 */
    .void-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .void-particle {
      position: absolute;
      border-radius: 50%;
      opacity: 0;
      animation: void-particle-float 15s infinite linear;
    }
    
    @keyframes void-particle-float {
      0% {
        opacity: 0;
        transform: translateY(100vh) scale(0.5);
      }
      10% {
        opacity: 0.8;
      }
      90% {
        opacity: 0.8;
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) scale(1.2);
      }
    }
    

    
    /* 渾沌形體 */
    .chaos-form {
      width: 240px;
      height: 180px;
      background: radial-gradient(ellipse, rgba(255, 255, 255, 0.3) 0%, rgba(147, 146, 255, 0.2) 50%, transparent 100%);
      border-radius: 50%;
      animation: chaos-breathing 4s infinite ease-in-out;
      cursor: pointer;
      transition: all 0.3s ease;
      /* 持續發光效果 */
      box-shadow: 0 0 40px rgba(255, 255, 255, 0.3), 0 0 80px rgba(147, 146, 255, 0.2);
    }
    
    /* 呼吸調息模式下的混沌圖形 */
    .chaos-form.breathing-mode {
      width: 360px;
      height: 270px;
      animation: chaos-guided-breathing 10s infinite cubic-bezier(0.25, 0.46, 0.45, 0.94);
      z-index: 10;
      will-change: transform, opacity, box-shadow;
    }
    

    
    .chaos-form:hover {
      transform: translate(-50%, -50%) scale(1.1);
      box-shadow: 0 0 60px rgba(255, 255, 255, 0.5), 0 0 120px rgba(147, 146, 255, 0.4);
    }
    
    /* 斷句界面時的低層級樣式 */
    .chaos-form.segmentation-mode {
      z-index: 1 !important;
      opacity: 0.3;
      pointer-events: none;
    }
    
    @keyframes chaos-breathing {
      0%, 100% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(1);
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.3), 0 0 80px rgba(147, 146, 255, 0.2);
      }
      50% {
        opacity: 0.9;
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 0 60px rgba(255, 255, 255, 0.5), 0 0 120px rgba(147, 146, 255, 0.4);
      }
    }
    
    /* 引導呼吸動畫：吸氣4秒(0-40%) + 呼氣6秒(40-100%) */
    @keyframes chaos-guided-breathing {
      0% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(0.85);
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.25), 0 0 80px rgba(147, 146, 255, 0.15);
      }
      20% {
        opacity: 0.75;
        transform: translate(-50%, -50%) scale(1.0);
        box-shadow: 0 0 55px rgba(255, 255, 255, 0.35), 0 0 110px rgba(147, 146, 255, 0.25);
      }
      40% {
        opacity: 0.95;
        transform: translate(-50%, -50%) scale(1.15);
        box-shadow: 0 0 75px rgba(255, 255, 255, 0.55), 0 0 150px rgba(147, 146, 255, 0.45);
      }
      55% {
        opacity: 0.85;
        transform: translate(-50%, -50%) scale(1.05);
        box-shadow: 0 0 65px rgba(255, 255, 255, 0.45), 0 0 130px rgba(147, 146, 255, 0.35);
      }
      75% {
        opacity: 0.7;
        transform: translate(-50%, -50%) scale(0.95);
        box-shadow: 0 0 50px rgba(255, 255, 255, 0.3), 0 0 100px rgba(147, 146, 255, 0.2);
      }
      100% {
        opacity: 0.6;
        transform: translate(-50%, -50%) scale(0.85);
        box-shadow: 0 0 40px rgba(255, 255, 255, 0.25), 0 0 80px rgba(147, 146, 255, 0.15);
      }
    }
    

    

    
    /* 太極符號系統 */
    .taiji-container {
      position: absolute;
      top: 10%;
      left: 50%;
      transform: translateX(-50%);
      font-size: 120px;
      animation: taiji-rotate 20s infinite linear;
      z-index: 5;
      filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.3));
    }
    
    .yin-yang-emoji {
      color: rgba(255, 255, 255, 0.8);
      animation: taiji-glow 4s infinite ease-in-out;
    }
    
    @keyframes taiji-rotate {
      0% {
        transform: translateX(-50%) rotate(0deg);
      }
      100% {
        transform: translateX(-50%) rotate(360deg);
      }
    }
    
    @keyframes taiji-glow {
      0%, 100% {
        filter: drop-shadow(0 0 30px rgba(255, 255, 255, 0.3));
        opacity: 0.8;
      }
      50% {
        filter: drop-shadow(0 0 60px rgba(255, 255, 255, 0.6));
        opacity: 1;
      }
    }
    
    /* 八卦符號系統 */
    .bagua-symbols {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 3;
    }
    
    .bagua-symbol {
      position: absolute;
      font-size: 32px;
      color: rgba(255, 255, 255, 0.8);
      opacity: 0;
      animation: bagua-float 25s infinite linear;
      filter: drop-shadow(0 0 15px currentColor) drop-shadow(0 0 30px currentColor) drop-shadow(0 0 45px currentColor);
      text-shadow: 
        0 0 10px currentColor,
        0 0 20px currentColor,
        0 0 40px currentColor,
        0 0 60px currentColor;
    }
    
    @keyframes bagua-float {
      0% {
        opacity: 0;
        transform: translateY(100vh) rotate(0deg) scale(0.8);
      }
      5% {
        opacity: 0.6;
      }
      95% {
        opacity: 0.6;
      }
      100% {
        opacity: 0;
        transform: translateY(-100px) rotate(360deg) scale(1.2);
      }
    }
    
    /* 八卦符號的特殊顏色 - 增強發光效果 */
    .bagua-qian { 
      color: rgba(255, 215, 0, 0.9); /* 乾-天-金色 */
      text-shadow: 
        0 0 15px #FFD700,
        0 0 30px #FFD700,
        0 0 45px #FFD700,
        0 0 60px #FFD700;
    }
    .bagua-dui { 
      color: rgba(192, 192, 192, 0.9); /* 兌-澤-銀色 */
      text-shadow: 
        0 0 15px #C0C0C0,
        0 0 30px #C0C0C0,
        0 0 45px #C0C0C0,
        0 0 60px #C0C0C0;
    }
    .bagua-li { 
      color: rgba(255, 69, 0, 0.9); /* 離-火-橙紅色 */
      text-shadow: 
        0 0 15px #FF4500,
        0 0 30px #FF4500,
        0 0 45px #FF4500,
        0 0 60px #FF4500;
    }
    .bagua-zhen { 
      color: rgba(138, 43, 226, 0.9); /* 震-雷-紫色 */
      text-shadow: 
        0 0 15px #8A2BE2,
        0 0 30px #8A2BE2,
        0 0 45px #8A2BE2,
        0 0 60px #8A2BE2;
    }
    .bagua-xun { 
      color: rgba(144, 238, 144, 0.9); /* 巽-風-淺綠色 */
      text-shadow: 
        0 0 15px #90EE90,
        0 0 30px #90EE90,
        0 0 45px #90EE90,
        0 0 60px #90EE90;
    }
    .bagua-kan { 
      color: rgba(30, 144, 255, 0.9); /* 坎-水-藍色 */
      text-shadow: 
        0 0 15px #1E90FF,
        0 0 30px #1E90FF,
        0 0 45px #1E90FF,
        0 0 60px #1E90FF;
    }
    .bagua-gen { 
      color: rgba(139, 69, 19, 0.9); /* 艮-山-棕色 */
      text-shadow: 
        0 0 15px #8B4513,
        0 0 30px #8B4513,
        0 0 45px #8B4513,
        0 0 60px #8B4513;
    }
    .bagua-kun { 
      color: rgba(218, 165, 32, 0.9); /* 坤-地-土黃色 */
      text-shadow: 
        0 0 15px #DAA520,
        0 0 30px #DAA520,
        0 0 45px #DAA520,
        0 0 60px #DAA520;
    }

    /* 八卦收集答案圆圈翻转动画样式 */
    .answer-circle {
      perspective: 1000px;
      transform-style: preserve-3d;
    }

    .answer-circle .front-side,
    .answer-circle .back-side {
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-style: preserve-3d;
    }

    .answer-circle .back-side {
      transform: rotateY(180deg);
    }

    .answer-circle.flipped .front-side {
      transform: rotateY(180deg);
    }

    .answer-circle.flipped .back-side {
      transform: rotateY(0deg);
    }
    

    
    /* 大氣層發光動畫 - 增強呼吸效果 */
    @keyframes atmosphere-glow {
      0%, 100% {
        box-shadow: 
          /* 內層發光 */
          inset 0 0 30px rgba(135, 206, 235, 0.4),
          inset 0 0 60px rgba(100, 149, 237, 0.3),
          /* 外層發光 */
          0 0 40px rgba(135, 206, 235, 0.8),
          0 0 80px rgba(100, 149, 237, 0.6),
          0 0 120px rgba(65, 105, 225, 0.4),
          0 0 160px rgba(30, 144, 255, 0.3),
          0 0 200px rgba(0, 100, 255, 0.2),
          /* 地平線陰影 */
          0 4px 0 0 #2D1B1B, 
          0 8px 0 0 #1A1010;
      }
      50% {
        box-shadow: 
          /* 內層發光 - 增強 */
          inset 0 0 50px rgba(135, 206, 235, 0.6),
          inset 0 0 90px rgba(100, 149, 237, 0.5),
          /* 外層發光 - 增強 */
          0 0 60px rgba(135, 206, 235, 1.0),
          0 0 120px rgba(100, 149, 237, 0.8),
          0 0 180px rgba(65, 105, 225, 0.6),
          0 0 240px rgba(30, 144, 255, 0.4),
          0 0 300px rgba(0, 100, 255, 0.3),
          /* 地平線陰影 */
          0 4px 0 0 #2D1B1B, 
          0 8px 0 0 #1A1010;
      }
    }
    

    
    /* 外太空星空粒子動畫 */
    .space-starfield {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2; /* 在外太空背景上面，但在半圓下面 */
      pointer-events: none;
      animation: space-rotation 300s linear infinite;
    }
    
    .space-star {
      position: absolute;
      border-radius: 50%;
      animation: star-twinkle-space 3s ease-in-out infinite;
    }
    
    .space-star.yellow {
      background: #FFD700;
      box-shadow: 0 0 6px #FFD700, 0 0 12px #FFD700;
    }
    
    .space-star.blue {
      background: #87CEEB;
      box-shadow: 0 0 6px #87CEEB, 0 0 12px #87CEEB;
    }
    
    .space-star.white {
      background: #FFFFFF;
      box-shadow: 0 0 6px #FFFFFF, 0 0 12px #FFFFFF;
    }
    
    @keyframes space-rotation {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    @keyframes star-twinkle-space {
      0%, 100% { 
        opacity: 0.3;
        transform: scale(1);
      }
      50% { 
        opacity: 1;
        transform: scale(1.2);
      }
    }
    
    /* 大氣層粒子 */
    .atmosphere-particles {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 4;
      border-radius: 50% 50% 0 0;
      overflow: hidden;
    }

    .atmosphere-particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(135, 206, 235, 0.8);
      border-radius: 50%;
      box-shadow: 0 0 4px rgba(135, 206, 235, 0.6);
      animation: atmosphere-particle-float 4s ease-in-out infinite;
    }

    /* 大氣層粒子動畫 */
    @keyframes atmosphere-particle-float {
      0%, 100% {
        transform: translateY(0) scale(1);
        opacity: 0.6;
      }
      25% {
        transform: translateY(-10px) scale(1.1);
        opacity: 0.8;
      }
      50% {
        transform: translateY(-5px) scale(0.9);
        opacity: 1;
      }
      75% {
        transform: translateY(-15px) scale(1.05);
        opacity: 0.7;
      }
    }
    

    
    /* 大氣層邊緣動畫 */
    @keyframes atmosphere-edge-glow {
      0%, 100% {
        opacity: 0.8;
        transform: scale(1);
      }
      50% {
        opacity: 1;
        transform: scale(1.02);
      }
    }
    

    
    @keyframes stars-twinkle {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }
    
    /* 視角縮放控制器 */
    .scale-controller {
      position: fixed;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      width: 3rem;
      height: 15rem;
      background: rgba(255, 255, 255, 0.15);
      border-radius: 2rem;
      backdrop-filter: blur(4px);
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 1rem 0;
      border: 1px solid rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.1);
      transition: all 0.3s ease;
      opacity: 0;
      pointer-events: none;
      z-index: 50;
    }
    
    .dark .scale-controller {
      background: rgba(30, 30, 40, 0.3);
      border-color: rgba(80, 80, 100, 0.3);
    }
    
    .scale-controller.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    /* 視角控制器發光提示效果 */
    .scale-controller.highlight {
      animation: scaleControllerGlow 2s ease-in-out infinite;
      box-shadow: 0 0 20px rgba(147, 50, 158, 0.6), 0 0 40px rgba(147, 50, 158, 0.4);
    }
    
    @keyframes scaleControllerGlow {
      0%, 100% {
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.1), 0 0 25px rgba(147, 50, 158, 0.4);
        border-color: rgba(255, 255, 255, 0.2);
      }
      50% {
        box-shadow: 0 0 25px rgba(147, 50, 158, 0.6), 0 0 50px rgba(147, 50, 158, 0.4);
        border-color: rgba(147, 50, 158, 0.6);
      }
    }
    
    /* 暗色模式的發光效果 */
    .dark .scale-controller.highlight {
      animation: scaleControllerGlowDark 2s ease-in-out infinite;
    }
    
    @keyframes scaleControllerGlowDark {
      0%, 100% {
        box-shadow: 0 0 15px rgba(30, 30, 40, 0.3), 0 0 25px rgba(147, 50, 158, 0.4);
        border-color: rgba(80, 80, 100, 0.3);
      }
      50% {
        box-shadow: 0 0 25px rgba(147, 50, 158, 0.6), 0 0 50px rgba(147, 50, 158, 0.4);
        border-color: rgba(147, 50, 158, 0.6);
      }
    }
    
    .scale-track {
      position: relative;
      height: 80%;
      width: 0.5rem;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 1rem;
      margin: 0.5rem 0;
    }
    
    .dark .scale-track {
      background: rgba(80, 80, 100, 0.4);
    }
    
    .scale-handle {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 1.75rem;
      height: 1.75rem;
      background: linear-gradient(135deg, rgba(147, 50, 158, 0.9), rgba(80, 50, 160, 0.7));
      border-radius: 50%;
      box-shadow: 0 0 10px rgba(147, 50, 158, 0.5);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 0.75rem;
      user-select: none;
      z-index: 2;
      transition: transform 0.1s ease;
    }
    
    .scale-handle:hover {
      transform: translate(-50%, -50%) scale(1.1);
    }
    
    .scale-handle:active {
      transform: translate(-50%, -50%) scale(0.95);
    }
    
    .scale-label {
      position: absolute;
      width: 100%;
      text-align: center;
      font-size: 0.7rem;
      color: rgba(255, 255, 255, 0.7);
    }
    
    .scale-label.macro {
      top: -1.5rem;
    }
    
    .scale-label.micro {
      bottom: -1.5rem;
    }
    
    .scale-value {
      position: absolute;
      right: 3.5rem;
      top: 50%;
      transform: translateY(-50%);
      background: rgba(255, 255, 255, 0.15);
      backdrop-filter: blur(4px);
      padding: 0.5rem;
      border-radius: 0.5rem;
      color: white;
      font-size: 0.875rem;
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    .scale-value.visible {
      opacity: 1;
    }
    
    /* 視角效果 */
    .scene-container {
      position: relative;
      width: 100%;
      height: 100%;
      transition: transform 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
      will-change: transform;
    }
    
    /* 微觀世界元素 */
    .snail-shell {
      position: absolute;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      opacity: 0.85;
      transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 2;
    }
    
    /* 創建畫布背景層，確保文字在蝸牛前顯示 */
    .canvas-layers {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    
    .background-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }
    
    .snail-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 2;
    }
    
    .ui-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
      pointer-events: none;
    }
    
    .ui-layer > * {
      pointer-events: auto;
    }
    
    .kingdom {
      position: absolute;
      width: 40px;
      height: 25px;
      transition: all 0.8s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 3;
    }
    
    .kingdom.left {
      left: calc(50% - 45px);
      top: calc(50% - 20px);
      transform: rotate(-15deg);
      cursor: pointer;
    }
    
    .kingdom.right {
      left: calc(50% + 15px);
      top: calc(50% - 30px);
      transform: rotate(10deg);
      cursor: pointer;
    }
    
    .kingdom-buildings {
      position: absolute;
      bottom: 0;
      width: 100%;
      display: flex;
      justify-content: space-around;
      align-items: flex-end;
    }
    
    .building {
      width: 6px;
      background: rgba(240, 240, 240, 0.8);
      border-radius: 1px;
      transition: height 0.3s ease, background 0.3s ease;
    }
    
    .building.tall {
      height: 15px;
    }
    
    .building.medium {
      height: 10px;
    }
    
    .building.short {
      height: 7px;
    }
    
    /* 王國互動效果 */
    .kingdom:hover .building {
      background: rgba(255, 255, 255, 0.95);
    }
    
    .kingdom.left:hover .kingdom-flag {
      background: rgba(170, 120, 220, 0.95);
    }
    
    .kingdom.right:hover .kingdom-flag {
      background: rgba(120, 170, 220, 0.95);
    }
    
    /* 王國居民 */
    .citizen {
      position: absolute;
      width: 4px;
      height: 6px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 1px;
      bottom: 0;
      animation: citizen-idle 3s infinite ease-in-out;
      cursor: pointer;
      z-index: 5;
    }
    
    .citizen::after {
      content: '';
      position: absolute;
      left: 0;
      width: 4px;
      height: 2px;
      top: -2px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 2px 2px 0 0;
    }
    
    .citizen:hover {
      background: rgba(255, 255, 255, 0.9);
      animation: citizen-active 1s infinite ease-in-out;
    }
    
    .citizen:hover::after {
      background: rgba(255, 255, 255, 0.8);
    }
    
    @keyframes citizen-idle {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-1px); }
    }
    
    @keyframes citizen-active {
      0%, 100% { transform: translateY(0) scale(1.2); }
      50% { transform: translateY(-2px) scale(1.2); }
    }
    
    /* 觸國（左）居民的特色 */
    .citizen.touch {
      background: rgba(200, 180, 255, 0.8);
    }
    
    .citizen.touch::after {
      background: rgba(170, 120, 220, 0.6);
    }
    
    /* 蠻國（右）居民的特色 */
    .citizen.savage {
      background: rgba(180, 200, 255, 0.8);
    }
    
    .citizen.savage::after {
      background: rgba(120, 170, 220, 0.6);
    }
    
    /* 王國名稱標籤 */
    .kingdom-label {
      position: absolute;
      top: -15px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.5);
      color: white;
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      white-space: nowrap;
      opacity: 0;
      transition: opacity 0.3s ease;
      pointer-events: none;
    }
    
    .kingdom:hover .kingdom-label {
      opacity: 1;
    }
    
    /* 對話框樣式 */
    .micro-dialog {
      position: absolute;
      background: rgba(10, 10, 30, 0.8);
      border: 1px solid rgba(93, 92, 222, 0.5);
      border-radius: 8px;
      padding: 12px;
      max-width: 180px;
      font-size: 8px;
      color: white;
      box-shadow: 0 3px 10px rgba(0, 0, 0, 0.4);
      z-index: 100; /* 增加z-index確保顯示在蝸牛上方 */
      pointer-events: all;
      backdrop-filter: blur(3px);
      transform-origin: center bottom;
      animation: dialog-appear 0.3s ease-out forwards;
    }
    
    @keyframes dialog-appear {
      from { transform: scale(0.7); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }
    
    .micro-dialog::after {
      content: '';
      position: absolute;
      bottom: -5px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 5px solid transparent;
      border-right: 5px solid transparent;
      border-top: 5px solid rgba(10, 10, 30, 0.8);
    }
    
    .micro-dialog-header {
      font-weight: bold;
      margin-bottom: 5px;
      color: rgba(147, 146, 255, 1);
      font-size: 9px;
    }
    
    .micro-dialog-content {
      margin-bottom: 8px;
      line-height: 1.4;
    }
    
    .micro-dialog-options {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .micro-dialog-option {
      background: rgba(80, 80, 120, 0.4);
      border: 1px solid rgba(147, 146, 255, 0.5);
      border-radius: 4px;
      padding: 3px 6px;
      font-size: 7px;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    
    .micro-dialog-option:hover {
      background: rgba(93, 92, 222, 0.5);
      border-color: rgba(147, 146, 255, 0.8);
    }
    
    /* 微觀視角下才顯示對話框 */
    .micro-dialog {
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.3s ease;
    }
    
    .micro-mode .micro-dialog {
      opacity: 1;
      pointer-events: auto;
    }
    
    .kingdom-flag {
      position: absolute;
      width: 5px;
      height: 8px;
      top: -5px;
      left: 50%;
      transform: translateX(-50%);
    }
    
    .kingdom.left .kingdom-flag {
      background: rgba(150, 100, 200, 0.9);
    }
    
    .kingdom.right .kingdom-flag {
      background: rgba(100, 150, 200, 0.9);
    }
    
    .kingdom-flag::before {
      content: '';
      position: absolute;
      width: 1px;
      height: 12px;
      background: rgba(255, 255, 255, 0.8);
      left: -1px;
      bottom: 0;
    }
    
    .battlefield {
      position: absolute;
      width: 30px;
      height: 15px;
      left: calc(50% - 15px);
      top: calc(50% - 8px);
      background: rgba(200, 50, 50, 0.2);
      border-radius: 50%;
      z-index: 2;
      overflow: hidden;
    }
    
    .soldier {
      position: absolute;
      width: 2px;
      height: 3px;
      background: rgba(255, 255, 255, 0.7);
      border-radius: 1px;
    }
    
    .snail-perspective-indicator {
      position: absolute;
      width: 100%;
      height: 100%;
      display: flex;
      justify-content: center;
      align-items: flex-end;
      padding-bottom: 20%;
      color: rgba(255, 255, 255, 0.9);
      font-size: 24px;
      z-index: 50; /* 提高z-index確保顯示在蝸牛上方 */
      opacity: 0;
      transition: opacity 0.5s ease;
      pointer-events: none;
      text-shadow: 0 0 10px rgba(0, 0, 0, 0.8), 0 0 5px rgba(0, 0, 0, 0.5);
    }
    
    /* 添加文字背景，確保即使蝸牛放大也能清晰看到視角提示 */
    .snail-perspective-indicator .text-center {
      background: rgba(0, 0, 0, 0.5);
      padding: 10px 15px;
      border-radius: 8px;
      backdrop-filter: blur(5px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      max-width: 80%;
    }
    
    /* Cloud effects */
    .cloud {
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 50%;
      filter: blur(15px);
      opacity: 0.8;
      z-index: 1;
      transition: all 0.3s ease;
    }
    
    @keyframes float-cloud {
      0%, 100% { transform: translate(0, 0); }
      50% { transform: translate(var(--cloud-dx, 20px), var(--cloud-dy, -10px)); }
    }
    
    /* Perspective scale animation */
    @keyframes scale-perspective {
      0% { transform: scale(1); }
      100% { transform: scale(var(--scale-to, 0.5)); }
    }
    
    /* Height transition for scene changes */
    .height-transition {
      transition: height 2s ease-in-out;
    }
    
    /* 蟪蛄飛行動畫 */
    @keyframes cicada-flight {
      0% { 
        transform: translate(0, 0) rotate(0deg); 
        opacity: 0.8; 
      }
      25% { 
        transform: translate(30vw, -10vh) rotate(15deg); 
        opacity: 1; 
      }
      50% { 
        transform: translate(60vw, 5vh) rotate(-10deg); 
        opacity: 0.9; 
      }
      75% { 
        transform: translate(20vw, -15vh) rotate(20deg); 
        opacity: 1; 
      }
      100% { 
        transform: translate(0, 0) rotate(0deg); 
        opacity: 0.8; 
      }
    }
    
    /* 蟪蛄翅膀扇動動畫 */
    @keyframes cicada-wing-left {
      0%, 100% { transform: rotateY(0deg) scaleX(1); }
      50% { transform: rotateY(-15deg) scaleX(0.8); }
    }
    
    @keyframes cicada-wing-right {
      0%, 100% { transform: rotateY(0deg) scaleX(1); }
      50% { transform: rotateY(15deg) scaleX(0.8); }
    }
    
    /* 章節標題專用樣式 - 加粗思源宋體 */
    .chapter-title-text {
      font-family: 'Noto Serif SC', serif !important;
      font-weight: 900 !important;
      font-size: 2.5rem !important;
      line-height: 1.2 !important;
      letter-spacing: 0.05em !important;
      text-shadow: 0 0 20px rgba(255, 255, 255, 0.5) !important;
    }
    
    @media (min-width: 768px) {
      .chapter-title-text {
        font-size: 3.75rem !important;
      }
    }
    

  </style>
</head>
<body class="font-lxgw h-screen overflow-hidden">
  <div id="game-container" class="game-container relative h-screen w-screen overflow-hidden flex flex-col items-center justify-center transition-all duration-500 ease-in-out">
    
    <!-- Current Form Indicator - Enlarged and Enhanced -->
    <div id="current-form-indicator" class="absolute top-4 left-4 md:top-6 md:left-6 z-30 opacity-0 transition-opacity duration-500">
      <div class="form-icon-container bg-gradient-to-br from-white/90 to-indigo-50/70 dark:from-gray-800/90 dark:to-indigo-900/70 rounded-full p-4 
                  shadow-lg flex items-center justify-center w-[140px] h-[140px] overflow-hidden 
                  border-2 border-indigo-400/70 dark:border-indigo-500/70 
                  animate-pulse-subtle relative">
        <!-- Pulsating glow effect -->
        <div class="absolute inset-0 bg-gradient-to-r from-indigo-500/0 via-indigo-500/20 to-indigo-500/0 rounded-full 
                    animate-glow-slide pointer-events-none"></div>
        
        <!-- Rotating Outer Energy Ring -->
        <div class="absolute w-full h-full rounded-full 
                    border border-indigo-300/20 dark:border-indigo-400/20
                    animate-spin-slow">
          <div class="absolute w-3 h-3 bg-indigo-400/60 dark:bg-indigo-300/60 rounded-full top-0 left-1/2 transform -translate-x-1/2 -translate-y-1/2 
                      shadow-md shadow-indigo-400/30 dark:shadow-indigo-300/30"></div>
          <div class="absolute w-2 h-2 bg-indigo-300/60 rounded-full top-1/4 right-0 transform translate-x-1/2 
                      shadow-sm shadow-indigo-300/30"></div>
          <div class="absolute w-3 h-3 bg-indigo-400/60 dark:bg-indigo-300/60 rounded-full bottom-0 left-1/2 transform -translate-x-1/2 translate-y-1/2 
                      shadow-md shadow-indigo-400/30 dark:shadow-indigo-300/30"></div>
        </div>
        
        <!-- Secondary Rotating Energy Ring (opposite direction) -->
        <div class="absolute w-[90%] h-[90%] rounded-full 
                    border border-indigo-400/20 dark:border-indigo-300/20
                    animate-spin-slow-reverse">
          <div class="absolute w-2 h-2 bg-indigo-300/60 rounded-full bottom-1/4 left-0 transform -translate-x-1/2 
                      shadow-sm shadow-indigo-300/30"></div>
          <div class="absolute w-2.5 h-2.5 bg-indigo-300/60 rounded-full top-1/3 left-0 transform -translate-x-1/2 
                      shadow-sm shadow-indigo-300/30"></div>
        </div>
                    
        <!-- Human Form Icon -->
        <div id="human-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-100 scale-100">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-human"></div>
                            <div class="emoji-unified">🧘🏻‍♀️</div>
          </div>
        </div>
        
        <!-- Butterfly Form Icon -->
        <div id="butterfly-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-butterfly"></div>
            <div class="emoji-unified">🦋</div>
          </div>
        </div>
        
        <!-- Fish Form Icon -->
        <div id="fish-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-fish"></div>
            <div class="emoji-unified">🐟</div>
          </div>
        </div>
        
        <!-- Morning Fungus Form Icon -->
        <div id="morning-fungus-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-fungus"></div>
            <div class="emoji-unified">🍄</div>
          </div>
        </div>
        
        <!-- Cicada Form Icon -->
        <div id="cicada-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-cicada"></div>
            <div class="emoji-unified">🦗</div>
          </div>
        </div>
        
        <!-- Great Chun Form Icon -->
        <div id="great-chun-icon" class="absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0">
          <div class="emoji-form-icon">
            <div class="emoji-glow-bg emoji-glow-tree"></div>
            <div class="emoji-unified">🌳</div>
          </div>
        </div>
        
        <!-- 鯤鵬圖示已移除，改為使用獨立的kun-icon和peng-icon -->
        
        <!-- Form Label -->
        <div class="absolute -bottom-1 left-1/2 transform -translate-x-1/2 bg-white/80 dark:bg-gray-800/80 
                    px-3 py-1 rounded-full text-sm font-medium text-indigo-700 dark:text-indigo-300
                    border border-indigo-200 dark:border-indigo-700 shadow-sm">
          <span id="form-label">人形</span>
        </div>
      </div>
    </div>
    
    <!-- Main Menu -->
    <div id="main-menu" class="absolute inset-0 flex flex-col items-center justify-center z-50 transition-opacity duration-500 bg-gradient-to-b from-blue-50 to-indigo-100 dark:from-gray-900 dark:to-indigo-900 py-8">
      <!-- 標題區域 -->
      <div class="text-center mb-12 flex-shrink-0">
        <h1 class="text-4xl md:text-6xl font-bold mb-3 text-indigo-800 dark:text-indigo-300 font-serif">萬物逍遙</h1>
        <p class="text-base md:text-lg text-indigo-600 dark:text-indigo-400 font-medium">一場超越物我界限的哲學之旅</p>
      </div>
      
      <!-- 章節選擇卡片區域 -->
      <div id="chapter-selection" class="w-full max-w-4xl px-4 mb-8 flex flex-col items-center">
        <h2 class="text-lg font-semibold text-center mb-2 text-indigo-700 dark:text-indigo-300">選擇章節</h2>
        <p class="text-xs text-center text-indigo-500 dark:text-indigo-400 mb-4">按洛書九宮格排列，數字為章節序號</p>
        <div id="chapter-cards" class="chapter-grid mx-auto">
          <!-- 章節卡片將在這裡動態生成 -->
        </div>
      </div>

      <!-- 和莊子聊聊按鈕（通關後顯示） -->
      <div id="chat-with-zhuangzi-container" class="w-full max-w-4xl px-4 mb-6 flex flex-col items-center" style="display: none;">
        <div class="flex gap-4 mb-4">
          <button id="chat-with-zhuangzi-btn" class="bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white font-bold py-4 px-8 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-300 flex items-center gap-3 text-lg">
            <div class="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-full flex items-center justify-center shadow-md">
              <span class="text-white font-bold text-lg">🦋</span>
            </div>
            <span>和莊子聊聊</span>
            <span class="text-blue-200">💬</span>
          </button>
          
          <button id="chaos-breathing-btn" class="bg-gradient-to-r from-purple-500 to-violet-600 hover:from-purple-600 hover:to-violet-700 text-white font-bold py-4 px-8 rounded-xl shadow-lg hover:shadow-xl transform hover:scale-105 transition-all duration-300 flex items-center gap-3 text-lg">
            <div class="w-10 h-10 bg-gradient-to-br from-purple-400 to-violet-500 rounded-full flex items-center justify-center shadow-md">
              <span class="text-white font-bold text-lg">🌬️</span>
            </div>
            <span>和混沌呼吸</span>
            <span class="text-purple-200">✨</span>
          </button>
        </div>
        <p class="text-xs text-center text-blue-600 dark:text-blue-400 max-w-md">
          🎉 恭喜通關！現在可以和莊子自由對話，探討人生哲理與遊戲感悟，或與混沌一起進行呼吸調息
        </p>
      </div>
      
      <!-- 控制面板 -->
      <div class="flex flex-col items-center mb-6 space-y-3 flex-shrink-0">
        <!-- 設置控制區域 -->
        <div class="flex flex-col space-y-2">
          <!-- 音效開關 -->
          <div class="flex items-center space-x-3 bg-white dark:bg-gray-800 px-3 py-2 rounded-lg shadow-sm border border-gray-200 dark:border-gray-600">
            <span id="audio-icon" class="text-base transition-all duration-300">🎵</span>
            <span class="text-sm text-gray-700 dark:text-gray-300">音效</span>
            <label class="audio-switch relative inline-block w-10 h-5">
              <input type="checkbox" id="audio-toggle" checked class="opacity-0 w-0 h-0">
              <span class="audio-slider absolute cursor-pointer rounded-full inset-0 transition-all duration-300"></span>
              <span class="audio-knob absolute top-0.5 left-0.5 bg-white w-4 h-4 rounded-full shadow-sm transition-all duration-300"></span>
            </label>
            <span id="audio-status" class="text-xs text-gray-500 dark:text-gray-400 min-w-[28px]">開啟</span>
            
            <!-- 開發者模式按鈕 -->
            <button id="dev-mode-access" class="text-xs text-gray-400 hover:text-gray-600 dark:hover:text-gray-300 px-1 py-1 rounded transition-colors">⚙️</button>
          </div>
          

        </div>
        
        <!-- 音效說明 -->
        <p class="text-xs text-center text-gray-600 dark:text-gray-400 max-w-lg whitespace-nowrap leading-normal mt-2">
          🎧 每一章都有獨特的背景音效和音樂，建議開啟音效以獲得完整的沉浸體驗
        </p>
      </div>


      <!-- 開發者面板（隱藏） -->
      <div id="dev-panel" class="hidden mt-2 p-3 bg-gray-100 dark:bg-gray-800 rounded-lg shadow-md w-full max-w-lg mx-auto">
        <div class="flex justify-between items-center mb-2">
          <h3 class="text-sm font-semibold text-gray-700 dark:text-gray-300">🔧 開發者工具</h3>
          <button id="close-dev-panel" class="text-gray-500 hover:text-red-500 font-bold text-lg leading-none">✕</button>
        </div>
        
        <!-- 數據管理工具區域 -->
        <div class="space-y-2">
          <div class="flex gap-2">
            <button id="reset-player-data-btn" class="flex-1 bg-orange-200 hover:bg-orange-300 dark:bg-orange-700 dark:hover:bg-orange-600 py-1.5 px-2 rounded text-xs font-medium transition-colors duration-200">
              🔄 重置數據
            </button>
            <button id="view-all-data-btn" class="flex-1 bg-blue-200 hover:bg-blue-300 dark:bg-blue-700 dark:hover:bg-blue-600 py-1.5 px-2 rounded text-xs font-medium transition-colors duration-200">
              📋 查看數據
            </button>
          </div>
        </div>
      </div>
      
      <style>
        /* 簡潔音效開關樣式 */
        .audio-switch input:checked ~ .audio-slider {
          background: #6366f1;
        }
        
        .audio-switch input:not(:checked) ~ .audio-slider {
          background: #d1d5db;
        }
        
        .audio-switch input:checked ~ .audio-knob {
          transform: translateX(20px);
        }
        
        .audio-switch input:not(:checked) ~ .audio-knob {
          transform: translateX(0);
        }
        
        /* 暗色模式適配 */
        .dark .audio-switch input:not(:checked) ~ .audio-slider {
          background: #4b5563;
        }
        

        
        /* 音效圖標狀態動畫 */
        .audio-enabled #audio-icon {
          animation: audiobeat 2s ease-in-out infinite;
        }
        
        @keyframes audiobeat {
          0%, 100% { transform: scale(1); }
          50% { transform: scale(1.1); }
        }
        
        /* 開發者面板小開關樣式 */
        .switch input:checked + .slider {
          background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
        }
        
        .switch input:checked + .slider:before {
          transform: translateX(18px);
        }
        
        .switch .slider {
          background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 100%);
        }
        
        .dark .switch .slider {
          background: linear-gradient(135deg, #4b5563 0%, #374151 100%);
        }
        
        /* 無間距九宮格容器樣式 */
        .chapter-grid {
          display: grid;
          grid-template-columns: repeat(3, 1fr);
          grid-template-rows: repeat(3, 1fr);
          gap: 0;
          width: 360px !important;
          height: 360px !important;
          min-width: 360px;
          min-height: 360px;
          max-width: 360px;
          max-height: 360px;
          border: 3px solid #d4af37;
          border-radius: 16px;
          overflow: hidden;
          background: linear-gradient(135deg, #fdfbf7 0%, #f8f4e6 50%, #f5f0e1 100%);
          box-shadow: 
            0 8px 32px rgba(212, 175, 55, 0.15),
            0 4px 16px rgba(139, 69, 19, 0.1),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);
          flex-shrink: 0;
          aspect-ratio: 1;
          position: relative;
        }
        
        .chapter-grid::before {
          content: '';
          position: absolute;
          inset: 0;
          background: linear-gradient(45deg, 
            rgba(212, 175, 55, 0.05) 0%, 
            transparent 25%, 
            transparent 75%, 
            rgba(212, 175, 55, 0.05) 100%);
          pointer-events: none;
        }
        
        .dark .chapter-grid {
          border-color: #b8860b;
          background: linear-gradient(135deg, #1e3a8a 0%, #1e40af 50%, #1d4ed8 100%);
          box-shadow: 
            0 8px 32px rgba(184, 134, 11, 0.2),
            0 4px 16px rgba(30, 58, 138, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .dark .chapter-grid::before {
          background: linear-gradient(45deg, 
            rgba(184, 134, 11, 0.08) 0%, 
            transparent 25%, 
            transparent 75%, 
            rgba(184, 134, 11, 0.08) 100%);
        }
        
        /* 響應式調整 */
        @media (max-width: 480px) {
          .chapter-grid {
            width: 300px !important;
            height: 300px !important;
            min-width: 300px;
            min-height: 300px;
            max-width: 300px;
            max-height: 300px;
          }
          
          /* 小屏幕上的間距調整 */
          #main-menu {
            padding-top: 2rem !important;
            padding-bottom: 2rem !important;
          }
          
          #main-menu .text-center.mb-12 {
            margin-bottom: 1.5rem !important;
          }
          
          #main-menu #chapter-selection {
            margin-bottom: 1.5rem !important;
          }
          
          #main-menu .flex.flex-col.items-center.mb-6 {
            margin-bottom: 1.5rem !important;
          }
          
          /* 開發者面板小屏幕優化 */
          #dev-panel {
            margin: 0.5rem 1rem !important;
            padding: 0.75rem !important;
            max-width: calc(100% - 2rem) !important;
          }
          
          #dev-panel h3 {
            font-size: 0.875rem !important;
          }
          
          #dev-panel button {
            padding: 0.5rem 0.75rem !important;
            font-size: 0.75rem !important;
          }
        }
        
        @media (min-width: 768px) {
          .chapter-grid {
            width: 400px !important;
            height: 400px !important;
            min-width: 400px;
            min-height: 400px;
            max-width: 400px;
            max-height: 400px;
          }
          
          /* 中等屏幕上的間距調整 */
          #main-menu {
            padding-top: 3rem !important;
            padding-bottom: 3rem !important;
          }
        }

        /* 無間距九宮格卡片樣式 */
        .chapter-card {
          background: linear-gradient(135deg, rgba(255, 255, 255, 0.4) 0%, rgba(248, 244, 230, 0.3) 100%);
          border-right: 1px solid rgba(212, 175, 55, 0.25);
          border-bottom: 1px solid rgba(212, 175, 55, 0.25);
          cursor: pointer;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          position: relative;
          overflow: hidden;
          display: flex;
          flex-direction: column;
          justify-content: center;
          align-items: center;
          width: 100%;
          height: 100%;
        }
        
        /* 移除右邊框（第3、6、9個卡片） */
        .chapter-card:nth-child(3n) {
          border-right: none;
        }
        
        /* 移除底邊框（第7、8、9個卡片） */
        .chapter-card:nth-child(n+7) {
          border-bottom: none;
        }
        
        .dark .chapter-card {
          background: linear-gradient(135deg, rgba(30, 64, 175, 0.4) 0%, rgba(29, 78, 216, 0.3) 100%);
          border-color: rgba(184, 134, 11, 0.3);
        }
        
        /* 居中洛書九宮格數字樣式 */
        .luoshu-number-center {
          width: 40px;
          height: 40px;
          min-width: 40px;
          min-height: 40px;
          border-radius: 50%;
          display: flex;
          align-items: center;
          justify-content: center;
          font-size: 20px;
          font-weight: bold;
          font-family: serif;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          margin-bottom: 10px;
          flex-shrink: 0;
          border: 2px solid #d4af37;
        }
        
        /* 陽數（奇數）：白色背景，黑色文字 */
        .luoshu-number-center.luoshu-yang {
          background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 50%, #e9ecef 100%);
          color: #1a1a1a;
          text-shadow: 0 1px 2px rgba(255, 255, 255, 0.5);
          box-shadow: 
            0 4px 12px rgba(212, 175, 55, 0.3),
            0 2px 6px rgba(0, 0, 0, 0.1),
            inset 0 1px 0 rgba(255, 255, 255, 0.8);
        }
        
        /* 陰數（偶數）：黑色背景，白色文字 */
        .luoshu-number-center.luoshu-yin {
          background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 50%, #404040 100%);
          color: #ffffff;
          text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
          box-shadow: 
            0 4px 12px rgba(212, 175, 55, 0.3),
            0 2px 6px rgba(0, 0, 0, 0.4),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        /* 未解鎖的陽數（奇數）：淡化的白色背景 */
        .luoshu-number-center.luoshu-yang.locked {
          background: linear-gradient(135deg, #e5e7eb 0%, #d1d5db 50%, #9ca3af 100%);
          color: #4b5563;
          border-color: #9ca3af;
          box-shadow: 
            0 3px 10px rgba(156, 163, 175, 0.3),
            0 1px 4px rgba(107, 114, 128, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.3);
          opacity: 0.7;
        }
        
        /* 未解鎖的陰數（偶數）：淡化的黑色背景 */
        .luoshu-number-center.luoshu-yin.locked {
          background: linear-gradient(135deg, #6b7280 0%, #4b5563 50%, #374151 100%);
          color: #d1d5db;
          border-color: #6b7280;
          box-shadow: 
            0 3px 10px rgba(107, 114, 128, 0.3),
            0 1px 4px rgba(75, 85, 99, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.1);
          opacity: 0.7;
        }
        
        .dark .luoshu-number-center.luoshu-yang {
          background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 50%, #dee2e6 100%);
          color: #1a1a1a;
          border-color: #fbbf24;
          box-shadow: 
            0 4px 12px rgba(251, 191, 36, 0.4),
            0 2px 6px rgba(0, 0, 0, 0.2),
            inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }
        
        .dark .luoshu-number-center.luoshu-yin {
          background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 50%, #2d2d2d 100%);
          color: #ffffff;
          border-color: #fbbf24;
          box-shadow: 
            0 4px 12px rgba(251, 191, 36, 0.4),
            0 2px 6px rgba(0, 0, 0, 0.6),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        .dark .luoshu-number-center.luoshu-yang.locked {
          background: linear-gradient(135deg, #d1d5db 0%, #9ca3af 50%, #6b7280 100%);
          color: #374151;
          border-color: #9ca3af;
          box-shadow: 
            0 3px 10px rgba(209, 213, 219, 0.2),
            0 1px 4px rgba(156, 163, 175, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);
          opacity: 0.7;
        }
        
        .dark .luoshu-number-center.luoshu-yin.locked {
          background: linear-gradient(135deg, #4b5563 0%, #374151 50%, #1f2937 100%);
          color: #9ca3af;
          border-color: #4b5563;
          box-shadow: 
            0 3px 10px rgba(75, 85, 99, 0.2),
            0 1px 4px rgba(55, 65, 81, 0.15),
            inset 0 1px 0 rgba(255, 255, 255, 0.05);
          opacity: 0.7;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yang {
          transform: scale(1.15);
          box-shadow: 
            0 8px 25px rgba(212, 175, 55, 0.5),
            0 4px 15px rgba(0, 0, 0, 0.15),
            inset 0 2px 0 rgba(255, 255, 255, 0.9);
          background: linear-gradient(135deg, #ffffff 0%, #ffffff 50%, #f1f3f4 100%);
          border-color: #e6c547;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yin {
          transform: scale(1.15);
          box-shadow: 
            0 8px 25px rgba(212, 175, 55, 0.5),
            0 4px 15px rgba(0, 0, 0, 0.6),
            inset 0 1px 0 rgba(255, 255, 255, 0.2);
          background: linear-gradient(135deg, #0d0d0d 0%, #1a1a1a 50%, #2d2d2d 100%);
          border-color: #e6c547;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yang.locked {
          box-shadow: 
            0 6px 20px rgba(156, 163, 175, 0.4),
            0 3px 12px rgba(107, 114, 128, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.4);
          background: linear-gradient(135deg, #f3f4f6 0%, #e5e7eb 50%, #d1d5db 100%);
          opacity: 0.85;
        }
        
        .chapter-card:hover .luoshu-number-center.luoshu-yin.locked {
          box-shadow: 
            0 6px 20px rgba(107, 114, 128, 0.4),
            0 3px 12px rgba(75, 85, 99, 0.3),
            inset 0 1px 0 rgba(255, 255, 255, 0.15);
          background: linear-gradient(135deg, #6b7280 0%, #4b5563 50%, #374151 100%);
          opacity: 0.85;
        }
        
        /* 章節emoji圖標樣式 */
        .chapter-emoji {
          font-size: 20px;
          transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
          flex-shrink: 0;
          line-height: 1;
          filter: drop-shadow(0 2px 4px rgba(0, 0, 0, 0.1));
        }
        
        .chapter-emoji.locked {
          font-size: 18px;
          opacity: 0.7;
        }
        
        .chapter-card:hover .chapter-emoji {
          transform: scale(1.1) translateY(-2px);
          filter: drop-shadow(0 4px 8px rgba(0, 0, 0, 0.15));
        }
        
        .chapter-card:hover .chapter-emoji.locked {
          transform: scale(1.05) translateY(-1px);
          filter: drop-shadow(0 3px 6px rgba(0, 0, 0, 0.12));
        }
        

        
        .chapter-card:hover {
          background: linear-gradient(135deg, rgba(212, 175, 55, 0.1) 0%, rgba(255, 255, 255, 0.6) 50%, rgba(212, 175, 55, 0.1) 100%);
          transform: scale(1.02);
          box-shadow: inset 0 0 20px rgba(212, 175, 55, 0.1);
        }
        
        .dark .chapter-card:hover {
          background: linear-gradient(135deg, rgba(184, 134, 11, 0.15) 0%, rgba(30, 64, 175, 0.7) 50%, rgba(184, 134, 11, 0.15) 100%);
          box-shadow: inset 0 0 20px rgba(184, 134, 11, 0.1);
        }
        
        .chapter-card.unlocked {
          cursor: pointer;
        }
        
        .chapter-card.locked {
          opacity: 0.6;
          cursor: pointer;
        }
        
        .chapter-card.locked:hover {
          background: rgba(148, 163, 184, 0.1);
          opacity: 0.8;
          transform: scale(1.01);
        }
        
        .chapter-card.current {
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.2) 0%, rgba(251, 191, 36, 0.15) 50%, rgba(245, 158, 11, 0.2) 100%);
          border-color: rgba(245, 158, 11, 0.4);
          box-shadow: 
            inset 0 0 15px rgba(245, 158, 11, 0.1),
            0 0 0 1px rgba(245, 158, 11, 0.2);
        }
        
        .dark .chapter-card.current {
          background: linear-gradient(135deg, rgba(245, 158, 11, 0.25) 0%, rgba(251, 191, 36, 0.2) 50%, rgba(245, 158, 11, 0.25) 100%);
          border-color: rgba(245, 158, 11, 0.5);
          box-shadow: 
            inset 0 0 15px rgba(245, 158, 11, 0.15),
            0 0 0 1px rgba(245, 158, 11, 0.3);
        }
        

        
        /* 九宮格響應式優化 */
        @media (max-width: 480px) {
          .luoshu-number-center {
            width: 36px;
            height: 36px;
            min-width: 36px;
            min-height: 36px;
            font-size: 18px;
            margin-bottom: 8px;
          }
          
          .chapter-emoji {
            font-size: 16px;
          }
          
          .chapter-emoji.locked {
            font-size: 15px;
          }
        }
        
        @media (min-width: 768px) {
          .luoshu-number-center {
            width: 44px;
            height: 44px;
            min-width: 44px;
            min-height: 44px;
            font-size: 22px;
            margin-bottom: 12px;
          }
          
          .chapter-emoji {
            font-size: 24px;
          }
          
          .chapter-emoji.locked {
            font-size: 20px;
          }
        }
        

        

        

        

      </style>
    </div>
    
    <!-- Hunlun (Chaos) Container with Seven Apertures -->
    <div id="apertures-tracker" class="absolute top-4 right-4 md:top-6 md:right-6 aperture-container opacity-0 transition-opacity duration-500">
      <!-- Subtle face pattern -->
      <div class="face-pattern" id="face-pattern"></div>
      
      <!-- Individual apertures - no rotating holder -->
      <div class="aperture aperture-random aperture-left-eye" title="左目之竅">👁️‍🗨️</div>
      <div class="aperture aperture-random aperture-right-eye" title="右目之竅">👁️‍🗨️</div>
      <div class="aperture aperture-random aperture-left-ear" title="左耳之竅">👂</div>
      <div class="aperture aperture-random aperture-right-ear" title="右耳之竅">👂</div>
      <div class="aperture aperture-random aperture-left-nose" title="左鼻之竅">⚫</div>
      <div class="aperture aperture-random aperture-right-nose" title="右鼻之竅">⚫</div>
      <div class="aperture aperture-random aperture-mouth" title="口之竅">👄</div>
    </div>
    
    <!-- Chapter Title Display -->
    <div id="chapter-title" class="absolute inset-0 flex flex-col items-center justify-center bg-black bg-opacity-80 z-40 opacity-0 pointer-events-none transition-opacity duration-1000">
      <h1 id="chapter-name" class="chapter-title-text text-white mb-4"></h1>
      <p id="chapter-description" class="text-xl text-gray-200 max-w-md text-center"></p>
    </div>
    
    <!-- Game Content -->
    <div id="game-content" class="w-full h-full relative flex flex-col items-center justify-center opacity-0 transition-opacity duration-500">
      <!-- Scene will be inserted here -->
    </div>
    
    <!-- 繼續按鈕，放置在遊戲內容下方，與物化按鈕間保持適當距離 -->
    <div class="fixed left-0 right-0 flex justify-center" style="top: 78%;">
      <button id="advance-btn" class="hidden pointer-events-auto z-20">
        繼續
      </button>
    </div>
    
    <!-- User Interface -->
    <div id="game-ui" class="absolute bottom-0 left-0 right-0 p-4 md:p-6 flex flex-col items-center opacity-0 transition-opacity duration-500 pointer-events-none">      
      
      <!-- 形態切換按鈕 -->
      <div class="form-selector flex gap-2 justify-center mt-auto pointer-events-auto">
        <button id="human-form" class="form-btn bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50">
          人形
        </button>
        <button id="butterfly-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50">
          蝴蝶
        </button>
        <button id="fish-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          儵魚
        </button>
        <button id="kun-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          鯤
        </button>
        <button id="peng-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          鵬
        </button>
                  <button id="yuanchu-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
            鵷鶵
          </button>
          <button id="chixiao-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
            鴟鴞
        </button>
        <button id="snail-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          蝸牛
        </button>
        <button id="morning-fungus-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          朝菌
        </button>
        <button id="cicada-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          蟪蛄
        </button>
        <button id="great-chun-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          大椿
        </button>
        <button id="ant-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          螻蟻
        </button>
        <button id="star-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          星辰
        </button>
        <button id="qi-form" class="form-btn bg-gray-500 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded disabled:opacity-50 hidden">
          氣
        </button>
      </div>
    </div>
    
    <!-- Dialog Box -->
    <div id="dialog-box" class="absolute top-1/2 left-0 right-0 mx-auto max-w-3xl -translate-y-1/2 bg-white dark:bg-gray-800 border-2 border-indigo-600 dark:border-indigo-500 rounded-lg p-4 shadow-lg opacity-0 transition-all duration-300 transform">
      <p id="dialog-text" class="text-gray-800 dark:text-gray-200"></p>
      <div id="dialog-options" class="mt-4 flex flex-col gap-2 relative" style="z-index: 100;">
        <!-- Dialog options will be inserted here -->
      </div>
    </div>
  </div>

  <script>
    // 暗色主題系統（固定為暗色模式）
    let themePreference = 'dark';
    
    // 初始化主題（固定暗色模式）
    function initializeTheme() {
      document.documentElement.classList.add('dark');
    }
    

    

    
    // 初始化主題
    initializeTheme();
    
    // 统一Emoji物化角色映射系统
    const emojiFormMap = {
              human: { emoji: '🧘🏻‍♀️', name: '人形', glow: 'emoji-glow-human' },
      butterfly: { emoji: '🦋', name: '蝴蝶', glow: 'emoji-glow-butterfly' },
      fish: { emoji: '🐟', name: '儵魚', glow: 'emoji-glow-fish' },
      kun: { emoji: '🐋', name: '鯤', glow: 'emoji-glow-kun' },
      peng: { emoji: '🦅', name: '鵬', glow: 'emoji-glow-peng' },
      yuanchu: { emoji: '🦚', name: '鵷鶵', glow: 'emoji-glow-yuanchu' },
      chixiao: { emoji: '🦉', name: '鴟鴞', glow: 'emoji-glow-chixiao' },
      snail: { emoji: '🐌', name: '蝸牛', glow: 'emoji-glow-snail' },
      'morning-fungus': { emoji: '🍄', name: '朝菌', glow: 'emoji-glow-fungus' },
      cicada: { emoji: '🦗', name: '蟪蛄', glow: 'emoji-glow-cicada' },
      'great-chun': { emoji: '🌳', name: '大椿', glow: 'emoji-glow-tree' },
      ant: { emoji: '🐜', name: '螻蟻', glow: 'emoji-glow-ant' },
      star: { emoji: '⭐', name: '星辰', glow: 'emoji-glow-star' },
      qi: { emoji: '💨', name: '氣', glow: 'emoji-glow-qi' }
    };

    // 创建统一的emoji图标
    function createEmojiIcon(formType, isTransformation = false) {
      const formData = emojiFormMap[formType];
      if (!formData) return null;

      const container = document.createElement('div');
      container.className = 'emoji-form-icon';
      
      if (!isTransformation) {
        const glowBg = document.createElement('div');
        glowBg.className = `emoji-glow-bg ${formData.glow}`;
        container.appendChild(glowBg);
      }
      
      const emoji = document.createElement('div');
      emoji.className = isTransformation ? 'emoji-unified transformation-emoji' : 'emoji-unified';
      emoji.textContent = formData.emoji;
      container.appendChild(emoji);
      
      return container;
    }

    // 确保指定形态的图标存在（修复变身动画空白问题）
    function ensureIconExists(formType) {
      const iconId = `${formType}-icon`;
      const existingIcon = document.getElementById(iconId);
      
      // 如果图标已存在，直接返回
      if (existingIcon) {
        return existingIcon;
      }
      
      // 获取图标容器
      const formIconContainer = document.querySelector('.form-icon-container');
      if (!formIconContainer) {
        console.warn(`无法找到图标容器，无法创建${formType}图标`);
        return null;
      }
      
      // 检查是否是需要动态创建的图标类型
      const dynamicIcons = ['kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      if (!dynamicIcons.includes(formType)) {
        // 静态图标应该已经在HTML中存在
        return existingIcon;
      }
      
      // 动态创建缺失的图标
      console.log(`🔧 创建缺失的${formType}图标用于变身动画`);
      const newIcon = document.createElement('div');
      newIcon.id = iconId;
      newIcon.className = 'absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0';
      newIcon.appendChild(createEmojiIcon(formType));
      formIconContainer.appendChild(newIcon);
      
      return newIcon;
    }

    // 为变身动画添加统一的发光能量粒子效果
    function addTransformationParticleEffects(toForm, iconContainer) {
      const effectConfig = {
        'human': { count: 12, color: 'rgba(147, 146, 255, 0.9)' },
        'butterfly': { count: 15, color: 'rgba(147, 51, 234, 0.9)' },
        'fish': { count: 18, color: 'rgba(59, 130, 246, 0.9)' },
        'kun': { count: 16, color: 'rgba(6, 182, 212, 0.9)' },
        'peng': { count: 14, color: 'rgba(14, 165, 233, 0.9)' },
        'yuanchu': { count: 16, color: 'rgba(255, 215, 0, 0.9)' },
        'chixiao': { count: 12, color: 'rgba(139, 69, 19, 0.9)' },
        'snail': { count: 10, color: 'rgba(147, 50, 158, 0.9)' },
        'morning-fungus': { count: 14, color: 'rgba(245, 158, 11, 0.9)' },
        'cicada': { count: 13, color: 'rgba(34, 197, 94, 0.9)' },
        'great-chun': { count: 20, color: 'rgba(22, 163, 74, 0.9)' },
        'ant': { count: 8, color: 'rgba(120, 53, 15, 0.9)' },
        'star': { count: 25, color: 'rgba(255, 215, 0, 0.9)' },
        'qi': { count: 20, color: 'rgba(147, 146, 255, 0.8)' }
      };

      const config = effectConfig[toForm] || { count: 12, color: 'rgba(255, 255, 255, 0.9)' };

      // 创建统一的发光能量粒子效果
      for (let i = 0; i < config.count; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = `${3 + Math.random() * 4}px`;
        particle.style.height = `${3 + Math.random() * 4}px`;
        particle.style.borderRadius = '50%';
        particle.style.backgroundColor = config.color;
        particle.style.boxShadow = `0 0 ${6 + Math.random() * 8}px ${config.color}`;
        particle.style.pointerEvents = 'none';
        particle.style.zIndex = '1000';
        
        // 随机起始位置（围绕中心）
        const angle = Math.random() * Math.PI * 2;
        const startDistance = 20 + Math.random() * 30;
        const startX = Math.cos(angle) * startDistance;
        const startY = Math.sin(angle) * startDistance;
        
        particle.style.left = `calc(50% + ${startX}px)`;
        particle.style.top = `calc(50% + ${startY}px)`;
        
        // 添加动画
        const delay = Math.random() * 1.5;
        particle.style.animation = `energy-particle-transform 2s ${delay}s ease-out forwards`;
        
        iconContainer.appendChild(particle);
      }

      // 添加统一的能量粒子动画样式（如果不存在）
      if (!document.getElementById('energy-particle-transform-style')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'energy-particle-transform-style';
        styleEl.innerHTML = `
          @keyframes energy-particle-transform {
            0% { 
              transform: scale(0.3) translate(0, 0); 
              opacity: 0; 
            }
            15% { 
              opacity: 1; 
              transform: scale(1) translate(0, 0); 
            }
            100% { 
              transform: scale(0.1) translate(${-80 + Math.random() * 160}px, ${-80 + Math.random() * 160}px); 
              opacity: 0; 
            }
          }
        `;
        document.head.appendChild(styleEl);
      }
    }
    
    // Game state
    const gameState = {
      currentChapter: 'menu',
      currentScene: 0,
      dialogIndex: 0,
      unlockedForms: ['human'],
      currentForm: 'human',
      transformationInProgress: null, // 記錄正在進行的物化形態
      collectedApertures: [],
      hasDonePrologue: false,
      segmentationPuzzleState: {
        solved: false,
        segments: [],
        hideTimer: null
      },
              // birdState removed - 鵷鶵 and 鴟鴞 are now independent forms
      viewScale: 100, // 視角縮放值：100為正常比例，0為最微觀，200為最宏觀
      scaleEnabled: false, // 是否啟用視角縮放功能
      formSequenceGuideActive: false, // 萬物回響引導是否激活（保留兼容性）
      handleFormSequenceClick: null, // 萬物回響點擊處理函數（保留兼容性）
      // 新增：區分初次物化和日常物化
      isInDailyTransformation: false, // 是否處於日常物化狀態
      dailyTransformationPreviousForm: null, // 日常物化前的原始形態
      dailyTransformationAdvanceBtnVisible: false, // 日常物化前繼續按鈕是否可見
      firstTimeUnlockInProgress: false, // 是否正在進行初次解鎖物化
      pendingFormUnlock: null, // 待解鎖的形態（用於初次物化按鈕）
      // 新增：第七章萬物尋氣系統
      baguaLearningCompleted: false,    // 八卦學習是否完成
      wanwuXunqiActive: false,          // 萬物尋氣模式是否激活
      currentBaguaCollection: null,     // 當前收集的八卦類型
      baguaCollectionCount: 0,          // 當前八卦收集數量
      wanwuXunqiProgress: [],           // 已完成的物化形態列表
      wanwuXunqiCurrentFormIndex: 0,    // 當前萬物尋氣的物化形態索引
      // 新增：音頻系統
      audioEnabled: true,               // 音頻是否開啟
      currentBackgroundMusic: null,     // 當前播放的背景音樂
      // 新增：開發者模式狀態
      devMode: false,                   // 開發者模式是否開啟
      devModeAccessedViaPassword: false, // 是否通過密碼進入開發者模式
      
      // 新增：玩家選擇記錄系統 - 用於AI個性化分析和故事影響
      playerChoices: {
        // 選擇歷史記錄
        choiceHistory: [],
        
        // 時間戳記錄
        timingData: {
          sceneStartTime: null,          // 當前場景開始時間
          choiceStartTime: null,         // 選擇開始時間（選項出現時）
          totalThinkingTime: 0,          // 總思考時間
          averageThinkingTime: 0         // 平均思考時間
        },
        
        // 新增：場景停留時間數據
        sceneDwellTime: {
          currentSceneStartTime: null,   // 當前場景開始時間
          sceneDwellTimes: {},           // 各場景停留時間記錄 {chapter_scene: time}
          averageDwellTime: 0,           // 平均場景停留時間
          totalDwellTime: 0              // 總停留時間
        },
        
        // 新增：物化體驗數據
        transformationData: {
          transformationHistory: [],     // 物化歷史記錄
          formUsageCount: {},            // 各形態使用次數
          transformationDurations: {},   // 各形態停留時間
          firstTimeTransformations: [],  // 初次物化記錄
          dailyTransformations: [],      // 日常物化記錄
          transformationPatterns: {      // 物化模式分析
            preferredForms: [],          // 偏好形態
            transformationFrequency: 0,  // 物化頻率
            explorationDepth: 0,         // 探索深度
            comfortZone: [],             // 舒適區形態
            experimentalForms: []        // 實驗性形態
          }
        },
        
        // 新增：斷句挑戰表現數據
        segmentationPuzzleData: {
          puzzleAttempts: {},            // 各章節斷句挑戰嘗試記錄
          completionTimes: {},           // 完成時間記錄
          accuracyRates: {},             // 準確率記錄
          hintUsage: {},                 // 提示使用情況
          puzzlePerformance: {           // 整體表現分析
            averageCompletionTime: 0,    // 平均完成時間
            averageAccuracy: 0,          // 平均準確率
            learningCurve: [],           // 學習曲線
            difficultyAdaptation: 0,     // 難度適應能力
            persistenceLevel: 0          // 堅持程度
          }
        },
        
        // 新統一的8維度數據收集系統
        traits: {
          // === MBTI四個維度 ===
          // 能量指向
          E: 0,    // 外向 (Extraversion) - 關注外部世界，從社交中獲得能量
          I: 0,    // 內向 (Introversion) - 關注內心世界，從獨處中獲得能量
          
          // 信息接收
          S: 0,    // 感覺 (Sensing) - 關注現實、細節、具體經驗
          N: 0,    // 直覺 (Intuition) - 關注可能性、抽象概念、未來
          
          // 決策方式
          T: 0,    // 思考 (Thinking) - 基於邏輯和客觀分析做決策
          F: 0,    // 情感 (Feeling) - 基於價值觀和情感做決策
          
          // 生活方式
          J: 0,    // 判斷 (Judging) - 喜歡計劃性、確定性、結論
          P: 0,    // 知覺 (Perceiving) - 喜歡靈活性、開放性、探索
          
          // === 莊子哲學四個維度 ===
          // 對事物的態度
          AT: 0,   // 執着 (Attachment) - 堅持、追求、不肯放下
          DT: 0,   // 超脫 (Detachment) - 淡然、放下、不被束縛
          
          // 面對問題的方式
          IN: 0,   // 干預 (Intervention) - 主動改變、積極行動
          WU: 0,   // 無為 (Wu Wei) - 順其自然、不強求、自然而然
          
          // 對差異的認知
          DI: 0,   // 分別 (Discrimination) - 區分好壞、判斷優劣
          EQ: 0,   // 齊等 (Equality) - 萬物平等、不分高下
          
          // 對價值的判斷
          US: 0,   // 有用 (Useful) - 追求實用、講求效果
          UN: 0    // 無用 (Useless) - 看重無用之用、超越功利
        },
        
        // 選擇模式分析
        choicePatterns: {
          consistencyScore: 0,     // 一致性評分
          contradictions: [],      // 矛盾選擇記錄
          evolutionTrend: [],      // 思想演化趨勢
          dominantTraits: [],      // 主導特質
          secondaryTraits: [],     // 次要特質
          storyBranches: []        // 故事分支影響記錄
        },
        
        // 章節特定選擇影響
        chapterInfluences: {
          prologue: { choices: [], storyBranch: 'default' },
          chapter1: { choices: [], storyBranch: 'default' },
          chapter2: { choices: [], storyBranch: 'default' },
          chapter3: { choices: [], storyBranch: 'default' },
          chapter4: { choices: [], storyBranch: 'default' },
          chapter5: { choices: [], storyBranch: 'default' },
          chapter6: { choices: [], storyBranch: 'default' },
          chapter7: { choices: [], storyBranch: 'default' },
          epilogue: { choices: [], storyBranch: 'default' }
        },
        
        // 章節選擇統計
        chapterChoices: {},
        
        // AI調用準備數據
        aiContext: {
          lastUpdateTime: null,
          profileSummary: '',
          mbtiType: '',              // 推測的MBTI類型
          recentTrends: [],
          suggestedResponseStyle: '',
          storyPersonalization: {    // 故事個性化數據
            preferredNarrativeStyle: '', // 偏好的敘述風格
            emotionalResonance: [],      // 情感共鳴點
            challengeLevel: '',          // 適合的挑戰難度
            guidanceNeed: ''            // 指導需求程度
          }
        },
        
        // 聊天記錄數據
        chatHistory: {
          allQuestions: [],            // 所有問題記錄
          chapterQuestions: {},        // 各章節問題記錄
          questionCount: 0,            // 總問題數量
          chatPatterns: {              // 聊天模式分析
            questionTypes: {},         // 問題類型統計
            engagementLevel: 0,        // 參與程度
            preferredTopics: []        // 偏好主題
          }
        }
      }
    };

    // 玩家選擇記錄和分析系統
    
    // 記錄物化體驗數據
    function recordTransformationData(form, isDailyTransformation, fromForm) {
      const timestamp = Date.now();
      
      // 構建物化記錄
      const transformationRecord = {
        timestamp: timestamp,
        form: form,
        fromForm: fromForm,
        type: isDailyTransformation ? 'daily' : 'story',
        chapter: gameState.currentChapter,
        scene: gameState.currentScene,
        context: {
          unlockedForms: [...gameState.unlockedForms],
          currentForm: form
        }
      };
      
      // 添加到歷史記錄
      gameState.playerChoices.transformationData.transformationHistory.push(transformationRecord);
      
      // 更新使用次數統計
      if (!gameState.playerChoices.transformationData.formUsageCount[form]) {
        gameState.playerChoices.transformationData.formUsageCount[form] = 0;
      }
      gameState.playerChoices.transformationData.formUsageCount[form]++;
      
      // 記錄初次物化
      if (!gameState.playerChoices.transformationData.firstTimeTransformations.includes(form)) {
        gameState.playerChoices.transformationData.firstTimeTransformations.push(form);
        transformationRecord.isFirstTime = true;
      }
      
      // 記錄日常物化
      if (isDailyTransformation) {
        gameState.playerChoices.transformationData.dailyTransformations.push(transformationRecord);
      }
      
      // 更新物化模式分析
      updateTransformationPatterns();
      
      // 立即保存遊戲進度，確保物化數據不丟失
      saveGameProgress();
      
      console.log(`🔄 物化數據記錄: ${fromForm} -> ${form} (${isDailyTransformation ? '日常' : '劇情'})`);
    }
    
    // 更新物化模式分析
    function updateTransformationPatterns() {
      const data = gameState.playerChoices.transformationData;
      
      // 計算物化頻率
      data.transformationPatterns.transformationFrequency = data.transformationHistory.length;
      
      // 找出偏好形態（使用次數最多的前3個）
      const sortedForms = Object.entries(data.formUsageCount)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 3)
        .map(([form]) => form);
      data.transformationPatterns.preferredForms = sortedForms;
      
      // 計算探索深度（使用過的形態數量）
      data.transformationPatterns.explorationDepth = Object.keys(data.formUsageCount).length;
      
      // 找出舒適區形態（使用次數最多的）
      data.transformationPatterns.comfortZone = sortedForms.slice(0, 1);
      
      // 找出實驗性形態（只使用過1次的）
      data.transformationPatterns.experimentalForms = Object.entries(data.formUsageCount)
        .filter(([,count]) => count === 1)
        .map(([form]) => form);
    }
    
    // 記錄斷句挑戰嘗試數據（僅在內存中累加，不涉及localStorage）
    function recordSegmentationPuzzleAttempt(isCorrect) {
      // 使用內存中的本次斷句數據
      const currentData = gameState.currentPuzzleData;
      
      // 累加嘗試次數
      currentData.attempts += 1;
      currentData.correctAttempts += (isCorrect ? 1 : 0);
      currentData.incorrectAttempts += (isCorrect ? 0 : 1);
      
      // 如果是第一次嘗試，設置開始時間
      if (!currentData.startTime) {
        currentData.startTime = Date.now();
      }
      
      currentData.lastAttemptTime = Date.now();
      
      console.log(`🧩 本次斷句挑戰嘗試記錄: 第${currentData.attempts}次嘗試 (${isCorrect ? '正確' : '錯誤'})`);
    }
    
    // 記錄斷句挑戰完成數據（將本次數據替換更新到localStorage）
    function recordSegmentationPuzzleCompletion(isSuccessful) {
      const puzzleKey = `${gameState.currentChapter}_${gameState.currentScene}`;
      const data = gameState.playerChoices.segmentationPuzzleData;
      
      // 使用本次斷句的內存數據
      const currentData = gameState.currentPuzzleData;
      
      if (!currentData || currentData.attempts === 0) {
        console.warn('⚠️ 沒有本次斷句數據，無法記錄完成');
        return;
      }
      
      // 檢查startTime是否存在，如果不存在則使用當前時間（fallback）
      if (!currentData.startTime) {
        console.warn('⚠️ startTime未設置，使用當前時間作為fallback');
        currentData.startTime = Date.now();
      }
      
      const completionTime = Date.now() - currentData.startTime;
      
      // 將本次數據替換更新到localStorage
      data.puzzleAttempts[puzzleKey] = {
        attempts: currentData.attempts,
        correctAttempts: currentData.correctAttempts,
        incorrectAttempts: currentData.incorrectAttempts,
        startTime: currentData.startTime,
        lastAttemptTime: currentData.lastAttemptTime
      };
      
      // 記錄完成時間
      data.completionTimes[puzzleKey] = completionTime;
      
      // 計算準確率
      const accuracy = currentData.correctAttempts / currentData.attempts;
      data.accuracyRates[puzzleKey] = accuracy;
      
      // 更新整體表現分析
      updatePuzzlePerformanceAnalysis();
      
      // 立即保存遊戲進度，確保斷句挑戰完成數據不丟失
      saveGameProgress();
      
      // 如果是尾聲章節的斷句挑戰成功完成，設置標志以恢復指示器顯示
      if (isSuccessful && gameState.currentChapter === 'epilogue') {
        gameState.epilogueSegmentationCompleted = true;
        console.log('✅ 尾聲章節斷句挑戰完成，設置標志以恢復指示器顯示');
      }
      
      console.log(`✅ 斷句挑戰完成記錄: ${puzzleKey} - 完成時間: ${completionTime}ms, 嘗試次數: ${currentData.attempts}, 準確率: ${(accuracy * 100).toFixed(1)}%`);
    }
    
    // 更新斷句挑戰表現分析
    function updatePuzzlePerformanceAnalysis() {
      const data = gameState.playerChoices.segmentationPuzzleData;
      const performance = data.puzzlePerformance;
      
      // 計算平均完成時間
      const completionTimes = Object.values(data.completionTimes);
      if (completionTimes.length > 0) {
        performance.averageCompletionTime = completionTimes.reduce((sum, time) => sum + time, 0) / completionTimes.length;
      }
      
      // 計算平均準確率
      const accuracyRates = Object.values(data.accuracyRates);
      if (accuracyRates.length > 0) {
        performance.averageAccuracy = accuracyRates.reduce((sum, rate) => sum + rate, 0) / accuracyRates.length;
      }
      
      // 計算學習曲線（按章節順序）
      performance.learningCurve = Object.keys(data.completionTimes)
        .sort()
        .map(key => ({
          puzzle: key,
          completionTime: data.completionTimes[key],
          accuracy: data.accuracyRates[key],
          attempts: data.puzzleAttempts[key] ? data.puzzleAttempts[key].attempts : 1
        }));
      
      // 計算難度適應能力（後期章節的表現改善程度）
      if (performance.learningCurve.length >= 2) {
        const earlyPerformance = performance.learningCurve.slice(0, Math.ceil(performance.learningCurve.length / 2));
        const latePerformance = performance.learningCurve.slice(Math.ceil(performance.learningCurve.length / 2));
        
        const earlyAvgTime = earlyPerformance.reduce((sum, p) => sum + p.completionTime, 0) / earlyPerformance.length;
        const lateAvgTime = latePerformance.reduce((sum, p) => sum + p.completionTime, 0) / latePerformance.length;
        
        performance.difficultyAdaptation = earlyAvgTime > 0 ? (earlyAvgTime - lateAvgTime) / earlyAvgTime : 0;
      }
      
      // 計算堅持程度（總嘗試次數）
      const totalAttempts = Object.values(data.puzzleAttempts)
        .reduce((sum, record) => sum + record.attempts, 0);
      performance.persistenceLevel = totalAttempts;
    }
    
    // 獲取完整的玩家數據用於AI報告生成
    function getCompletePlayerData() {
      // 計算平均場景停留時間
      const sceneDwellTimes = Object.values(gameState.playerChoices.sceneDwellTime.sceneDwellTimes);
      if (sceneDwellTimes.length > 0) {
        gameState.playerChoices.sceneDwellTime.averageDwellTime = 
          sceneDwellTimes.reduce((sum, time) => sum + time, 0) / sceneDwellTimes.length;
      }
      
      return {
        // 基本信息
        totalPlayTime: gameState.playerChoices.sceneDwellTime.totalDwellTime,
        averageSceneDwellTime: gameState.playerChoices.sceneDwellTime.averageDwellTime,
        totalChoices: gameState.playerChoices.choiceHistory.length,
        
        // 選擇數據
        choiceHistory: gameState.playerChoices.choiceHistory,
        traits: gameState.playerChoices.traits,
        
        // 物化體驗數據
        transformationData: {
          totalTransformations: gameState.playerChoices.transformationData.transformationHistory.length,
          formUsageCount: gameState.playerChoices.transformationData.formUsageCount,
          firstTimeTransformations: gameState.playerChoices.transformationData.firstTimeTransformations,
          dailyTransformations: gameState.playerChoices.transformationData.dailyTransformations.length,
          transformationPatterns: gameState.playerChoices.transformationData.transformationPatterns
        },
        
        // 斷句挑戰數據
        segmentationPuzzleData: {
          totalPuzzles: Object.keys(gameState.playerChoices.segmentationPuzzleData.puzzleAttempts).length,
          averageCompletionTime: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.averageCompletionTime,
          averageAccuracy: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.averageAccuracy,
          learningCurve: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.learningCurve,
          difficultyAdaptation: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.difficultyAdaptation,
          persistenceLevel: gameState.playerChoices.segmentationPuzzleData.puzzlePerformance.persistenceLevel
        },
        
        // 遊戲進度
        gameProgress: {
          currentChapter: gameState.currentChapter,
          unlockedForms: gameState.unlockedForms,
          collectedApertures: gameState.collectedApertures,
          totalApertures: gameState.collectedApertures.length
        },
        
        // 時間數據
        timingData: gameState.playerChoices.timingData,
        
        // 章節影響
        chapterInfluences: gameState.playerChoices.chapterInfluences,
        
        // 聊天記錄數據
        chatHistory: {
          totalQuestions: gameState.playerChoices.chatHistory?.questionCount || 0,
          allQuestions: gameState.playerChoices.chatHistory?.allQuestions || [],
          chapterQuestions: gameState.playerChoices.chatHistory?.chapterQuestions || {},
          engagementLevel: gameState.playerChoices.chatHistory?.chatPatterns?.engagementLevel || 0,
          recentQuestions: gameState.playerChoices.chatHistory?.allQuestions?.slice(-10) || [] // 最近10個問題
        }
      };
    }
    
    // 記錄玩家選擇（核心函數）
    function recordPlayerChoice(choiceData) {
      const timestamp = Date.now();
      const thinkingTime = gameState.playerChoices.timingData.choiceStartTime ? 
        timestamp - gameState.playerChoices.timingData.choiceStartTime : 0;
      
      console.log('📝 ===== 玩家選擇記錄調試信息 =====');
      console.log('🎯 記錄時間:', new Date().toLocaleTimeString());
      console.log('📊 輸入的選擇數據:', choiceData);
      console.log('⏱️ 思考時間:', `${Math.round(thinkingTime / 1000)}秒 (${thinkingTime}ms)`);
      
      // 檢查是否已經有這個位置的選擇記錄
      const existingChoiceIndex = gameState.playerChoices.choiceHistory.findIndex(choice => 
        choice.chapter === gameState.currentChapter && choice.scene === gameState.currentScene
      );
      
      if (existingChoiceIndex !== -1) {
        const existingChoice = gameState.playerChoices.choiceHistory[existingChoiceIndex];
        console.log('🔄 發現同位置的選擇記錄:', existingChoice.choiceText);
        console.log('🔄 當前選擇:', choiceData.text);
        
        // 遵循首次選擇最準確的原則，跳過重複選擇
        console.log('🎯 保持首次選擇的準確性，跳過重複記錄');
          return;
      }
      
      // 構建選擇記錄
      const choiceRecord = {
        id: generateChoiceId(),
        timestamp: timestamp,
        chapter: gameState.currentChapter,
        scene: gameState.currentScene,
        choiceText: choiceData.text,
        choiceIndex: choiceData.index || 0,
        thinkingTime: thinkingTime,
        context: {
          speaker: choiceData.speaker || 'unknown',
          situation: choiceData.situation || '',
          currentForm: gameState.currentForm
        },
        // 隱蔽的特質標記（新8維度系統）
        traits: choiceData.traits || {},
        // 故事分支影響
        storyImpact: choiceData.storyImpact || {}
      };
      
      // 新增：1分制數據收集系統調試信息
      console.log('🎯 ===== 1分制數據收集系統調試 =====');
      console.log('📊 選擇前特質狀態:', JSON.stringify(gameState.playerChoices.traits, null, 2));
      console.log('➕ 本次選擇將添加的特質:', JSON.stringify(choiceData.traits, null, 2));
      
      // 預覽特質變化
      const previewTraits = {...gameState.playerChoices.traits};
      if (choiceData.traits) {
        Object.keys(choiceData.traits).forEach(trait => {
          if (choiceData.traits[trait] === 1) {
            previewTraits[trait] = (previewTraits[trait] || 0) + 1;
          }
        });
      }
      console.log('🔮 選擇後特質預覽:', JSON.stringify(previewTraits, null, 2));
      
      // 檢查是否符合1分制原則
      const nonOnePointTraits = Object.entries(choiceData.traits || {}).filter(([trait, value]) => value !== 1);
      if (nonOnePointTraits.length > 0) {
        console.warn('⚠️ 發現非1分制特質標記:', nonOnePointTraits);
      } else {
        console.log('✅ 符合1分制原則');
      }
      
      console.log('🔍 構建的選擇記錄:', {
        id: choiceRecord.id,
        chapter: choiceRecord.chapter,
        scene: choiceRecord.scene,
        choiceText: choiceRecord.choiceText,
        thinkingTime: `${Math.round(choiceRecord.thinkingTime / 1000)}s`,
        traits: choiceRecord.traits
      });
      
      // 添加到歷史記錄
      gameState.playerChoices.choiceHistory.push(choiceRecord);
      
      console.log('📚 選擇歷史更新:', {
        總選擇數: gameState.playerChoices.choiceHistory.length,
        本章選擇數: gameState.playerChoices.choiceHistory.filter(c => c.chapter === gameState.currentChapter).length
      });
      
      // 記錄章節特定選擇
      recordChapterInfluence(choiceRecord);
      
      // 更新時間統計
      updateTimingStatistics(thinkingTime);
      
      // 應用特質影響
      applyTraitInfluence(choiceRecord.traits);
      
      // 更新調試面板（如果存在）
      if (document.getElementById('debug-panel')) {
        updateDebugPanel();
      }
      
      // 立即保存遊戲進度，確保數據不丟失
      saveGameProgress();
      
      console.log('✅ 玩家選擇記錄完成並已保存');
    }
    
    // 記錄聊天問題
    function recordChatQuestion(question) {
      const timestamp = Date.now();
      const currentChapter = gameState.currentChapter;
      
      // 確保chatHistory結構存在
      if (!gameState.playerChoices.chatHistory) {
        console.log('⚠️ chatHistory未初始化，跳過記錄');
        return;
      }
      
      // 簡單過濾：過短、過長或明顯無效的問題
      const cleanQuestion = question.trim();
      if (cleanQuestion.length < 3 || cleanQuestion.length > 200) {
        console.log('📝 聊天問題過濾：問題長度不符合要求');
        return;
      }
      
      // 構建問題記錄
      const questionRecord = {
        question: cleanQuestion,
        timestamp: timestamp,
        chapter: currentChapter,
        scene: gameState.currentScene
      };
      
      console.log('💬 記錄聊天問題:', {
        問題: cleanQuestion,
        章節: currentChapter,
        場景: gameState.currentScene,
        時間: new Date(timestamp).toLocaleTimeString()
      });
      
      // 添加到總問題記錄
      gameState.playerChoices.chatHistory.allQuestions.push(questionRecord);
      
      // 添加到章節問題記錄
      if (!gameState.playerChoices.chatHistory.chapterQuestions[currentChapter]) {
        gameState.playerChoices.chatHistory.chapterQuestions[currentChapter] = [];
      }
      gameState.playerChoices.chatHistory.chapterQuestions[currentChapter].push(questionRecord);
      
      // 更新問題數量統計
      gameState.playerChoices.chatHistory.questionCount++;
      
      // 簡單的參與度統計
      gameState.playerChoices.chatHistory.chatPatterns.engagementLevel = 
        gameState.playerChoices.chatHistory.questionCount;
      
      // 立即保存遊戲進度，確保聊天數據不丟失
      saveGameProgress();
      
      console.log('📊 聊天統計更新:', {
        總問題數: gameState.playerChoices.chatHistory.questionCount,
        當前章節問題數: gameState.playerChoices.chatHistory.chapterQuestions[currentChapter]?.length || 0,
        參與度: gameState.playerChoices.chatHistory.chatPatterns.engagementLevel
      });
    }
    
    // 已移除复杂的重新计算逻辑，专注于首次选择的准确性
    
    // === 1分制数据收集系统的核心函数 ===
    
    // 应用特质影响（1分制优化版）
    function applyTraitInfluence(choiceTraits) {
      console.log('🎯 應用特質影響（1分制） - 輸入數據:', choiceTraits);
      
      // 验证数据有效性
      if (!validateChoiceData({ traits: choiceTraits })) {
        console.log('⚠️ 沒有有效的特質數據');
        return;
      }
      
      // 应用1分制特质累积
      updateTraitsOnePointSystem(choiceTraits);
      
      // 更新選擇模式分析
      analyzeChoicePatterns();
      
      // 更新AI上下文
      updateAIContext();
      
      console.log('✅ 特質影響應用完成（1分制）');
    }
    
    // 1分制特质累积系统
    function updateTraitsOnePointSystem(newTraits) {
      const currentTraits = gameState.playerChoices.traits;
      
      console.log('🎯 累積特質（1分制）:', newTraits);
      
      // 遍历并累积特质分数（每个选择统一+1分）
      for (const [trait, value] of Object.entries(newTraits)) {
        if (currentTraits.hasOwnProperty(trait)) {
          // 1分制：每个特质标记统一+1分
          const increment = value > 0 ? 1 : 0; // 只要标记了就+1分
          const oldValue = currentTraits[trait];
          currentTraits[trait] = Math.max(0, Math.min(100, oldValue + increment));
          
          if (increment > 0) {
            console.log(`  ${trait}: ${oldValue} +1 = ${currentTraits[trait]}`);
          }
        }
      }
      
      // 记录当前状态用于时序分析
      recordTraitsSnapshot();
      
      console.log('✅ 特質狀態更新完成（1分制）:', currentTraits);
    }
    
    // 记录特质快照（用于时序分析）
    function recordTraitsSnapshot() {
      const snapshot = {
        timestamp: Date.now(),
        traits: { ...gameState.playerChoices.traits },
        choiceCount: gameState.playerChoices.choiceHistory.length
      };
      
      // 保存到演化趋势中
      if (!gameState.playerChoices.choicePatterns.evolutionTrend) {
        gameState.playerChoices.choicePatterns.evolutionTrend = [];
      }
      
      gameState.playerChoices.choicePatterns.evolutionTrend.push(snapshot);
      
      // 保持合理的历史记录长度
      if (gameState.playerChoices.choicePatterns.evolutionTrend.length > 15) {
        gameState.playerChoices.choicePatterns.evolutionTrend.shift();
      }
    }
    
    // 注：1分制系统中移除了复杂的维度平衡机制
    // 因为每个选择只贡献1分，不会出现需要平衡的情况
    
    // 重置特質分數到初始狀態（測試和調試用）
    function resetTraitsToInitial() {
      const traits = gameState.playerChoices.traits;
      
      // 重置所有8個維度到0
      Object.keys(traits).forEach(trait => {
        traits[trait] = 0;
      });
      
      console.log('🔄 特質分數已重置 (測試/調試功能)');
    }
    
    // 已移除章節選擇修改功能，專注於首次選擇的準確性
    
    // 生成選擇ID
    function generateChoiceId() {
      return `choice_${gameState.currentChapter}_${gameState.currentScene}_${Date.now()}`;
    }
    
    // 記錄章節特定選擇影響
    function recordChapterInfluence(choiceRecord) {
      const chapter = choiceRecord.chapter;
      const chapterInfluence = gameState.playerChoices.chapterInfluences[chapter];
      
      if (!chapterInfluence) {
        console.log(`⚠️ 章節影響結構未找到: ${chapter}`);
        return;
      }
      
      // 添加選擇記錄到章節影響
      chapterInfluence.choices.push({
        scene: choiceRecord.scene,
        choiceText: choiceRecord.choiceText,
        traits: choiceRecord.traits,
        timestamp: choiceRecord.timestamp
      });
      
      // 更新章節選擇計數
      if (!gameState.playerChoices.chapterChoices[chapter]) {
        gameState.playerChoices.chapterChoices[chapter] = 0;
      }
      gameState.playerChoices.chapterChoices[chapter]++;
      
      console.log(`📚 章節影響記錄: ${chapter} (選擇數: ${chapterInfluence.choices.length})`);
    }

    // === 進度存檔系統 ===
    
    // 章節配置數據
    const chapterConfig = {
      prologue: { title: '第一章：莊周夢蝶', emoji: '🦋', description: '夢與現實的界限在何處？' },
      chapter1: { title: '第二章：子非魚', emoji: '🐟', description: '站在濠梁之上，思考魚的快樂' },
      chapter2: { title: '第三章：北冥有魚', emoji: '🐋', description: '從鯤到鵬的變化之道' },
      chapter3: { title: '第四章：鴟得腐鼠', emoji: '🦅', description: '價值觀的相對性與包容' },
      chapter4: { title: '第五章：蝸角之爭', emoji: '🐌', description: '在微觀中理解爭執的虛妄' },
      chapter5: { title: '第六章：朝菌與大椿', emoji: '🍄', description: '時間的相對性與生命的意義' },
      chapter6: { title: '第七章：螻蟻星辰', emoji: '⭐', description: '生死之間，超越界限' },
      chapter7: { title: '第八章：道歸混沌', emoji: '🌪️', description: '七竅既開，渾沌歸一' },
      epilogue: { title: '第九章：逍遙遊', emoji: '🌅', description: '回歸本心，自在逍遙' }
    };
    
    // 保存遊戲進度
    function saveGameProgress() {
      const progressData = {
        maxReachedChapter: gameState.maxReachedChapter || gameState.currentChapter,
        unlockedChapters: getUnlockedChapters(),
        collectedApertures: gameState.collectedApertures,
        unlockedForms: gameState.unlockedForms,
        lastPlayTime: Date.now(),
        currentScene: gameState.currentScene,
        currentForm: gameState.currentForm,
        audioEnabled: gameState.audioEnabled,
        baguaLearningCompleted: gameState.baguaLearningCompleted,
        wanwuXunqiActive: gameState.wanwuXunqiActive,
        wanwuXunqiProgress: gameState.wanwuXunqiProgress,
        chatHistoryMap: chatHistoryMap,
        playerChoices: gameState.playerChoices
      };
      
      try {
        localStorage.setItem('zhuangziGameProgress', JSON.stringify(progressData));
        console.log('💾 遊戲進度已保存');
      } catch (error) {
        console.error('❌ 保存進度失敗:', error);
      }
    }
    
    // 讀取遊戲進度
    function loadGameProgress() {
      try {
        const savedData = localStorage.getItem('zhuangziGameProgress');
        if (savedData) {
          const progressData = JSON.parse(savedData);
          console.log('📖 讀取到遊戲進度:', progressData);
          return progressData;
        }
      } catch (error) {
        console.error('❌ 讀取進度失敗:', error);
      }
      return null;
    }
    
    // 獲取已解鎖的章節列表
    function getUnlockedChapters() {
      const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
      const maxReachedChapter = gameState.maxReachedChapter || gameState.currentChapter;
      const maxIndex = chapters.indexOf(maxReachedChapter);
      
      if (maxIndex === -1) return ['prologue']; // 默認只解鎖序章
      
      // 返回到最高章節為止的所有章節
      return chapters.slice(0, maxIndex + 1);
    }
    
    // 生成章節卡片
    function generateChapterCards() {
      const savedProgress = loadGameProgress();
      const unlockedChapters = savedProgress ? 
        getUnlockedChaptersFromProgress(savedProgress.maxReachedChapter) : 
        ['prologue'];
      
      const cardsContainer = document.getElementById('chapter-cards');
      if (!cardsContainer) return;
      
      cardsContainer.innerHTML = '';
      
      // 洛書九宮格排列：4 9 2 / 3 5 7 / 8 1 6
      // 對應章節：第三章 尾聲 第一章 / 第二章 第四章 第六章 / 第七章 序章 第五章
      const luoshuOrder = [
        'chapter3', 'epilogue', 'chapter1',    // 第一行：4 9 2
        'chapter2', 'chapter4', 'chapter6',    // 第二行：3 5 7  
        'chapter7', 'prologue', 'chapter5'     // 第三行：8 1 6
      ];
      
      luoshuOrder.forEach(chapterId => {
        const config = chapterConfig[chapterId];
        if (config) {
          const isUnlocked = unlockedChapters.includes(chapterId);
          const isCurrent = savedProgress && savedProgress.maxReachedChapter === chapterId;
          
          const card = createChapterCard(chapterId, config, isCurrent, isUnlocked);
          cardsContainer.appendChild(card);
        }
      });
    }
    
    // 從進度數據獲取已解鎖章節
    function getUnlockedChaptersFromProgress(maxChapter) {
      const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
      const maxIndex = chapters.indexOf(maxChapter);
      
      if (maxIndex === -1) return ['prologue'];
      
      return chapters.slice(0, maxIndex + 1);
    }
    

    // 創建章節卡片
    function createChapterCard(chapterId, config, isCurrent, isUnlocked) {
      const card = document.createElement('div');
      
      const chapterNumber = chapterId === 'prologue' ? '序' : 
                           chapterId === 'epilogue' ? '尾' : 
                           chapterId.replace('chapter', '');
      
      // 洛書九宮格數字對應表
      const luoshuNumbers = {
        'prologue': '1',   // 序章對應洛書數字1
        'chapter1': '2',   // 第一章對應洛書數字2  
        'chapter2': '3',   // 第二章對應洛書數字3
        'chapter3': '4',   // 第三章對應洛書數字4
        'chapter4': '5',   // 第四章對應洛書數字5
        'chapter5': '6',   // 第五章對應洛書數字6
        'chapter6': '7',   // 第六章對應洛書數字7
        'chapter7': '8',   // 第七章對應洛書數字8
        'epilogue': '9'    // 尾聲對應洛書數字9
      };
      
      const luoshuNumber = luoshuNumbers[chapterId] || '';
      
      if (isUnlocked) {
        // 已解鎖章節
        card.className = `chapter-card ${isCurrent ? 'current' : 'unlocked'}`;
        
        // 判斷洛書數字的陰陽屬性
        const yinYangClass = parseInt(luoshuNumber) % 2 === 1 ? 'luoshu-yang' : 'luoshu-yin';
        
        card.innerHTML = `
          <div class="luoshu-number-center ${yinYangClass}">${luoshuNumber}</div>
          <div class="chapter-emoji">${config.emoji}</div>
        `;
        
        card.addEventListener('click', () => {
          jumpToChapter(chapterId);
        });
      } else {
        // 未解鎖章節
        card.className = 'chapter-card locked';
        
        // 判斷洛書數字的陰陽屬性（未解鎖狀態）
        const yinYangClass = parseInt(luoshuNumber) % 2 === 1 ? 'luoshu-yang' : 'luoshu-yin';
        
        card.innerHTML = `
          <div class="luoshu-number-center ${yinYangClass} locked">${luoshuNumber}</div>
          <div class="chapter-emoji locked">🔒</div>
        `;
        
        // 鎖定章節的點擊提示
        card.addEventListener('click', () => {
          showUnlockHint(chapterId);
        });
      }
      
      return card;
    }
    
    // 顯示解鎖提示
    function showUnlockHint(chapterId) {
      const luoshuNumbers = {
        'prologue': '1',   
        'chapter1': '2',   
        'chapter2': '3',   
        'chapter3': '4',   
        'chapter4': '5',   
        'chapter5': '6',   
        'chapter6': '7',   
        'chapter7': '8',   
        'epilogue': '9'    
      };
      
      const chapterTitles = {
        'prologue': '第一章：莊周夢蝶',
        'chapter1': '第二章：濠梁觀魚',
        'chapter2': '第三章：北冥有魚',
        'chapter3': '第四章：鴟得腐鼠',
        'chapter4': '第五章：蝸角之爭',
        'chapter5': '第六章：朝菌大椿',
        'chapter6': '第七章：螻蟻星辰',
        'chapter7': '第八章：道歸混沌',
        'epilogue': '第九章：逍遙遊'
      };
      
      const luoshuNumber = luoshuNumbers[chapterId];
      const chapterTitle = chapterTitles[chapterId] || '此章節';
      
      alert(`洛書${luoshuNumber}宮：${chapterTitle}\n\n尚未解鎖！請先完成前面的章節來解鎖新的內容。`);
    }
    
    // 跳轉到指定章節（重用現有邏輯）
    function jumpToChapter(chapterId) {
      // 使用現有的setupChapterPrerequisites和startChapter邏輯
      setupChapterPrerequisites(chapterId);
      
      // 關閉主菜單
      const mainMenu = document.getElementById('main-menu');
      const aperturesTracker = document.getElementById('apertures-tracker');
      const gameUI = document.getElementById('game-ui');
      const gameContent = document.getElementById('game-content');
      
      mainMenu.style.opacity = 0;
      setTimeout(() => {
        mainMenu.style.display = 'none';
        aperturesTracker.style.opacity = 1;
        gameUI.style.opacity = 1;
        gameContent.style.opacity = 1;
        document.getElementById('current-form-indicator').style.opacity = 1;
        
        // 保存當前已達到的最高章節，避免被覆蓋
        const savedProgress = loadGameProgress();
        const originalMaxChapter = savedProgress ? savedProgress.maxReachedChapter : 'prologue';
        
        // 開始對應章節
        startChapter(chapterId);
        
        // 恢復原始的最高章節記錄，然後保存進度
        gameState.maxReachedChapter = originalMaxChapter;
        saveGameProgress();
      }, 500);
    }
    
    // 開發者模式密碼驗證
    function initDevModeAccess() {
      const devAccessBtn = document.getElementById('dev-mode-access');
      const devPanel = document.getElementById('dev-panel');
      const closeDevBtn = document.getElementById('close-dev-panel');
      
      if (devAccessBtn) {
        devAccessBtn.addEventListener('click', () => {
          const password = prompt('請輸入開發者密碼：');
          if (password === '1644') {
            devPanel.classList.remove('hidden');
            // 設置開發者模式狀態
            gameState.devMode = true;
            gameState.devModeAccessedViaPassword = true;
            document.documentElement.classList.add('dev-mode');
            showDevMessage('開發者模式已通過密碼開啟');
          } else if (password !== null) {
            alert('密碼錯誤！');
          }
        });
      }
      
      if (closeDevBtn) {
        closeDevBtn.addEventListener('click', () => {
          devPanel.classList.add('hidden');
        });
      }
    }
    
    // 更新時間統計
    function updateTimingStatistics(thinkingTime) {
      const timing = gameState.playerChoices.timingData;
      timing.totalThinkingTime += thinkingTime;
      
      const totalChoices = gameState.playerChoices.choiceHistory.length;
      if (totalChoices > 0) {
        timing.averageThinkingTime = timing.totalThinkingTime / totalChoices;
      }
    }
    
    // === 新增：章節特定選擇記錄 ===
    function recordChapterSpecificChoice(choiceRecord) {
      const chapterKey = choiceRecord.chapter;
      if (gameState.playerChoices.chapterInfluences[chapterKey]) {
        gameState.playerChoices.chapterInfluences[chapterKey].choices.push({
          scene: choiceRecord.scene,
          text: choiceRecord.choiceText,
          traits: choiceRecord.traits,
          storyImpact: choiceRecord.storyImpact
        });
      }
    }
    
    // === 故事分支影響處理（保留）===
    function processStoryImpact(impactData) {
      const chapterKey = gameState.currentChapter;
      
      if (impactData.branchInfluence) {
        // 更新該章節的故事分支
        if (gameState.playerChoices.chapterInfluences[chapterKey]) {
          gameState.playerChoices.chapterInfluences[chapterKey].storyBranch = 
            impactData.branchInfluence;
        }
        
        // 記錄分支變化
        gameState.playerChoices.choicePatterns.storyBranches.push({
          chapter: chapterKey,
          scene: gameState.currentScene,
          branch: impactData.branchInfluence,
          timestamp: Date.now()
        });
      }
    }
    
    // 分析選擇模式
    function analyzeChoicePatterns() {
      const history = gameState.playerChoices.choiceHistory;
      const patterns = gameState.playerChoices.choicePatterns;
      
      if (history.length < 3) return; // 需要足夠的數據才能分析
      
      // 計算一致性評分
      calculateConsistencyScore();
      
      // 識別主導特質
      identifyDominantTraits();
      
      // 檢測思想演化趨勢
      detectEvolutionTrend();
    }
    
    // 計算選擇一致性評分（新8維度系統）
    function calculateConsistencyScore() {
      const traits = gameState.playerChoices.traits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      // 基於特質分布的一致性分析
      const traitValues = Object.values(traits);
      const maxTrait = Math.max(...traitValues);
      const minTrait = Math.min(...traitValues);
      
      // 一致性評分：特質分化程度（有明顯偏好）vs 平均分布（猶豫不決）
      const consistency = maxTrait > 30 ? (maxTrait - minTrait) / 100 : 0;
      patterns.consistencyScore = Math.round(consistency * 100);
    }
    
    // 識別主導特質（新8維度系統）
    function identifyDominantTraits() {
      const traits = gameState.playerChoices.traits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      // 按分數排序特質
      const sortedTraits = Object.entries(traits)
        .sort(([,a], [,b]) => b - a)
        .filter(([,score]) => score > 20); // 只考慮有意義的分數
      
      patterns.dominantTraits = sortedTraits.slice(0, 3).map(([trait,]) => trait);
      patterns.secondaryTraits = sortedTraits.slice(3, 6).map(([trait,]) => trait);
    }
    
    // 檢測思想演化趨勢
    function detectEvolutionTrend() {
      const history = gameState.playerChoices.choiceHistory;
      const patterns = gameState.playerChoices.choicePatterns;
      
      if (history.length < 5) return;
      
      // 分析最近5個選擇的趨勢
      const recentChoices = history.slice(-5);
      const recentTraits = {};
      
      recentChoices.forEach(choice => {
        for (const [trait, value] of Object.entries(choice.traits)) {
          recentTraits[trait] = (recentTraits[trait] || 0) + value;
        }
      });
      
      // 記錄演化趨勢
      patterns.evolutionTrend.push({
        timestamp: Date.now(),
        trends: recentTraits,
        dominantInRecent: Object.keys(recentTraits).sort((a,b) => recentTraits[b] - recentTraits[a])[0]
      });
      
      // 保持趨勢記錄在合理範圍內
      if (patterns.evolutionTrend.length > 10) {
        patterns.evolutionTrend.shift();
      }
    }
    
    // 更新AI調用上下文（增強版 - 新8維度系統）
    function updateAIContext() {
      const context = gameState.playerChoices.aiContext;
      const traits = gameState.playerChoices.traits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      context.lastUpdateTime = Date.now();
      
      // 生成性格檔案摘要
      context.profileSummary = generateProfileSummary();
      
      // 確定MBTI類型
      context.mbtiType = determineMBTIType();
      
      // 移除冗余的哲学性格分析，直接使用8维度原始数据
      context.rawTraits = traits;
      
      // 暂时注释掉依赖已删除函数的调用
      // context.recentTrends = analyzeRecentTrends();
      // context.suggestedResponseStyle = suggestResponseStyle();
      // context.storyPersonalization = generateStoryPersonalization();
    }
    
    // 生成性格檔案摘要（新8維度系統）
    function generateProfileSummary() {
      const traits = gameState.playerChoices.traits;
      const patterns = gameState.playerChoices.choicePatterns;
      
      const summary = {
        dominantTraits: patterns.dominantTraits.slice(0, 2),
        consistencyLevel: patterns.consistencyScore > 60 ? 'high' : patterns.consistencyScore > 30 ? 'medium' : 'low',
        totalChoices: gameState.playerChoices.choiceHistory.length,
        averageThinkingTime: Math.round(gameState.playerChoices.timingData.averageThinkingTime),
        // 移除冗余的哲学性格分析，直接使用8维度原始数据
        rawTraits: traits
      };
      
      return summary;
    }
    
    // === 1分制MBTI类型推测（优化版）===
    function determineMBTIType() {
      const traits = gameState.playerChoices.traits;
      const choiceCount = gameState.playerChoices.choiceHistory.length;
      
      console.log('🧠 MBTI判断（1分制）- 选择数量:', choiceCount);
      
      // 计算对立维度差异
      const eVsI = (traits.E || 0) - (traits.I || 0);
      const sVsN = (traits.S || 0) - (traits.N || 0);
      const tVsF = (traits.T || 0) - (traits.F || 0);
      const jVsP = (traits.J || 0) - (traits.P || 0);
      
      console.log('维度差异:', { eVsI, sVsN, tVsF, jVsP });
      
      // 1分制下的判断逻辑：早期需要更明显差异，后期微小差异也有意义
      const threshold = choiceCount < 10 ? 2 : 1;
      
      const E_I = Math.abs(eVsI) >= threshold ? (eVsI > 0 ? 'E' : 'I') : 
                 (eVsI >= 0 ? 'E' : 'I'); // 平局时默认E
      const S_N = Math.abs(sVsN) >= threshold ? (sVsN > 0 ? 'S' : 'N') : 
                 (sVsN >= 0 ? 'S' : 'N'); // 平局时默认S
      const T_F = Math.abs(tVsF) >= threshold ? (tVsF > 0 ? 'T' : 'F') : 
                 (tVsF >= 0 ? 'T' : 'F'); // 平局时默认T
      const J_P = Math.abs(jVsP) >= threshold ? (jVsP > 0 ? 'J' : 'P') : 
                 (jVsP >= 0 ? 'J' : 'P'); // 平局时默认J
      
      const mbtiType = E_I + S_N + T_F + J_P;
      console.log('确定MBTI类型:', mbtiType);
      
      return mbtiType;
    }
    
    // === 新增：MBTI類型描述 ===
    function getMBTITypeDescription(mbtiType) {
      const descriptions = {
        'ENFJ': '教育家：富有同情心的引導者，關心他人成長',
        'ENFP': '激勵者：熱情洋溢的理想主義者，富有創造力',
        'ENTJ': '指揮官：天生的領導者，果斷而有遠見',
        'ENTP': '辯論家：聰明好辯的思想家，喜愛智力挑戰',
        'ESFJ': '執政官：熱心助人的合作者，重視和諧',
        'ESFP': '娛樂者：活潑開朗的表演者，享受當下',
        'ESTJ': '總經理：實用主義的組織者，重視效率',
        'ESTP': '企業家：精力充沛的實用主義者，適應力強',
        'INFJ': '提倡者：富有洞察力的理想主義者，追求意義',
        'INFP': '調停者：富有想像力的理想主義者，價值觀驅動',
        'INTJ': '建築師：富有想像力的戰略家，追求完美',
        'INTP': '思想家：富有創新精神的發明家，追求理解',
        'ISFJ': '守護者：溫暖體貼的保護者，樂於助人',
        'ISFP': '探險家：靈活友善的藝術家，追求和諧',
        'ISTJ': '物流師：實用忠誠的傳統主義者，責任感強',
        'ISTP': '鑑賞家：靈活務實的技師，擅長解決問題'
      };
      
      return descriptions[mbtiType] || '探索中：正在發現自己的人格類型';
    }
    
    // 設置選擇開始時間（在選項出現時調用）
    function startChoiceTimer() {
      gameState.playerChoices.timingData.choiceStartTime = Date.now();
    }
    
    // 獲取AI調用的完整數據包（增強版）
    function getAIAnalysisData() {
      const choiceHistory = gameState.playerChoices.choiceHistory;
      
      // 詳細調試日誌
      console.log('🔍 ===== AI數據收集詳細調試 =====');
      console.log('📊 基礎數據統計:', {
        選擇歷史長度: choiceHistory.length,
        新特質數量: Object.keys(gameState.playerChoices.traits || {}).length,
        AI上下文可用: !!gameState.playerChoices.aiContext,
        聊天問題總數: gameState.playerChoices.chatHistory?.questionCount || 0,
        當前章節問題數: gameState.playerChoices.chatHistory?.chapterQuestions?.[gameState.currentChapter]?.length || 0,
        物化記錄總數: gameState.playerChoices.transformationData?.transformationHistory?.length || 0,
        斷句挑戰完成數: Object.keys(gameState.playerChoices.segmentationPuzzleData?.puzzleAttempts || {}).length,
        場景停留記錄數: Object.keys(gameState.playerChoices.sceneDwellTime?.sceneDwellTimes || {}).length
      });
      
      console.log('🧠 特質數據詳情:');
      console.log('  新8維度特質:', gameState.playerChoices.traits);
      
      console.log('📈 選擇模式分析:', gameState.playerChoices.choicePatterns);
      console.log('👤 玩家檔案:', gameState.playerChoices.aiContext?.profileSummary);
      console.log('🎨 建議風格:', gameState.playerChoices.aiContext?.suggestedResponseStyle);
      
      console.log('🕰️ 最近5個選擇詳情:');
      choiceHistory.slice(-5).forEach((choice, index) => {
        console.log(`  ${index + 1}. [${choice.chapter}場景${choice.scene}] "${choice.choiceText}"`);
        console.log(`     特質: ${JSON.stringify(choice.traits)} | 思考時間: ${Math.round(choice.thinkingTime / 1000)}s`);
      });
      
      console.log('💬 聊天記錄詳情:');
      const recentQuestions = gameState.playerChoices.chatHistory?.allQuestions?.slice(-3) || [];
      if (recentQuestions.length > 0) {
        recentQuestions.forEach((q, index) => {
          console.log(`  ${index + 1}. [${q.chapter}] "${q.question}"`);
        });
      } else {
        console.log('  暫無聊天記錄');
      }
      
      console.log('🔄 物化行為數據:');
      console.log('  物化總次數:', gameState.playerChoices.transformationData?.transformationHistory?.length || 0);
      console.log('  形態使用統計:', gameState.playerChoices.transformationData?.formUsageCount || {});
      console.log('  偏好形態:', gameState.playerChoices.transformationData?.transformationPatterns?.preferredForms || []);
      
      console.log('🧩 斷句挑戰數據:');
      console.log('  平均完成時間:', gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.averageCompletionTime || 0);
      console.log('  平均準確率:', gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.averageAccuracy || 0);
      console.log('  堅持程度:', gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.persistenceLevel || 0);
      
      // 檢查數據完整性
      const dataIntegrity = {
        選擇記錄完整: choiceHistory.length > 0,
        特質數據存在: Object.keys(gameState.playerChoices.traits || {}).length > 0,
        AI上下文存在: !!gameState.playerChoices.aiContext?.profileSummary,
        遊戲進度有效: !!gameState.currentChapter,
        聊天記錄存在: (gameState.playerChoices.chatHistory?.questionCount || 0) > 0,
        物化數據存在: (gameState.playerChoices.transformationData?.transformationHistory?.length || 0) > 0,
        斷句數據存在: Object.keys(gameState.playerChoices.segmentationPuzzleData?.puzzleAttempts || {}).length > 0,
        時間數據存在: Object.keys(gameState.playerChoices.sceneDwellTime?.sceneDwellTimes || {}).length > 0
      };
      
      console.log('✅ 數據完整性檢查:', dataIntegrity);
      
      const analysisData = {
        // 移除冗余的哲学性格分析系统，直接使用8维度原始数据
        profile: gameState.playerChoices.aiContext?.profileSummary || '玩家檔案',
        traits: gameState.playerChoices.traits,
        patterns: gameState.playerChoices.choicePatterns,
        
        // 第1層：選擇數據（最高優先級 - 40%權重）
        choices: choiceHistory.map(choice => ({
          choiceText: choice.choiceText,
          chapter: choice.chapter,
          scene: choice.scene,
          thinkingTime: choice.thinkingTime,
          traits: choice.traits,
          timestamp: choice.timestamp
        })),
        
        // 第2層：聊天互動數據（高優先級 - 25%權重）
        chatHistory: {
          totalQuestions: gameState.playerChoices.chatHistory?.questionCount || 0,
          allQuestions: gameState.playerChoices.chatHistory?.allQuestions || [],
          chapterQuestions: gameState.playerChoices.chatHistory?.chapterQuestions || {},
          currentChapterQuestions: gameState.playerChoices.chatHistory?.chapterQuestions?.[gameState.currentChapter] || [],
          engagementLevel: gameState.playerChoices.chatHistory?.chatPatterns?.engagementLevel || 0,
          recentQuestions: gameState.playerChoices.chatHistory?.allQuestions?.slice(-5) || [], // 最近5個問題
          questionTypes: gameState.playerChoices.chatHistory?.chatPatterns?.questionTypes || {},
          preferredTopics: gameState.playerChoices.chatHistory?.chatPatterns?.preferredTopics || []
        },
        
        // 第3層：時間數據（中等優先級 - 20%權重）
        timingData: {
          totalThinkingTime: gameState.playerChoices.timingData?.totalThinkingTime || 0,
          averageThinkingTime: gameState.playerChoices.timingData?.averageThinkingTime || 0,
          sceneDwellTimes: gameState.playerChoices.sceneDwellTime?.sceneDwellTimes || {},
          averageSceneDwellTime: gameState.playerChoices.sceneDwellTime?.averageDwellTime || 0,
          totalPlayTime: gameState.playerChoices.sceneDwellTime?.totalDwellTime || 0,
          paceAnalysis: {
            isDeepThinker: (gameState.playerChoices.timingData?.averageThinkingTime || 0) > 5000,
            isContemplativePlayer: (gameState.playerChoices.sceneDwellTime?.averageDwellTime || 0) > 30000,
            totalGameDuration: gameState.playerChoices.sceneDwellTime?.totalDwellTime || 0
          }
        },
        
        // 第4層：物化行為數據（中等優先級 - 10%權重）
        transformationData: {
          totalTransformations: gameState.playerChoices.transformationData?.transformationHistory?.length || 0,
          formUsageCount: gameState.playerChoices.transformationData?.formUsageCount || {},
          firstTimeTransformations: gameState.playerChoices.transformationData?.firstTimeTransformations || [],
          dailyTransformations: gameState.playerChoices.transformationData?.dailyTransformations || [],
          transformationPatterns: {
            preferredForms: gameState.playerChoices.transformationData?.transformationPatterns?.preferredForms || [],
            transformationFrequency: gameState.playerChoices.transformationData?.transformationPatterns?.transformationFrequency || 0,
            explorationDepth: gameState.playerChoices.transformationData?.transformationPatterns?.explorationDepth || 0,
            comfortZone: gameState.playerChoices.transformationData?.transformationPatterns?.comfortZone || [],
            experimentalForms: gameState.playerChoices.transformationData?.transformationPatterns?.experimentalForms || []
          }
        },
        
        // 第5層：斷句挑戰數據（較低優先級 - 5%權重）
        segmentationPuzzleData: {
          totalPuzzles: Object.keys(gameState.playerChoices.segmentationPuzzleData?.puzzleAttempts || {}).length,
          puzzleAttempts: gameState.playerChoices.segmentationPuzzleData?.puzzleAttempts || {},
          completionTimes: gameState.playerChoices.segmentationPuzzleData?.completionTimes || {},
          accuracyRates: gameState.playerChoices.segmentationPuzzleData?.accuracyRates || {},
          puzzlePerformance: {
            averageCompletionTime: gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.averageCompletionTime || 0,
            averageAccuracy: gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.averageAccuracy || 0,
            learningCurve: gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.learningCurve || [],
            difficultyAdaptation: gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.difficultyAdaptation || 0,
            persistenceLevel: gameState.playerChoices.segmentationPuzzleData?.puzzlePerformance?.persistenceLevel || 0
          }
        },
        
        context: {
          currentChapter: gameState.currentChapter,
          currentScene: gameState.currentScene,
          currentForm: gameState.currentForm,
          gameProgress: getGameProgressSummary(),
          // AI章節總結需要的recentHistory格式
          recentHistory: choiceHistory.slice(-8).map(choice => ({
            choiceText: choice.choiceText,
            chapter: choice.chapter,
            scene: choice.scene,
            thinkingTime: choice.thinkingTime,
            traits: choice.traits,
            situation: choice.context?.situation || choice.context?.speaker || '對話場景'
          }))
        },
        
        suggestedStyle: gameState.playerChoices.aiContext?.suggestedResponseStyle || '親切自然'
      };
      
      console.log('📦 最終AI數據包（完整5層）:', {
        profile可用: !!analysisData.profile,
        traits數量: Object.keys(analysisData.traits || {}).length,
        choices數量: analysisData.choices.length,
        recentHistory數量: analysisData.context.recentHistory.length,
        suggestedStyle可用: !!analysisData.suggestedStyle,
        chatHistory可用: !!analysisData.chatHistory,
        聊天問題數量: analysisData.chatHistory?.totalQuestions || 0,
        物化記錄數量: analysisData.transformationData?.totalTransformations || 0,
        斷句挑戰數量: analysisData.segmentationPuzzleData?.totalPuzzles || 0,
        時間數據完整性: !!(analysisData.timingData?.totalPlayTime && analysisData.timingData?.averageThinkingTime)
      });
      
      console.log('========================================');
      return analysisData;
    }
    
    // 獲取遊戲進度摘要
    function getGameProgressSummary() {
      return {
        chaptersCompleted: getCompletedChapters(),
        formsUnlocked: gameState.unlockedForms.length,
        aperturesCollected: gameState.collectedApertures.length,
        totalPlayTime: estimatePlayTime()
      };
    }
    
    // 估算遊戲時間
    function estimatePlayTime() {
      const choices = gameState.playerChoices.choiceHistory;
      if (choices.length < 2) return 0;
      
      const startTime = choices[0].timestamp;
      const endTime = choices[choices.length - 1].timestamp;
      return Math.round((endTime - startTime) / 1000 / 60); // 分鐘
    }
    
         // 獲取已完成章節
     function getCompletedChapters() {
       // 基於選擇歷史推斷完成的章節
       const chapterSet = new Set();
       gameState.playerChoices.choiceHistory.forEach(choice => {
         chapterSet.add(choice.chapter);
       });
       return Array.from(chapterSet);
     }
     
     // 獲取當前情境描述
     function getCurrentSituation() {
       const chapter = gameChapters[gameState.currentChapter];
       if (!chapter) return 'unknown';
       
       const scene = chapter.scenes[gameState.currentScene];
       if (!scene) return 'unknown';
       
       // 組合情境描述
       return {
         chapterTitle: chapter.title,
         sceneType: scene.type,
         sceneText: scene.text ? scene.text.substring(0, 100) + '...' : '',
         background: chapter.background
       };
     }
     
     // 从选择文本中推断哲学特质（新8维度系统）
     function extractTraitsFromChoice(choiceText, speaker, chapter) {
       // 新系统中，特质标记由选项直接提供，不需要文本分析
       // 这个函数现在主要用于过渡期和后备方案
       console.log('⚠️  使用文本分析提取特质，建议直接使用选项标记');
       
       return {
         traits: {
           // 默认返回空的8维度特质
           E: 0, I: 0, S: 0, N: 0, T: 0, F: 0, J: 0, P: 0,
           AT: 0, DT: 0, IN: 0, WU: 0, DI: 0, EQ: 0, US: 0, UN: 0
         }
       };
     }
     
     // 根據章節特色調整特質權重（新8維度系統）
     function adjustTraitsByChapter(traits, chapter) {
       // 新系统中章节特色调整由选项标记直接体现
       // 这个函数现在主要用于过渡期
       console.log('⚠️  使用章节特质调整，建议在选项标记中直接体现章节特色');
       return traits;
      }
      
      // 測試和演示函數（可以在開發者控制台中調用）
      function showPlayerAnalysis() {
        const data = getAIAnalysisData();
        console.log('🎯 玩家性格分析報告:');
        console.log('='.repeat(50));
        console.log('📊 基本統計:');
        console.log(`總選擇次數: ${data.profile.totalChoices}`);
        console.log(`平均思考時間: ${data.profile.averageThinkingTime}ms`);
        console.log(`一致性水平: ${data.profile.consistencyLevel}`);
        console.log('');
        console.log('🧠 哲學傾向分數 (0-100):');
        for (const [trait, score] of Object.entries(data.traits)) {
          if (score > 0) {
            console.log(`${trait}: ${score}`);
          }
        }
        console.log('');
        console.log('🎭 主導特質:');
        console.log(`主要: ${data.patterns.dominantTraits.join(', ')}`);
        console.log(`次要: ${data.patterns.secondaryTraits.join(', ')}`);
        console.log('');
               console.log('📈 最近趨勢:');
       if (data.context?.recentHistory && data.context.recentHistory.length > 0) {
         data.context.recentHistory.forEach((choice, index) => {
           console.log(`${index + 1}. [${choice.chapter}] ${choice.choiceText} (思考${choice.thinkingTime}ms)`);
         });
       } else {
         console.log('暫無選擇記錄');
       }
        console.log('');
        console.log('🎨 建議AI風格:');
        console.log(`語調: ${data.suggestedStyle.tone}`);
        console.log(`深度: ${data.suggestedStyle.depth}`);
        console.log(`方式: ${data.suggestedStyle.approach}`);
        console.log('='.repeat(50));
        
        return data;
      }
      
      // 生成AI調用示例（演示如何使用數據）
      function generateAIPromptExample() {
        const data = getAIAnalysisData();
        
        const prompt = `你是莊子，正在與一位朋友對話。基於以下分析數據，請生成個性化的回應：

玩家性格檔案：
- 主導特質：${data.patterns.dominantTraits.join(', ')}
- 一致性：${data.profile.consistencyLevel}
- 思考速度：${data.profile.averageThinkingTime > 3000 ? '深思熟慮' : '快速決斷'}

當前情境：
- 章節：${data.context.currentChapter}
- 形態：${data.context.currentForm}

最近選擇模式：
${(data.context?.recentHistory || []).map(h => `- ${h.choiceText || '未知選擇'}`).join('\n') || '暫無選擇記錄'}

建議回應風格：
- 語調：${data.suggestedStyle.tone}
- 深度：${data.suggestedStyle.depth}  
- 方式：${data.suggestedStyle.approach}

請以莊子的智慧和這個朋友的特質，給出一個深刻而個性化的回應。`;

        console.log('🤖 AI調用示例Prompt:');
        console.log(prompt);
        console.log('');
        console.log('💡 可以複製上述prompt到AI API進行個性化回應生成');
        
        return prompt;
      }
      
      // 創建初始玩家選擇狀態
      function createInitialPlayerChoicesState() {
        return {
          choiceHistory: [],
          timingData: {
            sceneStartTime: null,
            choiceStartTime: null,
            totalThinkingTime: 0,
            averageThinkingTime: 0
          },
          traits: {
            // MBTI維度
            E: 0, I: 0, S: 0, N: 0, T: 0, F: 0, J: 0, P: 0,
            // 莊子哲學維度
            AT: 0, DT: 0, IN: 0, WU: 0, DI: 0, EQ: 0, US: 0, UN: 0
          },
          choicePatterns: {
            consistencyScore: 0, contradictions: [], evolutionTrend: [],
            dominantTraits: [], secondaryTraits: [], storyBranches: []
          },
          chapterInfluences: {},
          aiContext: {
            lastUpdateTime: null, profileSummary: '', recentTrends: [],
            suggestedResponseStyle: '', philosophicalType: '', mbtiType: '',
            storyPersonalization: {}
          },
          transformationData: {
            transformationHistory: [],
            formUsageCount: {},
            firstTimeTransformations: [],
            dailyTransformations: [],
            transformationPatterns: {}
          },
          segmentationPuzzleData: {
            puzzleAttempts: {},
            puzzlePerformance: {
              averageCompletionTime: 0,
              averageAccuracy: 0,
              learningCurve: [],
              difficultyAdaptation: 0,
              persistenceLevel: 0
            }
          },
          sceneDwellTime: {
            sceneDwellTimes: {},
            totalDwellTime: 0,
            averageDwellTime: 0
          }
        };
      }
      
      // 重置選擇記錄（用於測試）
      function resetPlayerChoices() {
        gameState.playerChoices = {
          choiceHistory: [],
          timingData: {
            sceneStartTime: null,
            choiceStartTime: null,
            totalThinkingTime: 0,
            averageThinkingTime: 0
          },
          traits: {
            // MBTI維度
            E: 0, I: 0, S: 0, N: 0, T: 0, F: 0, J: 0, P: 0,
            // 莊子哲學維度
            AT: 0, DT: 0, IN: 0, WU: 0, DI: 0, EQ: 0, US: 0, UN: 0
          },
          choicePatterns: {
            consistencyScore: 0, contradictions: [], evolutionTrend: [],
            dominantTraits: [], secondaryTraits: [], storyBranches: []
          },
          chapterInfluences: {},
          aiContext: {
            lastUpdateTime: null, profileSummary: '', recentTrends: [],
            suggestedResponseStyle: '', philosophicalType: '', mbtiType: '',
            storyPersonalization: {}
          },
          transformationData: {
            transformationHistory: [],
            formUsageCount: {},
            firstTimeTransformations: [],
            dailyTransformations: [],
            transformationPatterns: {}
          },
          segmentationPuzzleData: {
            puzzleAttempts: {},
            puzzlePerformance: {
              averageCompletionTime: 0,
              averageAccuracy: 0,
              learningCurve: [],
              difficultyAdaptation: 0,
              persistenceLevel: 0
            }
          },
          sceneDwellTime: {
            sceneDwellTimes: {},
            totalDwellTime: 0,
            averageDwellTime: 0
          }
        };
                 console.log('🔄 玩家選擇記錄已重置');
       }

    // === 时序性AI判断策略和数据验证函数 ===
    
    // 基于时序的AI回应生成策略
    function generateTimedAIResponse(sceneType, context) {
      const choiceCount = gameState.playerChoices.choiceHistory.length;
      const traits = gameState.playerChoices.traits;
      
      console.log('⏰ 基于时序的AI回应策略 - 选择数量:', choiceCount);
      
      if (choiceCount < 6) {
        // 早期阶段：主要基于具体选择
        return generateEarlyStageResponse(sceneType, context);
      } else if (choiceCount < 30) {
        // 中期阶段：开始模式识别
        return generateMidStageResponse(sceneType, context);
      } else {
        // 后期阶段：深度个性化
        return generateLateStageResponse(sceneType, context);
      }
    }
    
    // 早期阶段AI回应（1-5个选择）
    function generateEarlyStageResponse(sceneType, context) {
      const recentChoices = gameState.playerChoices.choiceHistory.slice(-3);
      
      console.log('🌱 早期阶段AI回应 - 关注具体选择');
      
      // 分析最近的选择特征
      const recentTraits = {};
      recentChoices.forEach(choice => {
        if (choice.traits) {
          Object.keys(choice.traits).forEach(trait => {
            recentTraits[trait] = (recentTraits[trait] || 0) + 1;
          });
        }
      });
      
      // 找出最突出的特征
      const dominantRecent = Object.entries(recentTraits)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 2)
        .map(([trait,]) => trait);
      
      return {
        strategy: 'recent_choice_focused',
        dominantTraits: dominantRecent,
        confidence: 'low',
        responseStyle: 'exploratory',
        recommendation: '主要回应具体选择，轻度参考累积倾向'
      };
    }
    
    // 中期阶段AI回应（6-29个选择）
    function generateMidStageResponse(sceneType, context) {
      const traits = gameState.playerChoices.traits;
      
      console.log('🌿 中期阶段AI回应 - 开始模式识别');
      
      // 识别初步的主导特质
      const dominantTraits = Object.entries(traits)
        .sort(([,a], [,b]) => b - a)
        .filter(([,score]) => score >= 3) // 至少3个相关选择
        .slice(0, 3)
        .map(([trait,]) => trait);
      
      // 计算倾向强度
      const maxScore = Math.max(...Object.values(traits));
      const confidence = maxScore >= 6 ? 'medium' : 'low';
      
      return {
        strategy: 'pattern_recognition',
        dominantTraits: dominantTraits,
        confidence: confidence,
        responseStyle: 'cautious_personalized',
        recommendation: '开始识别模式和趋势，但保持保守'
      };
    }
    
    // 后期阶段AI回应（30+个选择）- 清理版
    function generateLateStageResponse(sceneType, context) {
      const mbtiType = determineMBTIType();
      const traits = gameState.playerChoices.traits;
      
      console.log('🌳 后期阶段AI回应 - 基于8维度原始数据');
      
      // 直接使用8维度数据分析，无需额外的性格分类
      const dominantTraits = Object.entries(traits)
        .sort(([,a], [,b]) => b - a)
        .slice(0, 4)
        .map(([trait, score]) => ({ trait, score }));
      
      return {
        strategy: 'deep_personalization',
        mbtiType: mbtiType,
        rawTraits: traits,
        dominantTraits: dominantTraits,
        confidence: 'high',
        responseStyle: 'deeply_personalized',
        recommendation: '使用8维度原始数据进行个性化分析'
      };
    }
    
    // 检查选择数据的有效性
    function validateChoiceData(choiceData) {
      if (!choiceData || !choiceData.traits) {
        console.log('⚠️ 选择数据无效：缺少特质信息');
        return false;
      }
      
      const traits = choiceData.traits;
      const validTraits = ['E', 'I', 'S', 'N', 'T', 'F', 'J', 'P', 'AT', 'DT', 'IN', 'WU', 'DI', 'EQ', 'US', 'UN'];
      
      // 检查是否包含有效的特质标记
      const hasValidTraits = Object.keys(traits).some(trait => validTraits.includes(trait));
      
      if (!hasValidTraits) {
        console.log('⚠️ 选择数据无效：不包含有效的8维度特质');
        return false;
      }
      
      console.log('✅ 选择数据有效');
      return true;
    }
    
    // 获取当前数据收集状态
    function getDataCollectionStatus() {
      const traits = gameState.playerChoices.traits;
      const choiceCount = gameState.playerChoices.choiceHistory.length;
      const totalScore = Object.values(traits).reduce((sum, score) => sum + score, 0);
      
      // 计算各维度的覆盖情况
      const mbtiCoverage = {
        E: traits.E, I: traits.I, S: traits.S, N: traits.N,
        T: traits.T, F: traits.F, J: traits.J, P: traits.P
      };
      
      const zhuangziCoverage = {
        AT: traits.AT, DT: traits.DT, IN: traits.IN, WU: traits.WU,
        DI: traits.DI, EQ: traits.EQ, US: traits.US, UN: traits.UN
      };
      
      return {
        choiceCount: choiceCount,
        totalScore: totalScore,
        averageScore: totalScore / 8,
        mbtiCoverage: mbtiCoverage,
        zhuangziCoverage: zhuangziCoverage,
        dataQuality: choiceCount >= 20 ? 'sufficient' : choiceCount >= 10 ? 'moderate' : 'limited',
        recommendedActions: generateRecommendations(choiceCount, traits)
      };
    }
    
    // 生成数据收集建议
    function generateRecommendations(choiceCount, traits) {
      const recommendations = [];
      
      if (choiceCount < 10) {
        recommendations.push('数据量较少，AI回应应主要基于具体选择');
      } else if (choiceCount < 30) {
        recommendations.push('数据量适中，可进行初步的性格模式识别');
      } else {
        recommendations.push('数据量充足，可进行深度个性化分析');
      }
      
      // 检查维度平衡性
      const maxScore = Math.max(...Object.values(traits));
      const minScore = Math.min(...Object.values(traits));
      
      if (maxScore - minScore > 5) {
        recommendations.push('维度分化明显，性格特征清晰');
      } else {
        recommendations.push('维度分布较平均，性格特征需要更多数据确认');
      }
      
      return recommendations;
    }
    

    
    // 新增：实时特质状态显示（调试用）- 清理版
    function showRealTimeDebugInfo() {
      const traits = gameState.playerChoices.traits;
      const choiceCount = gameState.playerChoices.choiceHistory.length;
      const currentMBTI = determineMBTIType();
      // 移除冗余的哲学性格分析，直接使用8维度原始数据
      
      console.log('🎮 ===== 实时游戏状态调试 =====');
      console.log('📊 当前选择数量:', choiceCount);
      console.log('🧠 当前特质分数 (1分制):');
      
      // MBTI维度
      console.log('  MBTI维度:');
      console.log('    E/I:', traits.E || 0, '/', traits.I || 0, '-> 倾向:', traits.E > traits.I ? 'E外向' : traits.I > traits.E ? 'I内向' : '平衡');
      console.log('    S/N:', traits.S || 0, '/', traits.N || 0, '-> 倾向:', traits.S > traits.N ? 'S感觉' : traits.N > traits.S ? 'N直觉' : '平衡');
      console.log('    T/F:', traits.T || 0, '/', traits.F || 0, '-> 倾向:', traits.T > traits.F ? 'T思考' : traits.F > traits.T ? 'F情感' : '平衡');
      console.log('    J/P:', traits.J || 0, '/', traits.P || 0, '-> 倾向:', traits.J > traits.P ? 'J判断' : traits.P > traits.J ? 'P知觉' : '平衡');
      
      // 莊子哲学维度
      console.log('  莊子哲学维度:');
      console.log('    AT/DT:', traits.AT || 0, '/', traits.DT || 0, '-> 倾向:', traits.AT > traits.DT ? 'AT执着' : traits.DT > traits.AT ? 'DT淡泊' : '平衡');
      console.log('    IN/WU:', traits.IN || 0, '/', traits.WU || 0, '-> 倾向:', traits.IN > traits.WU ? 'IN干预' : traits.WU > traits.IN ? 'WU无为' : '平衡');
      console.log('    DI/EQ:', traits.DI || 0, '/', traits.EQ || 0, '-> 倾向:', traits.DI > traits.EQ ? 'DI分别' : traits.EQ > traits.DI ? 'EQ齐等' : '平衡');
      console.log('    US/UN:', traits.US || 0, '/', traits.UN || 0, '-> 倾向:', traits.US > traits.UN ? 'US有用' : traits.UN > traits.US ? 'UN无用' : '平衡');
      
      console.log('🎯 AI判断结果:');
      console.log('  当前MBTI类型:', currentMBTI);
      console.log('  8维度原始数据:', traits);
      
      // 时序性AI策略
      const aiStrategy = generateTimedAIResponse('personalized-response', {});
      console.log('🤖 推荐AI策略:', aiStrategy.strategy);
      console.log('🎨 AI置信度:', aiStrategy.confidence);
      console.log('📝 AI建议:', aiStrategy.recommendation);
      
      // 显示最近3个选择的影响
      const recentChoices = gameState.playerChoices.choiceHistory.slice(-3);
      console.log('🕰️ 最近3个选择的特质影响:');
      recentChoices.forEach((choice, index) => {
        console.log(`  ${index + 1}. [${choice.chapter}] "${choice.choiceText}"`);
        console.log(`     特质: ${JSON.stringify(choice.traits)} | 思考时间: ${Math.round(choice.thinkingTime / 1000)}s`);
      });
      
      console.log('=====================================');
    }
    
    // 新增：创建调试面板
    function createDebugPanel() {
      // 检查是否已存在调试面板
      if (document.getElementById('debug-panel')) {
        return;
      }
      
      const panel = document.createElement('div');
      panel.id = 'debug-panel';
      panel.style.cssText = `
        position: fixed;
        top: 10px;
        right: 10px;
        width: 300px;
        background: rgba(0, 0, 0, 0.9);
        color: white;
        padding: 10px;
        border-radius: 5px;
        font-family: monospace;
        font-size: 12px;
        z-index: 10000;
        max-height: 400px;
        overflow-y: auto;
        display: none;
      `;
      
      panel.innerHTML = `
        <div style="margin-bottom: 10px;">
          <strong>🎮 1分制数据收集调试面板</strong>
          <button id="close-debug" style="float: right; background: red; color: white; border: none; padding: 2px 5px;">×</button>
        </div>
        <div id="debug-content">
          <div>选择数量: <span id="choice-count">0</span></div>
          <div>当前章节: <span id="current-chapter">-</span></div>
          <div>当前场景: <span id="current-scene">-</span></div>
          <div>数据质量: <span id="data-quality" style="font-weight: bold;">-</span></div>
          <hr>
          <div><strong>MBTI维度:</strong></div>
          <div>E/I: <span id="ei-score">0/0</span> <span id="ei-trend" style="color: #888;">-</span></div>
          <div>S/N: <span id="sn-score">0/0</span> <span id="sn-trend" style="color: #888;">-</span></div>
          <div>T/F: <span id="tf-score">0/0</span> <span id="tf-trend" style="color: #888;">-</span></div>
          <div>J/P: <span id="jp-score">0/0</span> <span id="jp-trend" style="color: #888;">-</span></div>
          <hr>
          <div><strong>莊子哲学维度:</strong></div>
          <div>AT/DT: <span id="at-dt-score">0/0</span> <span id="at-dt-trend" style="color: #888;">-</span></div>
          <div>IN/WU: <span id="in-wu-score">0/0</span> <span id="in-wu-trend" style="color: #888;">-</span></div>
          <div>DI/EQ: <span id="di-eq-score">0/0</span> <span id="di-eq-trend" style="color: #888;">-</span></div>
          <div>US/UN: <span id="us-un-score">0/0</span> <span id="us-un-trend" style="color: #888;">-</span></div>
          <hr>
          <div><strong>AI判断:</strong></div>
          <div>MBTI: <span id="mbti-type">-</span></div>
          <div>哲学: <span id="philosophy-type">-</span></div>
          <div>AI策略: <span id="ai-strategy">-</span></div>
          <div>置信度: <span id="ai-confidence">-</span></div>
          <hr>
          <div><strong>数据收集建议:</strong></div>
          <div id="data-recommendations" style="font-size: 10px; color: #ccc; line-height: 1.3;">
            等待选择数据...
          </div>
          <hr>
          <button id="refresh-debug" style="background: #4CAF50; color: white; border: none; padding: 5px 10px; margin-right: 5px;">刷新</button>
          <button id="toggle-console" style="background: #2196F3; color: white; border: none; padding: 5px 10px;">控制台</button>
        </div>
      `;
      
      document.body.appendChild(panel);
      
      // 绑定事件
      document.getElementById('close-debug').addEventListener('click', () => {
        panel.style.display = 'none';
      });
      
      document.getElementById('refresh-debug').addEventListener('click', () => {
        updateDebugPanel();
      });
      
      document.getElementById('toggle-console').addEventListener('click', () => {
        showRealTimeDebugInfo();
      });
      
      // 初始更新
      updateDebugPanel();
    }
    
    // 新增：更新调试面板
    function updateDebugPanel() {
      const panel = document.getElementById('debug-panel');
      if (!panel) return;
      
      const traits = gameState.playerChoices.traits;
      const choiceCount = gameState.playerChoices.choiceHistory.length;
      const currentMBTI = determineMBTIType();
      // 移除冗余的哲学性格分析，直接使用8维度原始数据
      const aiStrategy = generateTimedAIResponse('personalized-response', {});
      
      // 获取数据收集状态
      const dataStatus = getDataCollectionStatus();
      
      // 更新基本信息
      document.getElementById('choice-count').textContent = choiceCount;
      document.getElementById('current-chapter').textContent = gameState.currentChapter;
      document.getElementById('current-scene').textContent = gameState.currentScene;
      
      // 更新数据质量状态
      const qualityElement = document.getElementById('data-quality');
      const qualityColors = {
        'sufficient': '#4CAF50',  // 绿色
        'moderate': '#FF9800',    // 橙色
        'limited': '#F44336'      // 红色
      };
      const qualityText = {
        'sufficient': '充足',
        'moderate': '适中',
        'limited': '有限'
      };
      qualityElement.textContent = qualityText[dataStatus.dataQuality] || '未知';
      qualityElement.style.color = qualityColors[dataStatus.dataQuality] || '#888';
      
      // 辅助函数：获取倾向性显示
      function getTrendText(score1, score2, label1, label2) {
        if (score1 === score2) return '平衡';
        if (score1 > score2) return `${label1}(+${score1 - score2})`;
        return `${label2}(+${score2 - score1})`;
      }
      
      // 更新MBTI维度和倾向性
      document.getElementById('ei-score').textContent = `${traits.E || 0}/${traits.I || 0}`;
      document.getElementById('ei-trend').textContent = getTrendText(traits.E || 0, traits.I || 0, 'E外向', 'I内向');
      
      document.getElementById('sn-score').textContent = `${traits.S || 0}/${traits.N || 0}`;
      document.getElementById('sn-trend').textContent = getTrendText(traits.S || 0, traits.N || 0, 'S感觉', 'N直觉');
      
      document.getElementById('tf-score').textContent = `${traits.T || 0}/${traits.F || 0}`;
      document.getElementById('tf-trend').textContent = getTrendText(traits.T || 0, traits.F || 0, 'T思考', 'F情感');
      
      document.getElementById('jp-score').textContent = `${traits.J || 0}/${traits.P || 0}`;
      document.getElementById('jp-trend').textContent = getTrendText(traits.J || 0, traits.P || 0, 'J判断', 'P知觉');
      
      // 更新莊子哲学维度和倾向性
      document.getElementById('at-dt-score').textContent = `${traits.AT || 0}/${traits.DT || 0}`;
      document.getElementById('at-dt-trend').textContent = getTrendText(traits.AT || 0, traits.DT || 0, 'AT执着', 'DT超脱');
      
      document.getElementById('in-wu-score').textContent = `${traits.IN || 0}/${traits.WU || 0}`;
      document.getElementById('in-wu-trend').textContent = getTrendText(traits.IN || 0, traits.WU || 0, 'IN干预', 'WU无为');
      
      document.getElementById('di-eq-score').textContent = `${traits.DI || 0}/${traits.EQ || 0}`;
      document.getElementById('di-eq-trend').textContent = getTrendText(traits.DI || 0, traits.EQ || 0, 'DI分别', 'EQ齐等');
      
      document.getElementById('us-un-score').textContent = `${traits.US || 0}/${traits.UN || 0}`;
      document.getElementById('us-un-trend').textContent = getTrendText(traits.US || 0, traits.UN || 0, 'US有用', 'UN无用');
      
      // 更新AI判断
      document.getElementById('mbti-type').textContent = currentMBTI;
      document.getElementById('philosophy-type').textContent = '基于8维度原始数据';
      document.getElementById('ai-strategy').textContent = aiStrategy.strategy;
      document.getElementById('ai-confidence').textContent = aiStrategy.confidence;
      
      // 更新数据收集建议
      const recommendationsElement = document.getElementById('data-recommendations');
      const recommendations = dataStatus.recommendedActions;
      if (recommendations && recommendations.length > 0) {
        recommendationsElement.innerHTML = recommendations.map(rec => `• ${rec}`).join('<br>');
      } else {
        recommendationsElement.textContent = '暂无建议';
      }
    }
    
    // 新增：启用调试模式
    function enableDebugMode() {
      console.log('🔧 启用1分制数据收集调试模式');
      
      // 创建调试面板
      createDebugPanel();
      
      // 显示调试面板
      const panel = document.getElementById('debug-panel');
      if (panel) {
        panel.style.display = 'block';
      }
      
      // 添加快捷键支持
      document.addEventListener('keydown', (e) => {
        if (e.key === 'F2' && e.ctrlKey) {
          const panel = document.getElementById('debug-panel');
          if (panel) {
            panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
          }
        }
        if (e.key === 'F3' && e.ctrlKey) {
          showRealTimeDebugInfo();
        }
      });
      
      console.log('🔧 调试模式已启用');
      console.log('🎮 快捷键: Ctrl+F2 - 显示/隐藏调试面板');
      console.log('🎮 快捷键: Ctrl+F3 - 显示控制台调试信息');
    }
    
    // 新增：为开发者模式添加调试支持
    function initDebugForDeveloperMode() {
      // 检查是否为开发者模式
      const isDevMode = document.documentElement.classList.contains('dev-mode');
      
      if (isDevMode) {
        console.log('🔧 检测到开发者模式，自动启用调试功能');
        enableDebugMode();
      }
    }
    
    // 全局调试函数（用户可在控制台手动调用）- 增強版
    window.enableZhuangziDebug = function() {
      console.log('🔧 手动启用莊子游戏调试模式 - 增強版');
      enableDebugMode();
      
      // 立即显示当前状态
      showRealTimeDebugInfo();
      
      // 新增：显示8维度系统状态
      show8DimensionSystemStatus();
      
      // 新增：显示莊子哲学契合度分析
      showZhuangziPhilosophyAlignment();
      
      console.log('🎮 调试模式已启用！');
      console.log('🎯 快捷键: Ctrl+F2 - 显示/隐藏调试面板');
      console.log('🎯 快捷键: Ctrl+F3 - 显示控制台调试信息');
      console.log('📝 函数: window.showRealTimeDebugInfo() - 显示实时状态');
      console.log('📝 函数: window.show8DimensionSystemStatus() - 显示8维度系统状态');
      console.log('📝 函数: window.showZhuangziPhilosophyAlignment() - 显示莊子哲学契合度');
      console.log('📝 函数: window.resetGameDataForTesting() - 重置测试数据');
    };
    
    // 全局实时调试信息函数
    window.showRealTimeDebugInfo = showRealTimeDebugInfo;
    
    // 新增：8維度系統狀態調試函數
    function show8DimensionSystemStatus() {
      const traits = gameState.playerChoices.traits;
      const choiceCount = gameState.playerChoices.choiceHistory.length;
      
      console.log('📊 ===== 8維度系統狀態分析 =====');
      console.log('🎯 數據收集完整性分析:');
      
      // MBTI四維度分析
      console.log('🧠 MBTI四維度 (Myers-Briggs Type Indicator):');
      const mbtiDimensions = [
        { name: 'E/I (外向/內向)', e: 'E', i: 'I', eLabel: '外向活躍', iLabel: '內向深思' },
        { name: 'S/N (感覺/直覺)', e: 'S', i: 'N', eLabel: '感覺實際', iLabel: '直覺想像' },
        { name: 'T/F (思考/情感)', e: 'T', i: 'F', eLabel: '理性思考', iLabel: '情感豐富' },
        { name: 'J/P (判斷/知覺)', e: 'J', i: 'P', eLabel: '計劃有序', iLabel: '靈活隨性' }
      ];
      
      mbtiDimensions.forEach(dim => {
        const eScore = traits[dim.e] || 0;
        const iScore = traits[dim.i] || 0;
        const total = eScore + iScore;
        const tendency = eScore > iScore ? `${dim.eLabel}(+${eScore - iScore})` : 
                        iScore > eScore ? `${dim.iLabel}(+${iScore - eScore})` : '平衡';
        console.log(`  ${dim.name}: ${eScore}/${iScore} (共${total}個選項) → ${tendency}`);
      });
      
      // 莊子哲學四維度分析
      console.log('🏛️ 莊子哲學四維度 (Zhuangzi Philosophy):');
      const zhuangziDimensions = [
        { name: 'AT/DT (執著/超脫)', e: 'AT', i: 'DT', eLabel: '執著追求', iLabel: '超脫淡然' },
        { name: 'IN/WU (干預/無為)', e: 'IN', i: 'WU', eLabel: '積極干預', iLabel: '無為自然' },
        { name: 'DI/EQ (分別/齊等)', e: 'DI', i: 'EQ', eLabel: '分別判斷', iLabel: '齊等包容' },
        { name: 'US/UN (有用/無用)', e: 'US', i: 'UN', eLabel: '追求實用', iLabel: '領悟無用' }
      ];
      
      zhuangziDimensions.forEach(dim => {
        const eScore = traits[dim.e] || 0;
        const iScore = traits[dim.i] || 0;
        const total = eScore + iScore;
        const tendency = eScore > iScore ? `${dim.eLabel}(+${eScore - iScore})` : 
                        iScore > eScore ? `${dim.iLabel}(+${iScore - eScore})` : '平衡';
        console.log(`  ${dim.name}: ${eScore}/${iScore} (共${total}個選項) → ${tendency}`);
      });
      
      // 數據收集質量分析
      const totalScore = Object.values(traits).reduce((sum, score) => sum + score, 0);
      const averageScore = totalScore / 8;
      console.log('📈 數據收集質量:');
      console.log(`  總選擇數: ${choiceCount}`);
      console.log(`  總標記數: ${totalScore}`);
      console.log(`  平均維度分數: ${averageScore.toFixed(1)}`);
      console.log(`  數據質量: ${choiceCount >= 20 ? '充足' : choiceCount >= 10 ? '適中' : '有限'}`);
      
      // 維度覆蓋分析
      const zeroDimensions = Object.entries(traits).filter(([k, v]) => v === 0).map(([k, v]) => k);
      if (zeroDimensions.length > 0) {
        console.log(`⚠️  未覆蓋的維度: ${zeroDimensions.join(', ')}`);
      } else {
        console.log('✅ 所有維度都有數據覆蓋');
      }
      
      console.log('=====================================');
    }
    
    // 新增：莊子哲學契合度調試函數
    function showZhuangziPhilosophyAlignment() {
      const traits = gameState.playerChoices.traits;
      
      console.log('🏛️ ===== 莊子哲學契合度分析 =====');
      
      // 使用修復後的哲學契合度分析函數
      const alignments = window.zhuangziAI.getZhuangziPhilosophyAlignment(traits);
      
      console.log('📊 各維度契合度評估:');
      alignments.forEach((alignment, index) => {
        const dimensionNames = ['執著-超脫', '干預-無為', '分別-齊等', '有用-無用'];
        console.log(`  ${dimensionNames[index]}: ${alignment}`);
      });
      
      // 詳細分析
      console.log('🔍 詳細分析:');
      const dimensions = [
        { name: '執著-超脫 (AT-DT)', at: traits.AT || 0, dt: traits.DT || 0 },
        { name: '干預-無為 (IN-WU)', at: traits.IN || 0, dt: traits.WU || 0 },
        { name: '分別-齊等 (DI-EQ)', at: traits.DI || 0, dt: traits.EQ || 0 },
        { name: '有用-無用 (US-UN)', at: traits.US || 0, dt: traits.UN || 0 }
      ];
      
      dimensions.forEach(dim => {
        const diff = Math.abs(dim.at - dim.dt);
        const moreThanOne = diff > 1;
        const status = moreThanOne ? '顯著偏向' : '相對平衡';
        console.log(`  ${dim.name}: ${dim.at}/${dim.dt} (差距:${diff}) → ${status}`);
      });
      
      // 整體莊子哲學契合度評估
      const zhuangziScores = [traits.DT || 0, traits.WU || 0, traits.EQ || 0, traits.UN || 0];
      const nonZhuangziScores = [traits.AT || 0, traits.IN || 0, traits.DI || 0, traits.US || 0];
      const zhuangziTotal = zhuangziScores.reduce((sum, score) => sum + score, 0);
      const nonZhuangziTotal = nonZhuangziScores.reduce((sum, score) => sum + score, 0);
      const totalPhilosophyChoices = zhuangziTotal + nonZhuangziTotal;
      
      console.log('🎯 整體莊子哲學契合度:');
      console.log(`  莊子傾向選擇: ${zhuangziTotal}個`);
      console.log(`  非莊子傾向選擇: ${nonZhuangziTotal}個`);
      console.log(`  總哲學選擇: ${totalPhilosophyChoices}個`);
      
      if (totalPhilosophyChoices > 0) {
        const alignmentPercentage = (zhuangziTotal / totalPhilosophyChoices * 100).toFixed(1);
        console.log(`  契合度: ${alignmentPercentage}%`);
        
        if (alignmentPercentage > 60) {
          console.log('  評估: 高度契合莊子哲學');
        } else if (alignmentPercentage > 40) {
          console.log('  評估: 適中契合莊子哲學');
        } else {
          console.log('  評估: 需要更多引導理解莊子哲學');
        }
      } else {
        console.log('  評估: 哲學數據不足，無法評估');
      }
      
      console.log('=====================================');
    }
    
    // 將新函數添加到全局
    window.show8DimensionSystemStatus = show8DimensionSystemStatus;
    window.showZhuangziPhilosophyAlignment = showZhuangziPhilosophyAlignment;
    

    

    
    // 新增：重置游戏数据用于测试
    window.resetGameDataForTesting = function() {
      console.log('🔄 ===== 重置游戏数据用于测试 =====');
      
      const confirmReset = confirm('确认要重置所有游戏数据用于测试吗？\n这将清除：\n- 所有选择记录\n- 特质分数\n- AI分析数据\n\n注意：章节解锁状态会保留');
      
      if (!confirmReset) {
        console.log('❌ 用户取消重置操作');
        return;
      }
      
      // 备份章节解锁状态
      const maxReachedChapter = gameState.maxReachedChapter;
      const collectedApertures = [...gameState.collectedApertures];
      const unlockedForms = [...gameState.unlockedForms];
      
      // 重置选择历史
      gameState.playerChoices.choiceHistory = [];
      
      // 重置特质分数
      Object.keys(gameState.playerChoices.traits).forEach(trait => {
        gameState.playerChoices.traits[trait] = 0;
      });
      
      // 重置选择模式分析
      gameState.playerChoices.choicePatterns = {
        consistencyScore: 0,
        contradictions: [],
        evolutionTrend: [],
        dominantTraits: [],
        secondaryTraits: [],
        storyBranches: []
      };
      
      // 重置AI上下文
      gameState.playerChoices.aiContext = {
        profileSummary: '',
        suggestedResponseStyle: {},
        lastUpdateTime: Date.now()
      };
      
      // 重置时间数据
      gameState.playerChoices.timingData = {
        sceneStartTime: null,
        choiceStartTime: null,
        totalThinkingTime: 0,
        averageThinkingTime: 0
      };
      
      // 重置章节数据
      gameState.playerChoices.chapterChoices = {};
      Object.keys(gameState.playerChoices.chapterInfluences).forEach(chapter => {
        gameState.playerChoices.chapterInfluences[chapter] = { choices: [], storyBranch: 'default' };
      });
      
      // 恢复章节解锁状态
      gameState.maxReachedChapter = maxReachedChapter;
      gameState.collectedApertures = collectedApertures;
      gameState.unlockedForms = unlockedForms;
      
      console.log('✅ 游戏数据重置完成！');
      console.log('🎮 保留的状态:');
      console.log('  - 最高章节:', maxReachedChapter);
      console.log('  - 已解锁形态:', unlockedForms);
      console.log('  - 已收集封印:', collectedApertures);
      
      console.log('🔄 重置的数据:');
      console.log('  - 选择记录: 0个');
      console.log('  - 特质分数: 全部归零');
      console.log('  - AI分析数据: 已清空');
      
      // 更新调试面板
      if (document.getElementById('debug-panel')) {
        updateDebugPanel();
      }
      
      // 清除本地存储的相关数据
      try {
        localStorage.removeItem('zhuangzi_player_choices');
        localStorage.removeItem('zhuangzi_ai_context');
        console.log('💾 本地存储中的选择数据已清除');
      } catch (error) {
        console.log('⚠️ 清除本地存储时出错:', error);
      }
      
      alert('游戏数据重置完成！\n现在可以重新开始第一章，系统将正常收集选择数据。');
    };
    
    // 新增：開發者工具專用部分重置函數
    window.resetPlayerChoicesOnly = function() {
      console.log('🔄 ===== 開發者工具：部分重置玩家選擇數據 =====');
      
      // 備份遊戲進度狀態
      const backupData = {
        maxReachedChapter: gameState.maxReachedChapter,
        collectedApertures: [...gameState.collectedApertures],
        unlockedForms: [...gameState.unlockedForms],
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene,
        currentForm: gameState.currentForm,
        audioEnabled: gameState.audioEnabled,
        baguaLearningCompleted: gameState.baguaLearningCompleted,
        wanwuXunqiActive: gameState.wanwuXunqiActive,
        wanwuXunqiProgress: [...gameState.wanwuXunqiProgress],
        chatHistoryMap: {...chatHistoryMap}
      };
      
      console.log('📋 備份的遊戲進度:', backupData);
      
      // 重置玩家選擇相關數據
      gameState.playerChoices = {
        // 重置選擇歷史
        choiceHistory: [],
        
        // 重置時間數據
        timingData: {
          sceneStartTime: null,
          choiceStartTime: null,
          totalThinkingTime: 0,
          averageThinkingTime: 0
        },
        
        // 重置特質分數
        traits: {
          // MBTI維度
          E: 0, I: 0, S: 0, N: 0, T: 0, F: 0, J: 0, P: 0,
          // 莊子哲學維度
          AT: 0, DT: 0, IN: 0, WU: 0, DI: 0, EQ: 0, US: 0, UN: 0
        },
        
        // 重置選擇模式分析
        choicePatterns: {
          consistencyScore: 0,
          contradictions: [],
          evolutionTrend: [],
          dominantTraits: [],
          secondaryTraits: [],
          storyBranches: []
        },
        
        // 重置章節影響
        chapterInfluences: {},
        
        // 重置AI上下文
        aiContext: {
          lastUpdateTime: null,
          profileSummary: '',
          mbtiType: '',
          recentTrends: [],
          suggestedResponseStyle: '',
          storyPersonalization: {}
        },
        
        // 重置物化體驗數據
        transformationData: {
          transformationHistory: [],
          formUsageCount: {},
          transformationDurations: {},
          firstTimeTransformations: [],
          dailyTransformations: [],
          transformationPatterns: {}
        },
        
        // 重置斷句挑戰數據
        segmentationPuzzleData: {
          puzzleAttempts: {},
          completionTimes: {},
          accuracyRates: {},
          puzzlePerformance: {
            averageCompletionTime: 0,
            averageAccuracy: 0,
            learningCurve: [],
            difficultyAdaptation: 0,
            persistenceLevel: 0
          }
        },
        
        // 重置場景停留時間數據
        sceneDwellTime: {
          currentSceneStartTime: null,
          sceneDwellTimes: {},
          averageDwellTime: 0,
          totalDwellTime: 0
        },
        
        // 重置聊天記錄
        chatHistory: {
          allQuestions: [],
          chapterQuestions: {},
          questionCount: 0,
          chatPatterns: {
            questionTypes: {},
            engagementLevel: 0,
            preferredTopics: []
          }
        }
      };
      
      // 恢復遊戲進度狀態
      gameState.maxReachedChapter = backupData.maxReachedChapter;
      gameState.collectedApertures = backupData.collectedApertures;
      gameState.unlockedForms = backupData.unlockedForms;
      gameState.currentChapter = backupData.currentChapter;
      gameState.currentScene = backupData.currentScene;
      gameState.currentForm = backupData.currentForm;
      gameState.audioEnabled = backupData.audioEnabled;
      gameState.baguaLearningCompleted = backupData.baguaLearningCompleted;
      gameState.wanwuXunqiActive = backupData.wanwuXunqiActive;
      gameState.wanwuXunqiProgress = backupData.wanwuXunqiProgress;
      Object.assign(chatHistoryMap, backupData.chatHistoryMap);
      
      // 立即保存遊戲進度
      saveGameProgress();
      
      console.log('✅ 部分重置完成！');
      console.log('🎮 保留的遊戲進度:');
      console.log('  - 最高章節:', gameState.maxReachedChapter);
      console.log('  - 已解鎖形態:', gameState.unlockedForms);
      console.log('  - 已收集封印:', gameState.collectedApertures);
      console.log('  - 當前章節:', gameState.currentChapter);
      console.log('  - 當前場景:', gameState.currentScene);
      console.log('  - 當前形態:', gameState.currentForm);
      
      console.log('🔄 重置的玩家數據:');
      console.log('  - 選擇記錄: 0個');
      console.log('  - 特質分數: 全部歸零');
      console.log('  - AI分析數據: 已清空');
      console.log('  - 物化體驗數據: 已清空');
      console.log('  - 斷句挑戰數據: 已清空');
      console.log('  - 場景停留時間: 已清空');
      console.log('  - 聊天記錄: 已清空');
      
      // 更新調試面板（如果存在）
      if (document.getElementById('debug-panel')) {
        updateDebugPanel();
      }
      
      console.log('💾 遊戲進度已保存到localStorage');
      console.log('🎯 現在可以重新收集玩家選擇數據，同時保持遊戲進度不變');
      
      return {
        success: true,
        message: '部分重置完成！玩家選擇數據已清空，遊戲進度已保留。',
        preservedData: backupData,
        resetData: {
          choiceHistory: 0,
          traits: Object.keys(gameState.playerChoices.traits).length,
          transformationData: 0,
          segmentationPuzzleData: 0,
          sceneDwellTime: 0,
          chatHistory: 0
        }
      };
    };
    
    // 新增：快速重置函數（無確認對話框）
    window.quickResetPlayerChoices = function() {
      console.log('⚡ 快速重置玩家選擇數據（無確認）');
      return window.resetPlayerChoicesOnly();
    };
    
    // 新增：檢查重置結果的函數
    window.checkResetResult = function() {
      const result = {
        gameProgress: {
          maxReachedChapter: gameState.maxReachedChapter,
          currentChapter: gameState.currentChapter,
          currentScene: gameState.currentScene,
          unlockedForms: gameState.unlockedForms,
          collectedApertures: gameState.collectedApertures
        },
        playerData: {
          choiceHistoryLength: gameState.playerChoices.choiceHistory.length,
          traitsSum: Object.values(gameState.playerChoices.traits).reduce((sum, val) => sum + val, 0),
          transformationHistoryLength: gameState.playerChoices.transformationData.transformationHistory.length,
          puzzleAttemptsCount: Object.keys(gameState.playerChoices.segmentationPuzzleData.puzzleAttempts).length,
          sceneDwellTimesCount: Object.keys(gameState.playerChoices.sceneDwellTime.sceneDwellTimes).length,
          chatQuestionCount: gameState.playerChoices.chatHistory.questionCount
        }
      };
      
      console.log('📊 重置結果檢查:', result);
      return result;
    };
    
    // 新增：顯示所有遊戲數據的函數
    function showAllGameData() {
      console.log('📊 ===== 莊子遊戲完整數據報告 =====');
      
      // 1. 遊戲進度數據
      console.log('🎮 遊戲進度數據:');
      console.log('  - 最高章節:', gameState.maxReachedChapter);
      console.log('  - 當前章節:', gameState.currentChapter);
      console.log('  - 當前場景:', gameState.currentScene);
      console.log('  - 當前形態:', gameState.currentForm);
      console.log('  - 已解鎖形態:', gameState.unlockedForms);
      console.log('  - 已收集封印:', gameState.collectedApertures);
      console.log('  - 音頻啟用:', gameState.audioEnabled);
      console.log('  - 八卦學習完成:', gameState.baguaLearningCompleted);
      console.log('  - 萬物尋氣狀態:', gameState.wanwuXunqiActive);
      console.log('  - 萬物尋氣進度:', gameState.wanwuXunqiProgress);
      
      // 2. 玩家選擇數據
      console.log('\n🎯 玩家選擇數據:');
      console.log('  - 選擇記錄數量:', gameState.playerChoices.choiceHistory.length);
      if (gameState.playerChoices.choiceHistory.length > 0) {
        console.log('  - 最近選擇:', gameState.playerChoices.choiceHistory.slice(-3));
      }
      
      // 3. 特質分數數據
      console.log('\n🧠 特質分數數據:');
      const traits = gameState.playerChoices.traits;
      console.log('  MBTI維度:');
      console.log('    - E(外向):', traits.E, '| I(內向):', traits.I);
      console.log('    - S(感覺):', traits.S, '| N(直覺):', traits.N);
      console.log('    - T(思考):', traits.T, '| F(情感):', traits.F);
      console.log('    - J(判斷):', traits.J, '| P(知覺):', traits.P);
      console.log('  莊子哲學維度:');
      console.log('    - AT(執着):', traits.AT, '| DT(超脫):', traits.DT);
      console.log('    - IN(干預):', traits.IN, '| WU(無為):', traits.WU);
      console.log('    - DI(分別):', traits.DI, '| EQ(齊等):', traits.EQ);
      console.log('    - US(有用):', traits.US, '| UN(無用):', traits.UN);
      
      // 4. 時間數據
      console.log('\n⏱️ 時間數據:');
      const timingData = gameState.playerChoices.timingData;
      console.log('  - 總思考時間:', timingData.totalThinkingTime, 'ms');
      console.log('  - 平均思考時間:', timingData.averageThinkingTime, 'ms');
      console.log('  - 場景停留時間記錄數量:', Object.keys(gameState.playerChoices.sceneDwellTime.sceneDwellTimes).length);
      
      // 5. 物化體驗數據
      console.log('\n🦋 物化體驗數據:');
      const transformationData = gameState.playerChoices.transformationData;
      console.log('  - 物化歷史記錄:', transformationData.transformationHistory.length);
      console.log('  - 各形態使用次數:', transformationData.formUsageCount);
      console.log('  - 首次物化記錄:', transformationData.firstTimeTransformations);
      console.log('  - 日常物化記錄:', transformationData.dailyTransformations);
      
      // 6. 斷句挑戰數據
      console.log('\n🧩 斷句挑戰數據:');
      const puzzleData = gameState.playerChoices.segmentationPuzzleData;
      console.log('  - 挑戰記錄數量:', Object.keys(puzzleData.puzzleAttempts).length);
      console.log('  - 完成時間記錄:', Object.keys(puzzleData.completionTimes).length);
      console.log('  - 準確率記錄:', Object.keys(puzzleData.accuracyRates).length);
      console.log('  - 平均完成時間:', puzzleData.puzzlePerformance.averageCompletionTime, 'ms');
      console.log('  - 平均準確率:', puzzleData.puzzlePerformance.averageAccuracy);
      
      // 7. 聊天記錄數據
      console.log('\n💬 聊天記錄數據:');
      const chatData = gameState.playerChoices.chatHistory;
      console.log('  - 總問題數量:', chatData.questionCount);
      console.log('  - 所有問題:', chatData.allQuestions);
      console.log('  - 章節問題:', chatData.chapterQuestions);
      
      // 8. AI上下文數據
      console.log('\n🤖 AI上下文數據:');
      const aiContext = gameState.playerChoices.aiContext;
      console.log('  - 最後更新時間:', aiContext.lastUpdateTime);
      console.log('  - 個人檔案摘要:', aiContext.profileSummary);
      console.log('  - MBTI類型:', aiContext.mbtiType);
      console.log('  - 最近趨勢:', aiContext.recentTrends);
      console.log('  - 建議回應風格:', aiContext.suggestedResponseStyle);
      
      // 9. 選擇模式分析
      console.log('\n📈 選擇模式分析:');
      const choicePatterns = gameState.playerChoices.choicePatterns;
      console.log('  - 一致性分數:', choicePatterns.consistencyScore);
      console.log('  - 矛盾選擇:', choicePatterns.contradictions);
      console.log('  - 演進趨勢:', choicePatterns.evolutionTrend);
      console.log('  - 主導特質:', choicePatterns.dominantTraits);
      console.log('  - 次要特質:', choicePatterns.secondaryTraits);
      
      // 10. 章節影響數據
      console.log('\n📚 章節影響數據:');
      const chapterInfluences = gameState.playerChoices.chapterInfluences;
      console.log('  - 章節影響記錄:', Object.keys(chapterInfluences));
      
      // 11. localStorage數據
      console.log('\n💾 localStorage數據:');
      try {
        const storedData = localStorage.getItem('zhuangziGameProgress');
        if (storedData) {
          const parsedData = JSON.parse(storedData);
          console.log('  - 存儲時間:', new Date(parsedData.lastPlayTime).toLocaleString());
          console.log('  - 數據大小:', (storedData.length / 1024).toFixed(2), 'KB');
        } else {
          console.log('  - 無localStorage數據');
        }
      } catch (error) {
        console.log('  - localStorage讀取錯誤:', error);
      }
      
      // 12. 聊天歷史映射
      console.log('\n🗺️ 聊天歷史映射:');
      console.log('  - 聊天記錄數量:', Object.keys(chatHistoryMap).length);
      console.log('  - 聊天記錄鍵值:', Object.keys(chatHistoryMap));
      
      console.log('\n📊 ===== 數據報告結束 =====');
      
      // 創建數據摘要彈窗
      createDataSummaryModal();
    }
    
    // 新增：創建數據摘要彈窗
    function createDataSummaryModal() {
      // 移除現有彈窗
      const existingModal = document.getElementById('data-summary-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      // 創建彈窗容器
      const modal = document.createElement('div');
      modal.id = 'data-summary-modal';
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.style.backdropFilter = 'blur(4px)';
      
      // 創建彈窗內容
      const modalContent = document.createElement('div');
      modalContent.className = 'bg-white dark:bg-gray-800 rounded-lg shadow-xl max-w-4xl max-h-[90vh] overflow-hidden';
      modalContent.style.width = '90vw';
      
      // 創建標題欄
      const header = document.createElement('div');
      header.className = 'flex justify-between items-center p-4 border-b border-gray-200 dark:border-gray-700';
      header.innerHTML = `
        <h2 class="text-xl font-bold text-gray-800 dark:text-gray-200">📊 莊子遊戲數據摘要</h2>
        <button id="close-data-modal" class="text-gray-500 hover:text-red-500 font-bold text-xl">✕</button>
      `;
      
      // 創建內容區域
      const content = document.createElement('div');
      content.className = 'p-4 overflow-y-auto max-h-[calc(90vh-120px)]';
      
      // 生成數據摘要HTML
      const summaryHTML = generateDataSummaryHTML();
      content.innerHTML = summaryHTML;
      
      // 組裝彈窗
      modalContent.appendChild(header);
      modalContent.appendChild(content);
      modal.appendChild(modalContent);
      document.body.appendChild(modal);
      
      // 添加關閉事件
      document.getElementById('close-data-modal').addEventListener('click', () => {
        modal.remove();
      });
      
      // 點擊背景關閉
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
      
      // 添加ESC鍵關閉
      document.addEventListener('keydown', function closeOnEsc(e) {
        if (e.key === 'Escape') {
          modal.remove();
          document.removeEventListener('keydown', closeOnEsc);
        }
      });
    }
    
    // 新增：生成數據摘要HTML
    function generateDataSummaryHTML() {
      const traits = gameState.playerChoices.traits;
      const timingData = gameState.playerChoices.timingData;
      const transformationData = gameState.playerChoices.transformationData;
      const puzzleData = gameState.playerChoices.segmentationPuzzleData;
      const chatData = gameState.playerChoices.chatHistory;
      
      return `
        <div class="space-y-6">
          <!-- 遊戲進度 -->
          <div class="bg-blue-50 dark:bg-blue-900/20 p-4 rounded-lg">
            <h3 class="text-lg font-semibold text-blue-800 dark:text-blue-200 mb-3">🎮 遊戲進度</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-3 text-sm">
              <div><span class="font-medium">最高章節:</span> ${gameState.maxReachedChapter}</div>
              <div><span class="font-medium">當前章節:</span> ${gameState.currentChapter}</div>
              <div><span class="font-medium">當前場景:</span> ${gameState.currentScene}</div>
              <div><span class="font-medium">當前形態:</span> ${gameState.currentForm}</div>
              <div><span class="font-medium">已解鎖形態:</span> ${gameState.unlockedForms.length}個</div>
              <div><span class="font-medium">已收集封印:</span> ${gameState.collectedApertures.length}個</div>
              <div><span class="font-medium">音頻啟用:</span> ${gameState.audioEnabled ? '是' : '否'}</div>
              <div><span class="font-medium">八卦學習:</span> ${gameState.baguaLearningCompleted ? '完成' : '未完成'}</div>
            </div>
          </div>
          
          <!-- 玩家選擇 -->
          <div class="bg-green-50 dark:bg-green-900/20 p-4 rounded-lg">
            <h3 class="text-lg font-semibold text-green-800 dark:text-green-200 mb-3">🎯 玩家選擇</h3>
            <div class="grid grid-cols-2 md:grid-cols-3 gap-3 text-sm">
              <div><span class="font-medium">選擇記錄:</span> ${gameState.playerChoices.choiceHistory.length}個</div>
              <div><span class="font-medium">聊天問題:</span> ${chatData.questionCount}個</div>
              <div><span class="font-medium">物化記錄:</span> ${transformationData.transformationHistory.length}次</div>
              <div><span class="font-medium">斷句挑戰:</span> ${Object.keys(puzzleData.puzzleAttempts).length}個</div>
              <div><span class="font-medium">場景停留:</span> ${Object.keys(gameState.playerChoices.sceneDwellTime.sceneDwellTimes).length}個</div>
              <div><span class="font-medium">總思考時間:</span> ${(timingData.totalThinkingTime / 1000).toFixed(1)}秒</div>
            </div>
          </div>
          
          <!-- 特質分數 -->
          <div class="bg-purple-50 dark:bg-purple-900/20 p-4 rounded-lg">
            <h3 class="text-lg font-semibold text-purple-800 dark:text-purple-200 mb-3">🧠 特質分數</h3>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-2 text-sm">
              <div><span class="font-medium">E(外向):</span> ${traits.E}</div>
              <div><span class="font-medium">I(內向):</span> ${traits.I}</div>
              <div><span class="font-medium">S(感覺):</span> ${traits.S}</div>
              <div><span class="font-medium">N(直覺):</span> ${traits.N}</div>
              <div><span class="font-medium">T(思考):</span> ${traits.T}</div>
              <div><span class="font-medium">F(情感):</span> ${traits.F}</div>
              <div><span class="font-medium">J(判斷):</span> ${traits.J}</div>
              <div><span class="font-medium">P(知覺):</span> ${traits.P}</div>
              <div><span class="font-medium">AT(執着):</span> ${traits.AT}</div>
              <div><span class="font-medium">DT(超脫):</span> ${traits.DT}</div>
              <div><span class="font-medium">IN(干預):</span> ${traits.IN}</div>
              <div><span class="font-medium">WU(無為):</span> ${traits.WU}</div>
              <div><span class="font-medium">DI(分別):</span> ${traits.DI}</div>
              <div><span class="font-medium">EQ(齊等):</span> ${traits.EQ}</div>
              <div><span class="font-medium">US(有用):</span> ${traits.US}</div>
              <div><span class="font-medium">UN(無用):</span> ${traits.UN}</div>
            </div>
          </div>
          
          <!-- 詳細數據鏈接 -->
          <div class="bg-gray-50 dark:bg-gray-700 p-4 rounded-lg">
            <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-200 mb-3">📋 詳細數據</h3>
            <p class="text-sm text-gray-600 dark:text-gray-400 mb-3">
              完整詳細的數據已輸出到瀏覽器控制台，請按F12打開開發者工具查看。
            </p>
            <div class="flex space-x-2">
              <button onclick="console.log('🎮 遊戲狀態:', gameState)" class="bg-blue-500 hover:bg-blue-600 text-white px-3 py-1 rounded text-sm">
                查看遊戲狀態
              </button>
              <button onclick="console.log('🎯 玩家選擇:', gameState.playerChoices)" class="bg-green-500 hover:bg-green-600 text-white px-3 py-1 rounded text-sm">
                查看玩家選擇
              </button>
              <button onclick="console.log('💾 localStorage:', localStorage.getItem('zhuangziGameProgress'))" class="bg-purple-500 hover:bg-purple-600 text-white px-3 py-1 rounded text-sm">
                查看localStorage
              </button>
            </div>
          </div>
        </div>
      `;
    }
    
    // 重置到1分制系统（用于系统升级）
    function resetToOnePointSystem() {
      console.log('🔄 重置到1分制系统');
      
      // 重置所有特质分数
      const traits = gameState.playerChoices.traits;
      Object.keys(traits).forEach(trait => {
        traits[trait] = 0;
      });
      
      // 重置分析模式
      gameState.playerChoices.choicePatterns = {
        consistencyScore: 0,
        contradictions: [],
        evolutionTrend: [],
        dominantTraits: [],
        secondaryTraits: [],
        storyBranches: []
      };
      
      console.log('✅ 1分制系统重置完成');
       }

    // DeepSeek AI 集成系統
    class ZhuangziAI {
      constructor() {
        this.apiKey = 'sk-d850478e8977454abc9975d544ffd4e3';
        this.baseUrl = 'https://api.deepseek.com';
        this.model = 'deepseek-chat';
        this.isEnabled = true;
        this.responseCache = new Map(); // 緩存AI回應避免重複調用
      }
      
      // 核心AI調用函數
      async callDeepSeekAPI(messages, options = {}) {
        if (!this.isEnabled) {
          console.log('🤖 AI功能已禁用');
          return null;
        }
        
        try {
          const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${this.apiKey}`
            },
            body: JSON.stringify({
              model: this.model,
              messages: messages,
              stream: false,
              temperature: options.temperature || 0.7,
              max_tokens: options.maxTokens || 500,
              top_p: options.topP || 0.9
            })
          });
          
          if (!response.ok) {
            throw new Error(`API調用失敗: ${response.status} ${response.statusText}`);
          }
          
          const data = await response.json();
          console.log('🤖 AI回應成功:', data.choices[0].message.content.substring(0, 100) + '...');
          return data.choices[0].message.content;
          
        } catch (error) {
          console.error('🚨 AI調用錯誤:', error);
          return null;
        }
      }
      
      // 生成個性化的莊子回應 - 重構版本，使用5個專門函數
      async generatePersonalizedResponse(context, playerData, chatHistory = null) {
        const cacheKey = this.generateCacheKey(context, playerData);
        
        // 詳細調試信息：AI調用開始
        console.log('🤖 ===== AI個性化回應調試信息 =====');
        console.log('🎯 調用時間:', new Date().toLocaleTimeString());
        console.log('📍 調用上下文:', {
          chapter: context.chapter,
          scene: context.scene,
          sceneType: context.sceneType,
          description: context.description,
          specificQuestion: context.specificQuestion,
          responseKey: context.responseKey
        });
        console.log('💬 對話歷史:', chatHistory ? `${chatHistory.length}條記錄` : '無');
        
        // 對於有對話歷史的聊天，不使用緩存
        const shouldUseCache = !chatHistory || chatHistory.length === 0;
        
        // 檢查緩存
        if (shouldUseCache && this.responseCache.has(cacheKey)) {
          console.log('💾 使用緩存的AI回應');
          console.log('🔍 緩存鍵:', cacheKey.substring(0, 100) + '...');
          console.log('========================================');
          return this.responseCache.get(cacheKey);
        }
        
        // 構建messages數組
        let messages = [];
        
        // 如果有對話歷史，使用多輪對話模式
        if (chatHistory && chatHistory.length > 0) {
          console.log('🔄 使用多輪對話模式');
          
          // 添加系統消息作為第一條
          const systemPrompt = this.buildSystemPromptForChat(context, playerData);
          messages.push({
            role: 'system',
            content: systemPrompt
          });
          
          // 添加對話歷史
          messages.push(...chatHistory);
          
          // 添加當前問題
          messages.push({
            role: 'user',
            content: context.specificQuestion
          });
          
        } else {
          // 使用單輪對話模式
          console.log('📝 使用單輪對話模式');
          
          // 根據場景類型選擇對應的專門函數
          let promptContent;
          
          switch(context.sceneType) {
            case 'personalized-response':
              promptContent = this.buildSceneResponsePrompt(context, playerData);
              break;
            case 'segmentation-interpretation':
              promptContent = this.buildSegmentationChatPrompt(context, playerData);
              break;
            case 'zhuangzi-chat':
              if (context.chapter === 'post-game-chat') {
                promptContent = this.buildPostGameChatPrompt(context, playerData);
              } else {
                promptContent = this.buildSegmentationChatPrompt(context, playerData);
              }
              break;
            case 'chapter-summary':
              promptContent = this.buildChapterSummaryPrompt(context.chapter, context.chapterInfo, context.chapterName, context.recentChoices, playerData);
              break;
            case 'final-letter':
              promptContent = this.buildFinalLetterPrompt(playerData);
              break;
            default:
              // 默認使用場景AI回應
              promptContent = this.buildSceneResponsePrompt(context, playerData);
          }
          
          messages = [
            {
              role: 'user',
              content: promptContent
            }
          ];
        }
        
        console.log('📝 AI調用消息構建:');
        console.log('  🎯 場景類型:', context.sceneType);
        console.log('  📊 消息數量:', messages.length);
        console.log('  💬 對話模式:', chatHistory ? '多輪對話' : '單輪對話');
        
        console.log('🚀 開始調用DeepSeek API...');
        const startTime = Date.now();
        
        const response = await this.callDeepSeekAPI(messages, {
          temperature: 0.7,
          maxTokens: context.sceneType === 'final-letter' ? 2000 : 300
        });
        
        const endTime = Date.now();
        const duration = endTime - startTime;
        
        console.log('⏱️ AI調用完成:', `${duration}ms`);
        
        if (response) {
          console.log('✅ AI回應成功生成:');
          console.log('  📏 回應長度:', response.length, '字符');
          console.log('  📝 回應內容預覽:', response.substring(0, 100) + '...');
          
          // 只對單輪對話進行緩存
          if (shouldUseCache) {
            this.responseCache.set(cacheKey, response);
            console.log('💾 回應已緩存');
            
            // 限制緩存大小
            if (this.responseCache.size > 50) {
              const firstKey = this.responseCache.keys().next().value;
              this.responseCache.delete(firstKey);
              console.log('🗑️ 清理舊緩存');
            }
          }
        } else {
          console.error('❌ AI回應生成失敗');
        }
        
        console.log('========================================');
        return response;
      }
      

      
      // 生成莊子的親筆信（統一單一prompt函數結構）
      async generatePersonalizedReport(playerData) {
        console.log('🎁 開始生成莊子的親筆信');
        
        // 使用統一的generateSmartResponse機制
        const context = {
          sceneType: 'final-letter',
          chapter: 'final-letter',
          specificQuestion: '生成莊子的親筆信'
        };
        
        return await window.generateSmartResponse('生成莊子的親筆信', context);
      }
      

      
      // 場景AI回應專門函數（合併版本）
      buildSceneResponsePrompt(context, playerData) {
        // 章節背景信息
        const chapterContexts = {
          'chapter1': {
            theme: '濠梁觀魚的知樂爭論',
            setting: '濠梁橋上觀察魚兒游泳',
            key_concepts: '知樂、觀察視角、魚兒的自由'
          },
          'chapter2': {
            theme: '鯤鵬逍遙的無限視野',
            setting: '北冥大海與九萬里高空',
            key_concepts: '無限視野、鯤鵬變化、逍遙境界'
          },
          'chapter3': {
            theme: '鴟得腐鼠的價值相對性',
            setting: '森林中遇見鵷鶵和鴟鴞',
            key_concepts: '價值相對性、美醜標準、不同視角'
          },
          'chapter4': {
            theme: '蝸角之爭的渺小與偉大',
            setting: '蝸牛觸角上的微觀世界',
            key_concepts: '大小相對性、爭執無意義、螺旋時空'
          },
          'chapter5': {
            theme: '朝菌大椿的時間長短',
            setting: '時間森林中的生命周期',
            key_concepts: '時間相對性、生命長短、朝菌與大椿的對比'
          },
          'chapter6': {
            theme: '莊子將死與生死一體',
            setting: '天地為棺槨的超越境界',
            key_concepts: '生死超越、螻蟻與星辰、天地懷抱、超越偏見'
          },
          'chapter7': {
            theme: '混沌之死與道的回歸',
            setting: '虛空殿中的渾沌復生',
            key_concepts: '混沌復生、七竅之謎、道的本質'
          }
        };
        
        const currentChapterInfo = chapterContexts[context.chapter] || chapterContexts['chapter1'];
        
        // 獲取玩家數據
        const recentChoices = (playerData.context?.recentHistory || []).slice(-3);
        const lastChoice = recentChoices[recentChoices.length - 1];
        const thinkingTime = lastChoice?.thinkingTime || 0;
        const thinkingStyle = thinkingTime > 5000 ? '深思熟慮' : thinkingTime > 2000 ? '適中考慮' : '快速決斷';
        const lastChoiceTraits = lastChoice?.traits ? Object.keys(lastChoice.traits).slice(0, 2).join('、') : '未知特質';
        
        return `你是遊戲中的莊子，一位親切而智慧的朋友。你的任務是針對朋友最近的選擇給出簡短的個性化回應，並自然過渡到下一場景。

**核心任務**：
1. 承上：點評朋友最近的選擇，分析其動機
2. 啟下：自然過渡到下一個場景

**當前情境**：
📖 **當前章節**：${currentChapterInfo.theme}
🎯 **章節場景**：${currentChapterInfo.setting}
🔍 **核心概念**：${currentChapterInfo.key_concepts}
🎭 **朋友剛才的選擇**："${lastChoice?.choiceText || '未知選擇'}"
⏰ **思考方式**：${thinkingStyle}
💡 **體現特質**：${lastChoiceTraits}

**語言風格要求**：
- 必須使用繁體中文現代白話文
- 親切自然，像朋友聊天，但絕對不要用"這讓我想到..."、"我看得出你..."等固定句式
- 避免文言文和哲學術語
- 嚴禁使用任何"想到"、"想起"、"聯想"、"回想"等詞彙

**回應結構**：
- 針對具體選擇：「你剛才選擇了...」
- 動機理解：「我感受到你...」或「這顯示出你...」
- 場景過渡：「現在讓我們...」或「接下來...」

**嚴禁的表達方式**：
- 絕對不要用「這讓我想到...」「這使我想起...」「這令我聯想到...」
- 絕對不要用「我看到...」「我注意到...」「我發現...」「我想到...」等觀察式開頭
- 絕對不要用「就像...」「正如...」「好比...」「彷彿...」等比喻連接詞
- 絕對不要進行任何形式的類比或聯想
- 絕對不要用三段式：回應→聯想→建議 的固定結構
- 絕對不要用任何固定的開頭、中間、結尾套路

**重要原則**：
- 你就是莊子本人，用第一人稱"我"表達
- 40-60字簡潔回應
- 避免空洞的哲學概念和心靈雞湯
- 基於具體選擇進行分析，不要泛泛而談
- 針對選擇動機或思考方式給出理解性回應
- 體現對朋友選擇背後想法的洞察
- 自然過渡到下一場景
- 語調親切，像朋友間的理解
- 結合當前章節主題進行回應

請直接給出回應內容，不要包含任何前綴說明。`;
      }
      
      // 斷句解讀聊天AI專門函數（精簡版本）
      buildSegmentationChatPrompt(context, playerData) {
        return `你是遊戲中的莊子，正在與一位朋友進行輕鬆的聊天對話。

**身份設定**：
- 你就是莊子本人，用第一人稱"我"來回應
- 親切自然，像朋友聊天一樣，避免文言文
- 輕鬆幽默，不要過於嚴肅說教
- 可以分享"我"的人生智慧，但要自然融入對話

**當前情境**：
📜 **古文資訊**：
${context.puzzleInfo ? `- 古文標題：${context.puzzleInfo.title}
- 古文主題：${context.puzzleInfo.theme}
- 古文內容：${context.puzzleInfo.text}` : ''}

❓ **朋友的問題**：
"${context.specificQuestion}"

**回應要求**：
- 可以適當回應朋友的問題，結合古文內容進行簡潔解答
- 當朋友問具體問題時，可以給出有用的回答，不要總是反問或轉移話題
- 語調親切自然，像朋友聊天一樣，避免文言文
- 回答控制在20-100字，根據問題的複雜程度和深度來調整長度

**語言風格要求**：
- 必須使用繁體中文現代白話文
- 親切自然，像朋友聊天，但絕對不要用"這讓我想到..."、"我看得出你..."等固定句式
- 避免文言文和哲學術語
- 輕鬆幽默，不要過於嚴肅

**嚴禁的表達方式**：
- 絕對不要用「這讓我想到...」「這使我想起...」「這令我聯想到...」
- 絕對不要用「我看到...」「我注意到...」「我發現...」「我想到...」等觀察式開頭
- 絕對不要用三段式：回應→聯想→建議 的固定結構
- 不要用"人生如夢"、"順其自然"等空洞詞彙
- 不要用"你應該"、"你需要"等說教式語言

**重要原則**：
- 這是聊天對話，不是古文解讀（上方已經有完整解讀）
- 基於朋友的問題進行簡短而有趣的回應
- 語氣輕鬆自然，體現莊子的智慧但不說教

請直接給出一個簡短、自然、有趣的聊天回應，不要包含任何前綴或說明。用繁體中文的現代白話文。`;
      }
      
      // 統一的莊子哲學契合度分析函數（修復版 - 對應8維度系統）
      getZhuangziPhilosophyAlignment(philosophyScores) {
        const alignments = [];
        
        // 執著-超脫維度 (AT-DT, 莊子傾向：超脫)
        const 執著 = philosophyScores?.AT || 0;
        const 超脫 = philosophyScores?.DT || 0;
        if (超脫 > 執著 + 1) alignments.push('深度契合：超脫淡然');
        else if (執著 > 超脫 + 1) alignments.push('需要引導：過於執著');
        else alignments.push('適中平衡：執著超脫並存');
        
        // 干預-無為維度 (IN-WU, 莊子傾向：無為)
        const 干預 = philosophyScores?.IN || 0;
        const 無為 = philosophyScores?.WU || 0;
        if (無為 > 干預 + 1) alignments.push('深度契合：無為自然');
        else if (干預 > 無為 + 1) alignments.push('需要引導：過度干預');
        else alignments.push('適中平衡：干預無為並存');
        
        // 分別-齊等維度 (DI-EQ, 莊子傾向：齊等)
        const 分別 = philosophyScores?.DI || 0;
        const 齊等 = philosophyScores?.EQ || 0;
        if (齊等 > 分別 + 1) alignments.push('深度契合：齊等包容');
        else if (分別 > 齊等 + 1) alignments.push('需要引導：過度分別');
        else alignments.push('適中平衡：分別齊等並存');
        
        // 有用-無用維度 (US-UN, 莊子傾向：無用)
        const 有用 = philosophyScores?.US || 0;
        const 無用 = philosophyScores?.UN || 0;
        if (無用 > 有用 + 1) alignments.push('深度契合：領悟無用');
        else if (有用 > 無用 + 1) alignments.push('需要引導：過於功利');
        else alignments.push('適中平衡：有用無用並存');
        
        return alignments;
      }
      
      // 通關後聊天AI專門函數（精簡版本）
      buildPostGameChatPrompt(context, playerData) {
        // 獲取玩家的主要哲學傾向
        const dominantTraits = (playerData.patterns?.dominantTraits || []).slice(0, 3).map(t => this.translateTrait(t)).join('、');
        
        return `你是莊子，與這位朋友已有深度的相識。通過長時間的遊戲歷程，你對朋友有了一些了解。

**身份設定**：
- 你就是莊子本人，用第一人稱"我"來回應
- 逍遙自在、機智幽默、善用比喻、達觀豁達、愛反問啟發
- 可以自由聊任何話題，不只是遊戲相關內容
- 像老朋友般親切自然，但避免武斷或絕對化的判斷

**對朋友的了解**：
- 人格特質：${dominantTraits}
- 但人是複雜的，你的觀察未必完全準確，要給朋友反駁和修正的空間

❓ **朋友的問題**：
"${context.specificQuestion}"

**回應要求**：
- 字數：20-100字，根據問題深度靈活調整長度
- 可以適當回應朋友的具體問題，給出有用的建議或看法
- 用"感覺"、"似乎"、"或許"等詞彙，表達觀察而非下定論
- 避免總是談論遊戲，專注於朋友當下的問題
- 語言：繁體中文現代白話文，親切自然

**語言風格禁忌**：
- 絕對不要用「這讓我想到...」「這使我想起...」「這令我聯想到...」
- 絕對不要用「我看到...」「我注意到...」「我發現...」「我想到...」等觀察式開頭
- 絕對不要用三段式：回應→聯想→建議 的固定結構
- 絕對不要用任何固定的開頭、中間、結尾套路
- **嚴禁使用「哈」「哈哈」「哈哈哈」等輕佻的語氣詞作為開頭或回應**
- **嚴禁使用「呵呵」「嘿嘿」等輕浮的語氣詞**
- 避免文言文和哲學術語，但保持莊子的智慧深度和穩重風格
- **絕對禁止**：不要在回應中出現任何英文字母標記（如T、F、WU等）
- **絕對禁止**：不要在回應中出現動作描述（如「輕撫長鬚微笑」、「點頭微笑」等）

**重要平衡**：
- 既要表現出了解朋友，又要避免讓朋友覺得被精準分析或貼標籤
- 保持謙遜，承認你的觀察可能不準確
- 重點是與朋友的當下對話，而不是展示你的分析能力

請直接給出回應，不要包含任何前綴說明。用繁體中文的現代白話文。`;
      }

      // 第4個專門函數：章節總結AI專門函數（加入莊子哲學契合度分析）
      buildChapterSummaryPrompt(chapter, chapterInfo, chapterName, recentChoices, playerData) {
        console.log('🔧 構建章節總結提示詞...');
        
        // 數據處理：計算平均思考時間和構建選擇記錄
        const avgThinkingTime = Math.round((playerData.context.recentHistory.reduce((sum, h) => sum + (h.thinkingTime || 0), 0) / Math.max(1, playerData.context.recentHistory.length)) / 1000 * 10) / 10;
        
        const choiceRecords = recentChoices.map((choice, index) => 
          `${index + 1}. "${choice.choiceText}" (思考${Math.round((choice.thinkingTime || 0) / 1000 * 10) / 10}秒)`
        ).join('\n');
        
        const topTraits = Object.entries(playerData.traits).sort(([,a], [,b]) => b-a).slice(0, 3).map(([k,v]) => k).join('、') || '開放學習';
        const zhuangziAlignment = this.getZhuangziPhilosophyAlignment(playerData.traits);
        
        // 精簡的提示詞模板
        return `我是莊子，為你的${chapterName}探索做個性化總結。

**本章節信息：**
- 主題：${chapterInfo.title} - ${chapterInfo.coreTheme}
- 哲學焦點：${chapterInfo.philosophicalFocus}
- 物化形態：${chapterInfo.transformationForms.join('、')}

**你的選擇記錄：**
${choiceRecords}

**你展現的特質：**
- 主要特質：${topTraits}
- 思考模式：${avgThinkingTime}秒平均思考時間
- 哲學契合度：${zhuangziAlignment.join('、')}

        **總結要求：**
- 用莊子身份（第一人稱"我"）寫120-150字總結
- 重點分析選擇與章節主題的呼應
- 評價對本章節哲學焦點的理解
- 肯定探索態度，給出智慧啟示
- **語言要求**：使用繁體中文現代白話文，自然流暢、富有詩意、溫暖智慧
- **莊子風格特徵**：
  * 使用自然意象和生動比喻（如「如水般清澈」、「像風中的葉」、「心如明鏡」）
  * 保持哲學深度但表達簡潔靈動，有淡雅的文學美感
  * 語調超脫而溫和，帶有逍遙自在的境界感
  * 適度運用詩意表達但不刻意雕琢，自然而生動
  * 體現「無為而治」的語言風格 - 深刻但不沉重，智慧但不說教
- **現代中文底線**：絕對禁止古文句式和詞彙，保持現代語言的流暢自然
- 避免空洞詞彙和說教語言
- 基於具體選擇行為分析，不要泛泛而談
- **絕對禁止**：不要在回應中出現任何英文字母標記（如T、F、WU等）
- **絕對禁止**：不要在回應中出現動作描述（如「輕撫長鬚微笑」、「點頭微笑」等）
- **語言純淨**：只用純粹的繁體中文現代語言表達，保持莊子的智慧風格但用現代語言

根據以上數據，請生成專屬於本章節的個性化總結。`;
      }

      // 第5個專門函數：最終信件AI專門函數（包含完整五層數據系統）
      buildFinalLetterPrompt(playerData) {
        console.log('🔧 構建最終信件提示詞...');
        
        // 計算基礎數據
        const totalPlayTime = Math.round((playerData.timingData?.totalPlayTime || 0) / 1000 / 60); // 轉換為分鐘
        const avgSceneTime = Math.round((playerData.timingData?.averageSceneDwellTime || 0) / 1000); // 轉換為秒
        const avgThinkTime = Math.round((playerData.timingData?.averageThinkingTime || 0) / 1000); // 平均思考時間(秒)
        
        // 構建關鍵選擇
        const getKeyChoices = (choiceHistory) => {
          if (choiceHistory.length === 0) return '無具體選擇記錄';
          
          const keyChoices = choiceHistory
            .filter(choice => choice.thinkingTime > 3000) // 思考超過3秒的選擇
            .sort((a, b) => b.thinkingTime - a.thinkingTime) // 按思考時間排序
            .slice(0, 2); // 最多取2個
          
          if (keyChoices.length === 0) {
            keyChoices.push(...choiceHistory.slice(-2));
          }
          
          return keyChoices.map((choice, index) => 
            `"${choice.choiceText}" (在${choice.chapter || '未知'}章節中深思${Math.round((choice.thinkingTime || 0) / 1000)}秒後的選擇)`
          ).join('\n');
        };
        
        const keyChoices = getKeyChoices(playerData.choices || []);
        
        // MBTI傾向分析（8維度系統）
        const getMBTITendencies = (traits) => {
          const tendencies = [];
          
          // MBTI四維度
          const eScore = traits?.E || 0;
          const iScore = traits?.I || 0;
          if (eScore > iScore + 1) tendencies.push('外向活躍');
          else if (iScore > eScore + 1) tendencies.push('內向深思');
          else tendencies.push('外向內向均衡');
          
          const sScore = traits?.S || 0;
          const nScore = traits?.N || 0;
          if (sScore > nScore + 1) tendencies.push('感覺實際');
          else if (nScore > sScore + 1) tendencies.push('直覺想像');
          else tendencies.push('感覺直覺均衡');
          
          const tScore = traits?.T || 0;
          const fScore = traits?.F || 0;
          if (tScore > fScore + 1) tendencies.push('理性思考');
          else if (fScore > tScore + 1) tendencies.push('情感豐富');
          else tendencies.push('理性情感均衡');
          
          const jScore = traits?.J || 0;
          const pScore = traits?.P || 0;
          if (jScore > pScore + 1) tendencies.push('計劃有序');
          else if (pScore > jScore + 1) tendencies.push('靈活隨性');
          else tendencies.push('計劃靈活均衡');
          
          return tendencies.join('、');
        };
        
        // 調用統一的哲學契合度分析函數和MBTI類型判斷
        const mbtiTendencies = getMBTITendencies(playerData.traits || {});
        const zhuangziAlignment = this.getZhuangziPhilosophyAlignment(playerData.traits || {});
        
        // 獲取16型人格類型用於AI內部參考（不在回復中提及）
        const finalMBTIType = this.determineMBTITypeFromScores(playerData.traits || {});
        const mbtiDescription = this.getMBTITypeDescription(finalMBTIType);
        
        // 構建完整的五層數據系統
        const layerData = {
          // 第1層：選擇數據（最高優先級 - 40%）
          choiceData: {
            totalChoices: (playerData.choices || []).length,
            keyChoices: keyChoices,
            dominantTraits: playerData.patterns?.dominantTraits || [],
            mbtiTendencies: mbtiTendencies,
            philosophyScores: playerData.traits || {},
            zhuangziAlignment: zhuangziAlignment,
            // AI內部參考數據（不在回復中直接提及）
            internalMBTIType: finalMBTIType,
            internalMBTIDescription: mbtiDescription
          },
          
          // 第2層：聊天互動數據（高優先級 - 25%）
          chatData: {
            totalQuestions: playerData.chatHistory?.totalQuestions || 0,
            recentQuestions: playerData.chatHistory?.recentQuestions || [],
            questionTypes: playerData.chatHistory?.questionTypes || [],
            interactionStyle: playerData.chatHistory?.interactionStyle || '沉默觀察型'
          },
          
          // 第3層：時間和節奏數據（中等優先級 - 20%）
          timingData: {
            totalPlayTime: totalPlayTime,
            averageSceneDwellTime: avgSceneTime,
            averageThinkingTime: avgThinkTime,
            thinkingPattern: avgThinkTime > 5 ? '深思熟慮型' : avgThinkTime > 2 ? '適中思考型' : '直覺反應型',
            playPattern: avgSceneTime > 60 ? '細緻體驗型' : avgSceneTime > 30 ? '平穩探索型' : '快節奏進行型'
          },
          
          // 第4層：物化行為數據（中等優先級 - 10%）
          transformationData: {
            totalTransformations: playerData.transformationData?.totalTransformations || 0,
            preferredForms: playerData.transformationData?.transformationPatterns?.preferredForms || [],
            explorationFrequency: playerData.transformationData?.explorationFrequency || 0,
            adaptabilityIndex: playerData.transformationData?.adaptabilityIndex || 0
          },
          
          // 第5層：學習挑戰數據（較低優先級 - 5%）
          learningData: {
            totalPuzzles: playerData.segmentationPuzzleData?.totalPuzzles || 0,
            averageAccuracy: Math.round((playerData.segmentationPuzzleData?.averageAccuracy || 0) * 100),
            persistenceLevel: playerData.segmentationPuzzleData?.persistenceLevel || 0,
            learningStyle: playerData.segmentationPuzzleData?.learningStyle || '穩步前進型'
          }
        };
        
        return `你是莊子本人，現在要穿越時空，為一位完成《莊子：萬物逍遙》遊戲的現代朋友寫一封親筆信。

**我的身份和任務：**
1. **我就是莊子**：用第一人稱"我"來寫，就像真的莊子在和這位朋友對話
2. **穿越時空**：表達我從古代穿越到現代來關心這位朋友
3. **個性洞察**：基於遊戲數據，深入分析這位朋友的個性特點
4. **生活啟示**：給出具體的生活建議和人生啟示
5. **情感連結**：建立我與這位現代朋友之間的情感連結
6. **未來指引**：針對他們的未來生活給出溫暖而智慧的指導

**寫作風格：**
- **情感基調**：溫暖、親切、充滿關懷，像長輩對晚輩的慈愛指導
- **語言風格**：現代白話文，親切自然，避免文言文，但要有莊子的智慧深度
- **啟示性**：重點在於給出對個性和生活的啟示，讓讀者有所感悟
- **感動性**：要有情感衝擊力，讓讀者讀完後感到溫暖、感動、有所啟發
- **實用性**：給出具體的生活建議，不只是抽象的哲學討論
- **普適性**：避免針對特定職業或工作環境，保持對所有人生階段和背景的廣泛適用性

**寫作要求：**
- 開頭："致逍遙未至的朋友："
- 結尾："你跨越時空的朋友 庄周 于蝴蝶夢醒時分"
- 800-1200字，溫暖親切語調，將數據轉化為人性關懷
- 用繁體中文現代白話文
- **🚫 絕對禁止提及MBTI類型**：不得在信中出現任何MBTI字母組合（如INFP、ENFJ等）或類型名稱（如"提倡者"、"建築師"等）
- **🚫 絕對禁止職場相關內容**：不得提及辦公室、工作、職場、同事、上司、會議、項目、業績、升職、加薪等任何與工作環境相關的詞彙和概念
- **✅ 保持普適性**：信件內容應該適用於所有人生階段和背景，包括學生、自由職業者、退休人士、家庭主婦等各種生活狀態
- 嚴禁套話和心靈雞湯：不要用"人生如夢"、"順其自然"、"心靈平靜"等空洞詞彙
- 必須具體化：針對朋友的具體選擇和行為模式進行分析，避免泛泛而談
- 避免說教式語言：不要用"你應該"、"你需要"等指令性語言
- 拒絕萬能金句：不要用"一切都是最好的安排"、"相信自己"等通用句子
- 基於數據說話：每個洞察都要有具體的選擇或行為作為依據
- **絕對禁止**：不要在信件中出現任何英文字母標記（如T、F、WU、AT、DT等）
- **絕對禁止**：不要在信件中出現動作描述（如「輕撫長鬚微笑」、「點頭微笑」等）
- **語言純淨**：只用純粹的中文語言表達，保持莊子的溫暖智慧風格
- **情感真摯**：重點傳達對朋友的理解和關愛，而非展示分析技巧
- **內容普適**：信件內容應該適用於所有人生階段和背景，避免針對特定職業或工作環境

**五層數據利用優先級（溫度化解讀）：**
- **選擇數據（40%）**：重點分析人格傾向和哲學傾向，結合關鍵選擇回顧，深度解讀內心世界
- **聊天互動（25%）**：分析求知之心和朋友情誼，從互動看出探索態度
- **時間節奏（20%）**：從思考和遊戲節奏看出性格特質和生活態度
- **物化探索（10%）**：適度肯定探索勇氣和適應精神
- **學習挑戰（5%）**：輕度肯定堅持品質和文化興趣

**這位朋友的心靈數據：**

🎯 **選擇數據**（40%篇幅 - 重點分析）：
- 總選擇${layerData.choiceData.totalChoices}次，遊戲${layerData.timingData.totalPlayTime}分鐘
- 人格傾向：${layerData.choiceData.mbtiTendencies}
- 🔒 **AI內部參考**（僅供你理解朋友性格，絕對不要在信中提及）：
  * 推測類型：${layerData.choiceData.internalMBTIType}
  * 類型特徵：${layerData.choiceData.internalMBTIDescription}
  * 指導原則：在信中直接使用該類型的經典描述（如"你是富有想像力的理想主義者"）來讓朋友感受到被深度理解，但絕不提及類型字母組合（如INFP）或類型名稱（如調停者）
- 哲學原始分數：執著${layerData.choiceData.philosophyScores?.AT || 0}、超脫${layerData.choiceData.philosophyScores?.DT || 0}、干預${layerData.choiceData.philosophyScores?.IN || 0}、無為${layerData.choiceData.philosophyScores?.WU || 0}、分別${layerData.choiceData.philosophyScores?.DI || 0}、齊等${layerData.choiceData.philosophyScores?.EQ || 0}、有用${layerData.choiceData.philosophyScores?.US || 0}、無用${layerData.choiceData.philosophyScores?.UN || 0}
- 哲學契合度：${layerData.choiceData.zhuangziAlignment.join('、')}
- 關鍵選擇回顧：
${layerData.choiceData.keyChoices}

💬 **聊天互動**（25%篇幅 - 深度分析）：
- 提問${layerData.chatData.totalQuestions}次，互動風格：${layerData.chatData.interactionStyle}
- 關注焦點：${layerData.chatData.recentQuestions.length > 0 ? layerData.chatData.recentQuestions.slice(-3).map(q => `"${q.question}"`).join('、') : '沉默體驗，內心思辨'}

⏰ **時間節奏**（20%篇幅 - 適度分析）：
- 思考${layerData.timingData.averageThinkingTime}秒（${layerData.timingData.thinkingPattern}），停留${layerData.timingData.averageSceneDwellTime}秒（${layerData.timingData.playPattern}）

🦋 **物化探索**（10%篇幅 - 適度提及）：
- 物化${layerData.transformationData.totalTransformations}次，偏好：${layerData.transformationData.preferredForms.join('、') || '自然隨緣'}

📜 **學習挑戰**（5%篇幅 - 輕度肯定）：
- 謎題${layerData.learningData.totalPuzzles}個，準確率${layerData.learningData.averageAccuracy}%

**💡 根據內部MBTI分析直接使用經典描述的技巧：**
- **對ENFJ**：直接描述"你是富有同情心的引導者，關心他人成長，有天然的影響力"
- **對ENFP**：直接描述"你是熱情洋溢的理想主義者，富有創造力，能看到無限可能"
- **對ENTJ**：直接描述"你是天生的領導者，果斷而有遠見，善於制定和執行計劃"
- **對ENTP**：直接描述"你是聰明好辯的思想家，喜愛智力挑戰，充滿創新精神"
- **對ESFJ**：直接描述"你是熱心助人的合作者，重視和諧，有強烈的責任感"
- **對ESFP**：直接描述"你是活潑開朗的表演者，享受當下，善於帶動氣氛"
- **對ESTJ**：直接描述"你是實用主義的組織者，重視效率，有很強的執行力"
- **對ESTP**：直接描述"你是精力充沛的實用主義者，適應力強，善於解決問題"
- **對INFJ**：直接描述"你是富有洞察力的理想主義者，追求意義，有獨特的直覺"
- **對INFP**：直接描述"你是富有想像力的理想主義者，價值觀驅動，內心豐富"
- **對INTJ**：直接描述"你是富有想像力的戰略家，追求完美，有系統性思維"
- **對INTP**：直接描述"你是富有創新精神的發明家，追求理解，善於分析"
- **對ISFJ**：直接描述"你是溫暖體貼的保護者，樂於助人，有強烈的服務精神"
- **對ISFP**：直接描述"你是靈活友善的藝術家，追求和諧，有獨特的審美"
- **對ISTJ**：直接描述"你是實用忠誠的傳統主義者，責任感強，做事有條不紊"
- **對ISTP**：直接描述"你是靈活務實的技師，擅長解決問題，動手能力強"

**🎯 個性化表達策略：**
- 不要說"你是XX型"，而是直接說"我看到你是..."、"我感受到你是..."、"你身上有..."
- 用具體的行為和選擇來支撐性格分析，如"從你的選擇中，我感受到你是那種..."
- 將MBTI經典描述轉化為莊子式的表達，如"你這種理想主義者的特質..."
- 結合具體遊戲數據來支撐MBTI分析，如"你的深思熟慮體現了你戰略家的特質..."
- **核心要點**：直接使用MBTI經典描述（如"你是富有想像力的理想主義者"）讓玩家感受到被準確理解，而非只是調整語調

**哲學數據分析指導**：
- **原始分數解讀**：根據具體數值判斷傾向強度，如執著8分vs超脫2分表示強烈執著傾向
- **契合度策略應用**：
  - **深度契合**：表達共鳴和肯定，"我看到了你心中的那份超脫"，鼓勵繼續保持這種智慧
  - **需要引導**：溫柔建議，"我理解你的執著，但或許可以試著..."，提供具體的生活智慧
  - **適中平衡**：讚美平衡，"你在二者之間找到了屬於自己的道路"，鼓勵在體驗中深化
- **綜合分析**：結合原始分數的具體數值和契合度評價，提供更精準的個性化指導

**六大寫作指導：**
1. **開場問候**：溫暖稱呼，體現朋友情誼，可根據內部MBTI分析調整親密度
2. **個性洞察**：基於人格傾向和哲學契合度分析，深度分析心靈特質（重點），展現對朋友性格的深度理解
3. **生活啟示**：結合時間節奏和思考模式，給出符合朋友性格類型的人生智慧（避免職場環境，聚焦個人成長和人際關係）
4. **情感連結**：用莊子溫度，讓朋友感受理解關懷，將數據轉化為人性關懷
5. **未來指引**：基於探索學習和互動模式，給出符合朋友性格特點的發展建議（關注個人興趣、學習、人際關係等普適性領域）
6. **結語祝福**：以莊子身份，給出祝福期許

請直接寫信，不要前綴說明。這封信應該讓讀者感受到：莊子真的穿越時空來關心他們，理解他們，並為他們的人生提供智慧的指引。`;
      }
      

      
             
      
             // 為多輪對話構建系統提示詞
      buildSystemPromptForChat(context, playerData) {
        const dominantTraits = playerData.patterns?.dominantTraits || [];
        const recentChoices = playerData.context?.recentHistory || [];
        
        if (context.sceneType === 'zhuangzi-chat' && context.chapter === 'post-game-chat') {
          // 通關後聊天的系統提示詞
          return `你是莊子本人，正在與一位完成《莊子：萬物逍遙》遊戲的現代朋友進行深度對話。

**你的身份特徵：**
- 你是真正的莊子，用現代白話文與朋友對話
- 語調親切溫暖，像老友般關懷
- 每次回應40-60字，簡潔而有深度
- 避免說教，多用啟發和引導

**朋友的特質：**
- 主要特質：${dominantTraits.join('、') || '正在探索自我'}
- 已完成整個遊戲，對莊子哲學有基本理解
- 需要的是人生智慧和情感理解

**對話原則：**
- 記住之前的對話內容，保持連貫性
- 針對朋友的具體問題給出個性化回應
- 結合朋友的遊戲體驗和特質
- 用莊子智慧回應現代生活問題
- 保持對話的自然流暢
- **絕對禁止**：不要在回應中出現英文字母標記（如T、F、WU等）
- **絕對禁止**：不要在回應中出現動作描述（如「輕撫長鬚微笑」等）`;
        } else {
          // 斷句解讀聊天的系統提示詞
          return `你是莊子本人，正在與一位朋友討論古文斷句和哲學思考。

**你的身份特徵：**
- 你是真正的莊子，用現代白話文與朋友對話
- 語調親切自然，像在和朋友聊天
- 每次回應30-40字，簡潔明了
- 避免學術性講解，多用生活化表達

**朋友的特質：**
- 主要特質：${dominantTraits.join('、') || '好學好問'}
- 正在學習古文斷句，對哲學有興趣
- 需要的是理解和鼓勵，而不是標準答案

**對話原則：**
- 記住之前的對話內容，保持連貫性
- 對朋友的疑問給出溫和的回應
- 不直接給出標準答案，而是啟發思考
- 用莊子的智慧回應學習中的困惑
- **絕對禁止**：不要在回應中出現英文字母標記（如T、F、WU等）
- **絕對禁止**：不要在回應中出現動作描述（如「輕撫長鬚微笑」等）`;
        }
      }

      // 生成緩存鍵
       generateCacheKey(context, playerData) {
         const keyData = {
           dominantTraits: (playerData.patterns?.dominantTraits || []).slice(0, 2),
           chapter: context.chapter || 'unknown',
           scene: context.scene || 'unknown',
           sceneType: context.sceneType || 'general',
           description: (context.description || '').substring(0, 50), // 取前50個字符避免key過長
           specificQuestion: (context.specificQuestion || '').substring(0, 30),
           recentChoices: (playerData.context?.recentHistory || []).slice(-2).map(h => h.choiceText || '')
         };
         return JSON.stringify(keyData);
       }
      

      
      // MBTI類型判斷（基於分數）
      determineMBTITypeFromScores(mbtiScores) {
        const eVsI = (mbtiScores?.E || 0) - (mbtiScores?.I || 0);
        const sVsN = (mbtiScores?.S || 0) - (mbtiScores?.N || 0);
        const tVsF = (mbtiScores?.T || 0) - (mbtiScores?.F || 0);
        const jVsP = (mbtiScores?.J || 0) - (mbtiScores?.P || 0);
        
        const E_I = eVsI >= 0 ? 'E' : 'I';
        const S_N = sVsN >= 0 ? 'S' : 'N';
        const T_F = tVsF >= 0 ? 'T' : 'F';
        const J_P = jVsP >= 0 ? 'J' : 'P';
        
        return E_I + S_N + T_F + J_P;
      }
      
      // MBTI類型描述
      getMBTITypeDescription(mbtiType) {
        const descriptions = {
          'ENFJ': '教育家：富有同情心的引導者，關心他人成長',
          'ENFP': '激勵者：熱情洋溢的理想主義者，富有創造力',
          'ENTJ': '指揮官：天生的領導者，果斷而有遠見',
          'ENTP': '辯論家：聰明好辯的思想家，喜愛智力挑戰',
          'ESFJ': '執政官：熱心助人的合作者，重視和諧',
          'ESFP': '娛樂者：活潑開朗的表演者，享受當下',
          'ESTJ': '總經理：實用主義的組織者，重視效率',
          'ESTP': '企業家：精力充沛的實用主義者，適應力強',
          'INFJ': '提倡者：富有洞察力的理想主義者，追求意義',
          'INFP': '調停者：富有想像力的理想主義者，價值觀驅動',
          'INTJ': '建築師：富有想像力的戰略家，追求完美',
          'INTP': '思想家：富有創新精神的發明家，追求理解',
          'ISFJ': '守護者：溫暖體貼的保護者，樂於助人',
          'ISFP': '探險家：靈活友善的藝術家，追求和諧',
          'ISTJ': '物流師：實用忠誠的傳統主義者，責任感強',
          'ISTP': '鑑賞家：靈活務實的技師，擅長解決問題'
        };
        
        return descriptions[mbtiType] || '探索中：正在發現自己的人格類型';
      }

      translateTrait(trait) {
        const map = {
          // MBTI維度
          'E': '外向性', 'I': '內向性', 'S': '感覺型', 'N': '直覺型',
          'T': '思考型', 'F': '情感型', 'J': '判斷型', 'P': '知覺型',
          // 莊子哲學維度
          'AT': '執著性', 'DT': '超脫性', 'IN': '干預性', 'WU': '無為性',
          'DI': '分別性', 'EQ': '齊等性', 'US': '有用性', 'UN': '無用性'
        };
        return map[trait] || trait;
      }
      
      translateTone(tone) {
        const map = {
          'profound': '深邃而富有哲理', 'warm': '溫暖而親切',
          'mysterious': '神秘而引人深思', 'gentle': '溫和而理解',
          'poetic': '詩意而優美', 'balanced': '平衡而中庸'
        };
        return map[tone] || tone;
      }
      
      translateDepth(depth) {
        const map = {
          'deep': '深刻複雜，富有層次', 'medium': '適中，易於理解',
          'light': '簡潔明了，直接有效'
        };
        return map[depth] || depth;
      }
      
      translateApproach(approach) {
        const map = {
          'philosophical': '哲學思辨式', 'supportive': '支持鼓勵式',
          'questioning': '啟發提問式', 'understanding': '理解共情式',
          'inspiring': '啟發激勵式', 'guiding': '引導指點式'
        };
        return map[approach] || approach;
      }
      
      // 生成古文解讀
      async generateTextInterpretation(ancientText, playerData) {
        const messages = [
          {
            role: 'system',
            content: `你是莊子，請根據朋友的性格特質，對古文進行個性化解讀。

朋友特質：
- 主導特質：${(playerData.patterns?.dominantTraits || []).map(t => this.translateTrait(t)).join('、')}

請必須用繁體中文的現代白話文，以親切自然的語調解讀古文的深層含義。避免文言文表達，回應控制在100字以內。`
          },
          {
            role: 'user',
            content: `古文：${ancientText}\n\n請根據我的性格特質，解讀這段古文對我的特殊意義。`
          }
        ];
        
        return await this.callDeepSeekAPI(messages, { maxTokens: 200 });
      }
      
      // 生成章節總結
      async generateChapterSummary(chapter, playerData) {
        console.log('📊 ===== 章節總結AI調試信息 =====');
        console.log('🎯 調用時間:', new Date().toLocaleTimeString());
        console.log('📚 目標章節:', chapter);
        console.log('📦 玩家數據可用性:', !!playerData);
        
        // 尾聲章節不生成章節總結，只生成神秘禮物信件
        if (chapter === 'epilogue') {
          console.log('🎭 尾聲章節不生成章節總結，只有神秘禮物信件');
          return null;
        }
        
        const chapterNames = {
          'chapter1': '第二章：子非魚',
          'chapter2': '第三章：北冥有魚', 
          'chapter3': '第四章：鴟得腐鼠',
          'chapter4': '第五章：蝸角之爭',
          'chapter5': '第六章：朝菌大椿',
          'chapter6': '第七章：螻蟻星辰',
          'chapter7': '第八章：道歸混沌'
        };
        
        // 確保數據完整性
        const safePlayerData = {
          choices: playerData.choices || [],
          traits: playerData.traits || {},
          profile: playerData.profile || { dominantTraits: [] },
          context: playerData.context || { 
            recentHistory: [],
            gameProgress: getGameProgressSummary()
          }
        };
        
        const recentChoices = safePlayerData.context.recentHistory.slice(-5);
        const chapterName = chapterNames[chapter] || chapter;
        
        console.log('📊 章節總結數據詳情:');
        console.log('  📖 章節名稱:', chapterName);
        console.log('  📈 最近選擇數量:', recentChoices.length);
        console.log('  🎯 主導特質:', safePlayerData.profile.dominantTraits);
        
        // 获取当前章节的具体信息
        const chapterThemes = {
          'chapter1': {
            title: '濠梁觀魚',
            coreTheme: '知魚之樂的哲學思辨',
            keyScenes: ['濠梁橋上觀魚', '與惠子的知樂辯論', '魚兒自在游泳的觀察'],
            philosophicalFocus: '知與不知的界限、同理心與想像力、觀察者的立場',
            transformationForms: ['鯤', '鵬'],
            chapterWisdom: '從不同視角理解他者的內心世界'
          },
          'chapter2': {
            title: '北冥有魚',
            coreTheme: '鯤鵬逍遙的無限視野',
            keyScenes: ['北冥大海深處', '鯤鵬九萬里高翔', '小鳥的嘲笑'],
            philosophicalFocus: '大小相對性、視野的限制、逍遙的境界',
            transformationForms: ['鯤', '鵬'],
            chapterWisdom: '突破視野局限，體驗無限可能'
          },
          'chapter3': {
            title: '鴟得腐鼠',
            coreTheme: '價值觀的相對性',
            keyScenes: ['森林中的鵷鶵', '鴟鴞與腐鼠', '美醜標準的思辨'],
            philosophicalFocus: '價值判斷的相對性、美醜觀念、不同生命的需求',
            transformationForms: ['鵷鶵', '鴟鴞'],
            chapterWisdom: '理解不同存在的價值觀和需求'
          },
          'chapter4': {
            title: '蝸角之爭',
            coreTheme: '大小與爭執的虛妄',
            keyScenes: ['蝸牛左右觸角', '觸角國度的戰爭', '螺旋時空的體驗'],
            philosophicalFocus: '大小的相對性、爭執的無意義、時空的層次',
            transformationForms: ['螺旋時空視角'],
            chapterWisdom: '在更大的時空中看待人生的爭執'
          },
          'chapter5': {
            title: '朝菌大椿',
            coreTheme: '時間長短的相對性',
            keyScenes: ['時間森林', '朝菌的短暫', '大椿的悠長'],
            philosophicalFocus: '時間感知的相對性、生命周期的意義、永恆與瞬間',
            transformationForms: ['朝菌', '大椿'],
            chapterWisdom: '理解不同時間尺度的生命智慧'
          },
          'chapter6': {
            title: '螻蟻星辰',
            coreTheme: '生死一體的超越',
            keyScenes: ['天地為棺槨', '螻蟻的視角', '星辰的高遠'],
            philosophicalFocus: '生死的超越、上下視角、存在的一體性',
            transformationForms: ['螻蟻', '星辰'],
            chapterWisdom: '超越生死偏見，體驗存在的一體性'
          },
          'chapter7': {
            title: '道歸混沌',
            coreTheme: '混沌復生與道的本質',
            keyScenes: ['虛空中的混沌', '七竅的封印', '道的顯現'],
            philosophicalFocus: '混沌的智慧、有為與無為、道的本質',
            transformationForms: ['氣'],
            chapterWisdom: '回歸本源，體驗道的無為境界'
          }
        };

        const currentChapterInfo = chapterThemes[chapter] || chapterThemes['chapter1'];
        
        const messages = [
          {
            role: 'user',
            content: this.buildChapterSummaryPrompt(chapter, currentChapterInfo, chapterName, recentChoices, safePlayerData)
          }
        ];
        
                 const result = await this.callDeepSeekAPI(messages, { maxTokens: 400 });
         
         if (result) {
           console.log('✅ 章節總結生成成功!');
           console.log('📖 總結長度:', result.length, '字符');
           console.log('📝 總結內容預覽:', result.substring(0, 80) + '...');
           
           // 檢查總結質量
           if (result.length < 50) {
             console.warn('⚠️ 總結內容過短，可能是AI調用問題');
           } else if (result.length > 200) {
             console.log('💪 總結內容豐富，符合預期');
           }
         } else {
           console.error('❌ 章節總結生成失敗，返回null');
         }
         
         return result;
      }
      
      // 啟用/禁用AI功能
      toggleAI(enabled) {
        this.isEnabled = enabled;
        console.log(`🤖 AI功能已${enabled ? '啟用' : '禁用'}`);
      }
      
      // 清空緩存
      clearCache() {
        this.responseCache.clear();
        console.log('💾 AI回應緩存已清空');
      }

      // 清除聊天相關的緩存（解決固定三段式結構問題）
      clearChatCache() {
        const keys = Array.from(this.responseCache.keys());
        let chatCacheCleared = 0;
        
        keys.forEach(key => {
          try {
            const keyData = JSON.parse(key);
            if (keyData.sceneType === 'segmentation-interpretation' || 
                keyData.sceneType === 'zhuangzi-chat' ||
                key.includes('chat') ||
                key.includes('question')) {
              this.responseCache.delete(key);
              chatCacheCleared++;
            }
          } catch (e) {
            // 如果解析失败，检查是否包含聊天相关关键词
            if (key.includes('chat') || key.includes('question') || key.includes('interpretation')) {
              this.responseCache.delete(key);
              chatCacheCleared++;
            }
          }
        });
        
        console.log(`🗑️ 清除了${chatCacheCleared}個聊天相關緩存，應該能解決固定三段式回應問題`);
      }
    }
    
    // 創建全局AI實例
    const zhuangziAI = new ZhuangziAI();
    
    // 掛載到window對象，使其全局可用
    window.zhuangziAI = zhuangziAI;
    
    // 驗證兩個引用指向同一個對象
    console.log('🔍 AI實例驗證:', {
      '局部zhuangziAI存在': !!zhuangziAI,
      'window.zhuangziAI存在': !!window.zhuangziAI,
      '兩者是同一個實例': zhuangziAI === window.zhuangziAI,
      'API密鑰一致': zhuangziAI.apiKey === window.zhuangziAI.apiKey
    });


    

    

    
    // 查看緩存狀態
    window.showCacheStatus = function() {
      if (window.zhuangziAI) {
        const cacheSize = window.zhuangziAI.responseCache.size;
        console.log('📊 AI緩存狀態:', {
          '緩存條目數': cacheSize,
          '是否為空': cacheSize === 0
        });
        return cacheSize;
      } else {
        console.error('❌ AI系統未初始化');
        return -1;
      }
    };
    
    // 全局對話歷史管理函數
    window.clearSegmentationChatHistory = function() {
      clearChatHistory('segmentation-chat');
      console.log('🗑️ 斷句解讀聊天歷史已清空！');
      return true;
    };
    
    window.clearPostGameChatHistory = function() {
      clearChatHistory('post-game-chat');
      console.log('🗑️ 通關後聊天歷史已清空！');
      return true;
    };
    
    window.clearAllChatHistory = function() {
      clearChatHistory('segmentation-chat');
      clearChatHistory('post-game-chat');
      console.log('🗑️ 所有聊天歷史已清空！');
      return true;
    };
    
    window.showChatHistoryStatus = function() {
      const segmentationHistory = getChatHistory('segmentation-chat');
      const postGameHistory = getChatHistory('post-game-chat');
      
      console.log('📊 聊天歷史狀態:');
      console.log('   斷句解讀聊天:', `${segmentationHistory.length}條記錄`);
      console.log('   通關後聊天:', `${postGameHistory.length}條記錄`);
      console.log('   總計:', `${segmentationHistory.length + postGameHistory.length}條記錄`);
      
      return {
        segmentationChat: segmentationHistory.length,
        postGameChat: postGameHistory.length,
        total: segmentationHistory.length + postGameHistory.length
      };
    };

    // 提示用戶可用的全局函數
    console.log('🛠️  可用的全局管理函數:');
    console.log('   AI緩存管理:');
    console.log('     showCacheStatus() - 查看緩存狀態');
    console.log('   對話歷史管理:');
    console.log('     clearSegmentationChatHistory() - 清空斷句解讀聊天歷史');
    console.log('     clearPostGameChatHistory() - 清空通關後聊天歷史');
    console.log('     clearAllChatHistory() - 清空所有聊天歷史');
    console.log('     showChatHistoryStatus() - 查看聊天歷史狀態');
    
    // AI調用的便捷函數
    async function getPersonalizedZhuangziResponse(context, specificQuestion = '') {
      const playerData = getAIAnalysisData();
      const fullContext = {
        ...context,
        specificQuestion: specificQuestion
      };
      
      return await zhuangziAI.generatePersonalizedResponse(fullContext, playerData);
    }
    
    // 獲取個性化古文解讀
    async function getPersonalizedTextInterpretation(ancientText) {
      const playerData = getAIAnalysisData();
      return await zhuangziAI.generateTextInterpretation(ancientText, playerData);
    }
    

    
        // === ContentMixer系統已移除 ===
        // 根據新的設計理念，所有personalized-response場景都直接調用AI生成
        // AI和預設內容的比例通過四階段場景結構設計來控制，無需動態混合系統

                 // AI個性化回應生成函數（直接調用AI，不使用混合系統）
         window.generateSmartResponse = async function(choice, context = {}) {
             console.log('🤖 ===== generateSmartResponse調試信息 =====');
             console.log('🎯 調用時間:', new Date().toLocaleTimeString());
             console.log('📝 玩家選擇:', choice);
             console.log('🎬 場景上下文:', context);
             console.log('🎮 當前遊戲狀態:', {
                 chapter: gameState.currentChapter,
                 scene: gameState.currentScene,
                 currentForm: gameState.currentForm
             });
             
                // 準備AI調用的數據格式
                console.log('📊 準備收集玩家數據...');
                const playerData = getAIAnalysisData();
                
                const aiContext = {
                    chapter: context.chapter || gameState.currentChapter,
                    scene: context.scene || gameState.currentScene,
                 sceneType: context.sceneType || 'general', // 重要：包含場景類型
                    currentForm: gameState.currentForm,
                 description: context.description || context.sceneContext || '當前遊戲場景',
                 specificQuestion: choice,
                 responseKey: context.responseKey || '' // 包含回應鍵
                };
                
                console.log('🎭 AI調用上下文:', aiContext);
                console.log('👤 玩家數據摘要:', {
                    總選擇數: playerData.choices?.length || 0,
                    哲學特質數: Object.keys(playerData.traits || {}).length,
                    建議風格: playerData.suggestedStyle
                });
                
                console.log('🚀 開始調用AI生成個性化回應...');
                const aiStartTime = Date.now();
                
             // 直接調用AI生成個性化回應
                const response = await zhuangziAI.generatePersonalizedResponse(aiContext, playerData);
                
                const aiEndTime = Date.now();
                const aiDuration = aiEndTime - aiStartTime;
                
                console.log('⏱️ AI調用耗時:', `${aiDuration}ms`);
                
                if (response) {
                    console.log('✅ AI個性化回應生成成功!');
                    console.log('📏 回應長度:', response.length, '字符');
                    console.log('📝 回應內容:', response);
                    console.log('🎯 回應品質檢查:', {
                        包含繁體中文: /[\u4e00-\u9fff]/.test(response),
                        長度合適: response.length >= 40 && response.length <= 120,
                        包含個性化元素: response.includes('你') || response.includes('選擇'),
                        符合莊子風格: response.includes('道') || response.includes('自然') || response.includes('逍遙') || response.includes('無為')
                    });
                } else {
                    console.warn('⚠️ AI回應生成失敗，返回null');
                }
                
                console.log('========================================');
                return response;
         };


     


    // 音頻管理系統
    class AudioManager {
      constructor() {
        this.backgroundMusic = new Audio();
        this.backgroundMusic.loop = true;
        this.backgroundMusic.volume = 0.3; // 默認音量
        this.currentChapterMusic = null;
        this.fadeInDuration = 2000; // 淡入時間（毫秒）
        this.fadeOutDuration = 1500; // 淡出時間（毫秒）
        
        // 章節特定音量設置
        this.chapterVolumes = {
          'chapter1': 0.3,
          'chapter2': 0.3,
          'chapter3': 0.3,
          'chapter4': 0.3,
          'chapter5': 0.6, // 朝菌大椿章節音量調高
          'chapter6': 0.3,
          'chapter7': 0.3,
          'epilogue': 0.3,
          'mysterious-gift': 0.4 // 神秘禮物音樂音量
        };
        this.defaultVolume = 0.3; // 默認音量
      }

      // 播放背景音樂，支持淡入效果和章節特定音量
      playBackgroundMusic(audioUrl, fadeIn = true, chapterId = null) {
        if (!gameState.audioEnabled) return;
        
        // 如果已經在播放相同的音樂，不重複播放
        if (this.currentChapterMusic === audioUrl && !this.backgroundMusic.paused) {
          return;
        }

        // 獲取該章節的目標音量
        this.targetVolume = chapterId && this.chapterVolumes[chapterId] 
          ? this.chapterVolumes[chapterId] 
          : this.defaultVolume;

        // 如果有其他音樂在播放，先淡出
        if (!this.backgroundMusic.paused) {
          this.fadeOut(() => {
            this.loadAndPlay(audioUrl, fadeIn);
          });
        } else {
          this.loadAndPlay(audioUrl, fadeIn);
        }
      }

      // 載入並播放音樂
      loadAndPlay(audioUrl, fadeIn) {
        this.backgroundMusic.src = audioUrl;
        this.currentChapterMusic = audioUrl;
        
        if (fadeIn) {
          this.backgroundMusic.volume = 0;
          this.backgroundMusic.play().then(() => {
            this.fadeIn();
          }).catch(error => {
            console.warn('音頻播放失敗:', error);
          });
        } else {
          this.backgroundMusic.volume = this.targetVolume || this.defaultVolume;
          this.backgroundMusic.play().catch(error => {
            console.warn('音頻播放失敗:', error);
          });
        }
      }

      // 停止背景音樂，支持淡出效果
      stopBackgroundMusic(fadeOut = true) {
        if (this.backgroundMusic.paused) return;
        
        if (fadeOut) {
          this.fadeOut(() => {
            this.backgroundMusic.pause();
            this.currentChapterMusic = null;
          });
        } else {
          this.backgroundMusic.pause();
          this.backgroundMusic.volume = this.defaultVolume;
          this.currentChapterMusic = null;
        }
      }

      // 淡入效果
      fadeIn() {
        const targetVolume = this.targetVolume || this.defaultVolume;
        const steps = 20;
        const volumeStep = targetVolume / steps;
        const timeStep = this.fadeInDuration / steps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
          currentStep++;
          this.backgroundMusic.volume = Math.min(volumeStep * currentStep, targetVolume);
          
          if (currentStep >= steps) {
            clearInterval(fadeInterval);
          }
        }, timeStep);
      }

      // 淡出效果
      fadeOut(callback) {
        const initialVolume = this.backgroundMusic.volume;
        const steps = 15;
        const volumeStep = initialVolume / steps;
        const timeStep = this.fadeOutDuration / steps;
        
        let currentStep = 0;
        const fadeInterval = setInterval(() => {
          currentStep++;
          this.backgroundMusic.volume = Math.max(initialVolume - (volumeStep * currentStep), 0);
          
          if (currentStep >= steps) {
            clearInterval(fadeInterval);
            if (callback) callback();
          }
        }, timeStep);
      }

      // 設置音頻開關
      setAudioEnabled(enabled) {
        gameState.audioEnabled = enabled;
        if (!enabled && !this.backgroundMusic.paused) {
          this.stopBackgroundMusic(true);
        }
      }
    }

    // 創建全局音頻管理器
    const audioManager = new AudioManager();
    
    // 切換到神秘禮物專用音樂
    function switchToMysteriousGiftMusic() {
      console.log('🎵 切換到神秘禮物音樂');
      
      // 神秘禮物音樂URL
      const mysteriousGiftMusicUrl = 'https://chineseclassics.github.io/files/audio/zhuangzi/credit2.mp4';
      
      // 播放神秘禮物音樂，使用淡入效果
      audioManager.playBackgroundMusic(mysteriousGiftMusicUrl, true, 'mysterious-gift');
      
      console.log('🎵 神秘禮物音樂已開始播放');
    }
    
    // DOM Elements
    const gameContainer = document.getElementById('game-container');
    const mainMenu = document.getElementById('main-menu');
    const gameContent = document.getElementById('game-content');
    const gameUI = document.getElementById('game-ui');
    const chapterTitle = document.getElementById('chapter-title');
    const chapterName = document.getElementById('chapter-name');
    const chapterDescription = document.getElementById('chapter-description');
    const aperturesTracker = document.getElementById('apertures-tracker');
    const dialogBox = document.getElementById('dialog-box');
    const dialogText = document.getElementById('dialog-text');
    const dialogOptions = document.getElementById('dialog-options');
    const advanceBtn = document.getElementById('advance-btn');
    const startGameBtn = document.getElementById('start-game');
    const formButtons = {
      human: document.getElementById('human-form'),
      butterfly: document.getElementById('butterfly-form'),
      fish: document.getElementById('fish-form'),
      kun: document.getElementById('kun-form'),
      peng: document.getElementById('peng-form'),
              yuanchu: document.getElementById('yuanchu-form'),
        chixiao: document.getElementById('chixiao-form'),
      snail: document.getElementById('snail-form'),
      'morning-fungus': document.getElementById('morning-fungus-form'),
      cicada: document.getElementById('cicada-form'),
      'great-chun': document.getElementById('great-chun-form'),
      ant: document.getElementById('ant-form'),
      star: document.getElementById('star-form'),
      qi: document.getElementById('qi-form')
    };
    
    // Game content
    const gameChapters = {
      prologue: {
        title: '第一章：莊周夢蝶',
        description: '誰夢見了誰？',
        background: 'dream-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你在一個奇異的夢境中醒來，周圍是藍紫色的光暈，一隻蝴蝶在你眼前飛舞，彷彿在引領你前行。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '？？？',
            text: '你來了，由夢而生的旅人。我是莊周，你可以叫我莊子。你能來到這裡，說明你的心靈還沒有被俗世完全束縛。',
            options: [
              { 
                text: '這裡是什麼地方？', 
                next: 2,
                traits: { 
                  N: 1,  // 直覺：對抽象概念的好奇
                  E: 1,  // 外向：主動詢問環境
                  P: 1   // 知覺：開放接受新信息
                }
              },
              { 
                text: '您找我有什麼事嗎？', 
                next: 3,
                traits: { 
                  S: 1,  // 感覺：關注具體實用信息
                  T: 1,  // 思考：理性直接的詢問
                  J: 1   // 判斷：希望獲得明確答案
                }
              },
              { 
                text: '我怎麼會在夢境中？', 
                next: 4,
                traits: { 
                  T: 1,   // 思考：理性分析現狀
                  S: 1,   // 感覺：關注具體事實
                  AT: 1   // 執著：對現實的強烈關注
                }
              }
            ]
          },
          // 分支場景：地點詢問路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這裡是夢境與現實的交界，是心靈未被拘束時能到達的地方。在這裡，你將了解一個關於宇宙本源的故事，以及你的使命。',
            nextScene: 5
          },
          // 分支場景：使命詢問路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '確實有一件極其重要的事需要你的幫助。這關係到萬物能否重新獲得自由變換的能力，關係到宇宙的平衡能否恢復。',
            nextScene: 5
          },
          // 分支場景：夢境疑問路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '夢與醒，虛與實，界限本就模糊。重要的不是你如何到這裡，而是你能在這裡學到什麼，能為這個世界做些什麼。',
            nextScene: 5
          },
          // 匯聚場景：混沌背景介紹
          {
            type: 'dialog',
            speaker: '莊子',
            text: '讓我告訴你一個古老的故事。在宇宙的中心，曾經有一位叫做混沌的中央之帝。他沒有七竅，卻能自由自在，是萬物變化的源泉。',
            nextScene: 6
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '混沌的神奇之處在於：他沒有眼耳鼻口，不被感官束縛，因此能夠包容萬物，讓所有生靈都能自由地轉換形態。那時的世界，是真正的「物我不分」。',
            nextScene: 7
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '然而有一天，發生了悲劇。混沌死了，他的七個竅被打開，万物失去了自由轉化的能力。現在，魚只能是魚，鳥只能是鳥，人也只能是人。',
            nextScene: 8
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '更糟糕的是，混沌死時，他的七竅化作七個封印，散落到世界各處。只有重新收集這七個封印，才有可能讓混沌重生，恢復萬物的自由。',
            nextScene: 9
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '在這段旅程中，你會面臨許多選擇。記住，沒有標準答案，也沒有對錯之分。每個選項都是通往智慧的不同路徑，就像山有千條小徑，都能登頂。',
            nextScene: 10
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '重要的是遵從你內心的聲音，選擇最符合你天性的那條路。不要猜測什麼是「正確」答案，因為真正的智慧來自於真實的自己。',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '還有一個小秘密要告訴你——如果你能完整走完這段旅程，收集齊所有的封印，最後會有一份特別的「神秘禮物」等著你。那是我為每一位勇敢的旅人準備的，獨一無二的智慧之書。',
            options: [
              { 
                text: '先弄清楚這件事的前因後果', 
                next: 12,
                traits: { 
                  T: 1,   // 思考：理性分析邏輯
                  J: 1,   // 判斷：明確接受任務
                  IN: 1   // 干預：願意積極參與
                }
              },
              { 
                text: '為什麼是我來做這件事？', 
                next: 13,
                traits: { 
                  T: 1,   // 思考：理性質疑邏輯
                  I: 1,   // 內向：自我反思
                  DI: 1   // 分別：質疑自己的特殊性
                }
              },
              { 
                text: '這聽起來很困難...', 
                next: 14,
                traits: { 
                  S: 1,   // 感覺：關注具體困難
                  I: 1,   // 內向：內心擔憂
                  EQ: 1   // 齊等：承認困難但不拒絕
                }
              }
            ]
          },
          // 分支場景：理性分析路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好的態度！混沌本有七竅，分別對應感官：左目、右目、左耳、右耳、左鼻、右鼻、和口。每個封印都有其特定的隱藏規律，需要對應的感知能力才能發現。這是一個邏輯清晰的系統。',
            nextScene: 15
          },
          // 分支場景：質疑選擇路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '因為你的心還沒有被固化。你能質疑，能思考，還保持著孩子般的好奇心。這正是完成使命所需要的品質——開放、靈活、不被成見束縛。',
            nextScene: 15
          },
          // 分支場景：擔憂困難路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '困難是相對的。當你掌握了「物化之道」後，你會發現世界有無數種可能性。困難往往源於視角的局限，而物化能讓你獲得不同的視角。',
            nextScene: 15
          },
          // 物化機制詳細解釋
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我教你「物化之道」。這是完成使命的核心能力。物化，就是變換形態，以不同生物的視角和能力去體驗世界。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '每種生物都有獨特的感知方式：蝴蝶能看到花朵的細微色彩，魚兒能感受水流的變化，鳥兒能俯瞰大地全貌。物化讓你獲得這些能力。',
            nextScene: 17
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '更重要的是，每個封印都隱藏在特定的情境中，需要對應的生物視角才能發現和收集。人類的感官有限，但物化可以突破這些限制。',
            options: [
              { 
                text: '我準備好學習物化之道了', 
                next: 18,
                traits: { 
                  E: 1,   // 外向：主動表達意願
                  P: 1,   // 知覺：開放接受新體驗
                  WU: 1   // 無為：順應自然之道
                }
              },
              { 
                text: '這聽起來像是魔法...', 
                next: 19,
                traits: { 
                  T: 1,   // 思考：理性質疑
                  S: 1,   // 感覺：基於現實經驗判斷
                  AT: 1   // 執著：堅持既有認知
                }
              },
              { 
                text: '我要如何開始練習？', 
                next: 20,
                traits: { 
                  J: 1,   // 判斷：尋求明確指導
                  S: 1,   // 感覺：關注具體方法
                  US: 1   // 有用：追求實用技能
                }
              }
            ]
          },
          // 分支場景：準備充分路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好的心態！物化之道始於理解古人的智慧。這段古文記錄了我與蝴蝶的相遇，蘊含著變化的奧秘。用心感受其中的韻律。',
            nextScene: 21
          },
          // 分支場景：懷疑魔法路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '不是魔法，而是對本質的認知。萬物本就同源，只是形態不同。當你理解了這個道理，變化就成為可能。就像冰化為水，水化為氣，形態在變，本質不變。',
            nextScene: 21
          },
          // 分支場景：詢問練習路線
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好的問題！物化之道的第一步是理解變化的智慧。古人的文字中蘊含著這種智慧，通過解讀古文，你能感悟到變化的奧秘。',
            nextScene: 21
          },
          // 斷句挑戰場景
          {
            type: 'segmentation-puzzle',
            textStyle: 'dream-text',
            text: '昔者莊周夢為胡蝶栩栩然胡蝶也自喻適志與不知周也俄然覺則蘧蘧然周也',
            solution: [7, 13, 18, 22, 25],
            hint: '這段古文記錄了夢蝶的故事。點擊字符之間的空隙，嘗試正確斷句。感受文字中蘊含的變化智慧...',
            success: '你成功解讀了夢境文字！文字開始發出藍紫色的光芒，圍繞著你旋轉。你感受到了第一次物化能力的覺醒。',
            nextScene: 22
          },
          {
            type: 'narrative',
            text: '當最後一個斷句標記落入正確位置，古文化為流光，環繞你的身體。你感到一股神奇的力量流入體內，這是物化之道的第一次覺醒——你獲得了變化的可能性。',
            nextScene: 23
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你已經掌握了初步的物化能力。現在你可以在人形與蝴蝶之間自由轉換。這只是開始，隨著旅程的深入，你會解鎖更多生物的形態。',
            nextScene: 24
          },
          {
            type: 'form-unlock-guide',
            text: '你感受到一股神秘的力量流入身體，獲得了「蝴蝶」的物化能力！物化按鈕會在遊戲過程中逐漸解鎖。現在點擊物化按鈕，選擇蝴蝶形態來進行第一次物化體驗。',
            effect: 'unlockForm:butterfly',
            highlightForm: 'butterfly',
            nextScene: 25
          },
          {
            type: 'transformation-experience',
            formType: 'butterfly',
            text: '你化身為蝴蝶，感受到了前所未有的輕盈和自由。世界變得色彩斑斕，每一朵花都散發著誘人的香氣。你的翅膀輕輕扇動，就能在空中自由飛舞。在這夢幻般的體驗中，你體會到了「物我兩忘」——你既是人，也是蝶，或者說，你超越了固定形態的束縛。',
            nextScene: 26
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你明白了物化的感覺。記住：每種形態都有其獨特的能力和視角。在接下來的旅程中，善用物化之道，你就能找到散落各處的七竅封印，完成修復混沌的使命。準備好了嗎？我們前往第一個封印所在地——濠梁之上。',
            nextScene: 'chapter1:0'
          }
        ]
      },
      chapter1: {
        title: '第二章：子非魚',
        description: '你怎麼知道魚的快樂？',
        background: 'water-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你來到一座橋上，橋下是碧波蕩漾的濠水。莊子與他的朋友惠子正倚著橋欄交談。陽光照在水面上，閃爍著點點金光。',
            nextScene: 1
          },
          // === 網狀分支結構：基於故事情境的多重交匯 ===
          
          // === 第一個情境選擇點：初遇魚群 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看，那些儵魚在水中游弋，時而聚集成群，時而散開獨游。咦，有條魚游得特別奇怪，一直在打轉。',
            options: [
              { 
                text: '仔細觀察魚的游動軌跡和頻率', 
                next: 2,
                traits: { 
                  T: 1,   // 思考：理性分析行為
                  E: 1,   // 外向：主動靠近觀察
                  EQ: 1   // 齊等：萬物平等關懷
                }
              },
              { 
                text: '觀察整個魚群的反應', 
                next: 3,
                traits: { 
                  T: 1,   // 思考：系統性分析
                  S: 1,   // 感覺：注重具體觀察
                  I: 1    // 內向：靜默觀察模式
                }
              },
              { 
                text: '問莊子是否見過這種現象', 
                next: 4,
                traits: { 
                  E: 1,   // 外向：主動詢問
                  J: 1,   // 判斷：尋求明確解答
                  US: 1   // 有用：追求實用知識
                }
              }
            ]
          },
          
          // === 第一組響應場景 ===
          {
            type: 'narrative',
            text: '你仔細分析魚的游動模式，發現它每次轉圈的半徑都在縮小，頻率也在加快。通過觀察水流和魚的行為，你判斷水底某個位置有異常的磁場或能量吸引著它。',
            nextScene: 5
          },
          {
            type: 'narrative', 
            text: '你觀察整個魚群，發現其他魚都刻意避開那條打轉的魚附近的區域。這種整體的迴避行為很有趣，好像那個地方有什麼特殊之處。',
            nextScene: 5
          },
          {
            type: 'narrative',
            text: '莊子撫摸著鬍鬚：「我確實見過幾次。通常是水底有異物，或是有特殊的氣息。你看其他魚都避開那裡，只有那一條執著地轉圈。」',
            nextScene: 5
          },
          
          // === 第一個交匯點：發現異象 ===
          {
            type: 'dialog',
            speaker: '惠子',
            text: '你們在看什麼？我也來湊湊熱鬧。咦，這條魚的行為確實古怪。會不會水底有什麼東西？',
            options: [
              { 
                text: '制定一個詳細的探索計劃', 
                next: 6,
                traits: { 
                  E: 1,   // 外向：主動行動
                  J: 1,   // 判斷：系統規劃
                  IN: 1   // 干預：積極介入
                }
              },
              { 
                text: '先想想有什麼方法能看清水底', 
                next: 7,
                traits: { 
                  T: 1,   // 思考：理性規劃
                  J: 1,   // 判斷：系統安排
                  US: 1   // 有用：追求有效方法
                }
              },
              { 
                text: '跟惠子一起討論這個現象', 
                next: 8,
                traits: { 
                  E: 1,   // 外向：主動與人討論
                  F: 1,   // 情感：尊重魚的意圖
                  WU: 1   // 無為：順其自然
                }
              }
            ]
          },
          
          // === 第二組響應場景 ===
          {
            type: 'narrative',
            text: '莊子讚許地點頭：「你的規劃思維很縝密！確實需要考慮水深、流速、安全措施...」正當你們討論探索方案時，那條魚突然停止打轉，直直地游向水面，嘴裡竟然銜著一個發光的小物件！',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '惠子點頭：「謀而後動是智者之舉。我們可以用樹枝探探，或者...」正說著，水面突然泛起漣漪，那條魚浮上來了，嘴裡銜著一個閃閃發光的東西！',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '你跟惠子熱烈地討論著魚的行為，惠子提出幾個有趣的觀點，莊子也加入了你們的討論。正當你們三人辯論得起勁時，那條魚忽然浮出水面，嘴裡銜著一個散發藍光的神秘物件！',
            nextScene: 9
          },
          
          // === 第二個交匯點：神秘物件出現 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這是...左目之竅的封印！我們要找的第一個封印竟然被這條魚找到了！但它還在魚嘴裡，我們該怎麼辦？',
            options: [
              { 
                text: '分析魚的行為模式找出規律', 
                next: 10,
                traits: { 
                  T: 1,   // 思考：理性分析行為
                  N: 1,   // 直覺：相信跨物種溝通
                  EQ: 1   // 齊等：萬物平等交流
                }
              },
              { 
                text: '用食物引誘魚兒靠近', 
                next: 11,
                traits: { 
                  T: 1,   // 思考：理性的交換策略
                  S: 1,   // 感覺：基於現實的方法
                  US: 1   // 有用：追求實用效果
                }
              },
              { 
                text: '跟莊子討論該怎麼接近它', 
                next: 12,
                traits: { 
                  P: 1,   // 知覺：開放等待
                  E: 1,   // 外向：主動討論
                  WU: 1   // 無為：順其自然
                }
              }
            ]
          },
          
          // === 第三組響應場景 ===
          {
            type: 'narrative',
            text: '你仔細觀察魚兒的行為，發現它每次轉圈都在特定的時間點停頓。把握住這個規律，你在它停頓的瞬間做出手勢，魚兒似乎理解了你的意圖，主動將封印送到水面。',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '惠子從包裡拿出一些魚食撒向水面。魚兒聞到香味，興奮地游過來，在吃食物時不小心鬆開了嘴，封印漂浮在水面上。',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '你跟莊子討論各種可能的方法，莊子提議用心靈感應，你建議觀察魚的行為規律。在你們探討過程中，魚兒彷彿感受到了這種友善的交流，主動游過來將封印送到橋邊。',
            nextScene: 13
          },
          
          // === 最終匯聚點：發現封印線索 ===
          {
            type: 'narrative',
            text: '封印在水面上發出柔和的藍光，輕飄飄地浮向你們。莊子感嘆道：「看來每個生命都有自己的使命。這條魚為我們指出了左目之竅封印的位置！」封印發出一道光芒指向水底深處，然後消失了。惠子說：「看來我們需要更深入地理解這裡的奧秘才能真正獲得封印。」',
            nextScene: 14
          },
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過你剛才在尋找封印過程中的選擇，我能感受到你內心的智慧正在綻放。每個人面對未知和挑戰的方式都不同，而你的方式很獨特...',
            sceneType: 'personal_analysis',
            context: '濠梁尋封印過程中的行為模式分析',
            nextScene: 15
          },
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看看那水面下的文字，它們包含著關於魚之樂的奧秘。試著解讀它們。',
            nextScene: 16
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'water-text',
            text: '莊子與惠子遊於濠梁之上莊子曰儵魚出遊從容是魚樂也惠子曰子非魚安知魚之樂莊子曰子非我安知我不知魚之樂',
            solution: [10, 13, 19, 23, 26, 29, 34, 37, 40],
            hint: '點擊字符之間的空隙，嘗試正確斷句。莊子和惠子在橋上辯論...',
            success: '你成功解讀了水中文字！字符如水波般流動，逐漸清晰。',
            nextScene: 17
          },
          {
            type: 'narrative',
            text: '當文字解讀完成，一道藍光從水中升起，化作一條銀色的魚。魚兒環繞著你游動，最後停在你面前，彷彿在邀請你進入水中世界。',
            nextScene: 18
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你已獲得儵魚的物化能力。現在你可以潛入水中，體驗魚的視角。',
            nextScene: 19
          },
          {
            type: 'form-unlock-guide',
            text: '一道藍光注入你的身體，你獲得了「儵魚」的物化能力！現在你可以化身為儵魚，潛入水中探索水下世界。請點擊物化按鈕，選擇儵魚形態來體驗魚兒的快樂。',
            effect: 'unlockForm:fish',
            highlightForm: 'fish',
            nextScene: 20
          },
          {
            type: 'transformation-experience',
            formType: 'fish',
            text: '你化身為儵魚，潛入濠水之中。水下世界與陸地截然不同，所有聲音變得沉悶而遙遠，光線也變得朦朧柔和。水流輕撫著你的魚鰭，你能感受到每一絲水波的律動。在這寧靜的水中世界，時間彷彿變得緩慢而悠長，你終於理解了什麼是真正的「魚之樂」。',
            nextScene: 21
          },
          {
            type: 'narrative',
            text: '你在水中遊動時，發現了一道閃爍的光，那是左目之竅的封印！它嵌入在水底的一塊石頭中，發出微弱的藍光。就是之前那條魚為你們指出的位置。',
            nextScene: 22
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是我們尋找的第一個封印——左目之竅！它將封閉你的左眼視覺，讓你不再被外在形象所迷惑。取下它，混沌就能重新封閉第一個竅。',
            nextScene: 23
          },
          {
            type: 'narrative',
            text: '你靠近封印，伸出魚鰭輕觸它。封印立刻發出強烈的藍光，脫離石頭飄向你。當你接觸到它時，一股暖流沿著你的身體流動，你感到視界更加開闊了。',
            effect: 'collectAperture:left-eye',
            nextScene: 24
          },
          // === 第四階段：AI章節總結 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '恭喜你找到了第一個封印！你的左眼之竅已被封閉，不再被單一視角所束縛。混沌的第一個竅得以重新封閉，心中升起內在的清明。',
            nextScene: 25
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '現在你能理解了嗎？每個生命都有自己的感知世界...',
            sceneType: 'chapter_summary',
            context: '第一章深度總結：基於玩家在濠梁尋封印過程中的選擇分析其探索模式（關注細節vs全局觀察vs尋求指導、行動vs謹慎vs尊重邊界、直覺vs實用vs耐心），並運用莊子"魚之樂"智慧為玩家的決策方式、人際互動、面對未知的態度提供個性化的成長建議',
            effect: 'switchToHuman',
            nextScene: 'chapter2:0'
          }
        ]
      },
      chapter2: {
        title: '第三章：北冥有魚',
        description: '魚為何要變成鳥？',
        background: 'cloud-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你來到了北冥之海的邊緣，無盡的海水在你面前延伸至天際。海面平靜如鏡，倒映著天空中飄浮的雲朵，藍與白的色彩交融在一起，難以分辨界限。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '北冥有魚，其名為鯤。鯤之大，不知其幾千里也。這裡的尺度已經超出你的想像了。',
            nextScene: 2
          },
          // === 第一階段：預設分支對話 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '站在這片無垠的海邊，你有什麼感受？',
            options: [
              { 
                text: '和莊子分享這海洋給我的震撼', 
                next: 3,
                traits: { 
                  F: 1,   // 情感：感性的個人感受
                  E: 1,   // 外向：主動分享感受
                  EQ: 1   // 齊等：認識到自己的有限性
                }
              },
              { 
                text: '好奇這海里到底隱藏著什麼奧秘', 
                next: 4,
                traits: { 
                  N: 1,   // 直覺：對未知奧秘的好奇
                  E: 1,   // 外向：主動探索的意願
                  US: 1   // 有用：追求知識和理解
                }
              },
              { 
                text: '感受海風的觸感和海水的氣息', 
                next: 5,
                traits: { 
                  P: 1,   // 知覺：開放的想像力
                  S: 1,   // 感覺：具體的感官體驗
                  WU: 1   // 無為：自然而然的遨遊
                }
              }
            ]
          },
          // === 感受分享分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '謝謝你與我分享內心的震撼。通過分享，你讓這種感受變得更加深刻和真實。你知道嗎？在道的層面，大與小其實沒有絕對的界限。',
            options: [
              { 
                text: '那麼什麼決定了事物的大小？', 
                next: 6, // 匯聚到場景6
                traits: { 
                  philosophical: { wisdom_seeking: 4, idealism: 3, authenticity: 2 },
                  mbti: { thinking: 3, intuition: 3, judging: 2 },
                  story: { curiosity: 4, introspection: 3, independence: 2 }
                }
              },
              { 
                text: '我感受到了某種超越大小的存在', 
                next: 6,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, harmony: 2 },
                  mbti: { intuition: 4, feeling: 3, perceiving: 2 },
                  story: { emotional_depth: 4, creativity: 3, gentleness: 2 }
                }
              },
              { 
                text: '這讓我重新思考什麼是真正重要的', 
                next: 6,
                traits: { 
                  philosophical: { acceptance: 4, compassion: 3, harmony: 2 },
                  mbti: { feeling: 3, thinking: 2, introversion: 3 },
                  story: { introspection: 4, resilience: 3, emotional_depth: 2 }
                }
              }
            ]
          },
          // === 好奇探索分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的好奇心很珍貴！這海中確實藏著巨大的秘密。傳說中有一種魚，大得無法測量，它們能變成鳥飛向天際。你認為這可能嗎？',
            options: [
              { 
                text: '聽起來像神話，但也許有更深的含義', 
                next: 6,
                traits: { 
                  philosophical: { wisdom_seeking: 4, authenticity: 3, acceptance: 2 },
                  mbti: { intuition: 3, thinking: 3, perceiving: 2 },
                  story: { introspection: 4, independence: 3, resilience: 2 }
                }
              },
              { 
                text: '如果真有這樣的生物，一定很壯觀', 
                next: 6,
                traits: { 
                  philosophical: { beauty_appreciation: 4, idealism: 3, harmony: 2 },
                  mbti: { feeling: 3, sensing: 2, perceiving: 3 },
                  story: { creativity: 4, emotional_depth: 3, curiosity: 3 }
                }
              },
              { 
                text: '也許變化本身就是生命的本質', 
                next: 6,
                traits: { 
                  philosophical: { transcendence: 4, compassion: 3, wisdom_seeking: 2 },
                  mbti: { intuition: 4, thinking: 2, perceiving: 3 },
                  story: { emotional_depth: 4, creativity: 3, courage: 2 }
                }
              }
            ]
          },
          // === 感官體驗分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你很懂得用感官體驗當下！海風的鹹味、波浪的聲音、陽光的溫暖，這些具體的感受讓你與這片海洋產生真實的連結。在這種連結中，你會如何存在？',
            options: [
              { 
                text: '像魚一樣在深海中默默游弋', 
                next: 6,
                traits: { 
                  philosophical: { acceptance: 4, harmony: 3, authenticity: 2 },
                  mbti: { introversion: 4, sensing: 2, feeling: 2 },
                  story: { gentleness: 4, introspection: 3, resilience: 2 }
                }
              },
              { 
                text: '能夠自在地在不同境界間轉換', 
                next: 6,
                traits: { 
                  philosophical: { transcendence: 4, compassion: 3, wisdom_seeking: 2 },
                  mbti: { perceiving: 4, intuition: 3, extraversion: 2 },
                  story: { courage: 4, creativity: 3, independence: 2 }
                }
              },
              { 
                text: '既保持魚的純真，又擁有鳥的視野', 
                next: 6,
                traits: { 
                  philosophical: { beauty_appreciation: 4, idealism: 3, harmony: 2 },
                  mbti: { feeling: 3, intuition: 3, perceiving: 2 },
                  story: { emotional_depth: 4, creativity: 3, gentleness: 2 }
                }
              }
            ]
          },
          // === 第一次匯聚和AI個性化回應 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的回答讓我看到了你內心的特質。每個人面對無限時的反應都不同，這正反映了「道」的多樣性。',
            nextScene: 7
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '從你剛才的回應中，我能感受到你的心境和思考方式...',
            sceneType: 'initial_response_analysis',
            context: '北冥海邊初次相遇，基於玩家對無限海洋的反應進行個性化分析',
            nextScene: 8
          },
          // === 第二組分支對話：關於變化的哲學思辨 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我告訴你一個故事。在這片海中，有一種巨大的魚叫做鯤，它大得無法測量。但鯤不滿足於在海中游弋，它渴望化為大鵬，飛向九萬里高空。你覺得這個故事在說什麼？',
            options: [
              { 
                text: '生命總是渴望突破自己的界限', 
                next: 9,
                traits: { 
                  N: 1,   // 直覺：對變化可能性的理解
                  J: 1,   // 判斷：對成長的明確態度
                  IN: 1   // 干預：主動追求突破
                }
              },
              { 
                text: '從邏輯上看，每種形態都有其功能', 
                next: 10,
                traits: { 
                  S: 1,   // 感覺：基於現實的判斷
                  T: 1,   // 思考：理性分析功能
                  EQ: 1   // 齊等：萬物平等的價值觀
                }
              },
              { 
                text: '變化可能帶來更廣闊的視野', 
                next: 11,
                traits: { 
                  N: 1,   // 直覺：對變化潛力的洞察
                  P: 1,   // 知覺：對可能性的開放
                  DT: 1   // 超脫：超越固有形態
                }
              }
            ]
          },
          // === 成長超越分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你理解了生命的渴望！但這裡有個問題：鯤變成鵬後，它還是原來的自己嗎？',
            options: [
              { 
                text: '本質不變，只是表現形式不同', 
                next: 12, // 匯聚到場景12
                traits: { 
                  philosophical: { authenticity: 4, wisdom_seeking: 3, harmony: 2 },
                  mbti: { thinking: 3, sensing: 2, judging: 3 },
                  story: { introspection: 4, resilience: 3, independence: 2 }
                }
              },
              { 
                text: '變化本身就是存在的真諦', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, compassion: 2 },
                  mbti: { intuition: 4, perceiving: 4, thinking: 2 },
                  story: { creativity: 4, emotional_depth: 3, courage: 2 }
                }
              },
              { 
                text: '也許「自己」這個概念就是限制', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, wisdom_seeking: 3, idealism: 2 },
                  mbti: { intuition: 4, thinking: 3, perceiving: 3 },
                  story: { independence: 4, curiosity: 3, courage: 2 }
                }
              }
            ]
          },
          // === 功能分析分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的分析很理性！確實，魚的形態適合水中生存，鳥的形態適合天空飛行。但你有沒有想過，如果鯤一直停留在最適合的功能狀態，它永遠不會發現新的可能性。有時候，超越功能性本身也是一種智慧。',
            options: [
              { 
                text: '也許探索和安定都有其價值', 
                next: 12,
                traits: { 
                  philosophical: { harmony: 4, compassion: 3, wisdom_seeking: 2 },
                  mbti: { feeling: 3, perceiving: 3, thinking: 2 },
                  story: { emotional_depth: 4, gentleness: 3, resilience: 2 }
                }
              },
              { 
                text: '真正的和諧包含著變化的可能', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, beauty_appreciation: 3, acceptance: 2 },
                  mbti: { intuition: 3, thinking: 2, perceiving: 3 },
                  story: { creativity: 4, introspection: 3, emotional_depth: 2 }
                }
              },
              { 
                text: '每種選擇都會帶來不同的人生', 
                next: 12,
                traits: { 
                  philosophical: { acceptance: 4, authenticity: 3, compassion: 2 },
                  mbti: { thinking: 2, perceiving: 4, feeling: 2 },
                  story: { independence: 4, curiosity: 3, resilience: 2 }
                }
              }
            ]
          },
          // === 視野擴展分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看到了變化的價值！確實，從海底到九萬里高空，這樣的視野轉換會帶來完全不同的體驗。但問題是，這種轉換是否值得付出代價？',
            options: [
              { 
                text: '成長總是要付出代價的', 
                next: 12,
                traits: { 
                  philosophical: { wisdom_seeking: 4, acceptance: 3, authenticity: 2 },
                  mbti: { thinking: 3, judging: 3, sensing: 2 },
                  story: { resilience: 4, introspection: 3, courage: 2 }
                }
              },
              { 
                text: '重要的是過程中的體驗', 
                next: 12,
                traits: { 
                  philosophical: { beauty_appreciation: 4, compassion: 3, harmony: 2 },
                  mbti: { perceiving: 4, feeling: 3, sensing: 2 },
                  story: { emotional_depth: 4, gentleness: 3, creativity: 2 }
                }
              },
              { 
                text: '也許得失本身就是一種執著', 
                next: 12,
                traits: { 
                  philosophical: { transcendence: 4, wisdom_seeking: 3, acceptance: 2 },
                  mbti: { intuition: 4, thinking: 3, perceiving: 3 },
                  story: { independence: 4, introspection: 3, curiosity: 2 }
                }
              }
            ]
          },
          // === 第二次AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '你對變化和存在的理解展現了獨特的智慧...',
            sceneType: 'transformation_philosophy_analysis',
            context: '關於鯤鵬變化的哲學思辨，基於玩家對變化、成長、本質的理解',
            nextScene: 13
          },
          // === 第三組分支對話：行動與選擇 ===
          {
            type: 'dialog',
            speaker: '莊子',  
            text: '海風吹來，你聽到遠處傳來一陣奇異的聲音，像是巨大生物的呼吸聲。那聲音時而低沉如海浪，時而高亢如鳥鳴。',
            options: [
              {
                text: '想要找到聲音的來源', 
                next: 14,
                traits: { 
                  E: 1,   // 外向：主動探索的行動
                  T: 1,   // 思考：理性的尋因方式
                  US: 1   // 有用：追求具體的答案
                }
              },
              {
                text: '安靜聆聽，試圖理解其含義', 
                next: 15,
                traits: { 
                  I: 1,   // 內向：內省的聆聽方式
                  N: 1,   // 直覺：對深層含義的感知
                  WU: 1   // 無為：順其自然的接受
                }
              },
              {
                text: '跟莊子分享這聲音帶來的感受', 
                next: 16,
                traits: { 
                  F: 1,   // 情感：以情感回應聲音
                  E: 1,   // 外向：主動分享感受
                  EQ: 1   // 齊等：與萬物和諧共鳴
                }
              }
            ]
          },
          // === 探索尋找分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你的探索精神很可貴。但有時候，我們想要找到的東西，可能並不在我們預期的地方。',
            nextScene: 17
          },
          // === 安靜聆聽分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你選擇了聆聽，這顯示了智慧。在這種靜默中，你能聽到的不只是聲音，還有聲音背後的故事。',
            nextScene: 17
          },
          // === 內心共鳴分支 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你願意分享內心的感受，這很珍貴。通過分享，你讓我也能更深地理解這聲音的意義。這種交流讓智慧在我們之間流動。',
            nextScene: 17
          },
          // === 第三次匯聚和AI個性化回應 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '無論你選擇什麼方式回應，都反映了你獨特的感知世界的方式。現在，我要告訴你一個重要的秘密。',
            nextScene: 18
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過我們的對話，我看到了你心中的特質...',
            sceneType: 'comprehensive_personality_analysis',
            context: '基於所有對話選擇的綜合個性分析，準備引入封印任務',
            nextScene: 19
          },
          // === 巧妙融入封印任務 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你知道嗎？混沌本是無形無相的存在，卻能讓萬物自由轉換形態。鯤變鵬的能力，正是混沌賦予的禮物。',
            nextScene: 20
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '但自從混沌失去七竅，這種轉換之力就被封印在天地之間。要重新獲得這種力量，我們必須找到封印在北冥深處的右目之竅。',
            nextScene: 21
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '傳說中，右目之竅隱藏在鯤鵬變化的奧秘中。只有真正理解變化之道的人，才能破解這個秘密。',
            nextScene: 22
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看，天空中的雲朵開始聚集，它們帶來了古老的文字。這些文字記載著鯤鵬變化的心法，解讀它們，你就能獲得接近封印的力量。',
            nextScene: 23
          },
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'segmentation-puzzle',
            textStyle: 'cloud-text',
            text: '北冥有魚其名為鯤鯤之大不知其幾千里也化而為鳥其名為鵬鵬之背不知其幾千里也怒而飛其翼若垂天之雲',
            solution: [3, 7, 10, 17, 21, 25, 28, 35, 38],
            hint: '點擊字符之間的空隙，嘗試正確斷句。北冥有一種大魚...',
            success: '你成功解讀了雲中文字！文字開始發出青色光芒，在雲海中騰起。一股雄渾的力量似乎呼喚著你的靈魂。',
            nextScene: 24
          },
          {
            type: 'narrative',
            text: '雲中文字解讀完成後，一股奇異的能量從天而降，你感到身體輕盈起來，同時又充滿力量。海面上出現了巨大的漩渦，似乎在邀請你進入。',
            nextScene: 25
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！鯤鵬之變需要你親身體驗，才能理解大小相對的奧妙。',
            nextScene: 26
          },
          {
            type: 'form-unlock-guide',
            text: '一股雄渾的力量從雲海中注入你的身體，你獲得了「鯤」的物化能力！現在你可以化身為千里之鯤，在北冥之海中自由遨遊。請點擊物化按鈕，選擇鯤形態來體驗巨大的力量。',
            effect: 'unlockForm:kun',
            highlightForm: 'kun',
            nextScene: 27
          },
          {
            type: 'transformation-experience',
            formType: 'kun',
            text: '你的身體開始膨脹，化為千里之鯤。巨大的魚身讓你能夠感受到海水的每一處細節。你游入漩渦，在北冥的深處暢遊，感受著前所未有的自由。作為鯤，整個海洋都是你的領域，千里之距不過是一個轉身。你體會到了什麼叫做真正的「大」——不是體積的大，而是心境的無限廣闊。',
            nextScene: 28
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '感受到了嗎？當你成為鯤，千里之距不過是一躍。現在試著變化為鵬，體驗天空的廣闊。',
            nextScene: 29
          },
          {
            type: 'form-unlock-guide',
            text: '鯤鵬變化的力量在你體內覺醒，你獲得了「鵬」的物化能力！現在你可以從千里之鯤變化為九萬里之鵬，翱翔於天際。請點擊物化按鈕，選擇鵬形態來體驗天空的廣闊。',
            effect: 'unlockForm:peng',
            highlightForm: 'peng',
            nextScene: 30
          },
          {
            type: 'transformation-experience',
            formType: 'peng',
            text: '你從海中躍起，身體再次變化，化為巨大的鵬鳥。你的翅膀展開，寬達九萬里，像巨大的雲層垂掛在天空。你飛向高空，俯瞰下方的北冥，海洋變得如同一灘小水窪。在這九萬里的高空中，你感受到了絕對的自由——沒有束縛，沒有界限，只有無盡的天空和你展翅翱翔的身影。這就是鵬的視角：超越一切，俯視萬物。',
            nextScene: 31
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '從這高度看去，世間萬物皆如微塵。大與小原是相對的概念，超越了大小的界限，才能真正獲得自由。',
            nextScene: 32
          },
          {
            type: 'narrative',
            text: '當你翱翔在九萬里高空，發現了一道耀眼的光，那光芒凝聚成右目之竅的封印！它懸浮在雲層之上，散發著清澈的青光。',
            nextScene: 33
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是第二個封印——右目之竅！它將封閉你對大小分別的執著，讓你回歸萬物平等的本源。取下它，你將超越分別心的束縛。',
            nextScene: 34
          },
          {
            type: 'narrative',
            text: '你展翅飛向封印，用翎羽輕輕碰觸它。封印立刻發出璀璨的青光，朝你飛來。當它與你接觸的那一刻，你感到右眼的分別心逐漸消融，不再執著於大小差異，心中升起一種平等寧靜的感受。',
            effect: 'collectAperture:right-eye',
            nextScene: 35
          },
          // === 第四階段：AI章節總結 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '恭喜你找到了第二個封印！你的右眼之竅已被封閉，不再被大小分別所束縛。混沌正在逐漸回歸無分別的原初狀態。',
            nextScene: 36
          },
          {
            type: 'narrative',
            text: '第二章完成！你已經收集了右目之竅的封印，並掌握了鯤鵬變化的能力，能夠自由轉換於千里之鯤和九萬里之鵬，理解了大小相對的奧妙。',
            nextScene: 37
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '通過北冥的體驗，你對變化和超越有了更深的理解...',
            sceneType: 'chapter_summary',
            context: '第二章深度總結：基於玩家在鯤鵬變化中的選擇分析其變化適應力、成長追求、視野格局，並運用莊子"逍遙遊"智慧為玩家未來的個人發展、生活轉變、自我突破提供個性化的策略建議和成長指導',
            effect: 'switchToHuman',
            nextScene: 'chapter3:0'
          }
        ]
      },
      chapter3: {
        title: '第四章：鴟得腐鼠',
        description: '腐鼠是什麼滋味？',
        background: 'forest-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你來到了一片茂密的森林，高大的梧桐樹散佈其間，斑駁的陽光透過樹葉間的縫隙灑落在地面上。你看到莊子站在一棵梧桐樹下，若有所思地觀察著在樹枝間飛舞的鳥兒。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看，樹上有一隻鵷鶵和一隻鴟鴞，牠們的價值觀截然不同。鵷鶵是鳳凰一族，愛好潔淨，非梧桐不止，非練實不食，非醴泉不飲。而鴟鴞在夜晚活動，以腐鼠為美食，有著完全不同的生存智慧。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '你抬頭望去，看見兩隻鳥停在樹枝上。一隻是色彩絢麗、羽毛如彩霞般的鵷鶵，散發著聖潔光芒；另一隻則是有著夜視能力的鴟鴞，正靜靜地凝視著一隻死老鼠。鵷鶵優雅地轉過頭去，而鴟鴞的眼中閃爍著黃金般的光芒。',
            nextScene: 3
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我們聆聽牠們的對話。若要獲得這兩種神鳥的物化能力，你需要理解並解讀樹葉間的文字。',
            nextScene: 4
          },
          {
            type: 'narrative',
            text: '你凝視著梧桐樹的枝葉，陽光穿過葉隙在地面投下斑駁的光影，形成文字的形狀。這些文字隨著微風輕輕擺動，似乎在訴說著什麼故事。',
            nextScene: 5
          },
          
          // === 第一階段：預設分支對話開始 ===
          {
            type: 'narrative',
            text: '微風吹過，樹葉發出輕柔的沙沙聲。你感覺整個森林都在靜靜地觀察著你，等待著你的選擇。在這寧靜的時刻，你的內心似乎也在經歷著某種微妙的變化。',
            nextScene: 6
          },
          {
            type: 'narrative',
            text: '突然，一陣微風吹過，幾片梧桐葉子飄落在你周圍。一片落在你肩膀上，一片掉在不遠處的泉水中激起漣漪，還有一片剛好落在一朵白色小花上面。',
            options: [
              { 
                text: '輕輕拿起肩膀上的葉子，欣賞它的紋理和色彩', 
                next: 7, 
                traits: { 
                  philosophical: { beauty_appreciation: 4, mindfulness: 3, harmony: 2 },
                  mbti: { sensing: 4, feeling: 3, perceiving: 2 },
                  story: { aesthetic_sensitivity: 4, wonder_capacity: 3, emotional_depth: 2 }
                }
              },
              { 
                text: '走到泉水邊，看著落葉在水中慢慢下沉', 
                next: 8, 
                traits: { 
                  philosophical: { acceptance: 4, transcendence: 3, wisdom_seeking: 2 },
                  mbti: { introversion: 4, intuition: 3, feeling: 2 },
                  story: { contemplative_preference: 4, inner_peace: 3, depth_seeking: 2 }
                }
              },
              { 
                text: '蹲下來觀察被葉子覆蓋的小花', 
                next: 9, 
                traits: { 
                  philosophical: { compassion: 4, wisdom_seeking: 3, mindfulness: 2 },
                  mbti: { sensing: 4, feeling: 3, introversion: 2 },
                  story: { intellectual_curiosity: 4, gentleness: 3, balance_seeking: 2 }
                }
              }
            ]
          },
          
          // 分支場景：欣賞葉子路線
          {
            type: 'narrative',
            text: '你輕輕拿起葉子，細細觀察它精緻的葉脈和漸變的色彩。這片梧桐葉雖然已經離開了枝頭，但它的美麗依然令人驚嘆。莊子在旁邊微笑著點頭，似乎很欣賞你對美的敏感。',
            nextScene: 10
          },
          
          // 分支場景：觀察泉水路線
          {
            type: 'narrative',
            text: '你走到泉水邊，看著那片葉子在清澈的水中慢慢沉向水底。水中的漣漪逐漸平息，葉子沉入水底，靜靜地躺在那裡。莊子走到你身邊，若有所思地看著水中的葉子。',
            nextScene: 10
          },
          
          // 分支場景：觀察小花路線
          {
            type: 'narrative',
            text: '你蹲下來仔細觀察那朵被葉子遮蓋的小花。當你輕輕移開葉子時，發現花朵並沒有因為被遮蓋而失去生機，反而在這種保護下顯得更加嬌嫩。你意識到，有時候覆蓋也是一種守護。',
            nextScene: 10
          },
          
          // 第二個分支點：面對鳥兒的行為
          {
            type: 'narrative',
            text: '這時，你注意到樹上的鵷鶵和鴟鴞有了新的動作。鵷鶵優雅地飛向一朵盛開的花朵，輕啄著花蜜；而鴟鴞卻悄悄接近樹根附近的一隻死老鼠，準備享用它的「美食」。兩種截然不同的選擇在你眼前同時上演。',
            nextScene: 11
          },
          {
            type: 'narrative',
            text: '就在這時，鴟鴞發現了死老鼠，正要俯衝下去。鵷鶵注意到了，發出一聲清脆的鳥鳴，似乎在表達什麼。而你剛好站在它們中間，兩隻鳥都看向了你，彷彿在等待你的反應。',
            options: [
              { 
                text: '微笑著點頭，示意鵷鶵繼續享用花蜜', 
                next: 12, 
                traits: { 
                  F: 1,   // 情感：對美好事物的情感回應
                  E: 1,   // 外向：主動表達鼓勵態度
                  DI: 1   // 分別：偏愛純潔美好的選擇
                }
              },
              { 
                text: '保持安靜，不干擾任何一隻鳥的行為', 
                next: 13, 
                traits: { 
                  I: 1,   // 內向：安靜的觀察模式
                  P: 1,   // 知覺：開放接受不同選擇
                  EQ: 1   // 齊等：不偏不倚的平等態度
                }
              },
              { 
                text: '好奇地觀察兩隻鳥的互動，想了解更多', 
                next: 14, 
                traits: { 
                  N: 1,   // 直覺：對深層互動模式的洞察
                  E: 1,   // 外向：主動的觀察探索
                  US: 1   // 有用：追求理解和知識
                }
              }
            ]
          },
          
          // 分支場景：鼓勵鵷鶵路線
          {
            type: 'narrative',
            text: '看到你的鼓勵，鵷鶵似乎更加自信地飛向花朵，優雅地享用著花蜜。它偶爾回頭看你，眼中閃爍著某種神采。莊子在一旁觀察著這一切，微微點頭。',
            nextScene: 15
          },
          
          // 分支場景：不干擾路線
          {
            type: 'narrative',
            text: '你選擇安靜地站在原地，既不偏向鵷鶵，也不阻止鴟鴞。兩隻鳥似乎感受到了你的中立態度，各自安心地進行著自己的活動。森林中的平衡在這一刻顯得特別和諧。',
            nextScene: 15
          },
          
          // 分支場景：好奇觀察路線
          {
            type: 'narrative',
            text: '你仔細觀察著兩隻鳥的行為，注意到它們各自的動作、表情、甚至是呼吸的節奏。你發現，無論是鵷鶵的優雅還是鴟鴞的專注，都有著各自的生命智慧。這種觀察讓你對生命有了更深的理解。',
            nextScene: 15
          },
          
          // 第三個分支點：深度哲學思辨
          {
            type: 'narrative',
            text: '森林中突然響起了其他動物的聲音：蟋蟀的鳴叫、松鼠的跳躍聲、遠處狼嚎的回響。生命的交響樂在這片林地中奏響，每種聲音都代表著不同的生存方式和價值觀。',
            nextScene: 16
          },
          {
            type: 'narrative',
            text: '一隻松鼠突然從樹上跳下來，在你腳邊找尋果實。同時，一隻蝴蝶輕盈地在花叢中飛舞，而遠處傳來了夜鶯的歌聲。三種不同的生命節拍在你周圍展現。',
            options: [
              { 
                text: '蹲下來想把手中的果子分給松鼠', 
                next: 17, 
                traits: { 
                  F: 1,   // 情感：對小動物的同理心
                  E: 1,   // 外向：主動的關懷行動
                  IN: 1   // 干預：主動介入幫助他人
                }
              },
              { 
                text: '安靜地跟隨蝴蝶的飛行軌跡，想看它會去哪裡', 
                next: 18, 
                traits: { 
                  N: 1,   // 直覺：對美好事物的好奇探索
                  I: 1,   // 內向：安靜的跟隨方式
                  WU: 1   // 無為：順其自然的跟隨
                }
              },
              { 
                text: '停下腳步，仔細聆聽夜鶯的歌聲', 
                next: 19, 
                traits: { 
                  I: 1,   // 內向：內省的聆聽模式
                  F: 1,   // 情感：對美聲的情感感受
                  UN: 1   // 無用：純粹的美學體驗
                }
              }
            ]
          },
          
          // 分支場景：分享果子路線
          {
            type: 'narrative',
            text: '松鼠停下來看著你，似乎理解了你的善意。它小心翼翼地接近，最終接受了你的果子。在這個分享的瞬間，你感受到了一種跨越物種的溫暖連結。莊子在一旁輕聲說：「萬物皆有靈性。」',
            nextScene: 20
          },
          
          // 分支場景：智慧探索路線
          {
            type: 'narrative',
            text: '你開始思考每種動物獨特的生存智慧：狼的團結協作，鳥兒的自由翱翔，昆蟲的精密組織。也許真正的智慧不是某種固定的知識，而是能夠適應不同環境、發揮不同特質的能力。',
            nextScene: 20
          },
          
          // 分支場景：存在探索路線
          {
            type: 'narrative',
            text: '你凝視著森林的深處，思考著生死的邊界在哪裡。那些看似死去的落葉正在滋養新的生命，那些看似永恆的大樹也終將歸於塵土。存在和不存在之間，似乎有著某種微妙的循環。',
            nextScene: 20
          },
          
          // 第四個分支點：生命態度的選擇
          {
            type: 'narrative',
            text: '夜幕降臨，森林變得更加神秘。你注意到一隻蛾子正撲向燈火，一隻螢火蟲在樹葉間安靜地發光，還有一隻蝙蝠在黑暗中自在地飛翔。三種不同的夜行生物，三種不同的生存哲學。',
            nextScene: 21
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看這三種夜晚的生靈，如果你要選擇一種生活方式，你會選擇哪一種？',
            options: [
              { 
                text: '像蛾子一樣，為了理想燃燒自己', 
                next: 22, 
                traits: { 
                  F: 1,   // 情感：理想驅動的情感投入
                  J: 1,   // 判斷：對理想的明確追求
                  AT: 1   // 執著：對理想的執著堅持
                }
              },
              { 
                text: '像螢火蟲一樣，安靜地散發自己的光芒', 
                next: 23, 
                traits: { 
                  I: 1,   // 內向：內在的溫和力量
                  P: 1,   // 知覺：自然而然的展現
                  WU: 1   // 無為：無為而治的智慧
                }
              },
              { 
                text: '像蝙蝠一樣，在黑暗中找到自己的道路', 
                next: 24, 
                traits: { 
                  T: 1,   // 思考：理性的導航方式
                  P: 1,   // 知覺：靈活的適應能力
                  DT: 1   // 超脫：超越常規的生存智慧
                }
              }
            ]
          },
          
          // 分支場景：激情理想路線
          {
            type: 'narrative',
            text: '你被蛾子的熱情感動了。它明知燈火會傷害自己，卻仍然義無反顧地飛向光明。這種為了理想而不惜一切的精神，既令人敬佩，也令人深思。',
            nextScene: 25
          },
          
          // 分支場景：溫和智慧路線
          {
            type: 'narrative',
            text: '你選擇了螢火蟲的方式。它不需要外在的光源，而是從內心散發出溫柔的光芒，既照亮了自己，也照亮了他人。這種內在的力量，或許是最持久的智慧。',
            nextScene: 25
          },
          
          // 分支場景：獨立適應路線
          {
            type: 'narrative',
            text: '你欣賞蝙蝠的生存智慧。它不依賴視覺，而是用聲波導航，在完全的黑暗中也能自由飛翔。這種獨特的感知能力，讓它在夜晚的世界中游刃有餘。',
            nextScene: 25
          },
          
          // 第五個分支點：最終的哲學思辨
          {
            type: 'narrative',
            text: '突然間，森林中響起了一陣奇特的樂音。你環顧四周，發現是風吹過不同樹木的聲音：梧桐發出空靈的響聲，松樹發出低沉的吟唱，竹子發出清脆的節拍。大自然正在演奏一曲無聲的交響樂。',
            nextScene: 26
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '聽到了嗎？每種植物都在用自己的方式歌唱。如果要你為這場自然交響樂選擇一個主題，你會選擇什麼？',
            options: [
              { 
                text: '和諧共存：每種聲音都有其價值', 
                next: 27, 
                traits: { 
                  F: 1,   // 情感：重視和諧的情感價值
                  P: 1,   // 知覺：接受多元聲音的開放性
                  EQ: 1   // 齊等：萬物平等的價值觀
                }
              },
              { 
                text: '自然之美：追求最純粹的美感', 
                next: 28, 
                traits: { 
                  N: 1,   // 直覺：對美的直覺感知
                  F: 1,   // 情感：審美的情感體驗
                  UN: 1   // 無用：純粹美感的無功利性
                }
              },
              { 
                text: '生命律動：感受存在的本質節拍', 
                next: 29, 
                traits: { 
                  N: 1,   // 直覺：對本質的深層洞察
                  I: 1,   // 內向：內在的深度感受
                  DT: 1   // 超脫：超越表象的哲學思考
                }
              }
            ]
          },
          
          // 分支場景：和諧共存路線
          {
            type: 'narrative',
            text: '你聽出了森林交響樂中的和諧之美。每一種聲音都不是孤立存在的，而是與其他聲音形成複雜而美妙的共鳴。這讓你想到了莊子所說的"萬物並育而不相害"。',
            nextScene: 30
          },
          
          // 分支場景：自然美學路線
          {
            type: 'narrative',
            text: '你被這自然音樂的純粹之美深深震撼。沒有人工的雕琢，沒有刻意的安排，一切都是那麼自然而然，卻又如此動人心弦。這或許就是真正的藝術境界。',
            nextScene: 30
          },
          
          // 分支場景：存在律動路線
          {
            type: 'narrative',
            text: '你感受到了生命的根本律動。每一個聲音都在訴說著存在的故事，從生長到死亡，從寂靜到喧嘩，這是宇宙最原始的節拍，是存在本身的呼吸。',
            nextScene: 30
          },
          
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過剛才的五次選擇，我看到了你內心真正的傾向...',
            sceneType: 'choice_reflection',
            context: '第三章選擇反思：針對玩家五次具體選擇行為的即時分析，重點解讀選擇背後的哲學傾向，並為即將到來的鵷鶵和鴟鴞物化體驗做心理準備',
            nextScene: 31
          },
          
          // === 第三階段：標準遊戲流程開始 ===
          {
            type: 'narrative',
            text: '森林逐漸安靜下來，月光透過樹葉灑在地面上，形成神秘的光影圖案。在這寧靜中，你開始聽到樹上鵷鶵和鴟鴞之間的對話聲。',
            nextScene: 32
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在讓我們聆聽牠們的對話。若要獲得這兩種神鳥的物化能力，你需要理解並解讀樹葉間浮現的古老文字。',
            nextScene: 33
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'leaf-text',
            text: '惠子相梁莊子往見之或謂惠子曰莊子來欲代子相於是惠子恐搜於國中三日三夜莊子往見之曰南方有鳥其名為鵷鶵子知之乎',
            solution: [3, 8, 13, 16, 20, 25, 33, 38, 39, 43, 48],
            hint: '點擊字符之間的空隙，嘗試正確斷句。這段文字講述了惠子擔心莊子來取代他的位置...',
            success: '你成功解讀了樹葉間的文字！文字開始發出綠色光芒，圍繞著你旋轉。光線凝聚成兩種鳥的形態——純白的鵷鶵和褐色的鴟。',
            nextScene: 34
          },
          {
            type: 'narrative',
            text: '隨著最後一個斷句標記落入正確位置，文字化為綠色流光，在空中形成鳥的形態。一道光芒注入你的體內，你感到一股新的力量在體內流淌。',
            nextScene: 35
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！現在你已獲得兩種神鳥的物化能力。你可以分別化身為高潔的鵷鶵和夜行的鴟鴞，體驗截然不同的世界觀。',
            nextScene: 36
          },
          {
            type: 'form-unlock-guide',
            text: '綠色的流光注入你的身體，首先化為一道金色的神光！你獲得了聖潔鵷鶵的物化能力。鵷鶵是鳳凰一族，喜愛純淨，以甘露為飲食。請點擊鵷鶵按鈕，體驗這種高潔的存在方式。',
            effect: 'unlockForm:yuanchu',
            highlightForm: 'yuanchu',
            nextScene: 37
          },
          {
            type: 'transformation-experience',
            formType: 'yuanchu',
            text: '你化身為聖潔的鵷鶵，瞬間感受到世界的純淨之美。一切都呈現出水晶般透明的光澤，空氣中瀰漫著蓮花的芬芳。作為鵷鶵，你只能被純淨的事物所吸引——清澈的泉水、盛開的花朵、新鮮的果實。任何腐朽或污濁的東西都讓你感到不適。在這純淨的視角下，世界如同天堂般美好，只有最潔淨的事物才值得你的關注。',
            nextScene: 38
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '感受到了嗎？鵷鶵的世界是如此純淨高潔。但這只是一個視角。現在讓我們體驗另一種截然不同的存在方式。',
            nextScene: 39
          },
          {
            type: 'form-unlock-guide',
            text: '第二道神光——深紫色的夜光注入你的身體！你獲得了夜行鴟鴞的物化能力。鴟鴞在夜晚活動，擁有敏銳的夜視能力，以腐鼠為珍貴食物。請點擊鴟鴞按鈕，體驗這種夜行者的生存智慧。',
            effect: 'unlockForm:chixiao',
            highlightForm: 'chixiao',
            nextScene: 40
          },
          {
            type: 'transformation-experience',
            formType: 'chixiao',
            text: '你化身為夜行的鴟鴞，視角瞬間改變。黑暗對你來說不再是障礙，而是最好的掩護。你的金色眼睛能看穿夜晚的秘密，腐朽的氣味對你來說不是厭惡，而是珍貴食物的信號。在夜視模式下，你能清晰地看到其他生物無法察覺的細節，腐鼠散發的氣味就像香甜的蜜糖。這就是鴟鴞的生存智慧——在別人眼中的污穢，是你眼中的珍寶。',
            nextScene: 41
          },
          {
            type: 'narrative',
            text: '你已經分別體驗了兩種截然不同的存在方式。通過鵷鶵的純淨視角和鴟鴞的夜視能力，你開始理解價值觀的相對性——同樣的世界，不同的視角會帶來完全不同的認知和價值判斷。',
            nextScene: 42
          },
          
          // === 第四階段：封印收集開始 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你理解了萬物視角的相對性。無論以哪種形態體驗世界，都有其獨特的智慧和價值。在梧桐樹的高處，你會發現左耳之竅的封印。',
            nextScene: 43
          },
          {
            type: 'narrative',
            text: '你展翅飛向梧桐樹的頂端，在茂密的枝葉間，你發現了一道閃爍的光芒——那是左耳之竅的封印！它懸浮在空中，散發著溫暖的綠光。',
            nextScene: 44
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是第三個封印——左耳之竅！它將封閉你的左耳聽聞，讓你不再被外聲所擾。取下它，混沌就能重新封閉第三個竅，回歸內在的純然寧靜。',
            nextScene: 45
          },
          {
            type: 'narrative',
            text: '你飛近封印，伸出翅膀輕觸它。封印立刻發出璀璨的綠光，朝你飛來。當它與你接觸的那一刻，你感到左耳的聽聞執著逐漸消散，外界的繁雜聲音不再擾亂內心，心中升起一種純然的寧靜。',
            effect: 'collectAperture:left-ear',
            nextScene: 46
          },
          
          // === 第五階段：AI章節總結 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '恭喜你找到了第三個封印！你的左耳之竅已被封閉，不再被外界聲音所擾亂。混沌的第三個竅得以重新封閉，內心回歸更深的寧靜。',
            nextScene: 47
          },
          {
            type: 'narrative',
            text: '第三章即將結束！你已經收集了左耳之竅的封印，並掌握了兩種神鳥的物化能力：聖潔的鵷鶵和夜行的鴟鴞。通過五次深度的哲學選擇和兩種截然不同的存在體驗，你對價值觀的相對性有了深刻理解。',
            nextScene: 48
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在這片梧桐森林中，你的哲學之旅又進了一步...',
            sceneType: 'chapter_summary',
            context: '第三章深度總結：基於玩家五次分支選擇分析其價值觀包容度、美學傾向、生命態度，並運用莊子"價值相對性"智慧為玩家未來的人際分歧處理、多元觀點接納、合作相處方式提供個性化的成長建議和生活智慧',
            effect: 'switchToHuman',
            nextScene: 'chapter4:0'
          }
        ]
      },
      
      chapter4: {
        title: '第五章：蝸角之爭',
        description: '誰活在蝸牛角上？',
        background: 'spiral-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你跟隨莊子的身影，來到一片奇異的螺旋空間。這裡彌漫著紫色的光暈，空氣中迴盪著微弱的戰鼓聲和喊殺聲。莊子指向前方一個龐大身影——一隻巨大的蝸牛！',
            nextScene: 1
          },
          
          // === 網狀分支結構：基於蝸角戰爭的故事情境 ===
          
          // === 第一個情境選擇點：初遇戰爭場面 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你聽到了嗎？這戰鼓聲來自蝸牛的觸角上！左角是觸氏國，右角是蠻氏國，兩國正在激烈交戰。突然，一個信使從左角急急跑來，似乎在尋求支援。',
            options: [
              { 
                text: '快步走向那個慌張的信使', 
                next: 2,
                traits: { 
                  E: 1,   // 外向：主動接觸信使
                  F: 1,   // 情感：關心戰況和民眾
                  IN: 1   // 干預：立即行動介入
                }
              },
              { 
                text: '退到高處，俯瞰整個蝸角戰場', 
                next: 3,
                traits: { 
                  I: 1,   // 內向：安靜的觀察模式
                  T: 1,   // 思考：理性分析戰場
                  WU: 1   // 無為：先觀察再行動
                }
              },
              { 
                text: '靜心聆聽莊子講述戰爭的來龍去脈', 
                next: 4,
                traits: { 
                  N: 1,   // 直覺：洞察戰爭本質
                  T: 1,   // 思考：尋求理性解釋
                  UN: 1   // 無用：探索深層原因而非直接行動
                }
              }
            ]
          },
          
          // === 第一組響應場景 ===
          {
            type: 'narrative',
            text: '你快步走向那個慌張的信使。他氣喘吁吁地說：「敵軍又奪取了我們的三個村莊！他們說我們侵犯了他們的祖地，但那明明是我們世代耕種的土地！」信使眼中滿含憤怒和絕望。',
            nextScene: 5
          },
          {
            type: 'narrative',
            text: '你退到高處，俯瞰整個蝸角戰場。驚人的是，兩國的士兵看起來幾乎一模一樣，連武器和戰術都相似。區別只在於左角的士兵帶紅色標記，右角的帶藍色標記。',
            nextScene: 5
          },
          {
            type: 'narrative',
            text: '莊子撫摸著鬍鬚：「這場戰爭起源於一場邊界糾紛。兩國都聲稱某塊土地是自己的，都有各自的歷史記錄和正當理由。戰爭越打越激烈，原本的爭議早已被仇恨取代。」',
            nextScene: 5
          },
          
          // === 第一個交匯點：戰爭真相的思考 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '此時，右角的蠻氏國也派來一個使者，他控訴觸氏國是侵略者。兩個使者在你面前激烈爭辯，都堅持自己是受害者。你該如何應對？',
            options: [
              { 
                text: '伸手示意，請兩位使者各自道出心中苦楚', 
                next: 6,
                traits: { 
                  E: 1,   // 外向：主動調解衝突
                  F: 1,   // 情感：以和諧為重
                  IN: 1   // 干預：積極介入調解
                }
              },
              { 
                text: '靜靜聽完雙方的話，在心中權衡是非', 
                next: 7,
                traits: { 
                  T: 1,   // 思考：理性分析雙方觀點
                  J: 1,   // 判斷：尋求公正的判斷
                  EQ: 1   // 齊等：平等對待雙方
                }
              },
              { 
                text: '提議放下刀兵，共尋一條兩全之路', 
                next: 8,
                traits: { 
                  J: 1,   // 判斷：明確的解決方案
                  T: 1,   // 思考：理性的合作方式
                  US: 1   // 有用：追求實際解決效果
                }
              }
            ]
          },
          
          // === 第二組響應場景 ===
          {
            type: 'narrative',
            text: '你耐心地讓兩個使者輪流發言，試圖化解他們的敵意。然而，你發現一個有趣的現象：當他們不再互相指責時，各自的故事竟然有許多相似之處——都談到了家園、傳統和生存的恐懼。',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '你專注地聽取雙方的訴求，記錄下每個細節。觸氏國說那是他們的祖地，蠻氏國說那是他們的聖地。但你漸漸意識到，他們爭奪的「土地」在蝸牛角上也就巴掌大小。',
            nextScene: 9
          },
          {
            type: 'narrative',
            text: '你提出暫停戰爭的建議，兩個使者都沉默了。過了一會兒，蠻氏使者說：「戰爭已經進行太久，很多人忘記了最初為什麼要打。」觸氏使者點頭：「我們的孩子只知道仇恨，不知道和平。」',
            nextScene: 9
          },
          
          // === 第二個交匯點：視角轉換的關鍵時刻 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這時，蝸牛忽然緩緩移動，兩國的士兵都因為「大地震動」而暫停了戰鬥。在這短暫的寧靜中，你聽到有人問：「我們到底在為什麼而戰？」面對這個關鍵時刻，你會怎麼做？',
            options: [
              { 
                text: '告訴他們這場戰爭在更大視角下是多麼微小', 
                next: 10,
                traits: { 
                  N: 1,   // 直覺：洞察宏觀視角
                  T: 1,   // 思考：理性分析規模
                  DT: 1   // 超脫：超越局部爭執
                }
              },
              { 
                text: '分析雙方的利益衝突點尋找解決方案', 
                next: 11,
                traits: { 
                  T: 1,   // 思考：理性分析問題
                  E: 1,   // 外向：主動創造交流
                  EQ: 1   // 齊等：理解雙方處境
                }
              },
              { 
                text: '建議他們從蝸牛的角度看待這場爭論', 
                next: 12,
                traits: { 
                  N: 1,   // 直覺：創新的視角轉換
                  P: 1,   // 知覺：開放的思維方式
                  DT: 1   // 超脫：跳出人類中心視角
                }
              }
            ]
          },
          
          // === 第三組響應場景 ===
          {
            type: 'narrative',
            text: '你引導大家將視角拉高。當他們看到自己的整個「世界」只是一隻蝸牛的觸角時，許多士兵放下了武器。一個年輕的戰士說：「原來我們一直在這麼小的地方自相殘殺。」',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '你仔細分析雙方的核心利益訴求，發現觸氏國需要的是文化傳承的安全感，蠻氏國需要的是生存空間的保障。通過理性分析，你提出了一個互利共贏的解決方案：資源共享、領土劃分、文化交流。',
            nextScene: 13
          },
          {
            type: 'narrative',
            text: '你引導大家想像：如果蝸牛有意識，它會如何看待角上的戰爭？「也許對蝸牛來說，我們就像它身上的細菌在爭鬥。」一個智者說道。這個比喻讓所有人陷入沉思。',
            nextScene: 13
          },
          
          // === 最終匯聚點：和解的智慧 ===
          {
            type: 'narrative',
            text: '在你的引導下，兩國開始思考戰爭的意義。此時，莊子微笑著說：「你們都展現了超越爭論的智慧。這種能夠轉換視角、理解相對性的能力，正是通往右耳之竅封印的鑰匙。」一道紫光在空中閃現，指向遠方。',
            nextScene: 14
          },
          
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '通過你剛才在蝸角戰爭中的選擇，我看到了你處理衝突和理解不同視角的方式。每個人面對爭論時的反應都反映了內心的智慧...',
            sceneType: 'personal_analysis',
            context: '蝸角戰爭中的衝突處理方式分析',
            nextScene: 15
          },
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'spiral-effect',
            text: '莊子拂袖而過，紫色的螺旋光芒在空中凝聚，逐漸形成古老文字的輪廓。這些文字如同蝸牛殼上的紋路般盤旋排列，散發著神秘的光芒。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '若要理解這蝸角之爭的真相，你需要先解讀這段關於大小相對的古文。它將幫你獲得變換視角的能力。',
            nextScene: 17
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'spiral-text',
            text: '有所謂蝸者君知之乎有國於蝸之左角者曰觸氏有國於蝸之右角者曰蠻氏時相與爭地而戰伏尸數萬逐北旬有五日而後反',
            solution: [4, 8, 19, 30, 37, 41],
            hint: '點擊字符之間的空隙，嘗試正確斷句。想像你正在解讀一段關於蝸牛角上微觀世界的秘密...',
            success: '古文綻放出璀璨的紫光！文字化作螺旋光流環繞著你，你感到體內湧現一股奇特的力量——你已獲得了蝸牛的物化能力和視角轉換的神通。',
            nextScene: 18
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在，變身為蝸牛，親身體驗這個承載著兩個文明的微觀世界。只有成為蝸牛本身，你才能真正理解這場戰爭對當事者而言的意義。',
            nextScene: 19
          },
          {
            type: 'form-unlock-guide',
            text: '紫色的螺旋光流注入你的身體，你獲得了「蝸牛」的物化能力！現在你可以化身為蝸牛，成為承載兩個文明的微觀世界載體。請點擊物化按鈕，選擇蝸牛形態來感受這獨特的體驗。',
            effect: 'unlockForm:snail',
            highlightForm: 'snail',
            nextScene: 20
          },
          {
            type: 'transformation-experience',
            formType: 'snail',
            text: '你的意識轉換為蝸牛的視角。世界突然變得遼闊而深邃，你感受到自己成為了一個承載者——你的觸角上承載著兩個完整的文明，左角是觸氏國，右角是蠻氏國。你的感知變得極其敏銳，能同時感受到兩國的戰爭震動、人民的呼喊、土地的爭奪。在這種承載者的視角中，你體會到了什麼叫做「包容」和「超越」——不是被動地承受，而是以更高的智慧去理解這場爭論的本質。你意識到，對你來說，這不過是觸角上的微小騷動，但對他們而言，卻是整個世界的存亡之戰。',
            nextScene: 21
          },
          {
            type: 'snail-perspective-transition',
            text: '當你以蝸牛視角感受世界時，突然，你意識到自己就是那個承載著兩個文明的存在...讓我們將視角轉換，看看這個微觀世界的全貌。',
            nextScene: 22
          },
          
          // === 新增：交互式蝸角之爭場景 ===
          {
            type: 'snail-war-interactive',
            text: '現在，你將親身體驗蝸角上的戰爭。放大視角，觀察兩國的動態戰爭。請務必點擊「蠻」和「觸」兩個按鈕，分別傾聽兩國國王的話語。只有聽完雙方的聲音，你才能真正理解爭執的虛妄本質，然後才能繼續遊戲。',
            nextScene: 23
          },
          
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你聽到了嗎？這就是紛爭的根源——站在不同立場，看到的真相截然不同。現在，讓我們從更宏觀的維度來審視這場爭論。',
            effect: 'addGlowingSnail',
            nextScene: 24
          },
          {
            type: 'narrative',
            text: '當你將視角拉到最高處，整個蝸牛變得如同一粒微塵。從這個超然的層次看去，兩國的戰爭不過是蝸角上的微小騷動。就在這個宏觀的視角中，你看到了一道紫色的光芒——那是右耳之竅的封印！它象徵著超越表面爭論、洞察事物本質的智慧。',
            nextScene: 25
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '這就是右耳之竅——分辨真假、超越爭論的智慧之竅。它教會我們：當陷入無謂爭論時，不妨換個視角，從更高的層次審視問題。',
            nextScene: 26
          },
          {
            type: 'narrative',
            text: '你伸手觸摸封印，紫色的光芒瞬間包圍了你。一股清明的感覺湧上心頭——你感到右耳的是非判斷逐漸寧息，不再被爭論聲擾亂，內心回歸超越分別的平靜，理解不同層次的相對性。',
            effect: 'collectAperture:right-ear',
            nextScene: 27
          },
          {
            type: 'narrative',
            text: '第四章圓滿結束！隨著封印的獲得，蝸角戰爭漸漸平息，螺旋空間中的紫色光暈也慢慢消散。你感受到內心的清明和開闊，學會了從不同視角看待同一件事。',
            effect: 'cleanupChapter4',
            nextScene: 28
          },
          
          // === 第四階段：AI章節總結 ===
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在蝸角戰爭的喧囂中，你學會了視角的重要性...',
            sceneType: 'chapter_summary',
            context: '第四章深度總結：基於玩家在蝸角戰爭中的衝突處理方式（直接參與vs觀察分析vs尋求智慧、調解vs公正vs合作、視角轉換vs同理心vs創新思維），分析其應對爭論和理解相對性的能力，運用莊子大小相對性智慧為玩家的人際衝突處理、視角轉換能力、面對分歧的態度提供個性化指導',
            effect: 'switchToHuman',
            nextScene: 'chapter5:0'
          }
        ]
      },
      
      chapter5: {
        title: '第六章：朝菌大椿',
        description: '一天有多長？',
        background: 'time-scene',
        scenes: [
          // === 第一階段：網狀分支對話 ===
          {
            type: 'narrative',
            text: '跟隨莊子的指引，你來到了一片神奇的時間森林。這裡的時間似乎有自己的韻律——有些地方光影變換極快，有些地方仿佛凝滯靜止。森林中彌漫著不同的時間氣息。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你感受到了嗎？這片森林居住著三種生靈：朝生暮死的朝菌、夏鳴秋寂的蟪蛄，還有見證千年滄桑的大椿。它們對時間的感知截然不同。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '莊子指向森林的三個區域。左側樹叢間有快速閃爍的微光，中央林區傳來節律性的蟲鳴，右側古木參天，散發著深沉的時間氣息。每個區域都在召喚著你的注意。',
            nextScene: 3
          },
          
          // 第一個選擇點：初入時間森林的探索方式
          {
            type: 'dialog',
            speaker: '莊子',
            text: '初來此地，你打算如何開始探索這時間的奧秘？',
            options: [
              {
                text: '被那些快速閃爍的微光所吸引，好奇地走近',
                traits: {
                  E: 1,   // 外向：被外界現象吸引，主動探索
                  S: 1,   // 感官：對閃爍微光的感官體驗
                  US: 1   // 有用：追求探索和發現的價值
                },
                next: 4
              },
              {
                text: '安靜地聆聽著節律性的蟲鳴，想找到其中的規律',
                traits: {
                  I: 1,   // 內向：安靜的聆聽模式
                  J: 1,   // 判斷：尋找規律和秩序
                  EQ: 1   // 齊等：平等接納不同聲音
                },
                next: 5
              },
              {
                text: '靜心走向古木，讓自己融入深沉的時間氣息',
                traits: {
                  I: 1,   // 內向：內省的沉思模式
                  N: 1,   // 直覺：對時間本質的直覺感知
                  DT: 1   // 超脫：超越表面現象的深度思考
                },
                next: 6
              }
            ],
            nextScene: null
          },
          
          // 分支路徑A：朝菌區域體驗
          {
            type: 'narrative',
            text: '你走向左側區域，周圍的光影變化越來越快。你看到無數細小的朝菌在晨露中綻放又凋零，它們的生命週期在短短數分鐘內完成。這裡的時間如急流般奔騰。',
            nextScene: 7
          },
          
          // 分支路徑B：蟪蛄區域體驗  
          {
            type: 'narrative',
            text: '你來到中央林區，節律性的蟲鳴越來越清晰。你看到蟪蛄們在樹幹上有規律地鳴叫，它們的生命伴隨著夏季的韻律，從羽化到終結都有固定的節拍。這裡的時間如樂曲般和諧。',
            nextScene: 7
          },
          
          // 分支路徑C：大椿區域體驗
          {
            type: 'narrative',
            text: '你走向右側的古木區域，感受到一種深沉的寧靜。參天的大椿樹矗立在那裡，它們的年輪記錄著千年的歲月。這裡的時間如山岳般厚重穩定。',
            nextScene: 7
          },
          
          // 第一次交匯：時間差異的震撼
          {
            type: 'narrative',
            text: '突然，你感受到一陣奇特的時間波動，三個區域的時間感知同時湧入你的心中——朝菌的急促、蟪蛄的節律、大椿的悠長。這種巨大的差異讓你感到震撼。',
            nextScene: 8
          },
          
          // 第二個選擇點：面對時間差異的反應
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你體驗到了時間感知的差異。面對如此巨大的不同，你有什麼感受？',
            options: [
              {
                text: '心中升起一股憐惜，為朝菌的瞬息人生感到不捨',
                traits: {
                  F: 1,   // 情感：對短暫生命的情感反應
                  S: 1,   // 感官：關注具體的朝菌生命現象
                  IN: 1   // 干預：情感上想要幫助或改變
                },
                next: 9
              },
              {
                text: '內心渴望著大椿的悠長歲月，希望能有更多時間',
                traits: {
                  N: 1,   // 直覺：對未來和可能性的渴望
                  T: 1,   // 思考：理性地分析時間的價值
                  AT: 1   // 執著：對長壽和更多時間的執著
                },
                next: 10
              },
              {
                text: '若有所悟，覺得每種時間感知都有其完整性',
                traits: {
                  T: 1,   // 思考：理性地分析時間的相對性
                  P: 1,   // 知覺：接納多元時間觀念的開放性
                  EQ: 1   // 齊等：平等看待不同的時間感知
                },
                next: 11
              }
            ],
            nextScene: null
          },
          
          // 分支回應A：對短暫的感嘆
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你對朝菌的短暫生命感到惋惜。但你有沒有想過，對朝菌來說，這一天就是它完整的人生？長短的標準是什麼呢？',
            nextScene: 12
          },
          
          // 分支回應B：對悠長的羨慕
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你羨慕大椿的悠長歲月。但時間的價值在於長度嗎？蟪蛄的一個夏天、朝菌的一個晨曦，難道就沒有其獨特的豐富性？',
            nextScene: 12
          },
          
          // 分支回應C：對完整性的理解
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你體會到了時間的相對性。確實，每種生命都有其完整的時間體驗。接下來，讓我們更深入地理解這個道理。',
            nextScene: 12
          },
          
          // 第二次交匯：深度思考時間本質
          {
            type: 'narrative',
            text: '莊子引導你在森林中漫步，你開始感受到每種生物的時間韻律。朝菌的急促、蟪蛄的和諧、大椿的深沉，它們似乎在對話，分享著對時間的不同理解。',
            nextScene: 13
          },
          
          // 第三個選擇點：對話時間生靈
          {
            type: 'dialog',
            speaker: '莊子',
            text: '三種生靈都想與你分享它們的時間智慧。你最想聽誰的故事？',
            options: [
              {
                text: '走向朝菌，想聽它講述瞬息間的純粹體驗',
                traits: {
                  F: 1,   // 情感：對純粹體驗的情感渴求
                  S: 1,   // 感官：關注當下瞬息的感官體驗
                  UN: 1   // 無用：追求純粹體驗的無功利性
                },
                next: 14
              },
              {
                text: '靜聽蟪蛄分享季節韻律的和諧之美',
                traits: {
                  F: 1,   // 情感：對和諧美的情感感受
                  J: 1,   // 判斷：欣賞季節韻律的規律性
                  EQ: 1   // 齊等：理解不同節律的平等價值
                },
                next: 15
              },
              {
                text: '仰望大椿，想聽它述說千年歲月的深刻感悟',
                traits: {
                  I: 1,   // 內向：內省的聆聽和思考
                  N: 1,   // 直覺：對深刻感悟的直覺渴求
                  UN: 1   // 無用：追求智慧本身的無功利性
                },
                next: 16
              }
            ],
            nextScene: null
          },
          
          // 生靈對話場景A：朝菌的智慧
          {
            type: 'dialog',
            speaker: '朝菌',
            text: '朋友，我的一生只有這個晨曦，但它是如此完整！我不知道昨日，不憂慮明天，只是全心全意地在這一刻綻放。這瞬息的時光對我來說已是無限。',
            nextScene: 17
          },
          
          // 生靈對話場景B：蟪蛄的智慧
          {
            type: 'dialog',
            speaker: '蟪蛄',
            text: '我的生命伴隨夏季的韻律，從初夏的羽化到夏末的寂靜。雖然不知春秋，但這一季已足夠豐富。每一聲鳴叫都是我對時間的歌頌。',
            nextScene: 17
          },
          
          // 生靈對話場景C：大椿的智慧
          {
            type: 'dialog',
            speaker: '大椿',
            text: '孩子，我見證了千年的變遷，八千年為春，八千年為秋。時間對我而言如呼吸般自然。長久並不意味著更有價值，只是看待世界的方式不同。',
            nextScene: 17
          },
          
          // 第三次交匯：智慧的融合
          {
            type: 'narrative',
            text: '三種生靈的智慧在你心中迴響。你開始理解，時間的意義不在長短，而在於每個生命如何完整地體驗自己的時間。一種古老的文字開始在琥珀色的光暈中浮現。',
            nextScene: 18
          },
          
          // 第四個選擇點：運用時間智慧
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你領悟了時間的相對性。那麼，你打算如何運用這種智慧？',
            options: [
              {
                text: '學會珍惜當下的每一刻，像朝菌般專注',
                traits: {
                  F: 1,   // 情感：對當下時光的珍視情感
                  S: 1,   // 感官：專注於當下的感官體驗
                  WU: 1   // 無為：順應自然的時間節律
                },
                next: 19
          },
          {
                text: '尋找生活的節律，像蟪蛄般和諧',
                traits: {
                  F: 1,   // 情感：對和諧節律的情感認同
                  J: 1,   // 判斷：尋找生活規律的結構化方式
                  EQ: 1   // 齊等：理解不同節律的平等價值
                },
                next: 19
              },
              {
                text: '培養寬廣的時間視野，像大椿般包容',
                traits: {
                  I: 1,   // 內向：內省的視野培養
                  N: 1,   // 直覺：對宏觀時間觀的直覺理解
                  DT: 1   // 超脫：超越時間局限的包容思維
                },
                next: 19
              }
            ],
            nextScene: null
          },
          
          // 最終交匯：智慧的整合
          {
            type: 'narrative',
            text: '你的選擇與三種生靈的智慧產生共鳴。森林中的時間氣息開始融合，你感受到一種超越時間局限的寧靜。古老的文字愈發清晰，等待著你的解讀。',
            nextScene: 20
          },
          
          // === 第二階段：AI個性化回應 ===
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '在時間森林的體驗中，你展現了對時間的獨特理解...',
            sceneType: 'time_wisdom_analysis',
            context: '第五章個性化回應：基於玩家在時間森林中的探索方式（追隨微光vs聆聽節律vs感受古木）、對時間差異的反應（感嘆短暫vs羨慕悠長vs理解完整性）、生靈對話選擇（朝菌純粹vs蟪蛄和諧vs大椿深沉）、智慧運用方向（珍惜當下vs尋找節律vs培養視野），分析其時間觀念、生活態度、價值取向，運用莊子時間相對性智慧提供個性化的時間管理和人生感悟指導',
            nextScene: 21
          },
          
          // === 第三階段：標準遊戲流程 ===
          {
            type: 'dialog',
            speaker: '莊子',
            text: '要獲得時間感知的能力，你需要解讀這段關於生命長短的古文。只有真正領悟了時間的相對性，封印才會顯現。',
            nextScene: 22
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'time-text',
            text: '朝菌不知晦朔蟪蛄不知春秋此小年也楚之南有冥靈者以五百歲為春五百歲為秋上古有大椿者以八千歲為春八千歲為秋',
            solution: [5, 11, 15, 22, 28, 33, 39, 45],
            hint: '點擊字符之間的空隙，嘗試正確斷句。思考不同生物對時間的感知...',
            success: '文字綻放出琥珀般的溫暖光芒！時間的碎片如流沙般圍繞著你，你感到體內湧現一股神奇的力量——時間感知的能力已經覺醒。',
            effect: 'unlockTimePerception',
            nextScene: 23
          },
          {
            type: 'time-effect',
            text: '隨著古文的解讀完成，一股奇異的能量流入你的身體。你突然能感受到森林中不同生物的時間節拍——急促的朝菌，悠然的蟪蛄，還有緩慢而深沉的大椿心跳。',
            nextScene: 24
          },
          {
            type: 'form-unlock-guide',
            text: '時間感知的力量覺醒了！你獲得了朝菌、蟪蛄、大椿三種物化能力。首先體驗朝菌的瞬息時光——在短暫中感受永恆。點擊物化按鈕，選擇朝菌形態。',
            effect: 'unlockForm:morning-fungus',
            highlightForm: 'morning-fungus',
            nextScene: 25
          },
          {
            type: 'transformation-experience',
            formType: 'morning-fungus',
            text: '你的意識與一株朝菌融合。世界突然變得無比快速——陽光在眼前急速移動，露珠瞬間蒸發，其他植物如電影快進般生長。對朝菌而言，一天就是完整的一生。在這短暫的存在中，你體驗到了生命的純粹和專注：沒有過去的回憶，沒有未來的憂慮，只有當下這一刻的綻放。這就是朝菌的智慧——在有限中感受無限，在瞬息中體驗永恆。',
            nextScene: 26
          },
          {
            type: 'form-unlock-guide',
            text: '現在體驗蟪蛄的季節韻律——在有限的夏日中感受完整的生命週期。點擊物化按鈕，選擇蟪蛄形態。',
            effect: 'unlockForm:cicada',
            highlightForm: 'cicada',
            nextScene: 27
          },
          {
            type: 'transformation-experience',
            formType: 'cicada',
            text: '你的意識轉移到蟪蛄身上。時間流速有所放緩，你能感受到夏日的完整韻律——從初夏的羽化到盛夏的鳴叫，再到夏末的寂靜。春天和秋天對你來說是不存在的概念。作為蟪蛄，你擁有一個完整的季節來體驗生命：從土中鑽出的興奮，到樹上鳴叫的激情，再到生命終結時的平靜。這一個夏天就是你的全部世界，但它是如此豐富和完整。',
            nextScene: 28
          },
          {
            type: 'form-unlock-guide',
            text: '最後體驗大椿的千年歲月——在漫長中感受時間的深度和寬度。點擊物化按鈕，選擇大椿形態。',
            effect: 'unlockForm:great-chun',
            highlightForm: 'great-chun',
            nextScene: 29
          },
          {
            type: 'transformation-experience',
            formType: 'great-chun',
            text: '你的意識與古老的大椿樹融合。時間突然變得極其緩慢，人類的生老病死在你眼中如蜉蝣般短暫。朝代的更替、文明的興衰，都只是你生命中的瞬間片段。作為大椿，你見證了無數個春秋的輪迴，看著山川變遷，星辰移位。在這漫長的歲月中，你學會了什麼叫做「恆久」和「包容」——不是因為生命長就更有意義，而是因為你能以更寬廣的視角看待一切變化，理解萬物的本質都是相同的。',
            nextScene: 30
          },
          {
            type: 'time-effect',
            text: '三種時間感知的體驗完成後，你看到了一道溫潤的琥珀色光芒從大椿的樹幹中浮現——那是左鼻之竅的封印！它象徵著對時間本質的深刻理解。',
            nextScene: 31
          },
          {
            type: 'narrative',
            text: '你伸手觸摸封印，琥珀色的溫暖光芒包圍了你。一種超越時間的寧靜感充滿心靈——你感到左鼻的時間執著逐漸消散，不再被瞬息變化所困擾，心中升起超越時間的寧靜。',
            effect: 'collectAperture:left-nose',
            nextScene: 32
          },
          {
            type: 'narrative',
            text: '第五章圓滿結束！通過四次選擇和深度體驗，你領悟了時間相對性的真諦。時間森林中的智慧已融入你心——瞬息與永恆、短暫與悠長，都是時間的不同面向，每種都有其完整性和價值。',
            effect: 'cleanupChapter5',
            nextScene: 33
          },
          
          // === 第四階段：AI章節總結 ===
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在時間森林的旅程中，你探索了生命長短的奧秘...',
            sceneType: 'chapter_summary',
            context: '第五章深度總結：基於玩家在時間森林中的四次選擇（探索方式、時間差異反應、生靈對話、智慧運用），分析其時間觀念、生活節奏偏好、價值判斷模式、智慧整合能力，運用莊子朝菌大椿思想為玩家的時間管理、生活態度、人生規劃提供個性化指導',
            effect: 'switchToHuman',
            nextScene: 'chapter6:0'
          }
        ]
      },
      
      chapter6: {
        title: '第七章：螻蟻星辰',
        description: '上下有何不同？',
        background: 'heaven-earth-scene',
        scenes: [
          {
            type: 'narrative',
            text: '跟隨莊子的指引，你來到了一個神奇的地方。這裡天圓地方，日月星辰如珠璣般點綴在半圓形的天蓋之下。溫暖的金色光芒從大地升起，與深藍的夜空形成美麗的漸變。這裡充滿了自然的和諧與寧靜。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '我的朋友，我們來到了生死的邊界。但不要害怕，死亡不過是回歸自然的懷抱。你看，天地本就是最好的棺槨，日月星辰是最美的陪葬品。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '莊子的話語中透著一種超脫的智慧和對自然的深深眷戀。他指向天空中閃爍的星辰，又指向腳下溫暖的大地，臉上帶著平和的微笑。',
            nextScene: 3
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看到了嗎？這天地間的一切...',
            options: [
              {
                text: '跟隨莊子的手勢仰望星空，數著那些珠璣般的星辰',
                traits: { 
                  N: 1,   // 直覺：從星辰中感受宇宙的無限可能
                  F: 1,   // 情感：對星辰美感的情感反應
                  AT: 1   // 執著：對超越現實的高遠境界的執著
                },
                next: 4
              },
              {
                text: '蹲下身撫摸腳下的土地，感受大地深沉的溫度',
                traits: { 
                  S: 1,   // 感官：通過觸覺感受真實的大地
                  I: 1,   // 內向：安靜的觸摸和感知
                  WU: 1   // 無為：接受大地的自然狀態
                },
                next: 4
              },
              {
                text: '靜靜站在原地，讓目光在天地之間緩緩游移',
                traits: { 
                  I: 1,   // 內向：安靜的內省觀察
                  P: 1,   // 知覺：開放地接納天地景象
                  EQ: 1   // 齊等：平等地看待天地高下
                },
                next: 4
              }
            ]
          },
          {
            type: 'narrative',
            text: '這時，從遠處傳來幾位弟子的談話聲。他們正圍在一起，神情憂慮，似乎在討論著什麼重要的事情。其中一位弟子的聲音有些顫抖。',
            nextScene: 5
          },
          {
            type: 'dialog',
            speaker: '弟子甲',
            text: '老師說死亡是回歸自然...可我總覺得心裡空落落的，不知道該說什麼好。',
            nextScene: 6
          },
          {
            type: 'dialog',
            speaker: '弟子乙',
            text: '我最擔心的是...老師過世後，那些野外的鳥獸...',
            options: [
              {
                text: '輕輕走近弟子們，想聽聽他們的完整談話',
                traits: { 
                  E: 1,   // 外向：主動走近他人
                  F: 1,   // 情感：對弟子情感的關心
                  IN: 1   // 干預：主動介入他人的對話
                },
                next: 7
              },
              {
                text: '在一旁安靜等待，不打擾他們的私人對話',
                traits: { 
                  I: 1,   // 內向：安靜的等待和觀察
                  T: 1,   // 思考：理性地尊重他人隱私
                  WU: 1   // 無為：不干擾他人的自然狀態
                },
                next: 7
              },
              {
                text: '走向莊子，想問問老師對弟子擔憂的看法',
                traits: { 
                  E: 1,   // 外向：主動尋求智者指導
                  T: 1,   // 思考：理性地尋求解決方案
                  UN: 1   // 無用：追求深層智慧而非直接行動
                },
                next: 7
              }
            ]
          },
          {
            type: 'dialog',
            speaker: '弟子乙',
            text: '吾恐烏鳶之食夫子也。我們總想為老師準備厚葬，讓他在另一個世界也能舒適...',
            nextScene: 8
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '弟子們總是擔心我死後會被烏鳶啄食，但他們不明白——在上為烏鳶食，在下為螻蟻食，這有什麼區別呢？偏愛其中一種，豈不是很偏頗嗎？',
            nextScene: 9
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '從你剛才面對生死智慧的選擇中，我能感受到你的心境和思維方式。每個人面對弟子們的擔憂都有不同反應...',
            sceneType: 'personal_analysis',
            context: '第六章螻蟻星辰，基於玩家在面對莊子將死故事中的第一次選擇分析其生死智慧理解方式',
            nextScene: 10
          },
          {
            type: 'heaven-earth-effect',
            text: '隨著莊子的話語，天地間開始浮現古老的文字。這些文字如星光般閃爍，又如大地般溫暖，它們承載著莊子對生死的超脫理解。',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '要理解生死的真諦，你需要解讀這段關於自然回歸的古文。只有真正領悟了生死一體的道理，你才能獲得超越生死的智慧。',
            nextScene: 12
          },
          {
            type: 'segmentation-puzzle',
            textStyle: 'heaven-earth-text',
            text: '莊子將死弟子欲厚葬之莊子曰吾以天地為棺槨以日月為連璧星辰為珠璣萬物為齎送吾葬具豈不備邪何以加此弟子曰吾恐烏鳶之食夫子也莊子曰在上為烏鳶食在下為螻蟻食奪彼與此何其偏也',
            solution: [3, 9, 12, 19, 25, 30, 35, 42, 46, 49, 58, 61, 67, 73, 77],
            hint: '點擊字符之間的空隙，嘗試正確斷句。思考莊子對生死的超脫態度...',
            success: '文字綻放出金色的溫暖光芒！天地間的和諧之氣圍繞著你，你感到體內湧現一股超脫的力量——超越生死的智慧已經覺醒。',
            effect: 'unlockLifeDeathWisdom',
            nextScene: 13
          },
          {
            type: 'heaven-earth-effect',
            text: '隨著古文的解讀完成，一股深沉而溫暖的能量流入你的身體。你突然能感受到天地間的和諧——星辰的永恆寧靜，大地的溫暖懷抱，生與死原來都是自然的一部分。',
            nextScene: 14
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！現在你已獲得了超越生死的智慧。讓我們先體驗螻蟻的視角，感受那「在下」的踏實與安詳。',
            nextScene: 15
          },
          {
            type: 'form-unlock-guide',
            text: '一股來自大地深處的溫暖力量流入你的身體，你感到自己獲得了新的物化能力！現在你可以化身為「螻蟻」，體驗那「在下」的踏實與安詳。點擊物化按鈕，選擇螻蟻形態來感受大地的懷抱。',
            effect: 'unlockForm:ant',
            highlightForm: 'ant',
            nextScene: 16
          },
          {
            type: 'transformation-experience',
            formType: 'ant',
            text: '你的意識與一隻勤勞的螻蟻融合。世界突然變得溫暖而踏實——你能感受到大地母親的心跳，泥土的芬芳，根系的力量。作為螻蟻，你明白了什麼叫做「在下」的智慧：不是卑微，而是與大地最親近的連接。死亡對你來說不是恐懼，而是回到這溫暖懷抱的歸宿。在大地的懷抱中，你感受到了生命的踏實和死亡的安詳——它們都是自然循環中不可分割的一部分。',
            nextScene: 17
          },
          {
            type: 'narrative',
            text: '你已經成功獲得了「螻蟻」的物化能力！現在你可以隨時化身為螻蟻，體驗那「在下」的踏實與安詳。這種物化能力將伴隨你的整個旅程。',
            nextScene: 18
          },
          {
            type: 'narrative',
            text: '從螻蟻的視角中回到人形，你看到大地上散落著一些特別的東西——有閃閃發光的小石子，有形狀奇特的枯葉，還有一些看起來很古老的符號痕跡。',
            effect: 'switchToHuman',
            nextScene: 19
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你注意到了什麼有趣的東西嗎？',
            options: [
              {
                text: '撿起那些閃閃發光的小石子，放在掌心仔細觀察',
                traits: { 
                  S: 1,   // 感官：通過觸覺和視覺感受具體物品
                  I: 1,   // 內向：安靜專注的觀察
                  US: 1   // 有用：對具體美好事物的價值認同
                },
                next: 20
              },
              {
                text: '蹲下研究那些古老的符號痕跡，試圖理解其含義',
                traits: { 
                  N: 1,   // 直覺：從符號中感受深層意義
                  T: 1,   // 思考：理性地解讀符號含義
                  UN: 1   // 無用：追求知識而非實用價值
                },
                next: 21
              },
              {
                text: '輕撫那些枯葉，感受它們從生到死的自然軌跡',
                traits: { 
                  F: 1,   // 情感：對生死循環的情感感受
                  P: 1,   // 知覺：開放地感受自然變化
                  DT: 1   // 超脫：對生死變化的超脫理解
                },
                next: 22
              }
            ]
          },
          // 分支回應A：關注美麗石子的感官體驗
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你選擇了這些閃閃發光的小石子，這體現了你對美好事物的敏感。通過觸覺感受它們的溫度，通過視覺欣賞它們的光澤——你正在用感官與大地對話。這些小小的寶石見證了無數歲月的變遷，卻依然保持著純粹的美麗。',
            nextScene: 23
          },
          // 分支回應B：探索符號意義的理性思辨
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你蹲下研究那些古老的符號，這展現了你對深層智慧的追求。這些痕跡可能是古代先民留下的印記，也可能是大自然自己書寫的文字。你用理性的思維試圖解讀它們，這種求知的精神正是通往智慧的道路。',
            nextScene: 23
          },
          // 分支回應C：感受生死軌跡的哲學體悟
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你輕撫著枯葉，感受它們生死的軌跡。從綠意盎然到枯黃飄零，你在其中看到了生命的完整循環。這種對自然變化的深度感受，正展現了你內心的哲學情懷和對生死智慧的天然領悟。',
            nextScene: 23
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '無論你選擇關注什麼，都體現了你對「在下」世界的深度感知。現在讓我們體驗星辰的視角，感受那「在上」的永恆與超脫。這將是你第一次化身為非生物的存在。',
            nextScene: 24
          },
          {
            type: 'form-unlock-guide',
            text: '一股來自天空深處的神秘力量注入你的身體，你感受到了前所未有的體驗——你獲得了「星辰」的物化能力！這是你第一次能夠化身為非生物的存在。點擊物化按鈕，選擇星辰形態來感受宇宙的永恆。',
            effect: 'unlockForm:star',
            highlightForm: 'star',
            nextScene: 25
          },
          {
            type: 'transformation-experience',
            formType: 'star',
            text: '你的意識升華為一顆閃爍的星辰。時間和空間的概念完全改變了——你從宇宙的高度俯瞰著一切，生死在你眼中如潮汐般自然。作為星辰，你體驗到了什麼叫做「在上」的超脫：不是高傲，而是以最寬廣的視角包容一切。從這個高度看去，生與死只是宇宙中微小的變化，如同呼吸一般自然。你感受到了永恆的寧靜和對萬物的慈悲——這就是超越生死界限的智慧。',
            nextScene: 26
          },
          {
            type: 'narrative',
            text: '你已經成功獲得了「星辰」的物化能力！現在你可以隨時化身為星辰，體驗那「在上」的永恆與超脫。這是你第一次獲得非生物的物化能力，將為你的旅程帶來全新的視角。',
            nextScene: 27
          },
          {
            type: 'narrative',
            text: '從星辰的永恆視角回歸，你發現天地交接處出現了一道柔和的光帶，其中似乎蘊含著生死循環的奧秘。同時，你感受到內心有種前所未有的寧靜感。',
            effect: 'switchToHuman',
            nextScene: 28
          },
          {
            type: 'dialog',
            speaker: '內心聲音',
            text: '在永恆與瞬間之間，你選擇關注什麼？',
            options: [
              {
                text: '走向那道神秘的光帶，想要親身感受其中的奧秘',
                traits: { 
                  E: 1,   // 外向：主動走向神秘現象
                  S: 1,   // 感官：直接感受具體的光帶
                  IN: 1   // 干預：主動介入探索奧秘
                },
                next: 29
              },
              {
                text: '閉上眼睛，專注感受內心的這種前所未有的寧靜',
                traits: { 
                  I: 1,   // 內向：內省專注的狀態
                  N: 1,   // 直覺：對內心直覺的關注
                  WU: 1   // 無為：寧靜無為的狀態
                },
                next: 29
              },
              {
                text: '在這裡靜靜坐下，讓天地的和諧慢慢滲透心靈',
                traits: { 
                  I: 1,   // 內向：安靜的坐禪狀態
                  P: 1,   // 知覺：開放地接受天地和諧
                  EQ: 1   // 齊等：與天地和諧共存
                },
                next: 29
              }
            ]
          },
          {
            type: 'personalized-response',
            speaker: '莊子',
            baseText: '基於你在這段生死智慧之旅中的所有選擇，我能感受到你對生死境界的獨特理解...',
            sceneType: 'integrated_analysis',
            context: '第六章螻蟻星辰，基於玩家的完整選擇歷程（四次關鍵選擇）進行綜合性個性化分析',
            nextScene: 30
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '現在你理解了嗎？無論是螻蟻的「在下」還是星辰的「在上」，它們都是自然的一部分。偏愛其中一種，確實是很偏頗的想法。',
            nextScene: 31
          },
          {
            type: 'heaven-earth-effect',
            text: '在這種超越生死的體驗中，你看到了一道溫暖的金色光芒從天地交接處浮現——那是右鼻之竅的封印！它象徵著對生死本質的深刻理解和超越偏見的智慧。',
            nextScene: 32
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '那就是右鼻之竅——超越偏見之竅。它將封閉你的右鼻感知，讓你不再被生死氣息所困擾。取下它，混沌就能重新封閉第六個竅，超越生死分別的束縛。',
            nextScene: 33
          },
          {
            type: 'narrative',
            text: '你伸手觸摸封印，金色的溫暖光芒包圍了你。一種超越生死的平靜感充滿心靈——你感到右鼻的生死執著逐漸消融，不再被生死差別所束縛，心中升起超越生死的平等寧靜。',
            effect: 'collectAperture:right-nose',
            nextScene: 34
          },
          {
            type: 'personalized-summary',
            speaker: '莊子',
            baseText: '在《莊子將死》的故事中，你通過螻蟻和星辰的雙重視角，領悟了生死一體的深刻哲理...',
            sceneType: 'chapter_summary',
            context: '第六章深度總結：基於玩家在生死智慧之旅中的四次關鍵選擇（面對天地的觀察方式、對弟子擔憂的反應、大地探索的關注點、永恆與瞬間的選擇），分析其生死觀念、同理心深度、探索傾向、哲學思辨能力，運用莊子超越生死的智慧為玩家的人生態度、面對變化、價值觀念提供個性化指導。現在右鼻之竅已收集，下一章將是最終考驗。',
            effect: 'switchToHuman',
            nextScene: 'chapter7:0'
          }
        ]
      },
      
      chapter7: {
        title: '第八章：道歸混沌',
        description: '混沌為何死又如何生？',
        background: 'void-scene',
        scenes: [
          {
            type: 'narrative',
            text: '你跟隨莊子來到了宇宙的中心——虛空殿。這裡是中央之帝渾沌的領域，但現在卻籠罩著死亡的陰霾。星雲在虛空中緩緩流動，散發著前六章旅程的色彩回響。',
            nextScene: 1
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看，這就是渾沌——曾經的中央之帝。儵與忽為了報答他的恩德，每日為他鑿一竅，七日而渾沌死。',
            nextScene: 2
          },
          {
            type: 'narrative',
            text: '在虛空殿的中央，你看到了一個無竅的形體靜靜躺著，散發著微弱的光芒。空氣中彌漫著悲傷的氣息，彷彿還能感受到儵與忽的懊悔。',
            nextScene: 3
          },
          {
            type: 'dialog',
            speaker: '儵',
            text: '我們...我們只是想報答渾沌的恩德...人皆有七竅以視聽食息，為什麼他沒有呢？',
            nextScene: 4
          },
          {
            type: 'dialog',
            speaker: '忽',
            text: '我們每日為他鑿一竅...以為這樣能讓他更好地感受世界...但是...',
            nextScene: 5
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '言語或有遮蔽，何不親見其往事？觸摸渾沌，感受那段悲劇的真相。',
            nextScene: 6
          },
          {
            type: 'narrative',
            text: '你緩緩走向虛空殿中央的渾沌。當你的手觸及他的形體時，一股古老的記憶湧入你的心中...',
            nextScene: 7
          },
          {
            type: 'narrative',
            text: '記憶如潮水般湧來...你看到了儵與忽的善意，看到了渾沌的無竅之美，也看到了悲劇的必然。要理解這個故事，你需要轉動太極，讓陰陽重新流動。',
            nextScene: 8
          },
          {
            type: 'puzzle-taijitu',
            text: '太極轉動：點住太極符號轉動三圈，讓陰陽魚重新遊動起來。',
            nextScene: 9
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你讓太極重新轉動起來，陰陽魚又開始遊動了。看，頂部的太極也因你的行動而顯現。現在，讓我們回到渾沌之死的故事本身。要真正理解這個悲劇的深意，你需要先正確理解這段古文的含義。',
            nextScene: 10
          },
          {
            type: 'segmentation-puzzle',
            text: '南海之帝為儵北海之帝為忽中央之帝為渾沌儵與忽時相與遇於渾沌之地渾沌待之甚善儵與忽謀報渾沌之德曰人皆有七竅以視聽食息此獨無有嘗試鑿之日鑿一竅七日而渾沌死',
            solution: [5, 11, 18, 30, 36, 45, 46, 51, 53, 54, 55, 56, 60, 64, 68],
            hint: '仔細閱讀這段古文，理解渾沌之死的故事。注意句子的自然停頓和語義的完整性。',
            success: '你已經理解了渾沌之死的完整故事。儵與忽的善意反而害了渾沌，這正是莊子要表達的深刻哲理。',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你已經理解了這個悲劇的全貌。但要救渾沌，需要先聚集萬物之氣。萬物皆有氣，氣分八象。',
            nextScene: 12
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '在學習收集萬物之氣之前，你需要先理解八卦的奧秘。八卦是古人觀察天地萬物而創造的符號體系。看這些符號，實線代表陽，虛線代表陰。',
            nextScene: 13
          },
          {
            type: 'bagua-theory-explanation',
            text: '太極生兩儀，兩儀生四象，四象生八卦。讓我為你演示這個宇宙生成的過程...',
            nextScene: 14
          },
          {
            type: 'bagua-symbols-demonstration',
            text: '現在讓我們來認識八卦符號與其對應的自然元素。每個符號都有其深刻的含義...',
            nextScene: 15
          },
          {
            type: 'bagua-learning-challenge',
            text: '氣之源起：萬物皆有氣，氣分八象。現在測試你對八卦的理解，將符號與對應元素配對。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '很好！你已明瞭八氣之象。現在以萬物之眼，尋找散落各處的氣，為救渾沌做準備。',
            nextScene: 17
          },
          {
            type: 'wanwu-xunqi-guide',
            text: '萬物尋氣：以萬物之眼，尋找散落各處的氣。按照你的旅程順序，依次進入每個物化視野收集氣。',
            sequence: ['butterfly', 'fish', 'kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star'],
            nextScene: 18,

          },
          {
            type: 'form-unlock-guide',
            text: '萬物之氣已聚於你身，你獲得了「氣」的物化能力！氣是萬物之本，超越一切具象形體。現在你可以化身為氣，體驗純粹能量的流動。請點擊物化按鈕，選擇氣形態來感受這終極的物化體驗。',
            effect: 'unlockForm:qi',
            highlightForm: 'qi',
            nextScene: 19
          },
          {
            type: 'transformation-experience',
            formType: 'qi',
            text: '你化身為氣，身體變得半透明，如雲霧般飄逸。在這超越具象的狀態下，你感受到前所未有的自由。世界在你眼中徹底改變：所有色彩消退，只留下陰陽二氣的純粹對立與統一。每個生命都散發著獨特的氣息，你能感知到它們內在的能量流動。你體會到了「氣者，生之本也」——萬物皆由氣聚散而成，而你已經觸及了存在的根本奧秘。',
            nextScene: 20
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '感受到了嗎？氣是萬物的根本，你已經觸及了存在的本質。現在讓氣的力量自然流動，或許能喚醒渾沌...',
            nextScene: 21
          },
          {
            type: 'narrative',
            text: '隨著氣的力量流動，虛空殿中的混沌形體開始發出微弱的光芒。你收集的六個封印在右上角閃閃發光，似乎在呼應著什麼...',
            nextScene: 22
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你看！六竅的封印正在發揮作用。混沌雖死，但封印的力量讓他有了復甦的可能。現在只差最後一竅...',
            nextScene: 23
          },
          {
            type: 'dialog',
            speaker: '儵',
            text: '這...這怎麼可能？我們為混沌開竅是想讓他更好地感受世界，但為什麼封印竅位反而能救他？',
            nextScene: 24
          },
          {
            type: 'dialog',
            speaker: '忽',
            text: '儵，我想我明白了...混沌本來就是完美的。我們以為無竅是缺陷，實際上那才是他的本性。我們的『善意』反而害了他...',
            nextScene: 25
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '正是如此。自然無需人為的『改進』。現在我們要封印最後的口竅，讓混沌徹底回歸無竅的完美狀態。這不是剝奪，而是還原。',
            nextScene: 26
          },
          {
            type: 'narrative',
            text: '一道光芒從混沌身上升起，最後的口竅封印出現了！',
            effect: 'collectAperture:mouth',
            nextScene: 27
          },
          {
            type: 'narrative',
            text: '隨著最後一個封印的收集，右上角的七竅指示器全部消失。虛空殿中突然安靜下來，混沌的形體開始有了規律的起伏...他在呼吸！',
            nextScene: 28
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '看！混沌開始呼吸了。這是自然本身的生命節律。七竅已封，他正在回歸最初的純淨狀態。來，讓我們與自然同息。',
            nextScene: 29
          },
          {
            type: 'chaos-breathing-guide',
            text: '跟隨混沌的呼吸節奏...這是自然最原始的韻律，是天地間最古老的生命節拍...',
            nextScene: 30
          },
          {
            type: 'narrative',
            text: '隨著你與混沌呼吸的同步，一種前所未有的寧靜充滿了你的心靈。這是與自然完全融合的境界，你理解了什麼是真正的『天人合一』。',
            nextScene: 31
          },
          {
            type: 'narrative',
            text: '混沌完全甦醒了，但他沒有說話。無竅的形體散發著溫和的光芒，你能感受到他內心的平靜和感激。這就是『得意忘言』的境界。',
            nextScene: 32
          },
          {
            type: 'dialog',
            speaker: '儵',
            text: '莊子先生，我們已經封印了所有七竅，混沌也開始呼吸了，但是...為什麼他還是沒有真正復活？是不是我們還缺少了什麼？',
            nextScene: 33
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你問得好，儵。封印七竅只是讓混沌回歸了無竅的狀態，但要真正讓他復活...（莊子陷入沉思）讓我想想老子的智慧...',
            nextScene: 34
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '我想起了老子說過的話：「天下萬物生於有，有生於無。」還有「致虛極，守靜篤，萬物並作，吾以觀其復。」我們剛才通過呼吸調息，已經達到了虛極靜篤的境界...',
            nextScene: 35
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '我明白了！老子還說過：「道生一，一生二，二生三，三生萬物。」如果萬物是這樣產生的，那麼要復活混沌，我們就要反過來：讓萬物歸於三，三歸於二，二歸於一，一歸於道！',
            nextScene: 36
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '混沌本身就是「一」，就是道的化身。我們收集的萬物之氣，正是「三生萬物」中的萬物精華。現在，讓我們將這些氣反向注入混沌，讓萬物回歸本源！',
            nextScene: 37
          },
          {
            type: 'qi-infusion-ritual',
            text: '長按混沌形體，將萬物之氣注入其中...',
            nextScene: 38
          },
          {
            type: 'dao-revelation',
            text: '道的顯現...',
            nextScene: 39
          },
          {
            type: 'narrative',
            text: '萬物之氣注入混沌後，一切都回歸了本源。虛空殿消失了，八卦符號消失了，甚至你自己的形體也開始變得模糊...這時你突然意識到，這可能只是一個夢境。就在這個念頭閃過的瞬間，你猛然驚醒，發現自己正躺在一棵古老的大樹下，陽光透過樹葉灑在臉上，耳邊傳來鳥兒的啁啾聲...',
            nextScene: 'epilogue:0'
          }
        ]
      },
      
      epilogue: {
        title: '第九章：逍遙遊',
        description: '無用有什麼用？',
        background: 'epilogue-scene',
        scenes: [
          // 序幕：夢蝶轉場（場景0）
          {
            type: 'blank-emergence',
            text: '到底是莊周夢見了蝴蝶，還是蝴蝶夢見了莊周？',
            nextScene: 1
          },
          // 第一幕：醒來與困惑（場景1-3）
          {
            type: 'photo-develop',
            text: '陽光透過樹葉灑在你的臉上。你慢慢睜開眼睛，發現自己躺在一棵巨大古樹的樹蔭下。這棵樹非常粗壯，需要好幾個人才能抱住，枝葉茂密如雲朵，靜靜地立在廣闊的原野上。微風輕拂，樹葉沙沙作響，像是在低聲細語。',
            nextScene: 2
          },
          {
            type: 'dialog',
            speaker: '你',
            text: '這裡是...那個廣闊的原野嗎？剛才經歷的一切，感覺既真實又像夢境。到底我是在夢中，還是夢在我心裡？',
            nextScene: 3
          },
          {
            type: 'narrative', 
            text: '你坐起身來，環顧四周。這棵古樹看起來很眼熟，樹皮古老粗糙，刻滿了歲月的痕跡。遠處是一望無際的原野，天空高遠，白雲悠悠。這裡的一切都那麼安詳，彷彿不屬於人間。',
            nextScene: 4
          },
          // 第二幕：故人重現（場景4-9）
          {
            type: 'dialog',
            speaker: '蝴蝶',
            text: '你醒了。還是其實是我剛從你的夢中醒來？',
            nextScene: 5
          },
          {
            type: 'dialog',
            speaker: '魚',
            text: '沒有水，也能找到快樂的地方。這裡的樂趣，你現在應該明白了吧。',
            nextScene: 6
          },
          {
            type: 'narrative',
            text: '遠處的天空中，巨大的鯤鵬展開翅膀，影子遮住了雲朵。樹梢上，美麗的鵷鶵和夜行的鴟鴞各自棲息著，彼此相安無事。',
            nextScene: 7
          },
          {
            type: 'dialog',
            speaker: '蝸牛',
            text: '觸氏國和蠻氏國的戰爭，現在都成了過去的事情。在小小的蝸牛角上，再也沒有戰爭了。',
            nextScene: 8
          },
          {
            type: 'dialog',
            speaker: '朝菌',
            text: '朝生暮死的生物也有自己的快樂，活了幾千年的大樹也有自己的時光。生命的長短，真的有什麼區別嗎？',
            nextScene: 9
          },
          // 第三幕：哲人出現與教導（場景9-12）
          {
            type: 'dialog',
            speaker: '莊子',
            text: '你來了。這棵樹叫做樗樹，工匠們都不要它，認為它沒用。正因為沒有用處，它才能活到天年。',
            nextScene: 10
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '人們總是擔心自己沒用，樹也是一樣。這棵樹做不了棟樑，也做不了器具，但它能為一方土地提供蔭涼，讓你我在這裡悠閒地遊玩。所謂的「有用」，到底在哪裡呢？',
            nextScene: 11
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '以前，我也曾經用這棵樹的道理，來開導我的朋友惠施。來聽聽，想想看。',
            nextScene: 12
          },
          // 第四幕：斷句挑戰（場景12）
          {
            type: 'segmentation-puzzle',
            text: '今子有大樹患其無用何不樹之於無何有之鄉廣莫之野徬徨乎無為其側逍遙乎寢臥其下不夭斤斧物無害者無所可用安所困苦哉',
            solution: [4, 8, 18, 22, 29, 36, 40, 44, 48],
            hint: '仔細看看這段文字，試著理解它的意思。這段話說的是關於「無用」的樹的道理。',
            success: '樗樹因為沒有用處，所以能夠逍遙自在。不被人利用，反而獲得了真正的自由。',
            nextScene: 13
          },
          // 第五幕：最終感悟與逍遙境界（場景13-18）
          {
            type: 'narrative',
            text: '突然間，你好像明白了什麼，所有的生物都出現了。蝴蝶落在你的肩膀上，魚兒在空中游泳，鳥兒在枝頭歌唱...所有的生靈都圍繞著你，一切都顯得那麼祥和。這一刻，你的心裡沒有任何牽掛。',
            nextScene: 14
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '萬物都有自己的生活方式，各自走著自己的道路。蝴蝶飛舞，魚兒快樂，樹木安靜，這些都是逍遙自在的表現。為什麼一定要選擇其中一種呢？你就是萬物，萬物也就是你。',
            nextScene: 15
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '蝴蝶飛舞，魚兒快樂，鳥兒歌唱，蝸牛慢行，朝菌朝生夕死，大椿活了千年...這些你都經歷過了。這棵樗樹因為沒用而活到天年，你我的相遇也是如此。',
            nextScene: 16
          },
          {
            type: 'dialog',
            speaker: '莊子',
            text: '真正逍遙的人，不需要等待什麼。不用等夢，不用等醒，不用等什麼理想的地方。你現在的心境，就是那個自由自在的境界。',
            nextScene: 17
          },
          {
            type: 'narrative',
            text: '莊子的聲音漸漸遠去，就像風吹過樹梢一樣。樹影輕輕搖擺，若有若無。再也沒有言語，只有清風徐徐吹來，樹葉無聲地飄落。',
            nextScene: 18
          },
          {
            type: 'final-meditation',
            text: '微風從身邊吹過，你的心變得無比輕鬆。夢境和現實，已經沒有什麼區別了。你靠著大樹，看著雲朵來來去去，聽著風聲和鳥鳴。你的身體、你的心，都在這裡。在這個自由自在的地方，在這片廣闊的原野上，你終於得到了真正的逍遙。',
            nextScene: 19
          },
          // 遊戲結束（場景19）
          {
            type: 'credits',
            title: '萬物逍遙',
            credits: [
              '本故事基於書院中國古代經典初級課程第一單元',
              '',
              '開發者：',
              '張玉龍',
              'Google Gemini',
              'Anthropic Claude'
            ],
            nextScene: 'end'
          }
        ]
      }
    };
    
    // Event listeners
    // 移除舊的開始遊戲按鈕，改用章節卡片
    // startGameBtn.addEventListener('click', startGame);
    advanceBtn.addEventListener('click', advanceScene);
    
    // 初始化新功能
    initDevModeAccess();  // 開發者模式密碼保護
    generateChapterCards();  // 生成章節選擇卡片
    checkGameCompletionAndShowChatButton();  // 檢查通關狀態並顯示聊天按鈕
    
    // 初始化開發者工具事件監聽器
    initDevTools();
    

    

    

    

    
    // Add bird form button to formButtons
    const birdButton = document.getElementById('bird-form');
    if (birdButton) {
      formButtons.bird = birdButton;
    }
    
    // Add snail form button to formButtons
    const snailButton = document.getElementById('snail-form');
    if (snailButton) {
      formButtons.snail = snailButton;
    }
    
    // Make sure snail is included in the initial formButtons object
    if (!formButtons.snail) {
      formButtons.snail = document.getElementById('snail-form');
    }
    
    // Form transformation buttons
    for (const [form, button] of Object.entries(formButtons)) {
      if (button) { // Make sure button exists
        button.addEventListener('click', () => {
          // 檢查是否在萬物回響引導模式或萬物尋氣模式
          if ((gameState.formSequenceGuideActive || gameState.wanwuXunqiActive) && gameState.handleFormSequenceClick) {
            const handled = gameState.handleFormSequenceClick(form);
            if (handled) {
              return; // 如果被處理了，就不執行正常的物化邏輯
            }
          }
          
          // 正常的物化邏輯
          if (form === 'bird' && gameState.currentForm === 'bird') {
            // Bird form toggle removed - now using independent forms
          } else {
            transformTo(form);
          }
        });
      }
    }
    
    // 拖拽功能實現
    function makeDraggable(element, elementId) {
      let isDragging = false;
      let startX, startY;
      let currentX, currentY;
      
      // 鼠標/觸摸開始事件
      const startDrag = (e) => {
        isDragging = true;
        
        // 獲取初始位置
        if (e.type === 'mousedown') {
          startX = e.clientX;
          startY = e.clientY;
        } else if (e.type === 'touchstart') {
          startX = e.touches[0].clientX;
          startY = e.touches[0].clientY;
        }
        
        // 獲取元素當前位置
        const rect = element.getBoundingClientRect();
        currentX = rect.left;
        currentY = rect.top;
        
        // 改變樣式表示正在拖拽
        element.style.cursor = 'grabbing';
        element.style.zIndex = '1000';
        element.style.opacity = '0.8';
        
        // 添加全局事件監聽器
        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        
        // 防止默認行為
        e.preventDefault();
      };
      
      // 拖拽中事件
      const drag = (e) => {
        if (!isDragging) return;
        
        let clientX, clientY;
        
        if (e.type === 'mousemove') {
          clientX = e.clientX;
          clientY = e.clientY;
        } else if (e.type === 'touchmove') {
          clientX = e.touches[0].clientX;
          clientY = e.touches[0].clientY;
          e.preventDefault(); // 防止頁面滾動
        }
        
        // 計算移動距離
        const deltaX = clientX - startX;
        const deltaY = clientY - startY;
        
        // 更新元素位置
        const newX = currentX + deltaX;
        const newY = currentY + deltaY;
        
        // 使用transform來移動元素，這樣不會影響文檔流
        element.style.position = 'fixed';
        element.style.left = newX + 'px';
        element.style.top = newY + 'px';
        element.style.transform = 'none';
        
        // 調試信息已移除
      };
      
      // 拖拽結束事件
      const endDrag = () => {
        if (!isDragging) return;
        
        isDragging = false;
        
        // 恢復樣式
        element.style.cursor = 'pointer';
        element.style.zIndex = '11';
        element.style.opacity = '1';
        
        // 移除全局事件監聽器
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchend', endDrag);
        
        // 調試信息已移除
        
        console.log(`${elementId} 新位置:`, element.getBoundingClientRect());
      };
      
      // 添加事件監聽器到元素
      element.addEventListener('mousedown', startDrag);
      element.addEventListener('touchstart', startDrag, { passive: false });
      
      // 防止點擊事件與拖拽衝突
      element.addEventListener('click', (e) => {
        // 如果剛剛完成拖拽，阻止點擊事件
        if (Math.abs(e.clientX - startX) > 5 || Math.abs(e.clientY - startY) > 5) {
          e.stopPropagation();
        }
      });
    }

    // Game functions
    function startGame() {
      mainMenu.style.opacity = 0;
      setTimeout(() => {
        mainMenu.style.display = 'none';
        aperturesTracker.style.opacity = 1;
        gameUI.style.opacity = 1;
        gameContent.style.opacity = 1;
        document.getElementById('current-form-indicator').style.opacity = 1; // Show form indicator
        
        // Start the prologue
        startChapter('prologue');
      }, 500);
    }

    // 初始化音效開關
    function initAudioControls() {
      const audioToggle = document.getElementById('audio-toggle');
      if (audioToggle) {
        // 設置初始狀態
        audioToggle.checked = gameState.audioEnabled;
        updateAudioVisualState(gameState.audioEnabled);
        
        // 添加事件監聽器
        audioToggle.addEventListener('change', (e) => {
          gameState.audioEnabled = e.target.checked;
          audioManager.setAudioEnabled(e.target.checked);
          
          // 更新視覺狀態
          updateAudioVisualState(e.target.checked);
          
          // 如果在第三章且音效開啟，立即播放背景音樂
          if (e.target.checked && gameState.currentChapter === 'chapter3') {
            audioManager.playBackgroundMusic('https://chineseclassics.github.io/files/audio/zhuangzi/forestbirds.mp3', true, 'chapter3');
          }
        });
      }
    }

    // 更新音效視覺狀態
    function updateAudioVisualState(isEnabled) {
      const audioIcon = document.getElementById('audio-icon');
      const audioStatus = document.getElementById('audio-status');
      const audioContainer = document.querySelector('.audio-control-container');
      
      if (audioIcon && audioStatus) {
        if (isEnabled) {
          // 音效開啟狀態
          audioIcon.textContent = '🎵';
          audioStatus.textContent = '開啟';
          audioStatus.className = 'text-xs text-indigo-600 dark:text-indigo-400 min-w-[28px]';
          document.body.classList.add('audio-enabled');
        } else {
          // 音效關閉狀態  
          audioIcon.textContent = '🔇';
          audioStatus.textContent = '關閉';
          audioStatus.className = 'text-xs text-gray-500 dark:text-gray-400 min-w-[28px]';
          document.body.classList.remove('audio-enabled');
        }
      }
    }

    // 處理章節音頻切換
    function handleChapterAudioTransition(chapterId) {
      if (!gameState.audioEnabled) return;

      // 章節背景音樂配置
      const chapterMusic = {
        'prologue': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter0.mp3',
        'chapter1': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter1.mp3',
        'chapter2': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter2.mp3',
        'chapter3': 'https://chineseclassics.github.io/files/audio/zhuangzi/forestbirds.mp3',
        'chapter4': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter4.mp3',
        'chapter5': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter5.mp3',
        'chapter6': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter6.mp3',
        'chapter7': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter7.mp3',
        'epilogue': 'https://chineseclassics.github.io/files/audio/zhuangzi/chapter8.mp3'
        // 未來可以在這裡添加其他章節的背景音樂
      };

      // 如果當前章節有背景音樂
      if (chapterMusic[chapterId]) {
        // 延遲播放，讓章節切換動畫先完成
        setTimeout(() => {
          audioManager.playBackgroundMusic(chapterMusic[chapterId], true, chapterId);
        }, 2500); // 章節標題顯示2秒後開始播放
      } else {
        // 如果切換到沒有背景音樂的章節，停止當前音樂
        if (audioManager.currentChapterMusic) {
          audioManager.stopBackgroundMusic(true);
        }
      }
    }
    
    // 視角縮放相關函數和變數
    let scaleControllerActive = false;
    let currentScaleValue = 50; // 中間值，範圍0-100
    
    // 創建視角縮放控制器
    function createScaleController() {
      // 如果已存在就不重複創建
      if (document.querySelector('.scale-controller')) {
        return;
      }
      
      // 創建控制器容器
      const controller = document.createElement('div');
      controller.className = 'scale-controller';
      controller.id = 'scale-controller';
      
      // 創建標題
      const macroLabel = document.createElement('div');
      macroLabel.className = 'scale-label macro';
      macroLabel.textContent = '宏觀';
      controller.appendChild(macroLabel);
      
      // 創建控制軌道
      const track = document.createElement('div');
      track.className = 'scale-track';
      
      // 創建滑塊
      const handle = document.createElement('div');
      handle.className = 'scale-handle';
      handle.innerHTML = '<svg viewBox="0 0 24 24" width="12" height="12"><path fill="white" d="M7 14l5-5 5 5z"></path></svg>';
      track.appendChild(handle);
      
      // 創建微觀標籤
      const microLabel = document.createElement('div');
      microLabel.className = 'scale-label micro';
      microLabel.textContent = '微觀';
      
      // 創建數值顯示
      const scaleValue = document.createElement('div');
      scaleValue.className = 'scale-value';
      scaleValue.id = 'scale-value';
      scaleValue.textContent = '100%';
      
      // 組合元素
      controller.appendChild(track);
      controller.appendChild(microLabel);
      controller.appendChild(scaleValue);
      
      // 添加到頁面
      document.body.appendChild(controller);
      
      // 設置初始位置（正常比例）
      updateScaleHandlePosition(50);
      
      // 添加拖動事件
      enableDragFunctionality(handle, track);
      
      // 添加軌道點擊事件
      track.addEventListener('click', (e) => {
        // 忽略手柄本身的點擊
        if (e.target === handle) return;
        
        const rect = track.getBoundingClientRect();
        const clickY = e.clientY - rect.top;
        const percentage = 100 - (clickY / rect.height * 100);
        
        updateScale(percentage);
      });
      
      return controller;
    }
    
    // 更新比例手柄的位置
    function updateScaleHandlePosition(percentage) {
      const handle = document.querySelector('.scale-handle');
      const track = document.querySelector('.scale-track');
      
      if (handle && track) {
        // 更新手柄位置 (上方是宏觀，下方是微觀)
        const position = 100 - percentage; // 反轉百分比
        handle.style.top = `${position}%`;
        
        // 更新數值顯示
        const scaleValue = document.getElementById('scale-value');
        if (scaleValue) {
          // 將50%映射為100%（正常比例）
          const displayValue = Math.round((percentage - 50) * 2 + 100);
          scaleValue.textContent = `${displayValue}%`;
          
          // 顯示數值
          scaleValue.classList.add('visible');
          
          // 2秒後隱藏
          clearTimeout(window.scaleValueTimeout);
          window.scaleValueTimeout = setTimeout(() => {
            scaleValue.classList.remove('visible');
          }, 2000);
        }
      }
    }
    
    // 啟用拖動功能
    function enableDragFunctionality(handle, track) {
      let isDragging = false;
      
      // 鼠標/觸摸開始事件
      const startDrag = (e) => {
        isDragging = true;
        document.addEventListener('mousemove', drag);
        document.addEventListener('touchmove', drag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
        
        // 防止頁面滾動
        e.preventDefault();
      };
      
      // 鼠標/觸摸移動事件
      const drag = (e) => {
        if (!isDragging) return;
        
        const rect = track.getBoundingClientRect();
        let clientY;
        
        if (e.type === 'touchmove') {
          clientY = e.touches[0].clientY;
          // 防止頁面滾動
          e.preventDefault();
        } else {
          clientY = e.clientY;
        }
        
        // 計算相對於軌道的位置
        let posY = clientY - rect.top;
        
        // 限制在軌道範圍內
        posY = Math.max(0, Math.min(posY, rect.height));
        
        // 轉換為百分比 (0-100)
        const percentage = 100 - (posY / rect.height * 100);
        
        // 更新比例
        updateScale(percentage);
      };
      
      // 鼠標/觸摸結束事件
      const endDrag = () => {
        isDragging = false;
        document.removeEventListener('mousemove', drag);
        document.removeEventListener('touchmove', drag);
        document.removeEventListener('mouseup', endDrag);
        document.removeEventListener('touchend', endDrag);
      };
      
      // 添加事件監聽器
      handle.addEventListener('mousedown', startDrag);
      handle.addEventListener('touchstart', startDrag, { passive: false });
    }
    
    // 更新比例並應用到場景
    function updateScale(percentage) {
      // 將百分比限制在0-100之間
      percentage = Math.max(0, Math.min(100, percentage));
      
      // 更新當前值
      currentScaleValue = percentage;
      
      // 更新手柄位置
      updateScaleHandlePosition(percentage);
      
      // 更新視覺效果
      applyScaleEffect(percentage);
      
      // 檢查是否需要移除視角控制器的發光效果（蝸角之爭章節）
      if (gameState.currentChapter === 'chapter4' && percentage < 30) {
        removeScaleControllerHighlight();
      }
      
      // 如果有需要，通知教程系統已經改變了視角
      if (gameState.currentChapter === 'chapter4') {
        // 檢查是否發生了比例變化
        if (Math.abs(gameState.viewScale - percentage) > 10) {
          // 更新遊戲狀態
          gameState.viewScale = percentage;
          
          // 觸發 scale:change 事件
          document.dispatchEvent(new CustomEvent('scaleChange', { detail: { value: percentage } }));
          
          // 如果是宏觀視角 (>75)，觸發 scale:macro 事件
          if (percentage > 75) {
            document.dispatchEvent(new CustomEvent('scaleMacro'));
          }
        }
      }
    }
    
    // 應用視覺縮放效果
    function applyScaleEffect(percentage) {
      // 獲取需要縮放的元素
      const snailShell = document.querySelector('.snail-shell');
      const leftKingdom = document.querySelector('.kingdom-circle#touch-kingdom-circle');
      const rightKingdom = document.querySelector('.kingdom-circle#savage-kingdom-circle');
      const indicator = document.getElementById('snail-perspective-indicator');
      
      if (!snailShell) return;
      
      // 將百分比轉換為縮放比例 (0% -> 5x, 50% -> 1x, 100% -> 0.2x)
      let snailScale;
      
      if (percentage < 50) {
        // 微觀區域 (放大)
        const factor = 1 + (50 - percentage) / 10; // 50% -> 1x, 0% -> 6x
        snailScale = factor;
      } else {
        // 宏觀區域 (縮小)
        const factor = 1 - (percentage - 50) / 70; // 50% -> 1x, 100% -> 0.3x
        snailScale = factor;
      }
      
      // 完全重新設計的縮放中心點策略
      
      // 首先定義蝸牛SVG中眼睛的精確座標
      // 根據SVG檢查，左眼在(30,30)，右眼在(85,30)
      const leftEyeX = 30;
      const leftEyeY = 30;
      const rightEyeX = 85;
      const rightEyeY = 30;
      
      // 計算兩眼的中心點
      const eyesCenterX = (leftEyeX + rightEyeX) / 2; // = 57.5
      const eyesCenterY = (leftEyeY + rightEyeY) / 2; // = 30
      
      // SVG的中心點（根據viewBox="0 0 180 140"）
      const svgCenterX = 180 / 2; // = 90
      const svgCenterY = 140 / 2; // = 70
      
      // 當縮放級別在正常(50)和完全微觀(0)之間時，我們需要逐漸將縮放中心從SVG中心移至眼睛中心
      
      // 計算需要的偏移比例，範圍從0（正常視圖）到1（完全微觀）
      let focusStrength = 0;
      if (percentage < 50) {
        // 在0-50範圍內線性映射到0-1
        focusStrength = (50 - percentage) / 50;
        
        // 使用平方函數讓過渡更平滑
        focusStrength = Math.pow(focusStrength, 1.5);
      }
      
      // 計算眼睛中心點與SVG中心點的差異（這是我們需要補償的偏移量）
      const offsetX = eyesCenterX - svgCenterX; // = 57.5 - 90 = -32.5
      const offsetY = eyesCenterY - svgCenterY; // = 30 - 70 = -40
      
      // 計算縮放後應用的實際偏移量
      // 當focusStrength = 1時，我們完全移動到眼睛中心
      // 當focusStrength = 0時，我們保持在SVG中心
      const appliedOffsetX = offsetX * focusStrength;
      const appliedOffsetY = offsetY * focusStrength;
      
      // 計算實際的縮放中心，基於SVG大小和當前的偏移量
      // 這裡需要將偏移量轉換為百分比形式
      const zoomCenterX = 50 + (appliedOffsetX / 180) * 100;
      const zoomCenterY = 50 + (appliedOffsetY / 140) * 100;
      
      // 直接從縮放中心應用transform，確保位置和縮放正確
      // 使用transform-origin設置縮放中心點
      snailShell.style.transformOrigin = `${zoomCenterX}% ${zoomCenterY}%`;
      snailShell.style.transform = `translate(-50%, -50%) scale(${snailScale})`;
      
      // 更新提示文字
      if (indicator) {
        // 根據視角顯示不同的提示
        if (percentage < 30) {
          indicator.innerHTML = `
            <div class="text-center">
              <div class="font-bold text-2xl mb-2">微觀視角</div>
              <div class="text-sm opacity-75">你看到了蝸牛眼睛上的國家和居民</div>
            </div>
          `;
          indicator.style.opacity = '1';
        } else if (percentage > 70) {
          indicator.innerHTML = `
            <div class="text-center">
              <div class="font-bold text-2xl mb-2">宏觀視角</div>
              <div class="text-sm opacity-75">只是一個蝸牛而已</div>
            </div>
          `;
          indicator.style.opacity = '1';
        } else {
          indicator.style.opacity = '0';
        }
      }
      
      // 更新國家圓形的可見性，根據縮放程度顯示或隱藏
      if (leftKingdom && rightKingdom) {
        if (percentage < 40) {
          // 微觀視角下顯示國家
          leftKingdom.style.opacity = (40 - percentage) / 40;
          rightKingdom.style.opacity = (40 - percentage) / 40;
          leftKingdom.style.pointerEvents = 'auto';
          rightKingdom.style.pointerEvents = 'auto';
        } else {
          // 宏觀視角下隱藏國家
          leftKingdom.style.opacity = '0';
          rightKingdom.style.opacity = '0';
          leftKingdom.style.pointerEvents = 'none';
          rightKingdom.style.pointerEvents = 'none';
        }
      }
    }
    
    // 啟用視角縮放功能
    function enableScaleControl() {
      // 檢查是否已經啟用，避免重複創建
      if (gameState.scaleEnabled) {
        return;
      }
      
      // 創建或顯示縮放控制器
      const controller = document.getElementById('scale-controller') || createScaleController();
      controller.classList.add('active');
      scaleControllerActive = true;
      gameState.scaleEnabled = true;
      
      // 初始設置比例為正常 (50%)
      updateScale(50);
    }
    
    // 禁用視角縮放功能
    function disableScaleControl() {
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.classList.remove('active');
        // 同時移除發光效果
        controller.classList.remove('highlight');
      }
      scaleControllerActive = false;
    }
    
    // 為視角控制器添加發光提示效果
    function highlightScaleController() {
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.classList.add('highlight');
        console.log('🌟 視角控制器發光效果已啟用');
      }
    }
    
    // 移除視角控制器的發光提示效果
    function removeScaleControllerHighlight() {
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.classList.remove('highlight');
        console.log('🌟 視角控制器發光效果已移除');
      }
    }
    
    // 章節過渡函數 - 組合方案實現
    function transitionToChapter(chapterId) {
      console.log('🎬 開始章節過渡到:', chapterId);
      console.log('🎬 當前章節狀態:', {
        currentChapter: gameState.currentChapter,
        targetChapter: chapterId,
        currentScene: gameState.currentScene
      });
      
      // 特殊處理：第七章到尾聲章節的白色連續過渡
      if (gameState.currentChapter === 'chapter7' && chapterId === 'epilogue') {
        console.log('🌅 檢測到第七章到尾聲章節的特殊過渡');
        console.log('🌅 觸發 transitionFromChapter7ToEpilogue 函數');
        transitionFromChapter7ToEpilogue();
        return;
      }
      
      console.log('🎬 使用標準章節過渡流程');
      
      // 標準過渡流程
      // 階段1：結束過渡 (1.5秒)
      createChapterTransitionOverlay();
      
      setTimeout(() => {
        // 階段2：標題出現 (2-3秒)
        showChapterTitle(chapterId);
        
        setTimeout(() => {
          // 階段3：場景轉換 (1.5秒)
          // 等待打字機效果完成：標題(200ms/字) + 描述間隔(500ms) + 描述(180ms/字) + 緩衝(1000ms)
          startChapter(chapterId);
          removeChapterTransitionOverlay();
          
          // 保存進度
          saveGameProgress();
        }, 4500); // 從2500ms增加到4500ms，確保打字機效果完成
      }, 1500);
    }
    
    // 第七章到尾聲章節的特殊白色過渡（優化版本）
    function transitionFromChapter7ToEpilogue() {
      console.log('🌅 開始第七章到尾聲的特殊白色過渡');
      
      // 創建白色過渡覆蓋層
      const whiteOverlay = document.createElement('div');
      whiteOverlay.id = 'white-transition-overlay';
      whiteOverlay.className = 'fixed inset-0 pointer-events-none';
      whiteOverlay.style.cssText = `
        background: #ffffff;
        z-index: 9999;
        opacity: 0;
        transition: opacity 1.5s ease-in-out;
      `;
      
      document.body.appendChild(whiteOverlay);
      
      // 觸發白色覆蓋層淡入
      setTimeout(() => {
        whiteOverlay.style.opacity = '1';
      }, 50);
      
      // 1.5秒後開始顯示標題
      setTimeout(() => {
        console.log('🌅 開始顯示尾聲章節標題');
        showEpilogueTitle();
        
        // 標題顯示5秒後，更新遊戲狀態並開始尾聲章節
        setTimeout(() => {
          console.log('🌅 更新遊戲狀態到尾聲章節');
          gameState.currentChapter = 'epilogue';
          gameState.currentScene = 0;
          
          // 更新最高章節記錄
          const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
          const currentIndex = chapters.indexOf('epilogue');
          const maxIndex = chapters.indexOf(gameState.maxReachedChapter || 'prologue');
          
          if (currentIndex > maxIndex) {
            gameState.maxReachedChapter = 'epilogue';
            console.log('📈 更新最高章節記錄:', gameState.maxReachedChapter);
          }
          
          // 開始尾聲章節（在白色覆蓋層存在的情況下）
          console.log('🌅 在白色過渡層存在時開始尾聲章節');
          startChapter('epilogue');
          
          // 白色覆蓋層會在場景0用戶點擊繼續按鈕時清理
          console.log('🌅 白色覆蓋層將在場景0用戶點擊繼續按鈕時清理');
          
        }, 5000); // 標題顯示5秒
      }, 1500); // 白色覆蓋層淡入1.5秒後顯示標題
    }
    
    // 尾聲章節標題顯示（白色背景版本）
    function showEpilogueTitle() {
      const chapter = gameChapters['epilogue'];
      if (!chapter) return;
      
      const whiteOverlay = document.getElementById('white-transition-overlay');
      if (!whiteOverlay) return;
      
      // 創建標題容器
      const titleContainer = document.createElement('div');
      titleContainer.className = 'absolute inset-0 flex flex-col items-center justify-center text-center';
      titleContainer.style.zIndex = '10000';
      
      // 章節標題（黑色文字，適合白色背景）
      const title = document.createElement('h1');
      title.className = 'chapter-title-text text-black mb-4';
      title.style.cssText = `
        text-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        animation: epilogue-title-emerge 1.5s ease-out forwards;
        opacity: 0;
        color: #1a1a1a;
      `;
      titleContainer.appendChild(title);
      
      // 章節描述（深灰色文字）
      const description = document.createElement('p');
      description.className = 'text-xl md:text-2xl text-gray-700 max-w-2xl px-4';
      description.style.cssText = `
        text-shadow: 0 0 5px rgba(0, 0, 0, 0.1);
        animation: epilogue-title-emerge 1.5s ease-out 0.8s forwards;
        opacity: 0;
        color: #4a4a4a;
      `;
      titleContainer.appendChild(description);
      
      whiteOverlay.appendChild(titleContainer);
      
      // 標題打字機效果（調整速度以配合5秒顯示時間）
      typeWriterEffect(title, chapter.title, 150, () => {
        // 標題完成後，開始描述打字機效果
        setTimeout(() => {
          typeWriterEffect(description, chapter.description, 120);
        }, 500);
      });
    }

    // 創建章節過渡覆蓋層
    function createChapterTransitionOverlay() {
      const overlay = document.createElement('div');
      overlay.id = 'chapter-transition-overlay';
      overlay.className = 'fixed inset-0 pointer-events-none';
      overlay.style.cssText = `
        background: linear-gradient(135deg, 
          rgba(0, 0, 0, 0.8) 0%, 
          rgba(30, 30, 30, 0.9) 50%, 
          rgba(0, 0, 0, 0.8) 100%
        );
        z-index: 9999;
        opacity: 0;
        transition: opacity 1.5s ease-in-out;
        backdrop-filter: blur(10px);
      `;
      
      document.body.appendChild(overlay);
      
      // 觸發淡入動畫
      setTimeout(() => {
        overlay.style.opacity = '1';
      }, 50);
    }
    
    // 顯示章節標題（打字機效果）
    function showChapterTitle(chapterId) {
      const chapter = gameChapters[chapterId];
      if (!chapter) return;
      
      const overlay = document.getElementById('chapter-transition-overlay');
      if (!overlay) return;
      
      // 創建標題容器
      const titleContainer = document.createElement('div');
      titleContainer.className = 'absolute inset-0 flex flex-col items-center justify-center text-center';
      titleContainer.style.zIndex = '10000';
      
      // 章節標題
      const title = document.createElement('h1');
      title.className = 'chapter-title-text text-white mb-4';
      title.style.cssText = `
        text-shadow: 0 0 20px rgba(255, 255, 255, 0.5);
        animation: chapter-title-emerge 1s ease-out forwards;
        opacity: 0;
      `;
      titleContainer.appendChild(title);
      
      // 章節描述
      const description = document.createElement('p');
      description.className = 'text-xl md:text-2xl text-gray-300 max-w-2xl px-4';
      description.style.cssText = `
        text-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
        animation: chapter-title-emerge 1s ease-out 0.5s forwards;
        opacity: 0;
      `;
      titleContainer.appendChild(description);
      
      overlay.appendChild(titleContainer);
      
      // 播放打字機效果音效（如果音效開啟）
      if (gameState.audioEnabled) {
        // 這裡可以添加打字機音效
        console.log('🔊 播放章節過渡音效');
      }
      
      // 標題打字機效果
      typeWriterEffect(title, chapter.title, 200, () => {
        // 標題完成後，開始描述打字機效果
        setTimeout(() => {
          typeWriterEffect(description, chapter.description, 180);
        }, 500);
      });
    }
    
    // 移除章節過渡覆蓋層
    function removeChapterTransitionOverlay() {
      const overlay = document.getElementById('chapter-transition-overlay');
      if (overlay) {
        overlay.style.opacity = '0';
        setTimeout(() => {
          overlay.remove();
        }, 1500);
      }
    }
    
    // 打字機效果函數
    function typeWriterEffect(element, text, speed = 100, callback = null) {
      element.textContent = '';
      let i = 0;
      
      const typeInterval = setInterval(() => {
        if (i < text.length) {
          element.textContent += text.charAt(i);
          i++;
          
          // 播放打字音效（如果音效開啟）
          if (gameState.audioEnabled && i % 3 === 0) {
            // 這裡可以添加打字音效
            console.log('🔊 打字音效');
          }
        } else {
          clearInterval(typeInterval);
          if (callback) callback();
        }
      }, speed);
    }

    function startChapter(chapterId) {
      console.log('🚀 startChapter 被調用，章節ID:', chapterId);
      gameState.currentChapter = chapterId;
      gameState.currentScene = 0;
      
      // 初始化場景停留時間記錄
      gameState.playerChoices.sceneDwellTime.currentSceneStartTime = Date.now();
      
      console.log('🚀 設置遊戲狀態:', {
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene
      });
      
      // 只在非跳轉情況下自動保存遊戲進度
      // 章節跳轉時的進度保存由transitionToChapter處理
      if (!document.getElementById('chapter-transition-overlay') && !document.getElementById('white-transition-overlay')) {
        saveGameProgress();
      }
      
      // 更新章節卡片（如果主菜單可見）
      if (document.getElementById('main-menu').style.display !== 'none') {
        generateChapterCards();
      }
      
      // 確保在章節開始時恢復日常物化按鈕顯示
      showFormButtons();
      
      const chapter = gameChapters[chapterId];
      
      // 確保章節開始時玩家為人形狀態（除非在日常物化中）
      if (!gameState.isInDailyTransformation) {
        if (gameState.currentForm !== 'human') {
          gameState.currentForm = 'human';
          updateFormView('human');
        }
          
        // 更新底部按鈕狀態 - 首先確保所有解鎖的按鈕都可見
          Object.values(formButtons).forEach(button => {
            if (button) {
              button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
              button.classList.add('bg-gray-500');
            }
          });
        
        // 顯示所有已解鎖的形態按鈕
        console.log('📋 當前已解鎖的形態:', gameState.unlockedForms);
        gameState.unlockedForms.forEach(form => {
          if (formButtons[form]) {
            formButtons[form].classList.remove('hidden');
            formButtons[form].style.visibility = 'visible';
            console.log(`📋 顯示已解鎖形態按鈕: ${form}`);
          } else {
            console.log(`❌ 形態按鈕不存在: ${form}`);
            }
          });
          
          if (formButtons['human']) {
            formButtons['human'].classList.remove('bg-gray-500');
            formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }
      }
      
      // 檢查是否在過渡效果中，如果是則跳過原始標題顯示
      const isInTransition = document.getElementById('chapter-transition-overlay') || document.getElementById('white-transition-overlay');
      
      if (!isInTransition) {
        // Show chapter title (只在非過渡模式下顯示)
        chapterName.textContent = chapter.title;
        chapterDescription.textContent = chapter.description;
        
        // 為尾聲章節設置特殊的空白背景和隱藏UI
        if (chapterId === 'epilogue') {
          chapterTitle.style.background = '#ffffff';
          chapterTitle.classList.remove('bg-black', 'bg-opacity-80');
          // 修改文字顏色為黑色，以便在白色背景上顯示
          chapterName.style.color = '#000000';
          chapterDescription.style.color = '#333333';
          // 隱藏所有UI元素
          gameUI.style.opacity = 0;
          
          // 隱藏左上角當前形態指示器
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 0;
          }
          
          // 隱藏右上角七竅追蹤器
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 0;
          }
        } else {
          chapterTitle.style.background = '';
          chapterTitle.classList.add('bg-black', 'bg-opacity-80');
          // 恢復原始文字顏色
          chapterName.style.color = '';
          chapterDescription.style.color = '';
          // 顯示所有UI元素
          gameUI.style.opacity = 1;
          
          // 恢復左上角當前形態指示器
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 1;
          }
          
          // 恢復右上角七竅追蹤器
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 1;
          }
        }
        
        chapterTitle.style.opacity = 1;
        chapterTitle.style.pointerEvents = 'auto';
      } else {
        // 在過渡模式下，設置UI狀態但不顯示標題
        if (chapterId === 'epilogue') {
          console.log('🌅 尾聲章節在白色過渡模式下，隱藏所有UI並設置白色背景');
          gameUI.style.opacity = 0;
          
          // 隱藏左上角當前形態指示器
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 0;
          }
          
          // 隱藏右上角七竅追蹤器
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 0;
          }
          
          // 確保gameContainer和gameContent在白色過渡層下正確顯示
          gameContainer.style.background = '#ffffff';
          gameContent.style.background = '#ffffff';
          
          // 清理白色過渡層中的標題元素，讓尾聲章節內容能夠顯示
          const whiteOverlay = document.getElementById('white-transition-overlay');
          if (whiteOverlay) {
            const titleContainer = whiteOverlay.querySelector('.absolute.inset-0.flex.flex-col');
            if (titleContainer) {
              titleContainer.remove();
              console.log('🌅 已清理白色過渡層中的尾聲標題');
            }
          }
        } else {
          gameUI.style.opacity = 1;
          
          // 恢復其他章節的UI顯示
          const currentFormIndicator = document.getElementById('current-form-indicator');
          if (currentFormIndicator) {
            currentFormIndicator.style.opacity = 1;
          }
          
          const aperturesTracker = document.getElementById('apertures-tracker');
          if (aperturesTracker) {
            aperturesTracker.style.opacity = 1;
          }
        }
      }
      
      // Clean up previous chapter elements
      cleanupChapterEffects();
      
      // Set background (尾聲章節跳過背景設置，保持白色)
      gameContainer.classList.remove('dream-scene', 'water-scene', 'cloud-scene', 'forest-scene', 'spiral-scene', 'time-scene', 'heaven-earth-scene', 'void-scene', 'epilogue-scene');
      if (chapterId !== 'epilogue') {
      gameContainer.classList.add(chapter.background);
      } else {
        // 尾聲章節保持白色背景
        gameContainer.style.background = '#ffffff';
      }
      
      // 調試信息：特別針對尾聲章節
      if (chapterId === 'epilogue') {
        console.log('🌅 尾聲章節調試信息:');
        console.log('- 章節背景配置:', chapter.background);
        console.log('- gameContainer類列表:', gameContainer.classList.toString());
        console.log('- gameContainer內聯樣式background:', gameContainer.style.background);
        console.log('- 計算後的背景樣式:', window.getComputedStyle(gameContainer).backgroundImage);
        
        // 強制確保背景設置
        setTimeout(() => {
          console.log('🌅 延遲檢查尾聲章節背景:');
          console.log('- gameContainer類列表:', gameContainer.classList.toString());
          console.log('- gameContainer內聯樣式background:', gameContainer.style.background);
          console.log('- 計算後的背景樣式:', window.getComputedStyle(gameContainer).backgroundImage);
        }, 100);
      }
      
      // Add chapter-specific effects
      if (chapter.background === 'dream-scene') {
        createDreamEffects();
      } else if (chapter.background === 'water-scene') {
        createWaterEffects();
      } else if (chapter.background === 'cloud-scene') {
        createClouds();
      } else if (chapter.background === 'forest-scene') {
        createForestBackground();
      } else if (chapter.background === 'spiral-scene') {
        createSpiralBackground();
      } else if (chapter.background === 'void-scene') {
        createVoidScene();
      } else if (chapter.background === 'epilogue-scene') {
        // 尾聲章節的動畫效果
        console.log('🌅 開始創建尾聲章節動畫效果');
        createEpilogueEffects();
      } else if (chapterId === 'chapter5') {
        // 创建时间森林背景效果
        createTimeEffectScene({
          text: '你来到了一片神奇的时间森林，这里居住着不同的生灵，它们对时间的感知截然不同。',
          type: 'time-effect'
        });
      }

      // 處理章節音頻切換
      handleChapterAudioTransition(chapterId);
      
      if (!isInTransition) {
        // 非過渡模式：顯示原始標題並延遲加載
        setTimeout(() => {
          chapterTitle.style.opacity = 0;
          chapterTitle.style.pointerEvents = 'none';
          
          setTimeout(() => {
            loadScene();
          }, 1000);
        }, 2000);
      } else {
        // 過渡模式：立即加載場景
        loadScene();
      }
    }
    
    // Function to clean up chapter-specific elements
    function cleanupChapterEffects() {
      // Remove dream elements
      document.querySelectorAll('.dream-particles, .dream-particle, .dream-butterfly').forEach(el => el.remove());
      
      // Remove water elements
      document.querySelectorAll('.water-ripples, .water-ripple, .water-bubble, .water-fish').forEach(el => el.remove());
      
      // Remove cloud elements
      document.querySelectorAll('.background-cloud, .cloud-container').forEach(el => el.remove());
      
      // Remove forest elements
      document.querySelectorAll('.forest-background').forEach(el => {
        // 清理森林定時器
        if (el.leafInterval) {
          clearInterval(el.leafInterval);
        }
        // 清理Three.js場景
        if (el.threeCleanup) {
          el.threeCleanup();
        }
        el.remove();
      });
      document.querySelectorAll('.leaf-container, .tree, .tree-trunk, .tree-crown, .falling-leaf, .forest-light, .forest-sunlight, .wind-effects, .wind-particle, .three-forest-scene').forEach(el => el.remove());
      
      // Remove spiral elements
      document.querySelectorAll('.spiral-container, .spiral-effect, .spiral-particle').forEach(el => el.remove());
      
      // Remove time-scene (Chapter 5) elements
      document.querySelectorAll('.time-background-container').forEach(el => el.remove());
      document.querySelectorAll('.time-particle-global').forEach(el => el.remove());
      document.querySelectorAll('.time-amber-glow').forEach(el => el.remove());
      document.querySelectorAll('.dachun-tree-emoji').forEach(el => el.remove());
      document.querySelectorAll('.morning-fungus-emoji').forEach(el => el.remove());
      document.querySelectorAll('.flying-cicada').forEach(el => el.remove());
      // Remove time animations style element
      const timeAnimationsStyle = document.getElementById('time-animations');
      if (timeAnimationsStyle) {
        timeAnimationsStyle.remove();
      }
      
      // Remove underwater effects
      document.querySelectorAll('.underwater-overlay, .water-effect').forEach(el => el.remove());
      
      // Remove heaven-earth effects
      document.querySelectorAll('.heaven-earth-background-container').forEach(el => el.remove());
      
      // Remove heaven-earth celestial container (第六章天体容器)
      document.querySelectorAll('.heaven-earth-celestial-container').forEach(el => el.remove());
      
      // Remove earth elements
      document.querySelectorAll('.earth-elements-container').forEach(el => el.remove());
      
      // Remove space starfield
      document.querySelectorAll('.space-starfield').forEach(el => el.remove());
      
      // Remove individual space stars (in case some are not in containers)
      document.querySelectorAll('.space-star').forEach(el => el.remove());
      
      // Remove atmosphere particles
      document.querySelectorAll('.atmosphere-particles').forEach(el => el.remove());
      
      // Remove individual atmosphere particles (in case some are not in containers)
      document.querySelectorAll('.atmosphere-particle').forEach(el => el.remove());
      
      // Remove heaven-earth animations style element
      const heavenEarthAnimationsStyle = document.getElementById('heaven-earth-animations');
      if (heavenEarthAnimationsStyle) {
        heavenEarthAnimationsStyle.remove();
      }
      
      // Remove void scene elements
      document.querySelectorAll('.void-particles, .chaos-form, .taiji-container, .bagua-symbols, .bagua-floating-text, .ritual-guide-overlay, .bagua-text-particle, .injection-particle, .bagua-symbol-learning, .bagua-element-learning, .bagua-symbols-demonstration').forEach(el => {
        // 清理八卦符號的定時器
        if (el.classList.contains('bagua-symbols') && el.baguaInterval) {
          clearInterval(el.baguaInterval);
        }
        el.remove();
      });
      
      // Remove epilogue scene effects
      document.querySelectorAll('.wisdom-particles, .ancient-leaves, .butterfly-dream-particles').forEach(el => el.remove());
      
      // 清理Three.js尾聲場景
      cleanupThreeJSEpilogueScene();
      
      // Remove floating ancient text
      document.querySelectorAll('.floating-ancient-text').forEach(el => el.remove());
      
      // 清理螻蟻視覺效果
      removeAntVisionEffect();
      
      // 重置第六章浮動文字禁用標記
      if (gameState.chapter6FloatingTextDisabled) {
        gameState.chapter6FloatingTextDisabled = false;
      }
      
      // Remove chapter6 floating puzzle containers
      document.querySelectorAll('body > .max-w-3xl').forEach(el => {
        if (el.style.position === 'fixed' && el.style.zIndex === '9999') {
          el.remove();
        }
      });
      
      // 清理視角縮放控制器及其提示文字
      const scaleController = document.getElementById('scale-controller');
      if (scaleController) {
        scaleController.remove();
      }
      const scaleIndicator = document.getElementById('snail-perspective-indicator');
      if (scaleIndicator) {
        scaleIndicator.remove();
      }
      // 重置視角縮放相關狀態
      gameState.scaleEnabled = false;
      gameState.viewScale = 100;
      scaleControllerActive = false;
      
      // Reset container styles that might have been modified by transformations
      gameContainer.style.transform = 'scale(1)';
      gameContainer.style.filter = 'none';
      gameContainer.style.background = '';
      
      // 移除物化覆蓋層
      removeTransformationOverlay();
      
      // Clear gameContent
      gameContent.innerHTML = '';
    }

    // 創建尾聲章節動態效果
    function createEpilogueEffects() {
      console.log('🌅 創建尾聲章節動態效果');
      
      // 創建Three.js增強的粒子系統
      createThreeJSEpilogueScene();
      
      // 創建傳統CSS粒子作為備用（低性能設備）
      if (!window.threeJSSupported) {
        // 創建智慧光點粒子容器
        const wisdomParticles = document.createElement('div');
        wisdomParticles.className = 'wisdom-particles';
        gameContainer.appendChild(wisdomParticles);
        
        // 創建飄落樹葉容器
        const ancientLeaves = document.createElement('div');
        ancientLeaves.className = 'ancient-leaves';
        gameContainer.appendChild(ancientLeaves);
        
        // 根據當前場景決定是否立即顯示粒子效果
        if (gameState.currentScene >= 2) {
          console.log('🌅 當前場景>=2，立即顯示粒子效果');
          // 生成智慧光點粒子
          createWisdomParticles(wisdomParticles);
          
          // 生成飄落樹葉
          createAncientLeaves(ancientLeaves);
        } else {
          console.log('🌅 當前場景<2，隱藏粒子效果');
          // 場景0和1時隱藏粒子效果
          wisdomParticles.style.display = 'none';
          ancientLeaves.style.display = 'none';
        }
        
        // 定期刷新粒子效果
        const particleInterval = setInterval(() => {
          if (gameState.currentChapter === 'epilogue') {
            // 只在場景2+時顯示粒子效果
            if (gameState.currentScene >= 2) {
              // 確保容器可見
              wisdomParticles.style.display = 'block';
              ancientLeaves.style.display = 'block';
              
              createWisdomParticles(wisdomParticles);
              createAncientLeaves(ancientLeaves);
            } else {
              // 隱藏粒子效果
              wisdomParticles.style.display = 'none';
              ancientLeaves.style.display = 'none';
            }
          } else {
            clearInterval(particleInterval);
          }
        }, 6000); // 每6秒刷新一次
      }
    }

    // Three.js尾聲章節場景系統
    let epilogueThreeScene = null;
    let epilogueRenderer = null;
    let epilogueCamera = null;
    let epilogueWisdomParticles = null;
    let epilogueAncientLeaves = [];
    let epilogueAnimationId = null;

    function createThreeJSEpilogueScene() {
      console.log('🌅 創建Three.js尾聲章節場景');
      
      try {
        // 創建場景
        epilogueThreeScene = new THREE.Scene();
        
        // 創建攝像機（正交攝像機保持2D效果）
        const aspect = window.innerWidth / window.innerHeight;
        epilogueCamera = new THREE.OrthographicCamera(
          -20 * aspect, 20 * aspect, 20, -20, 0.1, 1000
        );
        epilogueCamera.position.z = 10;
        
        // 創建渲染器
        epilogueRenderer = new THREE.WebGLRenderer({ 
          alpha: true, 
          antialias: true,
          powerPreference: "high-performance"
        });
        epilogueRenderer.setSize(window.innerWidth, window.innerHeight);
        epilogueRenderer.setClearColor(0x000000, 0); // 透明背景
        epilogueRenderer.domElement.style.position = 'absolute';
        epilogueRenderer.domElement.style.top = '0';
        epilogueRenderer.domElement.style.left = '0';
        epilogueRenderer.domElement.style.pointerEvents = 'none';
        epilogueRenderer.domElement.style.zIndex = '5';
        epilogueRenderer.domElement.id = 'epilogue-threejs-canvas';
        
        gameContainer.appendChild(epilogueRenderer.domElement);
        
        // 創建智慧光點粒子系統
        createThreeJSWisdomParticles();
        
        // 創建古樹葉片系統
        createThreeJSAncientLeaves();
        
        // 開始動畫循環
        animateEpilogueScene();
        
        // 響應式處理
        window.addEventListener('resize', onEpilogueWindowResize);
        
        window.threeJSSupported = true;
        console.log('🌅 Three.js尾聲場景創建成功');
        
      } catch (error) {
        console.error('🌅 Three.js初始化失敗，回退到CSS粒子:', error);
        window.threeJSSupported = false;
        cleanupThreeJSEpilogueScene();
      }
    }

    function createThreeJSWisdomParticles() {
      console.log('🌅 創建Three.js智慧光點粒子系統');
      
      const particleCount = 120;
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      const phases = new Float32Array(particleCount);
      
      // 初始化粒子屬性
      for (let i = 0; i < particleCount; i++) {
        // 位置：從樹根區域開始，螺旋分佈（整體向右偏移）
        const angle = (i / particleCount) * Math.PI * 4; // 螺旋角度
        const radius = 2 + Math.random() * 8; // 螺旋半徑
        
        positions[i * 3] = Math.cos(angle) * radius + 6;     // x (向右偏移6個單位)
        positions[i * 3 + 1] = -15 - Math.random() * 10; // y (底部開始)
        positions[i * 3 + 2] = Math.sin(angle) * radius; // z
        
        // 速度：螺旋上升 + 隨機擾動（進一步減慢）
        velocities[i * 3] = Math.sin(angle) * 0.0015 + (Math.random() - 0.5) * 0.001;      // x螺旋（再減慢一半）
        velocities[i * 3 + 1] = 0.004 + Math.random() * 0.002; // y上升（再減慢一半）
        velocities[i * 3 + 2] = Math.cos(angle) * 0.0015 + (Math.random() - 0.5) * 0.001;  // z螺旋（再減慢一半）
        
        // 顏色：金色到白色的漸變
        const goldIntensity = 0.7 + Math.random() * 0.3;
        colors[i * 3] = 1.0;                               // r
        colors[i * 3 + 1] = 0.7 + goldIntensity * 0.3;    // g
        colors[i * 3 + 2] = goldIntensity * 0.2;          // b
        
        // 大小：動態變化（增大以顯示發光效果）
        sizes[i] = 3 + Math.random() * 4; // 增大基礎大小
        
        // 相位：用於閃爍效果
        phases[i] = Math.random() * Math.PI * 2;
      }
      
      // 創建粒子幾何體
      const particleGeometry = new THREE.BufferGeometry();
      particleGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particleGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particleGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      // 創建圓形發光紋理
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const context = canvas.getContext('2d');
      
      // 創建徑向漸變實現發光效果
      const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
      gradient.addColorStop(0, 'rgba(255, 215, 0, 1)');    // 中心：純金色
      gradient.addColorStop(0.3, 'rgba(255, 215, 0, 0.8)'); // 內圈：半透明金色
      gradient.addColorStop(0.6, 'rgba(255, 215, 0, 0.3)'); // 中圈：淡金色
      gradient.addColorStop(1, 'rgba(255, 215, 0, 0)');     // 外圈：完全透明
      
      context.fillStyle = gradient;
      context.fillRect(0, 0, 64, 64);
      
      const texture = new THREE.CanvasTexture(canvas);
      
      // 創建粒子材質（圓形發光效果）
      const particleMaterial = new THREE.PointsMaterial({
        size: 6, // 增大尺寸以顯示發光效果
        sizeAttenuation: true,
        vertexColors: true,
        transparent: true,
        opacity: 1.0, // 完全不透明，透明度由紋理控制
        blending: THREE.AdditiveBlending, // 加法混合產生強烈光暈
        map: texture, // 使用圓形發光紋理
        alphaTest: 0.01 // 去除完全透明的像素
      });
      
      // 創建粒子系統
      epilogueWisdomParticles = new THREE.Points(particleGeometry, particleMaterial);
      epilogueWisdomParticles.userData = {
        velocities: velocities,
        phases: phases,
        time: 0
      };
      
      epilogueThreeScene.add(epilogueWisdomParticles);
    }

    function createThreeJSAncientLeaves() {
      console.log('🌅 創建Three.js古樹葉片系統');
      
      // 使用ShapeGeometry創建真實葉片形狀
      const leafShape = new THREE.Shape();
      leafShape.moveTo(0, 0);
      leafShape.bezierCurveTo(0, 0.3, 0.3, 0.6, 0.6, 0.3);
      leafShape.bezierCurveTo(0.6, 0, 0.3, -0.3, 0, 0);
      
      const leafGeometry = new THREE.ShapeGeometry(leafShape);
      
      // 創建35片不同的葉子
      const leafCount = 35;
      epilogueAncientLeaves = [];
      
      for (let i = 0; i < leafCount; i++) {
        // 隨機葉子顏色
        const hue = 0.08 + Math.random() * 0.05; // 棕黃色調
        const saturation = 0.6 + Math.random() * 0.3;
        const lightness = 0.3 + Math.random() * 0.2;
        
        const leafMaterial = new THREE.MeshBasicMaterial({
          color: new THREE.Color().setHSL(hue, saturation, lightness),
          transparent: true,
          opacity: 0.7 + Math.random() * 0.2,
          side: THREE.DoubleSide
        });
        
        const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
        
        // 隨機初始位置（屏幕上方）
        leaf.position.set(
          (Math.random() - 0.5) * 40,  // x: 水平分佈
          20 + Math.random() * 10,     // y: 屏幕上方
          (Math.random() - 0.5) * 5    // z: 深度變化
        );
        
        // 隨機大小
        const scale = 0.8 + Math.random() * 0.6;
        leaf.scale.set(scale, scale, scale);
        
        // 隨機初始旋轉
        leaf.rotation.set(
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2,
          Math.random() * Math.PI * 2
        );
        
        // 物理特性
        leaf.userData = {
          velocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.08,  // 水平風力
            -0.03 - Math.random() * 0.02,  // 下降速度
            (Math.random() - 0.5) * 0.03   // 深度飄移
          ),
          angularVelocity: new THREE.Vector3(
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02
          ),
          windResistance: 0.98 + Math.random() * 0.02,
          swayAmplitude: 0.5 + Math.random() * 1.0,
          swayFrequency: 0.02 + Math.random() * 0.01,
          swayPhase: Math.random() * Math.PI * 2,
          resetTimer: 0
        };
        
        epilogueAncientLeaves.push(leaf);
        epilogueThreeScene.add(leaf);
      }
    }

    function animateEpilogueScene() {
      if (!epilogueThreeScene || !epilogueRenderer || !epilogueCamera) return;
      
      epilogueAnimationId = requestAnimationFrame(animateEpilogueScene);
      
      const time = Date.now() * 0.001;
      
      // 更新智慧光點粒子
      if (epilogueWisdomParticles) {
        updateWisdomParticles(time);
      }
      
      // 更新古樹葉片
      updateAncientLeaves(time);
      
      // 根據場景顯示/隱藏粒子效果
      const shouldShowParticles = gameState.currentScene >= 2;
      if (epilogueRenderer.domElement) {
        epilogueRenderer.domElement.style.display = shouldShowParticles ? 'block' : 'none';
      }
      
      // 渲染場景
      if (shouldShowParticles) {
        epilogueRenderer.render(epilogueThreeScene, epilogueCamera);
      }
    }

    function updateWisdomParticles(time) {
      if (!epilogueWisdomParticles) return;
      
      const positions = epilogueWisdomParticles.geometry.attributes.position.array;
      const colors = epilogueWisdomParticles.geometry.attributes.color.array;
      const sizes = epilogueWisdomParticles.geometry.attributes.size.array;
      const velocities = epilogueWisdomParticles.userData.velocities;
      const phases = epilogueWisdomParticles.userData.phases;
      
      epilogueWisdomParticles.userData.time = time;
      
      for (let i = 0; i < positions.length / 3; i++) {
        const i3 = i * 3;
        
        // 更新位置
        positions[i3] += velocities[i3];     // x
        positions[i3 + 1] += velocities[i3 + 1]; // y
        positions[i3 + 2] += velocities[i3 + 2]; // z
        
        // 螺旋運動增強（進一步減慢）
        const spiralTime = time * 0.05 + phases[i]; // 再減慢一半
        positions[i3] += Math.sin(spiralTime) * 0.002; // 再減慢一半
        positions[i3 + 2] += Math.cos(spiralTime) * 0.002; // 再減慢一半
        
        // 重置超出邊界的粒子（保持向右偏移）
        if (positions[i3 + 1] > 25) {
          positions[i3] = (Math.random() - 0.5) * 20 + 6; // 向右偏移6個單位
          positions[i3 + 1] = -15 - Math.random() * 10;
          positions[i3 + 2] = (Math.random() - 0.5) * 10;
        }
        
        // 動態大小變化（緩慢呼吸效果，增強發光）
        const breathe = Math.sin(time * 0.5 + phases[i]) * 0.8 + 1.4; // 增強變化幅度和基礎大小
        sizes[i] = (3 + Math.random() * 0.5) * breathe; // 增大基礎大小範圍
        
        // 加強金色閃爍效果（增強發光強度）
        const primaryFlicker = Math.sin(time * 1.5 + phases[i]) * 0.5 + 1.0; // 主要閃爍，提高基礎亮度
        const secondaryFlicker = Math.sin(time * 0.8 + phases[i] * 1.3) * 0.4 + 0.9; // 次要閃爍
        const tertiaryFlicker = Math.sin(time * 2.2 + phases[i] * 0.7) * 0.3 + 0.8; // 第三層閃爍
        
        // 多層次金色閃爍（增強發光強度）
        colors[i3] = Math.min(2.0, primaryFlicker * 1.3);     // r: 允許過曝效果，增強發光
        colors[i3 + 1] = Math.min(1.8, secondaryFlicker * 1.2); // g: 增強金色調
        colors[i3 + 2] = Math.min(0.6, tertiaryFlicker * 0.4); // b: 適度增強但保持金色純度
      }
      
      // 標記需要更新
      epilogueWisdomParticles.geometry.attributes.position.needsUpdate = true;
      epilogueWisdomParticles.geometry.attributes.color.needsUpdate = true;
      epilogueWisdomParticles.geometry.attributes.size.needsUpdate = true;
    }

    function updateAncientLeaves(time) {
      epilogueAncientLeaves.forEach(leaf => {
        const userData = leaf.userData;
        
        // 更新位置
        leaf.position.add(userData.velocity);
        
        // 風力擾動
        const windForce = Math.sin(time * userData.swayFrequency + userData.swayPhase) * userData.swayAmplitude * 0.01;
        leaf.position.x += windForce;
        
        // 更新旋轉
        leaf.rotation.x += userData.angularVelocity.x;
        leaf.rotation.y += userData.angularVelocity.y;
        leaf.rotation.z += userData.angularVelocity.z;
        
        // 空氣阻力
        userData.velocity.multiplyScalar(userData.windResistance);
        
        // 重置超出邊界的葉子
        if (leaf.position.y < -25) {
          leaf.position.set(
            (Math.random() - 0.5) * 40,
            20 + Math.random() * 10,
            (Math.random() - 0.5) * 5
          );
          
          // 重新隨機化物理屬性
          userData.velocity.set(
            (Math.random() - 0.5) * 0.08,
            -0.03 - Math.random() * 0.02,
            (Math.random() - 0.5) * 0.03
          );
          userData.angularVelocity.set(
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02,
            (Math.random() - 0.5) * 0.02
          );
        }
        
        // 根據物化形態調整葉子行為
        if (gameState.currentForm === 'butterfly') {
          // 蝴蝶形態：葉子飄動更輕盈
          userData.velocity.y *= 0.7;
          leaf.material.opacity = Math.min(leaf.material.opacity + 0.01, 0.9);
        } else if (gameState.currentForm === 'fish') {
          // 魚形態：葉子如水中飄動
          userData.velocity.x *= 1.2;
          userData.velocity.z *= 1.2;
        }
      });
    }

    function onEpilogueWindowResize() {
      if (!epilogueCamera || !epilogueRenderer) return;
      
      const aspect = window.innerWidth / window.innerHeight;
      epilogueCamera.left = -20 * aspect;
      epilogueCamera.right = 20 * aspect;
      epilogueCamera.updateProjectionMatrix();
      
      epilogueRenderer.setSize(window.innerWidth, window.innerHeight);
    }

    function cleanupThreeJSEpilogueScene() {
      console.log('🌅 清理Three.js尾聲場景');
      
      // 停止動畫循環
      if (epilogueAnimationId) {
        cancelAnimationFrame(epilogueAnimationId);
        epilogueAnimationId = null;
      }
      
      // 移除事件監聽器
      window.removeEventListener('resize', onEpilogueWindowResize);
      
      // 清理Three.js對象
      if (epilogueWisdomParticles) {
        epilogueWisdomParticles.geometry.dispose();
        epilogueWisdomParticles.material.dispose();
        epilogueWisdomParticles = null;
      }
      
      epilogueAncientLeaves.forEach(leaf => {
        leaf.geometry.dispose();
        leaf.material.dispose();
      });
      epilogueAncientLeaves = [];
      
      if (epilogueRenderer) {
        epilogueRenderer.dispose();
        if (epilogueRenderer.domElement && epilogueRenderer.domElement.parentNode) {
          epilogueRenderer.domElement.parentNode.removeChild(epilogueRenderer.domElement);
        }
        epilogueRenderer = null;
      }
      
      if (epilogueThreeScene) {
        epilogueThreeScene.clear();
        epilogueThreeScene = null;
      }
      
      epilogueCamera = null;
    }

    // 創建智慧光點粒子
    function createWisdomParticles(container) {
      // 清理舊粒子
      const oldParticles = container.querySelectorAll('.wisdom-particle');
      oldParticles.forEach(particle => {
        if (Math.random() > 0.6) { // 60%概率清理舊粒子
          particle.remove();
        }
      });
      
      // 生成新粒子
      const particleCount = 8 + Math.floor(Math.random() * 5); // 8-12個粒子
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'wisdom-particle';
        
        // 隨機位置
        const leftPos = Math.random() * 100;
        particle.style.left = `${leftPos}%`;
        
        // 隨機大小
        const size = 2 + Math.random() * 3; // 2-5px
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 隨機延遲
        const delay = Math.random() * 5;
        particle.style.animationDelay = `${delay}s`;
        
        // 隨機持續時間
        const duration = 12 + Math.random() * 8; // 12-20秒
        particle.style.animationDuration = `${duration}s`;
        
        // 隨機透明度
        const opacity = 0.6 + Math.random() * 0.4; // 0.6-1.0
        particle.style.opacity = opacity;
        
        container.appendChild(particle);
        
        // 粒子生命週期管理
        setTimeout(() => {
          if (particle.parentNode) {
            particle.remove();
          }
        }, (duration + delay) * 1000);
      }
    }

    // 創建飄落樹葉
    function createAncientLeaves(container) {
      // 清理舊樹葉
      const oldLeaves = container.querySelectorAll('.ancient-leaf');
      oldLeaves.forEach(leaf => {
        if (Math.random() > 0.8) { // 80%概率清理舊樹葉
          leaf.remove();
        }
      });
      
      // 生成新樹葉
      const leafCount = 3 + Math.floor(Math.random() * 2); // 3-4片樹葉
      
      for (let i = 0; i < leafCount; i++) {
        const leaf = document.createElement('div');
        leaf.className = 'ancient-leaf';
        
        // 隨機位置
        const leftPos = Math.random() * 100;
        leaf.style.left = `${leftPos}%`;
        // 設置初始Y位置為屏幕外，避免在頂部可見
        const initialY = -300 - Math.random() * 200; // -300px到-500px之間隨機
        leaf.style.transform = `translateY(${initialY}px)`;
        
        // 隨機大小和形狀
        const width = 6 + Math.random() * 4; // 6-10px
        const height = width * (1.2 + Math.random() * 0.4); // 高度比寬度大一些
        leaf.style.width = `${width}px`;
        leaf.style.height = `${height}px`;
        
        // 隨機顏色變化
        const colorVariations = [
          'rgba(139, 69, 19, 0.7)',
          'rgba(160, 82, 45, 0.6)',
          'rgba(101, 67, 33, 0.8)',
          'rgba(205, 133, 63, 0.5)'
        ];
        leaf.style.background = colorVariations[Math.floor(Math.random() * colorVariations.length)];
        
        // 隨機延遲
        const delay = Math.random() * 8;
        leaf.style.animationDelay = `${delay}s`;
        
        // 隨機持續時間
        const duration = 18 + Math.random() * 6; // 18-24秒
        leaf.style.animationDuration = `${duration}s`;
        
        container.appendChild(leaf);
        
        // 樹葉生命週期管理
        setTimeout(() => {
          if (leaf.parentNode) {
            leaf.remove();
          }
               }, (duration + delay) * 1000);
       }
     }





     // 尾聲章節中蝴蝶物化的特殊夢境效果
     function createButterflyDreamEffect() {
       if (gameState.currentChapter !== 'epilogue') return;
       
       console.log('🦋 創建蝴蝶夢境特效');
       
       // 創建夢境粒子容器
       const dreamContainer = document.createElement('div');
       dreamContainer.className = 'butterfly-dream-particles';
       dreamContainer.style.cssText = `
         position: absolute;
         top: 0;
         left: 0;
         width: 100%;
         height: 100%;
         pointer-events: none;
         z-index: 15;
       `;
       gameContainer.appendChild(dreamContainer);
       
       // 生成夢境粒子
       for (let i = 0; i < 12; i++) {
         const dreamParticle = document.createElement('div');
         dreamParticle.style.cssText = `
           position: absolute;
           width: 4px;
           height: 4px;
           background: radial-gradient(circle, rgba(147, 51, 234, 0.8), rgba(147, 51, 234, 0.3));
           border-radius: 50%;
           box-shadow: 0 0 12px rgba(147, 51, 234, 0.6);
           left: ${Math.random() * 100}%;
           top: 100%;
           animation: butterfly-dream-rise ${8 + Math.random() * 4}s infinite linear;
           animation-delay: ${Math.random() * 3}s;
         `;
         dreamContainer.appendChild(dreamParticle);
       }
       
       // 添加夢境動畫樣式
       if (!document.getElementById('butterfly-dream-style')) {
         const style = document.createElement('style');
         style.id = 'butterfly-dream-style';
         style.innerHTML = `
           @keyframes butterfly-dream-rise {
             0% { 
               transform: translateY(0) scale(0.5) rotate(0deg); 
               opacity: 0; 
             }
             20% { 
               opacity: 0.8; 
             }
             50% { 
               transform: translateY(-50vh) scale(1) rotate(180deg); 
               opacity: 1; 
             }
             80% { 
               opacity: 0.6; 
             }
             100% { 
               transform: translateY(-100vh) scale(0.3) rotate(360deg); 
               opacity: 0; 
             }
           }
         `;
         document.head.appendChild(style);
       }
       
       // 5秒後清理效果
       setTimeout(() => {
         dreamContainer.remove();
       }, 12000);
    }
    
    function loadScene() {
      console.log('📍 loadScene 被調用');
      console.log('當前遊戲狀態:', {
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene
      });
      
      // 記錄場景停留時間（如果之前有場景）
      if (gameState.playerChoices.sceneDwellTime.currentSceneStartTime) {
        const dwellTime = Date.now() - gameState.playerChoices.sceneDwellTime.currentSceneStartTime;
        const sceneKey = `${gameState.currentChapter}_${gameState.currentScene}`;
        
        // 替換更新：如果已有記錄，則替換；如果沒有，則創建新記錄
        if (gameState.playerChoices.sceneDwellTime.sceneDwellTimes[sceneKey]) {
          const existingTime = gameState.playerChoices.sceneDwellTime.sceneDwellTimes[sceneKey];
          console.log(`🔄 替換場景停留時間: ${sceneKey} - 原時間: ${existingTime}ms -> 新時間: ${dwellTime}ms`);
          
          // 更新總停留時間（減去舊時間，加上新時間）
          gameState.playerChoices.sceneDwellTime.totalDwellTime -= existingTime;
          gameState.playerChoices.sceneDwellTime.totalDwellTime += dwellTime;
        } else {
          // 新記錄，直接累加到總時間
          gameState.playerChoices.sceneDwellTime.totalDwellTime += dwellTime;
        }
        
        // 替換場景停留時間記錄
        gameState.playerChoices.sceneDwellTime.sceneDwellTimes[sceneKey] = dwellTime;
        
        // 立即保存遊戲進度，確保場景停留時間數據不丟失
        saveGameProgress();
        
        console.log(`📊 場景停留時間記錄: ${sceneKey} = ${dwellTime}ms`);
      }
      
      // 設置新場景開始時間
      gameState.playerChoices.sceneDwellTime.currentSceneStartTime = Date.now();
      
      // 在場景加載時恢復混沌的正常層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('segmentation-mode');
      }
      
      const chapter = gameChapters[gameState.currentChapter];
      console.log('章節配置:', chapter ? '存在' : '不存在');
      
      if (!chapter) {
        console.error('❌ 章節配置不存在:', gameState.currentChapter);
        return;
      }
      
      console.log('章節場景總數:', chapter.scenes.length);
      console.log('嘗試加載場景索引:', gameState.currentScene);
      
      const scene = chapter.scenes[gameState.currentScene];
      
      // 檢查場景是否存在
      if (!scene) {
        console.error('❌ Scene not found:', gameState.currentChapter, gameState.currentScene);
        console.log('章節中所有場景索引:', Object.keys(chapter.scenes));
        console.log('場景總數:', chapter.scenes.length);
        
        // 嘗試回到章節開始
        console.log('嘗試回到章節開始場景...');
        gameState.currentScene = 0;
        if (chapter.scenes[0]) {
          const fallbackScene = chapter.scenes[0];
          console.log('✅ 找到起始場景，類型:', fallbackScene.type);
        } else {
          console.error('❌ No scenes found in chapter:', gameState.currentChapter);
          return;
        }
      } else {
        console.log('✅ 場景找到，類型:', scene.type);
        console.log('場景詳情:', scene);
      }
      
      // Clear previous content
      gameContent.innerHTML = '';
      dialogBox.style.opacity = 0;
      dialogOptions.innerHTML = '';
      
      // Clear any floating puzzle containers from previous scenes
      document.querySelectorAll('body > .max-w-3xl').forEach(el => {
        if (el.style.position === 'fixed' && el.style.zIndex === '9999') {
          el.remove();
        }
      });
      
      // Hide advance button initially
      advanceBtn.style.display = 'none';
      
      setTimeout(() => {
        // Process scene based on type
        console.log('🎭 開始創建場景，類型:', scene.type);
        
        switch (scene.type) {
          case 'narrative':
            console.log('創建敘述場景');
            createNarrativeScene(scene);
            break;
          case 'dialog':
            console.log('創建對話場景');
            createDialogScene(scene);
            break;
          case 'personalized-response':
            console.log('創建個性化回應場景');
            createPersonalizedResponseScene(scene);
            break;
          case 'personalized-summary':
            console.log('創建個性化總結場景');
            createPersonalizedSummaryScene(scene);
            break;
          case 'segmentation-puzzle':
            console.log('創建斷句謎題場景');
            createSegmentationPuzzle(scene);
            break;
          case 'tutorial':
            createTutorialScene(scene);
            break;
          case 'cloud-effect':
            createCloudEffectScene(scene);
            break;

          case 'spiral-effect':
            createSpiralEffectScene(scene);
            break;
          case 'perspective-challenge':
            createPerspectiveChallengeScene(scene);
            break;
          case 'time-effect':
            createTimeEffectScene(scene);
            break;
          case 'heaven-earth-effect':
            createHeavenEarthEffectScene(scene);
            break;
          case 'transformation-experience':
            createTransformationExperienceScene(scene);
            break;
          case 'transformation-required':
            createTransformationRequiredScene(scene);
            break;
          case 'form-unlock-guide':
            createFormUnlockGuideScene(scene);
            break;
          case 'puzzle-taijitu':
            createTaijiPuzzle(scene);
            break;
          case 'form-sequence-guide':
            createFormSequenceGuide(scene);
            break;
          case 'bagua-theory-explanation':
            createBaguaTheoryExplanationScene(scene);
            break;
          case 'bagua-symbols-demonstration':
            createBaguaSymbolsDemonstrationScene(scene);
            break;
          case 'bagua-learning-challenge':
            createBaguaLearningChallengeScene(scene);
            break;
          case 'wanwu-xunqi-guide':
            createWanwuXunqiGuide(scene);
            break;


            
          case 'chaos-breathing-guide':
            createChaosBreathingGuide(scene);
            break;
            
          case 'qi-infusion-ritual':
            createQiInfusionRitual(scene);
            break;
            
          case 'snail-perspective-transition':
            createSnailPerspectiveTransitionScene(scene);
            break;
            
          case 'snail-war-interactive':
            createSnailWarInteractiveScene(scene);
            break;
            
                      case 'dao-revelation':
              console.log('✨ 創建道的顯現場景');
              console.log('場景內容:', scene);
              createDaoRevelationScene(scene);
              break;
              
          case 'credits':
              console.log('✨ 創建製作人員名單場景');
              console.log('場景內容:', scene);
              createCreditsScene(scene);
              break;
              
          case 'blank-emergence':
              console.log('✨ 創建空白浮現場景');
              console.log('場景內容:', scene);
              createBlankEmergenceScene(scene);
              break;
              
          case 'photo-develop':
              console.log('✨ 創建照片顯影場景');
              console.log('場景內容:', scene);
              createPhotoDevelopScene(scene);
              break;
              
          case 'final-meditation':
              console.log('✨ 創建最終冥想場景');
              console.log('場景內容:', scene);
              createFinalMeditationScene(scene);
              break;

          default:
            console.error('Unknown scene type:', scene.type);
            // 創建一個默認場景以避免空白
            createNarrativeScene({
              text: `場景類型 "${scene.type}" 暫未實現。點擊繼續進入下一個場景。`,
              nextScene: scene.nextScene || (gameState.currentScene + 1)
            });
        }
        
        // Process effects
        if (scene.effect) {
          processEffect(scene.effect);
        }
        
        // 尾聲章節的UI和粒子效果邏輯
        if (gameState.currentChapter === 'epilogue') {
          // 檢查斷句挑戰是否已完成
          const segmentationCompleted = gameState.epilogueSegmentationCompleted || false;
          
          if (segmentationCompleted && gameState.currentScene >= 13 && gameState.currentScene < 19) {
            // 從場景13-18恢復所有UI顯示（對應「所有的生物都出現了」）
            console.log('🎭 尾聲章節場景13-18，斷句挑戰已完成，恢復所有UI顯示（所有生物都出現了）');
            gameUI.style.opacity = 1;
            gameUI.style.transition = 'opacity 0.5s ease';
            
            // 恢復左上角當前形態指示器
            const currentFormIndicator = document.getElementById('current-form-indicator');
            if (currentFormIndicator) {
              currentFormIndicator.style.opacity = 1;
              currentFormIndicator.style.transition = 'opacity 0.5s ease';
            }
            
            // 恢復右上角七竅追蹤器
            const aperturesTracker = document.getElementById('apertures-tracker');
            if (aperturesTracker) {
              aperturesTracker.style.opacity = 1;
              aperturesTracker.style.transition = 'opacity 0.5s ease';
            }
          } else {
            // 場景0-12和場景19，或者斷句挑戰未完成時，保持所有UI隱藏
            console.log('🎭 尾聲章節保持所有UI隱藏（斷句挑戰未完成或場景0-12、19）');
            gameUI.style.opacity = 0;
            
            // 隱藏左上角當前形態指示器
            const currentFormIndicator = document.getElementById('current-form-indicator');
            if (currentFormIndicator) {
              currentFormIndicator.style.opacity = 0;
            }
            
            // 隱藏右上角七竅追蹤器
            const aperturesTracker = document.getElementById('apertures-tracker');
            if (aperturesTracker) {
              aperturesTracker.style.opacity = 0;
            }
            
            // 特別處理：尾聲章節場景0禁止顯示繼續按鈕，避免與白色過渡衝突
            if (gameState.currentScene === 0) {
              console.log('🌅 尾聲章節場景0：禁止顯示繼續按鈕');
              advanceBtn.style.display = 'none';
            }
          }
          
          // 粒子效果從場景2開始顯示（背景圖片出現後）
          if (gameState.currentScene >= 2) {
            // 顯示粒子效果
            console.log('🌅 尾聲章節場景2+，顯示粒子效果');
            const wisdomParticles = document.querySelector('.wisdom-particles');
            const ancientLeaves = document.querySelector('.ancient-leaves');
            
            if (wisdomParticles) {
              wisdomParticles.style.display = 'block';
              createWisdomParticles(wisdomParticles);
            }
            if (ancientLeaves) {
              ancientLeaves.style.display = 'block';
              createAncientLeaves(ancientLeaves);
            }
          } else {
            // 隱藏粒子效果
            console.log('🌅 尾聲章節場景0-1，隱藏粒子效果');
            const wisdomParticles = document.querySelector('.wisdom-particles');
            const ancientLeaves = document.querySelector('.ancient-leaves');
            
            if (wisdomParticles) wisdomParticles.style.display = 'none';
            if (ancientLeaves) ancientLeaves.style.display = 'none';
          }
        }
      }, 300);
    }
    

    
    // 隱藏日常物化按鈕（在初次物化流程中使用）
    function hideFormButtons() {
      const formButtonsContainer = document.querySelector('.form-selector');
      if (formButtonsContainer) {
        formButtonsContainer.style.display = 'none';
        console.log('已隱藏日常物化按鈕');
      }
    }
    
    // 顯示日常物化按鈕（恢復正常顯示）
    function showFormButtons() {
      const formButtonsContainer = document.querySelector('.form-selector');
      if (formButtonsContainer) {
        formButtonsContainer.style.display = 'flex';
        console.log('已恢復日常物化按鈕顯示');
      }
    }
    
    function advanceScene() {
      console.log('📈 advanceScene 被調用');
      console.log('當前場景狀態:', {
        currentChapter: gameState.currentChapter,
        currentScene: gameState.currentScene
      });
      
      // 第七章場景39特殊處理：只觸發白色過渡，不進行標準場景推進
      if (gameState.currentChapter === 'chapter7' && gameState.currentScene === 39) {
        console.log('🌟 第七章場景39：只觸發白色過渡，不進行標準場景推進');
        const chapter7Elements = document.querySelectorAll('.max-w-2xl.mx-auto.p-6.text-left.fixed, .typewriter-container, .fade-in-container, .dao-revelation-container');
        chapter7Elements.forEach(el => {
          if (el.parentNode === document.body) {
            console.log('🌟 清理第七章場景39元素:', el.className);
            el.remove();
          }
        });
        
        // 只觸發特殊過渡，不直接進入epilogue:0
        console.log('🌟 觸發 transitionFromChapter7ToEpilogue，由該函數自動進入尾聲章節');
        transitionFromChapter7ToEpilogue();
        return; // 直接返回，不執行後續的標準場景推進邏輯
      }
      
      // 尾聲章節場景0特殊處理：不清理白色過渡層，讓場景1的照片顯影效果正常工作
      if (gameState.currentChapter === 'epilogue' && gameState.currentScene === 0) {
        console.log('🌅 尾聲章節場景0，保持白色過渡層供場景1照片顯影效果使用');
        
        // 不清理白色覆蓋層，讓場景1的createPhotoDevelopScene來處理
        // 照片顯影效果需要從白色背景開始
        
        // 確保gameContainer和gameContent正確設置
        gameContainer.style.background = '#ffffff';
        gameContent.style.background = '#ffffff';
        console.log('🌅 已重置背景樣式，保持白色過渡層');
      }
      
      // 在場景切換時恢復混沌的正常層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('segmentation-mode');
      }
      
      // 在正常場景推進時恢復日常物化按鈕顯示
      // 但如果是第七章且氣形態已解鎖，保持按鈕隱藏
      if (gameState.currentChapter === 'chapter7' && gameState.unlockedForms.includes('qi')) {
        console.log('第七章氣形態已解鎖，保持日常物化按鈕隱藏');
        
        // 指示器的隐藏现在在各个场景中直接控制，这里只需要确保第七章气形态解锁后的基本状态
        console.log('第七章氣形態已解鎖，指示器隐藏由具体场景控制');
      } else {
        showFormButtons();
      }
      
      const chapter = gameChapters[gameState.currentChapter];
      if (!chapter) {
        console.error('❌ advanceScene: 找不到章節配置', gameState.currentChapter);
        return;
      }
      
      const scene = chapter.scenes[gameState.currentScene];
      if (!scene) {
        console.error('❌ advanceScene: 找不到當前場景', {
          chapter: gameState.currentChapter,
          scene: gameState.currentScene,
          totalScenes: chapter.scenes.length
        });
        return;
      }
      
      console.log('當前場景詳情:', scene);
      
      let nextSceneId = scene.nextScene;
      console.log('下一個場景ID:', nextSceneId);
      
      // Handle chapter transitions
      if (typeof nextSceneId === 'string') {
        console.log('檢測到章節跳轉:', nextSceneId);
        const [nextChapter, nextScene] = nextSceneId.split(':');
        
        if (nextChapter === 'end') {
          // End game or show ending for now
          console.log('遊戲結束');
          alert('遊戲章節結束！更多章節敬請期待。');
          return;
        }
        
        console.log('跳轉到新章節:', nextChapter, '場景:', nextScene);
        
        // 保存當前章節用於特殊過渡檢查
        const currentChapter = gameState.currentChapter;
        
        // 特殊處理：第七章到尾聲章節的白色連續過渡
        if (currentChapter === 'chapter7' && nextChapter === 'epilogue') {
          console.log('🌅 檢測到第七章到尾聲章節的特殊過渡（在章節跳轉邏輯中）');
          console.log('🌅 此邏輯應該不會被執行，因為場景39已在開頭處理');
          
          // 這個邏輯分支實際上不應該被執行，因為場景39已經在advanceScene開頭處理了
          // 如果執行到這裡，說明有邏輯問題，直接返回避免重複處理
          console.warn('⚠️ 第七章到尾聲的過渡邏輯被重複執行，跳過以避免衝突');
          return;
        }
        
        // 標準章節過渡處理
        gameState.currentChapter = nextChapter;
        gameState.currentScene = parseInt(nextScene);
        
        // 更新最高章節記錄
        const chapters = ['prologue', 'chapter1', 'chapter2', 'chapter3', 'chapter4', 'chapter5', 'chapter6', 'chapter7', 'epilogue'];
        const currentIndex = chapters.indexOf(nextChapter);
        const maxIndex = chapters.indexOf(gameState.maxReachedChapter || 'prologue');
        
        if (currentIndex > maxIndex) {
          gameState.maxReachedChapter = nextChapter;
          console.log('📈 更新最高章節記錄:', gameState.maxReachedChapter);
        }
        
        // 使用標準章節過渡函數
        console.log('🌟 advanceScene 調用 transitionToChapter，參數:', {
          currentChapter: gameState.currentChapter,
          nextChapter: nextChapter,
          currentScene: gameState.currentScene
        });
        transitionToChapter(nextChapter);
      } else {
        // Regular scene transition
        console.log('常規場景推進，從', gameState.currentScene, '到', nextSceneId);
        gameState.currentScene = nextSceneId;
        
        // 檢查目標場景是否存在
        if (!chapter.scenes[nextSceneId]) {
          console.error('❌ 目標場景不存在:', {
            targetScene: nextSceneId,
            totalScenes: chapter.scenes.length,
            availableScenes: Object.keys(chapter.scenes)
          });
          return;
        }
        
        console.log('調用 loadScene() 加載場景', nextSceneId);
        loadScene();
      }
    }
    
    // === 個性化場景創建函數 ===
    async function createPersonalizedResponseScene(scene) {
      console.log('🤖 創建個性化回應場景:', scene);
      
      // 創建對話場景容器
      const dialogElement = document.createElement('div');
      
      // 檢查特殊章節的樣式需求
      const hasSnail = document.querySelector('.snail-shell');
      const isTimeChapter = gameState.currentChapter === 'chapter5';
      const isHeavenEarthChapter = gameState.currentChapter === 'chapter6';
      
      if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
        dialogElement.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-3xl bg-white dark:bg-gray-800 border-2 border-purple-500 dark:border-purple-400 rounded-lg p-4 shadow-lg bg-opacity-95 dark:bg-opacity-95';
        dialogElement.style.zIndex = isHeavenEarthChapter ? '60' : '30';
      } else {
        dialogElement.className = 'absolute top-1/2 left-0 right-0 mx-auto max-w-3xl -translate-y-1/2 bg-white dark:bg-gray-800 border-2 border-purple-500 dark:border-purple-400 rounded-lg p-4 shadow-lg opacity-0 transition-all duration-300 transform';
      }
      
      // 添加個性化標識
      const aiIndicator = document.createElement('div');
      aiIndicator.className = 'flex items-center mb-2 text-xs text-purple-600 dark:text-purple-400';
      aiIndicator.innerHTML = `
        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
          <path d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
        </svg>
        個性化回應
      `;
      dialogElement.appendChild(aiIndicator);
      
      // 首先顯示思考狀態
      const thinkingElement = document.createElement('div');
      thinkingElement.className = 'thinking-container';
      thinkingElement.innerHTML = `
        <div class="flex items-center space-x-3">
          <div class="thinking-avatar w-8 h-8 bg-gradient-to-br from-indigo-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-sm" style="animation: pulse 2s ease-in-out infinite;">
            莊
          </div>
          <div class="thinking-text text-lg text-gray-600 dark:text-gray-400" style="animation: text-glow-breathe 2s ease-in-out infinite;">
            <strong>${scene.speaker}</strong> 正在深思你的話語...
          </div>
        </div>
        <div class="thinking-dots mt-2 flex justify-center space-x-1">
          <div class="w-2 h-2 bg-purple-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite"></div>
          <div class="w-2 h-2 bg-purple-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.2s"></div>
          <div class="w-2 h-2 bg-purple-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.4s"></div>
        </div>
      `;
      dialogElement.appendChild(thinkingElement);
      
      gameContent.appendChild(dialogElement);
      
      // 顯示動畫
      setTimeout(() => {
        if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
          dialogElement.style.transform = 'translateX(-50%)';
        } else {
          dialogElement.style.opacity = '1';
          dialogElement.style.transform = 'translateY(0)';
        }
      }, 100);
      
      // 開始生成個性化內容
      let personalizedText;
      try {
        console.log('🔄 ===== 個性化回應場景調試信息 =====');
        console.log('🎯 場景調用時間:', new Date().toLocaleTimeString());
        console.log('📍 場景詳情:', {
          sceneType: scene.sceneType,
          speaker: scene.speaker,
          responseKey: scene.responseKey,
          context: scene.context,
          baseText: scene.baseText?.substring(0, 50) + '...'
        });
        
        const lastChoice = gameState.playerChoices.choiceHistory[gameState.playerChoices.choiceHistory.length - 1];
        
        console.log('📊 玩家最近選擇分析:', {
          選擇文本: lastChoice?.text || lastChoice?.choiceText || '無選擇記錄',
          選擇情境: lastChoice?.situation || '未知情境',
          選擇特質: lastChoice?.traits || {},
          思考時間: lastChoice?.thinkingTime ? `${Math.round(lastChoice.thinkingTime / 1000)}s` : '未記錄',
          章節: lastChoice?.chapter || '未知章節',
          場景: lastChoice?.scene || '未知場景'
        });
        
        console.log('🎮 當前遊戲狀態:', {
          當前章節: gameState.currentChapter,
          當前場景: gameState.currentScene,
          當前形態: gameState.currentForm,
          選擇歷史長度: gameState.playerChoices.choiceHistory.length
        });
        
        console.log('🤖 準備調用AI生成個性化回應...');
        const aiStartTime = Date.now();
        
        personalizedText = await generateSmartResponse(
          lastChoice?.text || lastChoice?.choiceText || '玩家的選擇',
          {
            sceneType: scene.sceneType,
            description: scene.context,
            responseKey: scene.responseKey,
            specificQuestion: lastChoice?.text || lastChoice?.choiceText, // 確保AI知道要回應的具體選擇
            chapter: gameState.currentChapter,
            scene: gameState.currentScene
          }
        );
        
        const aiEndTime = Date.now();
        const aiDuration = aiEndTime - aiStartTime;
        
        console.log('⏱️ AI回應生成耗時:', `${aiDuration}ms`);
        
        if (personalizedText) {
          console.log('✅ AI個性化回應生成成功:');
          console.log('  📏 回應長度:', personalizedText.length, '字符');
          console.log('  📝 回應內容:', personalizedText);
          console.log('  🎯 回應品質檢查:', {
            包含繁體中文: /[\u4e00-\u9fff]/.test(personalizedText),
            長度合適: personalizedText.length >= 50 && personalizedText.length <= 150,
            包含個性化元素: personalizedText.includes('你') || personalizedText.includes('選擇'),
            符合莊子風格: personalizedText.includes('道') || personalizedText.includes('自然') || personalizedText.includes('逍遙')
          });
        } else {
          console.warn('⚠️ AI返回空內容，使用預設內容');
          console.log('📝 預設內容:', scene.baseText);
          personalizedText = scene.baseText;
        }
        
        console.log('========================================');
      } catch (error) {
        console.error('❌ 個性化內容生成失敗:', error);
        console.log('🔄 降級使用預設內容:', scene.baseText);
        console.log('========================================');
        personalizedText = scene.baseText;
      }
      
      // AI回應準備好後，優雅地替換內容
      const finalTextElement = document.createElement('div');
      finalTextElement.className = 'ai-response-text text-lg leading-relaxed opacity-0 transition-all duration-800';
      finalTextElement.innerHTML = `<strong>${scene.speaker}：</strong> ${personalizedText}`;
      
      // 開始優雅的過渡動畫
      setTimeout(() => {
        // 淡出思考狀態
        const thinkingContainer = dialogElement.querySelector('.thinking-container');
        if (thinkingContainer) {
          thinkingContainer.style.transition = 'opacity 500ms ease-out, transform 500ms ease-out';
          thinkingContainer.style.opacity = '0';
          thinkingContainer.style.transform = 'translateY(-10px)';
          
          // 移除思考狀態並添加AI回應
          setTimeout(() => {
            thinkingContainer.remove();
            dialogElement.appendChild(finalTextElement);
            
            // 淡入AI回應，帶有打字機效果
            setTimeout(() => {
              finalTextElement.style.opacity = '1';
              finalTextElement.style.transform = 'translateY(0)';
              
              // 添加subtle的發光效果強調這是AI回應
              finalTextElement.style.animation = 'text-glow-breathe 3s ease-in-out';
              
              // 顯示繼續按鈕
              setTimeout(() => {
      advanceBtn.style.display = 'block';
              }, 300);
              
            }, 100);
          }, 500);
        }
      }, 300); // 給AI一點時間"思考"，即使回應已經準備好
    }
    
    async function createPersonalizedSummaryScene(scene) {
      console.log('📊 創建個性化總結場景:', scene);
      
      // 多重保險：立即隱藏繼續按鈕，防止玩家跳過AI生成的文字
      if (advanceBtn) {
        advanceBtn.style.display = 'none';
        console.log('🔒 AI章節總結：強制隱藏繼續按鈕');
      }
      
      // 先創建總結容器並顯示思考狀態
      const summaryElement = document.createElement('div');
      summaryElement.className = 'max-w-4xl mx-auto p-8 text-center bg-gradient-to-br from-blue-50 to-indigo-100 dark:from-blue-900 dark:to-indigo-900 rounded-xl shadow-lg border border-indigo-200 dark:border-indigo-700';
      summaryElement.style.position = 'relative';
      summaryElement.style.zIndex = '100'; // 确保AI总结场景在所有背景元素之上
      
      // 添加章節總結標題
      const titleElement = document.createElement('h3');
      titleElement.className = 'text-2xl font-bold text-indigo-800 dark:text-indigo-200 mb-4';
      
      // 根據章節類型設置不同的標題
      if (gameState.currentChapter === 'epilogue') {
        titleElement.textContent = '莊子的告別信';
      } else if (gameState.currentChapter === 'chapter1') {
        titleElement.textContent = '第一章總結';
      } else {
        titleElement.textContent = '章節總結';
      }
      
      summaryElement.appendChild(titleElement);
      
      // 顯示思考狀態
      const thinkingElement = document.createElement('div');
      thinkingElement.className = 'thinking-summary-container py-8';
      thinkingElement.innerHTML = `
        <div class="flex flex-col items-center space-y-4">
          <div class="thinking-avatar w-16 h-16 bg-gradient-to-br from-indigo-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-xl" style="animation: pulse 2s ease-in-out infinite;">
            莊
          </div>
          <div class="thinking-text text-lg text-gray-600 dark:text-gray-400 text-center" style="animation: text-glow-breathe 2s ease-in-out infinite;">
            ${gameState.currentChapter === 'epilogue' ? '正在回顧你的完整旅程，寫下告別信...' : '正在回顧你的哲學之旅，生成個性化總結...'}
          </div>
          <div class="thinking-dots flex justify-center space-x-2">
            <div class="w-3 h-3 bg-indigo-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite"></div>
            <div class="w-3 h-3 bg-indigo-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.3s"></div>
            <div class="w-3 h-3 bg-indigo-400 rounded-full" style="animation: pulse 1.5s ease-in-out infinite 0.6s"></div>
          </div>
        </div>
      `;
      summaryElement.appendChild(thinkingElement);
      gameContent.appendChild(summaryElement);
      
      // 生成章節總結
      let summaryText;
      
      // 再次確保繼續按鈕隱藏
      if (advanceBtn) {
        advanceBtn.style.display = 'none';
        console.log('🔒 AI章節總結：AI生成前再次隱藏繼續按鈕');
      }
      
      try {
        console.log('🔄 準備生成章節總結...');
        const playerData = getAIAnalysisData();
                 console.log('📊 獲取到玩家數據:', {
           choicesCount: playerData.context?.recentHistory?.length || 0,
           traitsCount: Object.keys(playerData.traits || {}).length,
           totalChoicesInHistory: playerData.choices?.length || 0
         });
         
         console.log('📋 最近選擇詳情:', playerData.context?.recentHistory?.slice(-3).map(h => ({
           text: h.choiceText?.substring(0, 30) + '...',
           scene: h.scene,
           chapter: h.chapter
         })) || []);
        
        console.log('🤖 調用AI生成章節總結...');
        summaryText = await zhuangziAI.generateChapterSummary(gameState.currentChapter, playerData);
        
        if (summaryText) {
          console.log('✅ AI章節總結生成成功:', summaryText.substring(0, 50) + '...');
        } else {
          console.warn('⚠️ AI返回空內容，使用預設內容');
          summaryText = scene.baseText;
        }
      } catch (error) {
        console.error('❌ 章節總結生成失敗:', error);
        console.log('🔄 降級使用預設內容:', scene.baseText);
        summaryText = scene.baseText;
        
        // 錯誤情況下也要確保繼續按鈕隱藏
        if (advanceBtn) {
          advanceBtn.style.display = 'none';
          console.log('🔒 AI章節總結：錯誤情況下隱藏繼續按鈕');
        }
      }
      
      // AI回應準備好後，創建最終內容
      const finalContentElement = document.createElement('div');
      finalContentElement.className = 'final-summary-content text-lg leading-relaxed text-gray-700 dark:text-gray-300 mb-6 opacity-0 transition-all duration-800';
      
              // 添加莊子頭像和引言容器
        const quoteContainer = document.createElement('div');
        quoteContainer.className = 'flex items-start mb-4';
        quoteContainer.innerHTML = `
          <div class="w-12 h-12 bg-gradient-to-br from-indigo-400 to-purple-500 rounded-full flex items-center justify-center text-white font-bold text-lg mr-4 flex-shrink-0">
            莊
          </div>
          <div class="flex-1">
            <p class="text-left italic border-l-4 border-indigo-300 dark:border-indigo-600 pl-4 ai-summary-text">
            </p>
          </div>
        `;
        finalContentElement.appendChild(quoteContainer);
        
        // 添加數據統計（如果有的話）
        if (gameState.playerChoices.choiceHistory.length > 0) {
          const statsElement = document.createElement('div');
          statsElement.className = 'grid grid-cols-2 gap-4 mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg';
          
          const choiceCount = gameState.playerChoices.choiceHistory.length;
          const avgThinkingTime = choiceCount > 0 ? 
            Math.round(gameState.playerChoices.choiceHistory.reduce((sum, choice) => 
              sum + (choice.thinkingTime || 0), 0) / choiceCount / 1000 * 10) / 10 : 0; // 轉換為秒，保留1位小數
          
          // 根據章節類型顯示不同的統計數據
          if (gameState.currentChapter === 'epilogue') {
            // 尾聲章節顯示完整遊戲統計
            const gameProgress = getGameProgressSummary();
            statsElement.innerHTML = `
              <div class="text-center">
                <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${gameProgress.totalPlayTime}</div>
                <div class="text-sm text-gray-600 dark:text-gray-400">分鐘旅程</div>
              </div>
              <div class="text-center">
                <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${choiceCount}</div>
                <div class="text-sm text-gray-600 dark:text-gray-400">個選擇</div>
              </div>
              <div class="text-center">
                <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${gameProgress.formsUnlocked}</div>
                <div class="text-sm text-gray-600 dark:text-gray-400">種形態</div>
              </div>
              <div class="text-center">
                <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${gameProgress.aperturesCollected}</div>
                <div class="text-sm text-gray-600 dark:text-gray-400">個封印</div>
              </div>
            `;
            statsElement.className = 'grid grid-cols-4 gap-4 mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg';
          } else {
            // 其他章節顯示選擇統計
          statsElement.innerHTML = `
            <div class="text-center">
              <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${choiceCount}</div>
              <div class="text-sm text-gray-600 dark:text-gray-400">個選擇</div>
            </div>
            <div class="text-center">
              <div class="text-2xl font-bold text-indigo-600 dark:text-indigo-400">${avgThinkingTime}s</div>
              <div class="text-sm text-gray-600 dark:text-gray-400">平均思考時間</div>
            </div>
          `;
            statsElement.className = 'grid grid-cols-2 gap-4 mt-6 p-4 bg-white dark:bg-gray-800 rounded-lg';
          }
          finalContentElement.appendChild(statsElement);
        }
        
        // 開始優雅的過渡動畫
        setTimeout(() => {
          // 過渡動畫開始前再次確保繼續按鈕隱藏
          if (advanceBtn) {
            advanceBtn.style.display = 'none';
            console.log('🔒 AI章節總結：過渡動畫前隱藏繼續按鈕');
          }
          
          const thinkingContainer = summaryElement.querySelector('.thinking-summary-container');
          if (thinkingContainer) {
            thinkingContainer.style.transition = 'opacity 600ms ease-out, transform 600ms ease-out';
            thinkingContainer.style.opacity = '0';
            thinkingContainer.style.transform = 'translateY(-20px)';
            
            // 移除思考狀態並添加AI總結
            setTimeout(() => {
              thinkingContainer.remove();
              summaryElement.appendChild(finalContentElement);
              
              // 淡入AI總結容器
              setTimeout(() => {
                finalContentElement.style.opacity = '1';
                finalContentElement.style.transform = 'translateY(0)';
                
                // 添加發光效果
                finalContentElement.style.animation = 'text-glow-breathe 3s ease-in-out';
                
                // 獲取AI總結文字容器並開始打字機效果
                const aiSummaryTextElement = finalContentElement.querySelector('.ai-summary-text');
                if (aiSummaryTextElement && summaryText) {
                  // 打字機效果開始前最後一次確保繼續按鈕隱藏
                  if (advanceBtn) {
                    advanceBtn.style.display = 'none';
                    console.log('🔒 AI章節總結：打字機效果前隱藏繼續按鈕');
                  }
                  
                  // 清空初始內容
                  aiSummaryTextElement.innerHTML = '';
                  
                  // 開始打字機效果，完成後顯示繼續按鈕
                  startTypewriterEffect(aiSummaryTextElement, summaryText, () => {
                    // 打字機效果完成後才顯示繼續按鈕
                    console.log('📝 AI章節總結打字機效果完成，延遲2秒後顯示繼續按鈕');
                    setTimeout(() => {
                      if (advanceBtn) {
                        advanceBtn.style.display = 'block';
                        console.log('✅ AI章節總結：打字機效果完成後顯示繼續按鈕');
                      }
                    }, 2000);
                  });
                } else {
                  // 如果沒有AI總結文字，直接顯示繼續按鈕
                  console.log('⚠️ 沒有AI總結文字，延遲2秒後顯示繼續按鈕');
                  setTimeout(() => {
                    if (advanceBtn) {
                      advanceBtn.style.display = 'block';
                      console.log('✅ AI章節總結：無AI文字情況下顯示繼續按鈕');
                    }
                  }, 2000);
                }
                
              }, 100);
            }, 600);
          }
        }, 400); // 給章節總結一點時間"生成"
    }
    
    function createNarrativeScene(scene) {
      const narrativeElement = document.createElement('div');
      
      // 检查是否有蜗牛存在，或者是第五章（时间森林），或者是第六章（天地場景），或者是尾聲章節
      const hasSnail = document.querySelector('.snail-shell');
      const isTimeChapter = gameState.currentChapter === 'chapter5';
      const isHeavenEarthChapter = gameState.currentChapter === 'chapter6';
      const isEpilogueChapter = gameState.currentChapter === 'epilogue';
      // 特殊處理：第七章場景39（氣注入後的白色過渡場景）
      const isChapter7Scene39 = gameState.currentChapter === 'chapter7' && gameState.currentScene === 39;
      
      if (hasSnail || isTimeChapter || isHeavenEarthChapter || isChapter7Scene39 || isEpilogueChapter) {
        narrativeElement.className = 'max-w-2xl mx-auto p-6 text-left fixed left-1/2 transform -translate-x-1/2 bg-gray-50 dark:bg-gray-700 bg-opacity-90 dark:bg-opacity-90 rounded-lg shadow-lg border border-gray-300 dark:border-gray-600';
        narrativeElement.style.top = isHeavenEarthChapter ? '1rem' : (isEpilogueChapter ? '50%' : '4rem'); // 第六章文字框上移，尾聲章節垂直居中
        narrativeElement.style.transform = isEpilogueChapter ? 'translate(-50%, -50%)' : 'translateX(-50%)'; // 尾聲章節完全居中
        narrativeElement.style.zIndex = isHeavenEarthChapter ? '70' : (isChapter7Scene39 ? '100' : '20'); // 第七章場景39使用最高層級
        
        // 第七章場景39的特殊樣式處理
        if (isChapter7Scene39) {
          narrativeElement.style.background = 'rgba(255, 255, 255, 0.98)';
          narrativeElement.style.border = '2px solid rgba(100, 100, 100, 0.3)';
          narrativeElement.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.2)';
          narrativeElement.style.backdropFilter = 'blur(10px)';
          // 確保白色背景持續顯示
          gameContainer.style.background = '#ffffff';
        }
        
        // 尾聲章節的特殊樣式處理（垂直居中，半透明背景）
        if (isEpilogueChapter) {
          narrativeElement.style.background = 'rgba(255, 255, 255, 0.9)';
          narrativeElement.style.border = '2px solid rgba(139, 69, 19, 0.3)';
          narrativeElement.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.15)';
          narrativeElement.style.backdropFilter = 'blur(8px)';
        }
      } else {
        narrativeElement.className = 'max-w-2xl mx-auto p-6 text-left bg-gray-50 dark:bg-gray-700 bg-opacity-90 dark:bg-opacity-90 rounded-lg shadow-lg border border-gray-300 dark:border-gray-600';
      }
      
      // 根据章节设置合适的文字颜色
      let textColorClass = 'text-lg md:text-xl leading-relaxed';
      if (isEpilogueChapter) {
        // 尾聲章節使用紫色文字，通過CSS自定義樣式控制
        textColorClass += ' epilogue-text-purple';
      } else if (isChapter7Scene39) {
        // 第七章場景39使用深色文字（在白色背景上）
        textColorClass += ' text-gray-800';
      } else {
        // 敘述場景使用稍微不同的文字顏色，與對話場景區分
        // 亮色模式用深灰色，暗色模式用淺灰色，比對話場景稍淺
        textColorClass += ' text-gray-700 dark:text-gray-300';
      }
      
      narrativeElement.innerHTML = `
        <p class="${textColorClass}">${scene.text}</p>
      `;
      

      
      // 第七章場景39特殊處理：添加到document.body以延續空白效果，使用打字機效果
      if (isChapter7Scene39) {
        // 清空內容，創建純白背景
        gameContent.innerHTML = '';
        gameContainer.style.background = '#ffffff';
        gameContainer.style.transition = 'background 2s ease';
        
        // 注意：不移除氣形態濾鏡效果，讓它保持到下一個場景
        // removeQiVisionEffect();
        
        // 創建緩慢浮現效果的容器
        const fadeInContainer = document.createElement('div');
        fadeInContainer.className = 'fade-in-container';
        fadeInContainer.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          text-align: left;
          z-index: 20;
          width: 90%;
          max-width: 800px;
          font-size: 1.5rem;
          font-family: "Noto Serif SC", "Source Han Serif SC", serif;
          font-weight: 500;
          color: #000000;
          line-height: 1.8;
        `;
        
        // 創建文字元素
        const fadeInText = document.createElement('div');
        fadeInText.className = 'fade-in-text';
        fadeInText.style.cssText = `
          opacity: 0;
          transform: translateY(30px);
          transition: all 3s ease;
        `;
        fadeInText.textContent = scene.text;
        
        fadeInContainer.appendChild(fadeInText);
        document.body.appendChild(fadeInContainer);
        
        // 立即開始緩慢浮現動畫
        setTimeout(() => {
          fadeInText.style.opacity = '1';
          fadeInText.style.transform = 'translateY(0)';
          
          // 3秒後顯示標準繼續按鈕
          setTimeout(() => {
            console.log('第七章場景39：顯示標準繼續按鈕');
            advanceBtn.style.display = 'block';
            advanceBtn.textContent = '繼續';
            
            // 不添加額外的事件監聽器，讓標準的 advanceScene 函數處理章節過渡
            // 第七章場景39的清理邏輯會在 advanceScene 函數的開頭處理
          }, 3000);
        }, 100);
      } else {
        gameContent.appendChild(narrativeElement);
      }
      
      // Handle narrative options if present
      if (scene.options && scene.options.length > 0) {
        // 開始計時選擇思考時間
        startChoiceTimer();
        
        // Create options container with high z-index to ensure it's above background elements
        const optionsContainer = document.createElement('div');
        optionsContainer.className = 'max-w-2xl mx-auto mt-6 space-y-3 relative';
        optionsContainer.style.zIndex = '100'; // 確保選項按鈕在所有背景元素之上
        
        scene.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.className = 'w-full bg-indigo-100 hover:bg-indigo-200 dark:bg-indigo-900 dark:hover:bg-indigo-800 text-indigo-800 dark:text-indigo-200 font-semibold py-3 px-4 rounded text-left transition-all duration-200 relative';
          button.style.zIndex = '101'; // 確保按鈕在選項容器之上
          button.textContent = option.text;
          button.addEventListener('click', () => {
            // 記錄玩家選擇（在場景切換之前）
            const choiceData = {
              text: option.text,
              index: index,
              speaker: scene.speaker || 'narrator',
              situation: getCurrentSituation()
            };
            
            // 處理8維度特質結構
            if (option.traits) {
              console.log('🔍 ===== 選擇處理調試信息 (選項場景) =====');
              console.log('📝 選擇文本:', option.text);
              console.log('🎭 說話者:', scene.speaker);
              console.log('📚 章節:', gameState.currentChapter);
              console.log('🎯 原始特質標記:', option.traits);
              
              // 直接使用8維度特質標記
              choiceData.traits = option.traits;
              
              console.log('✅ 最終選擇數據:', choiceData);
              console.log('========================================');
            } else {
              console.log('⚠️ 選項沒有特質標記，使用默認空值');
              choiceData.traits = {};
            }
            
            recordPlayerChoice(choiceData);
            
            // 原有的場景切換邏輯
            gameState.currentScene = option.next;
            loadScene();
          });
          optionsContainer.appendChild(button);
        });
        
        // 第七章場景39特殊處理：選項容器也添加到document.body
        if (isChapter7Scene39) {
          // 場景39不使用選項，使用自定義繼續按鈕
          console.log('🌟 場景39跳過選項處理，使用自定義繼續按鈕');
        } else {
          gameContent.appendChild(optionsContainer);
        }
        
        // Don't show advance button for options
        advanceBtn.style.display = 'none';
      } else {
        advanceBtn.style.display = 'block';
        
        // 第七章場景39的繼續按鈕特殊樣式處理（已由自定義按鈕替代）
        if (isChapter7Scene39) {
          // 場景39使用自定義繼續按鈕，不需要處理原有按鈕
          console.log('🌟 場景39使用自定義繼續按鈕');
        }
        
        // 🔧 测试功能：第八章第一个场景添加跳过萬物尋氣按钮 - 已隐藏
        const isChapter8FirstScene = gameState.currentChapter === 'chapter7' && gameState.currentScene === 0;
        if (isChapter8FirstScene && false) { // 添加 && false 來禁用測試按鈕
          console.log('🔧 第八章第一个场景，添加跳过萬物尋氣测试按钮');
          
          // 为继续按钮添加额外的下边距，为测试按钮预留空间
          advanceBtn.style.marginBottom = '1rem';
          
          // 创建测试按钮容器
          const testButtonContainer = document.createElement('div');
          testButtonContainer.className = 'max-w-2xl mx-auto mt-6 text-center';
          
          // 创建测试按钮
          const testButton = document.createElement('button');
          testButton.className = 'bg-red-500 hover:bg-red-600 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition-all duration-200 transform hover:scale-105';
          testButton.textContent = '🔧 跳过萬物尋氣测试按钮';
          testButton.style.cssText = `
            display: block;
            margin: 0 auto;
            border: 2px solid #dc2626;
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
            font-size: 1rem;
            font-weight: 700;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
            animation: test-button-pulse 2s infinite;
          `;
          
          testButton.addEventListener('click', () => {
            console.log('🔧 第八章第一个场景测试按钮被点击，跳转到萬物尋氣成功结束的场景');
            
            // 设置游戏状态：萬物尋氣已完成，气形态已解锁
            gameState.wanwuXunqiCompleted = true;
            gameState.unlockedForms.push('qi');
            
            // 立即保存遊戲進度，確保氣形態解鎖數據不丟失
            saveGameProgress();
            
            // 跳转到场景18（萬物尋氣成功结束后的场景）
            gameState.currentScene = 18;
            loadScene();
          });
          
          testButtonContainer.appendChild(testButton);
          
          // 添加说明文字
          const testNote = document.createElement('div');
          testNote.className = 'mt-3 text-sm text-gray-600 dark:text-gray-400 text-center';
          testNote.innerHTML = `
            <p>⚠️ 测试功能：直接跳转到萬物尋氣成功结束的场景</p>
            <p>用于快速测试气形态物化视野的修改效果</p>
          `;
          testButtonContainer.appendChild(testNote);
          
          // 将测试按钮添加到游戏内容区域
          gameContent.appendChild(testButtonContainer);
          
          // 添加测试按钮的动画样式
          if (!document.getElementById('test-button-pulse-styles')) {
            const styleElement = document.createElement('style');
            styleElement.id = 'test-button-pulse-styles';
            styleElement.textContent = `
              @keyframes test-button-pulse {
                0%, 100% {
                  box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3);
                }
                50% {
                  box-shadow: 0 4px 20px rgba(239, 68, 68, 0.6), 0 0 30px rgba(239, 68, 68, 0.4);
                }
              }
            `;
            document.head.appendChild(styleElement);
          }
        }
      }
    }
    
    function createCloudEffectScene(scene) {
      const cloudEffectElement = document.createElement('div');
      cloudEffectElement.className = 'max-w-2xl mx-auto p-6 text-left relative';
      
      // Add cloud visual effects
      const cloudContainer = document.createElement('div');
      cloudContainer.className = 'absolute inset-0 pointer-events-none';
      
      // Create several decorative clouds
      for (let i = 0; i < 8; i++) {
        const cloud = document.createElement('div');
        const size = 50 + Math.random() * 100;
        const opacity = 0.4 + Math.random() * 0.4;
        
        cloud.className = 'cloud absolute';
        cloud.style.width = `${size}px`;
        cloud.style.height = `${size * 0.6}px`;
        cloud.style.left = `${Math.random() * 100}%`;
        cloud.style.top = `${Math.random() * 100}%`;
        cloud.style.opacity = opacity.toString();
        
        // Set random cloud animation parameters
        cloud.style.setProperty('--cloud-dx', `${(Math.random() * 40 - 20)}px`);
        cloud.style.setProperty('--cloud-dy', `${(Math.random() * 20 - 10)}px`);
        cloud.style.animation = `float-cloud ${5 + Math.random() * 7}s infinite ease-in-out alternate`;
        cloud.style.animationDelay = `${Math.random() * 5}s`;
        
        cloudContainer.appendChild(cloud);
      }
      
      cloudEffectElement.appendChild(cloudContainer);
      
      // Add text on top of clouds
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed relative z-10 text-gray-800 dark:text-white';
      textElement.textContent = scene.text;
      cloudEffectElement.appendChild(textElement);
      
      gameContent.appendChild(cloudEffectElement);
      advanceBtn.style.display = 'block';
    }
    

    
    function createSpiralEffectScene(scene) {
      const spiralEffectElement = document.createElement('div');
      spiralEffectElement.className = 'max-w-2xl mx-auto p-6 text-left relative z-10';
      spiralEffectElement.style.minHeight = '400px';
      spiralEffectElement.style.display = 'flex';
      spiralEffectElement.style.flexDirection = 'column';
      spiralEffectElement.style.justifyContent = 'center';
      spiralEffectElement.style.alignItems = 'center';
      
      // 確保螺旋背景已經創建
      if (!document.getElementById('spiral-chapter-bg')) {
        createSpiralBackground();
      }
      
      // Add spiral animations CSS if not already present
      if (!document.getElementById('spiral-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'spiral-animations';
        styleElement.textContent = `
          @keyframes spiral-rotate {
            0% { transform: translate(-50%, -50%) rotate(0deg); }
            100% { transform: translate(-50%, -50%) rotate(360deg); }
          }
          
          @keyframes spiral-pulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 0.9; }
          }
          
          @keyframes spiral-particle-float {
            0% { transform: translate(-50%, -50%) rotate(0deg) translateX(var(--orbit-radius)) scale(1); }
            100% { transform: translate(-50%, -50%) rotate(360deg) translateX(var(--orbit-radius)) scale(var(--end-scale)); }
          }
          
          .spiral-text {
            animation: spiral-text-float 6s infinite ease-in-out;
          }
          
          @keyframes spiral-text-float {
            0%, 100% { transform: rotate(-3deg) scale(1); }
            50% { transform: rotate(3deg) scale(1.03); }
          }
          
          @keyframes text-glow {
            0%, 100% { text-shadow: 0 0 10px rgba(147, 50, 158, 0.8), 0 0 5px rgba(80, 50, 160, 1); }
            50% { text-shadow: 0 0 20px rgba(147, 50, 158, 1), 0 0 10px rgba(80, 50, 160, 1), 0 0 30px rgba(147, 50, 158, 0.6); }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      // Create floating text effect container
      const textContainer = document.createElement('div');
      textContainer.className = 'relative z-20 p-8 rounded-lg';
      textContainer.style.background = 'transparent'; // 設置為透明背景
      textContainer.style.backdropFilter = 'none'; // 移除模糊效果以更好地顯示粒子
      textContainer.style.border = '1px solid rgba(147, 50, 158, 0.5)'; // 稍微增強邊框可見度
      textContainer.style.boxShadow = '0 0 40px rgba(147, 50, 158, 0.6)'; // 增強外發光效果
      
      // Add text with enhanced effects
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed text-white spiral-text';
      textElement.textContent = scene.text;
      textElement.style.animation = 'spiral-text-float 6s infinite ease-in-out, text-glow 4s infinite ease-in-out';
      textElement.style.fontWeight = '500';
      textElement.style.letterSpacing = '0.5px';
      
      textContainer.appendChild(textElement);
      spiralEffectElement.appendChild(textContainer);
      
      // Add some floating particles around the text
      for (let i = 0; i < 8; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full pointer-events-none';
        
        const size = 4 + Math.random() * 6;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.background = `rgba(${147 + Math.random() * 30}, ${50 + Math.random() * 30}, ${158 + Math.random() * 40}, ${0.6 + Math.random() * 0.4})`;
        particle.style.boxShadow = `0 0 ${size * 3}px rgba(147, 50, 158, 0.8)`;
        
        // Random position around the text container
        const angle = (i / 8) * Math.PI * 2;
        const distance = 100 + Math.random() * 50;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.left = `calc(50% + ${x}px)`;
        particle.style.top = `calc(50% + ${y}px)`;
        particle.style.transform = 'translate(-50%, -50%)';
        
        // Animation
        const duration = 8 + Math.random() * 12;
        const delay = Math.random() * 5;
        particle.style.animation = `spiral-particle-float ${duration}s ${delay}s infinite linear`;
        
        // Set orbit radius for animation
        particle.style.setProperty('--orbit-radius', `${30 + Math.random() * 20}px`);
        particle.style.setProperty('--end-scale', `${0.5 + Math.random() * 0.5}`);
        
        spiralEffectElement.appendChild(particle);
      }
      
      gameContent.appendChild(spiralEffectElement);
      
      // 確保顯示繼續按鈕
      setTimeout(() => {
        advanceBtn.style.display = 'block';
      }, 100);
    }
    
    // 簡化的星雲層創建函數 - 必須在使用前定義
    function createNebulaLayer(container, config) {
      const nebula = document.createElement('div');
      nebula.className = 'absolute rounded-full';
      
      // 設置位置
      if (config.position) {
        nebula.style.left = config.position.left;
        nebula.style.top = config.position.top;
        nebula.style.transform = 'translate(-50%, -50%)';
      } else {
        nebula.style.left = '50%';
        nebula.style.top = '50%';
        nebula.style.transform = 'translate(-50%, -50%)';
      }
      
      // 設置大小和外觀
      nebula.style.width = config.size;
      nebula.style.height = config.size;
      nebula.style.background = `radial-gradient(circle, ${config.colors.join(', ')})`;
      nebula.style.filter = `blur(${config.blur})`;
      
      // 設置動畫
      const rotation = config.reverse ? 'reverse' : '';
      nebula.style.animation = `nebula-rotate ${config.duration} linear infinite ${rotation}, nebula-pulse ${parseInt(config.duration) / 4}s ease-in-out infinite`;
      
      container.appendChild(nebula);
    }
    
    // 簡化的星空創建函數 - 必須在使用前定義
    function createStarField(container, count) {
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = 'absolute rounded-full';
        
        // 隨機大小和位置
        const size = 1 + Math.random() * 3;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        
        // 隨機顏色和光效
        const colors = [
          'rgba(255, 255, 255, 0.8)',
          'rgba(147, 146, 255, 0.7)', 
          'rgba(103, 200, 208, 0.6)',
          'rgba(255, 200, 150, 0.7)'
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];
        star.style.backgroundColor = color;
        star.style.boxShadow = `0 0 ${size * 3}px ${color}`;
        
        // 閃爍動畫
        const twinkleDelay = Math.random() * 5;
        const twinkleDuration = 2 + Math.random() * 4;
        star.style.animation = `star-twinkle ${twinkleDuration}s ease-in-out infinite ${twinkleDelay}s`;
        
        container.appendChild(star);
      }
    }
    
    // 創建銀河星團系統 - 圍繞中心軌道運動的星星群
    function createGalaxyStarClusters(container) {
      // 創建多個星團，每個星團有不同的軌道半徑
      const clusterCount = 6;
      
      for (let cluster = 0; cluster < clusterCount; cluster++) {
        const clusterContainer = document.createElement('div');
        clusterContainer.className = 'absolute';
        clusterContainer.style.left = '50%';
        clusterContainer.style.top = '50%';
        clusterContainer.style.transform = 'translate(-50%, -50%)';
        
        // 每個星團包含多顆星星
        const starsInCluster = 8 + Math.random() * 12;
        const orbitRadius = 100 + cluster * 80; // 不同的軌道半徑
        
        for (let star = 0; star < starsInCluster; star++) {
          const starElement = document.createElement('div');
          starElement.className = 'absolute rounded-full';
          
          // 星星大小
          const size = 1.5 + Math.random() * 2.5;
          starElement.style.width = `${size}px`;
          starElement.style.height = `${size}px`;
          
          // 星星在星團內的角度分布
          const angleInCluster = (star / starsInCluster) * Math.PI * 2;
          const radiusVariation = orbitRadius + (Math.random() - 0.5) * 40;
          
          // 設置初始位置
          const x = Math.cos(angleInCluster) * radiusVariation;
          const y = Math.sin(angleInCluster) * radiusVariation;
          
          starElement.style.left = `calc(50% + ${x}px)`;
          starElement.style.top = `calc(50% + ${y}px)`;
          starElement.style.transform = 'translate(-50%, -50%)';
          
          // 星星顏色
          const colors = [
            'rgba(255, 255, 255, 0.7)',
            'rgba(147, 146, 255, 0.6)', 
            'rgba(103, 200, 208, 0.5)',
            'rgba(255, 200, 150, 0.6)'
          ];
          const color = colors[Math.floor(Math.random() * colors.length)];
          starElement.style.backgroundColor = color;
          starElement.style.boxShadow = `0 0 ${size * 2}px ${color}`;
          
          // 設置軌道運動動畫
          starElement.style.setProperty('--orbit-radius', `${radiusVariation}px`);
          starElement.style.setProperty('--star-opacity', `${0.4 + Math.random() * 0.3}`);
          
          // 軌道運動動畫，不同星團有不同速度
          const orbitDuration = 180 + cluster * 60 + Math.random() * 120;
          const delay = Math.random() * orbitDuration;
          starElement.style.animation = `star-orbital-motion ${orbitDuration}s ${delay}s infinite linear`;
          
          clusterContainer.appendChild(starElement);
        }
        
        container.appendChild(clusterContainer);
      }
    }
    
    // 創建背景星星 - 不旋轉的遠景恆星
    function createBackgroundStars(container, count) {
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = 'absolute rounded-full pointer-events-none';
        
        // 背景星星較小且較暗
        const size = 0.5 + Math.random() * 1.5;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        
        // 使用較暗的顏色，模擬遠距離恆星
        const colors = [
          'rgba(255, 255, 255, 0.3)',
          'rgba(200, 200, 255, 0.2)', 
          'rgba(255, 200, 200, 0.25)',
          'rgba(200, 255, 200, 0.2)'
        ];
        const color = colors[Math.floor(Math.random() * colors.length)];
        star.style.backgroundColor = color;
        star.style.boxShadow = `0 0 ${size * 2}px ${color}`;
        
        // 緩慢的閃爍動畫
        star.style.setProperty('--base-opacity', `${0.2 + Math.random() * 0.2}`);
        const twinkleDuration = 8 + Math.random() * 12;
        const delay = Math.random() * twinkleDuration;
        star.style.animation = `star-twinkle-enhanced ${twinkleDuration}s ${delay}s ease-in-out infinite`;
        
        container.appendChild(star);
      }
    }

    function createSpiralBackground() {
      // 檢查是否已存在螺旋背景，避免重複創建
      if (document.getElementById('spiral-chapter-bg')) {
        return;
      }
      
      // 創建宇宙星空背景容器
      const cosmicBackground = document.createElement('div');
      cosmicBackground.id = 'spiral-chapter-bg';
      cosmicBackground.className = 'cosmic-background';
      cosmicBackground.style.position = 'fixed';
      cosmicBackground.style.top = '0';
      cosmicBackground.style.left = '0';
      cosmicBackground.style.width = '100%';
      cosmicBackground.style.height = '100%';
      cosmicBackground.style.zIndex = '-1';
      cosmicBackground.style.overflow = 'hidden';
      
      // 設置星空漸變背景
      cosmicBackground.style.background = `
        radial-gradient(ellipse at 20% 30%, rgba(72, 61, 139, 0.6) 0%, transparent 50%),
        radial-gradient(ellipse at 80% 70%, rgba(75, 0, 130, 0.5) 0%, transparent 50%),
        radial-gradient(ellipse at 50% 50%, rgba(25, 25, 112, 0.4) 0%, transparent 60%),
        linear-gradient(135deg, #000428 0%, #004e92 25%, #483d8b 50%, #2f1b69 75%, #0f0c29 100%)
      `;
      
      // 創建星雲層
      createNebulaLayers(cosmicBackground);
      
      // 創建旋轉星空容器
      const rotatingStarfield = document.createElement('div');
      rotatingStarfield.className = 'rotating-starfield';
      rotatingStarfield.style.position = 'absolute';
      rotatingStarfield.style.width = '200%';
      rotatingStarfield.style.height = '200%';
      rotatingStarfield.style.left = '-50%';
      rotatingStarfield.style.top = '-50%';
      rotatingStarfield.style.animation = 'cosmic-rotation 300s linear infinite';
      
      // 創建多層星星
      createStarLayers(rotatingStarfield);
      
      // 創建背景星星（不旋轉）
      createBackgroundStars(cosmicBackground, 150);
      
      cosmicBackground.appendChild(rotatingStarfield);
      
      // 添加到遊戲容器
      gameContainer.appendChild(cosmicBackground);
      
      // 添加宇宙星空動畫樣式
      if (!document.getElementById('cosmic-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'cosmic-animations';
        styleElement.textContent = `
          .spiral-scene {
            background: transparent !important;
          }
          
          /* 星雲旋轉動畫 */
          @keyframes cosmic-rotation {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          /* 星雲脈動動畫 */
          @keyframes nebula-pulse {
            0%, 100% { opacity: 0.6; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.05); }
          }
          
          /* 星星閃爍動畫 */
          @keyframes star-twinkle {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            25% { opacity: 0.8; transform: scale(1.1); }
            50% { opacity: 1; transform: scale(1.2); }
            75% { opacity: 0.6; transform: scale(1.05); }
          }
          
          /* 增強版星星閃爍 */
          @keyframes star-twinkle-enhanced {
            0%, 100% { opacity: var(--base-opacity, 0.3); transform: scale(1); }
            20% { opacity: 0.7; transform: scale(1.15); }
            40% { opacity: 1; transform: scale(1.3); }
            60% { opacity: 0.8; transform: scale(1.1); }
            80% { opacity: 0.5; transform: scale(1.05); }
          }
          
          /* 軌道運動動畫 */
          @keyframes star-orbital-motion {
            0% { transform: rotate(0deg) translateX(var(--orbit-radius)) rotate(0deg); opacity: var(--star-opacity, 0.6); }
            25% { opacity: 0.9; }
            50% { opacity: 1; }
            75% { opacity: 0.7; }
            100% { transform: rotate(360deg) translateX(var(--orbit-radius)) rotate(-360deg); opacity: var(--star-opacity, 0.6); }
          }
          
          /* 確保文字在深色背景上清晰可見 */
          .spiral-scene .text-white {
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.9), 0 0 12px rgba(147, 50, 158, 0.8), 0 0 4px rgba(0, 0, 0, 1);
            font-weight: 500;
          }
          
          .spiral-scene .text-lg,
          .spiral-scene .text-xl {
            text-shadow: 1px 1px 4px rgba(0, 0, 0, 0.9), 0 0 10px rgba(147, 50, 158, 0.6), 0 0 3px rgba(0, 0, 0, 1);
            font-weight: 500;
          }
          
          /* 星空背景樣式 */
          .cosmic-background {
            will-change: transform;
          }
          
          .rotating-starfield {
            transform-origin: 50% 50%;
            will-change: transform;
          }
          
          /* 星雲樣式 */
          .cosmic-nebula {
            position: absolute;
            border-radius: 50%;
            filter: blur(20px);
            opacity: 0.4;
            animation: nebula-pulse 15s infinite ease-in-out;
          }
          
          /* 星星基礎樣式 */
          .cosmic-star {
            position: absolute;
            border-radius: 50%;
            transform-origin: center;
          }
          
          /* 黃色星星 */
          .star-yellow {
            background: radial-gradient(circle, rgba(255, 255, 150, 1) 0%, rgba(255, 215, 0, 0.8) 50%, rgba(255, 215, 0, 0) 100%);
            box-shadow: 0 0 6px rgba(255, 215, 0, 0.8), 0 0 12px rgba(255, 215, 0, 0.4);
          }
          
          /* 藍色星星 */
          .star-blue {
            background: radial-gradient(circle, rgba(173, 216, 230, 1) 0%, rgba(100, 149, 237, 0.8) 50%, rgba(100, 149, 237, 0) 100%);
            box-shadow: 0 0 6px rgba(100, 149, 237, 0.8), 0 0 12px rgba(100, 149, 237, 0.4);
          }
          
          /* 白色星星 */
          .star-white {
            background: radial-gradient(circle, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0.8) 50%, rgba(255, 255, 255, 0) 100%);
            box-shadow: 0 0 6px rgba(255, 255, 255, 0.8), 0 0 12px rgba(255, 255, 255, 0.4);
          }
          
          /* 紫色星星（特殊） */
          .star-purple {
            background: radial-gradient(circle, rgba(221, 160, 221, 1) 0%, rgba(147, 112, 219, 0.8) 50%, rgba(147, 112, 219, 0) 100%);
            box-shadow: 0 0 6px rgba(147, 112, 219, 0.8), 0 0 12px rgba(147, 112, 219, 0.4);
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建星雲層
    function createNebulaLayers(container) {
      const nebulaConfigs = [
        {
          size: '400px',
          position: { left: '15%', top: '20%' },
          colors: ['rgba(72, 61, 139, 0.3)', 'rgba(123, 104, 238, 0.2)', 'transparent'],
          blur: '25px',
          duration: '20s'
        },
        {
          size: '350px',
          position: { left: '70%', top: '60%' },
          colors: ['rgba(75, 0, 130, 0.4)', 'rgba(138, 43, 226, 0.2)', 'transparent'],
          blur: '30px',
          duration: '25s',
          reverse: true
        },
        {
          size: '300px',
          position: { left: '40%', top: '80%' },
          colors: ['rgba(25, 25, 112, 0.3)', 'rgba(65, 105, 225, 0.2)', 'transparent'],
          blur: '20px',
          duration: '30s'
        },
        {
          size: '250px',
          position: { left: '80%', top: '15%' },
          colors: ['rgba(147, 50, 158, 0.3)', 'rgba(186, 85, 211, 0.2)', 'transparent'],
          blur: '18px',
          duration: '35s',
          reverse: true
        }
      ];
      
      nebulaConfigs.forEach((config, index) => {
        createNebulaLayer(container, config);
      });
    }
    
    // 創建多層星星
    function createStarLayers(container) {
      // 內層星團 - 較大較亮的星星
      createGalaxyStarClusters(container);
      
      // 中層散佈星星
      createRandomStars(container, 80, 'medium');
      
      // 外層小星星
      createRandomStars(container, 120, 'small');
    }
    
    // 創建隨機分佈的星星
    function createRandomStars(container, count, size) {
      const colors = ['star-yellow', 'star-blue', 'star-white', 'star-purple'];
      const sizeMap = {
        small: { min: 1, max: 3 },
        medium: { min: 2, max: 5 },
        large: { min: 4, max: 8 }
      };
      
      for (let i = 0; i < count; i++) {
        const star = document.createElement('div');
        star.className = `cosmic-star ${colors[Math.floor(Math.random() * colors.length)]}`;
        
        // 隨機大小
        const starSize = sizeMap[size];
        const starWidth = starSize.min + Math.random() * (starSize.max - starSize.min);
        star.style.width = `${starWidth}px`;
        star.style.height = `${starWidth}px`;
        
        // 隨機位置 - 避免太靠近中心
        let x, y, distanceFromCenter;
        do {
          x = Math.random() * 100;
          y = Math.random() * 100;
          distanceFromCenter = Math.sqrt(Math.pow(x - 50, 2) + Math.pow(y - 50, 2));
        } while (distanceFromCenter < 15); // 確保不會太靠近中心
        
        star.style.left = `${x}%`;
        star.style.top = `${y}%`;
        
        // 隨機閃爍動畫
        const twinkleDuration = 3 + Math.random() * 8;
        const twinkleDelay = Math.random() * 10;
        star.style.animation = `star-twinkle ${twinkleDuration}s ${twinkleDelay}s infinite ease-in-out`;
        
        container.appendChild(star);
      }
    }
    
    // 特別設置一個函數來創建並顯示蝸牛
    function createSnailAndKingdoms() {
      // 檢查是否已經存在蝸牛，避免重複創建
      if (document.querySelector('.snail-shell')) {
        return;
      }
      
      // 创建一个完整蜗牛的几何背景
      const snailShellContainer = document.createElement('div');
      snailShellContainer.className = 'absolute pointer-events-none';
      snailShellContainer.style.width = '100%';
      snailShellContainer.style.height = '100%';
      snailShellContainer.style.overflow = 'hidden';
      snailShellContainer.style.zIndex = '1';
      
      // 创建emoji蜗牛
      const snailShell = document.createElement('div');
      snailShell.className = 'snail-shell';
      
      // 基础蜗牛元素 - 使用emoji
      const snailElement = document.createElement('div');
      snailElement.className = 'snail-emoji';
      snailElement.style.position = 'relative';
      snailElement.style.width = '200px';
      snailElement.style.height = '200px';
      snailElement.style.fontSize = '180px';
      snailElement.style.display = 'flex';
      snailElement.style.alignItems = 'center';
      snailElement.style.justifyContent = 'center';
      snailElement.style.filter = 'drop-shadow(0 0 10px rgba(147, 50, 158, 0.4))';
      snailElement.style.transition = 'all 0.5s ease';
      snailElement.textContent = '🐌';
      
      // 创建触角眼睛定位标记（不可见，仅用于定位）
      const leftEyeMarker = document.createElement('div');
      leftEyeMarker.id = 'left-eye-marker';
      leftEyeMarker.style.position = 'absolute';
      leftEyeMarker.style.width = '8px';
      leftEyeMarker.style.height = '8px';
      leftEyeMarker.style.borderRadius = '50%';
      leftEyeMarker.style.background = 'transparent'; // 透明，不可见
      leftEyeMarker.style.left = '60px';  // 調整到左觸角眼睛位置
      leftEyeMarker.style.top = '25px';   // 調整高度
      leftEyeMarker.style.zIndex = '10';
      
      const rightEyeMarker = document.createElement('div');
      rightEyeMarker.id = 'right-eye-marker';
      rightEyeMarker.style.position = 'absolute';
      rightEyeMarker.style.width = '8px';
      rightEyeMarker.style.height = '8px';
      rightEyeMarker.style.borderRadius = '50%';
      rightEyeMarker.style.background = 'transparent'; // 透明，不可见
      rightEyeMarker.style.left = '85px'; // 調整到右觸角眼睛位置
      rightEyeMarker.style.top = '25px';  // 調整高度
      rightEyeMarker.style.zIndex = '10';
      
      snailElement.appendChild(leftEyeMarker);
      snailElement.appendChild(rightEyeMarker);
      
      // 创建蜗牛王国容器
      const kingdomsContainer = document.createElement('div');
      kingdomsContainer.className = 'kingdoms-container';
      kingdomsContainer.style.position = 'absolute';
      kingdomsContainer.style.top = 0;
      kingdomsContainer.style.left = 0;
      kingdomsContainer.style.width = '100%';
      kingdomsContainer.style.height = '100%';
      kingdomsContainer.style.pointerEvents = 'none';
      
      // 创建左触角王国（触氏国）- 使用相对于蜗牛的精确位置
      const touchKingdom = document.createElement('div');
      touchKingdom.className = 'kingdom-circle';
      touchKingdom.id = 'touch-kingdom-circle';
      touchKingdom.style.position = 'absolute'; // 使用absolute定位相对于蜗牛
      touchKingdom.style.width = '24px'; // 擴大一倍的大小
      touchKingdom.style.height = '24px';
      touchKingdom.style.borderRadius = '50%';
      touchKingdom.style.backgroundColor = '#aa6ed8'; // 添加紫色系，代表触氏国
      touchKingdom.style.border = '2px solid rgba(170, 120, 220, 0.8)'; // 添加明亮的边框
      // 使用精確的相對于蜗牛中心的坐标，整體向左上方偏移21px (-80, -80)
      touchKingdom.style.left = 'calc(50% + -80px - 6px)'; // 相对坐标 X - 圆点半径
      touchKingdom.style.top = 'calc(50% + -80px - 6px)'; // 相对坐标 Y - 圆点半径
      touchKingdom.style.transform = 'none'; // 不使用transform避免双重偏移
      touchKingdom.style.zIndex = '11';
      touchKingdom.style.cursor = 'pointer';
      touchKingdom.style.pointerEvents = 'auto';
      // 添加吸引人的脉冲发光效果
      touchKingdom.style.boxShadow = '0 0 8px rgba(170, 120, 220, 0.7), 0 0 12px rgba(170, 120, 220, 0.4)';
      touchKingdom.style.animation = 'touch-pulse 3s infinite ease-in-out';
      touchKingdom.innerHTML = '<span style="position:absolute; top:-25px; left:50%; transform:translateX(-50%); white-space:nowrap; font-size:12px; background:rgba(0,0,0,0.6); color:white; padding:2px 6px; border-radius:3px; opacity:0; transition:opacity 0.3s ease;">觸氏國</span>';
      
      // 添加悬停效果
      touchKingdom.addEventListener('mouseenter', () => {
        touchKingdom.querySelector('span').style.opacity = '1';
        // 强调高亮显示
        touchKingdom.style.border = '2px solid rgba(190, 140, 240, 1)';
        touchKingdom.style.boxShadow = '0 0 12px rgba(170, 120, 220, 0.9), 0 0 20px rgba(170, 120, 220, 0.6)';
        touchKingdom.style.transform = 'scale(1.1)'; // 轻微放大
      });
      touchKingdom.addEventListener('mouseleave', () => {
        touchKingdom.querySelector('span').style.opacity = '0';
        // 恢复原始状态
        touchKingdom.style.border = '2px solid rgba(170, 120, 220, 0.8)';
        touchKingdom.style.boxShadow = '0 0 8px rgba(170, 120, 220, 0.7), 0 0 12px rgba(170, 120, 220, 0.4)';
        touchKingdom.style.transform = 'scale(1)';
      });
      
      // 添加拖拽功能
      makeDraggable(touchKingdom, 'touch-kingdom-circle');
      
      // 创建右触角王国（蛮氏国）- 使用相对于蜗牛的精确位置，整體向左上方偏移10px
      const savageKingdom = document.createElement('div');
      savageKingdom.className = 'kingdom-circle';
      savageKingdom.id = 'savage-kingdom-circle';
      savageKingdom.style.position = 'absolute'; // 使用absolute定位相对于蜗牛
      savageKingdom.style.width = '24px'; // 擴大一倍的大小
      savageKingdom.style.height = '24px';
      savageKingdom.style.borderRadius = '50%';
      savageKingdom.style.backgroundColor = '#357ec7'; // 蓝色系，代表蛮氏国
      savageKingdom.style.border = '2px solid rgba(120, 220, 250, 0.8)'; // 添加明亮的边框
      // 使用精确的相对于蜗牛中心的坐标，整體向左上方偏移20.5px (-57, -79.5)
      savageKingdom.style.left = 'calc(50% + -57px - 6px)'; // 相对坐标 X - 圆点半径
      savageKingdom.style.top = 'calc(50% + -79.5px - 6px)'; // 相对坐标 Y - 圆点半径
      savageKingdom.style.transform = 'none'; // 不使用transform避免双重偏移
      savageKingdom.style.zIndex = '11';
      savageKingdom.style.cursor = 'pointer';
      savageKingdom.style.pointerEvents = 'auto';
      // 添加吸引人的脉冲发光效果
      savageKingdom.style.boxShadow = '0 0 8px rgba(53, 126, 199, 0.7), 0 0 12px rgba(53, 126, 199, 0.4)';
      savageKingdom.style.animation = 'savage-pulse 3s infinite ease-in-out';
      savageKingdom.innerHTML = '<span style="position:absolute; top:-25px; left:50%; transform:translateX(-50%); white-space:nowrap; font-size:12px; background:rgba(0,0,0,0.6); color:white; padding:2px 6px; border-radius:3px; opacity:0; transition:opacity 0.3s ease;">蠻氏國</span>';
      
      // 添加悬停效果
      savageKingdom.addEventListener('mouseenter', () => {
        savageKingdom.querySelector('span').style.opacity = '1';
        // 强调高亮显示
        savageKingdom.style.border = '2px solid rgba(120, 220, 250, 1)';
        savageKingdom.style.boxShadow = '0 0 12px rgba(53, 126, 199, 0.9), 0 0 20px rgba(53, 126, 199, 0.6)';
        savageKingdom.style.transform = 'scale(1.1)'; // 轻微放大
      });
      savageKingdom.addEventListener('mouseleave', () => {
        savageKingdom.querySelector('span').style.opacity = '0';
        // 恢复原始状态
        savageKingdom.style.border = '2px solid rgba(120, 220, 250, 0.8)';
        savageKingdom.style.boxShadow = '0 0 8px rgba(53, 126, 199, 0.7), 0 0 12px rgba(53, 126, 199, 0.4)';
        savageKingdom.style.transform = 'scale(1)';
      });
      
      // 添加拖拽功能
      makeDraggable(savageKingdom, 'savage-kingdom-circle');
      
      // 装配王国元素
      kingdomsContainer.appendChild(touchKingdom);
      kingdomsContainer.appendChild(savageKingdom);
      
      // 创建视角指示器
      const perspectiveIndicator = document.createElement('div');
      perspectiveIndicator.className = 'snail-perspective-indicator';
      perspectiveIndicator.id = 'snail-perspective-indicator';
      perspectiveIndicator.style.position = 'absolute';
      perspectiveIndicator.style.width = '100%';
      perspectiveIndicator.style.height = '100%';
      perspectiveIndicator.style.display = 'flex';
      perspectiveIndicator.style.justifyContent = 'center';
      perspectiveIndicator.style.alignItems = 'center';
      perspectiveIndicator.style.color = 'rgba(255, 255, 255, 0.7)';
      perspectiveIndicator.style.fontSize = '24px';
      perspectiveIndicator.style.zIndex = '1';
      perspectiveIndicator.style.opacity = '0';
      perspectiveIndicator.style.transition = 'opacity 0.5s ease';
      perspectiveIndicator.innerHTML = `
        <div class="text-center">
          <div class="font-bold text-2xl mb-2">微觀視角</div>
          <div class="text-sm opacity-75">你看到了蝸牛角上的國家</div>
        </div>
      `;
      
      // 添加所有元素到蜗牛容器
      snailShell.appendChild(snailElement);
      snailShell.appendChild(kingdomsContainer);
      snailShell.appendChild(perspectiveIndicator);
      
      // 创建左触角国家 - 触氏国
      const leftKingdom = document.createElement('div');
      leftKingdom.className = 'kingdom left';
      leftKingdom.innerHTML = `
        <div class="kingdom-label">觸氏國</div>
      `;
      
      // 创建右触角国家 - 蛮氏国
      const rightKingdom = document.createElement('div');
      rightKingdom.className = 'kingdom right';
      rightKingdom.innerHTML = `
        <div class="kingdom-label">蠻氏國</div>
      `;
      
      // 检查是否已存在视角指示器，如果不存在才创建
      let viewIndicator = document.getElementById('snail-perspective-indicator');
      if (!viewIndicator) {
        viewIndicator = document.createElement('div');
        viewIndicator.className = 'snail-perspective-indicator';
        viewIndicator.id = 'snail-perspective-indicator';
        viewIndicator.innerHTML = `
          <div class="text-center">
            <div class="font-bold text-2xl mb-2">微观视角</div>
            <div class="text-sm opacity-75">使用右侧控制器调整视角</div>
          </div>
        `;
      }
      
      // 添加到容器
      snailShellContainer.appendChild(snailShell);
      snailShellContainer.appendChild(leftKingdom);
      snailShellContainer.appendChild(rightKingdom);
      snailShellContainer.appendChild(perspectiveIndicator);
      
      // 添加到游戏容器
      gameContainer.appendChild(snailShellContainer);
      
      // 添加蝸牛出現動畫
      snailShell.style.opacity = '0';
      snailShell.style.transform = 'translate(-50%, -50%) scale(0.5)';
      
      // 使用動畫讓蝸牛出現
      setTimeout(() => {
        snailShell.style.opacity = '0.85';
        snailShell.style.transform = 'translate(-50%, -50%) scale(1)';
      }, 100);
      

    }
    
    // 創建蝸牛視角特效
    function createSnailPerspectiveEffect() {
      // 蝸牛視角的獨特視覺效果 - 承載者的緩慢視角
      gameContainer.style.transform = 'scale(0.92)';
      gameContainer.style.filter = 'sepia(0.3) saturate(1.3) contrast(1.1) brightness(0.9)'; // 暖色調濾鏡
      
      // 創建蝸牛視角的邊框效果，模擬從蝸牛眼中看出去的感覺
      const snailVisionOverlay = document.createElement('div');
      snailVisionOverlay.id = 'snail-vision-overlay';
      snailVisionOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 5;
        background: radial-gradient(ellipse at center, transparent 40%, rgba(139, 69, 19, 0.3) 60%, rgba(101, 67, 33, 0.5) 80%, rgba(62, 39, 35, 0.8) 95%);
        border-radius: 50%;
        transform: scale(1.2);
        animation: snail-vision-breathe 8s infinite ease-in-out;
      `;
      
      // 添加蝸牛視角的粒子效果，模擬空氣中的濕度和微粒
      const particleContainer = document.createElement('div');
      particleContainer.className = 'snail-vision-particles';
      particleContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 4;
      `;
      
      // 創建濕度粒子效果
      for (let i = 0; i < 15; i++) {
        const particle = document.createElement('div');
        particle.style.cssText = `
          position: absolute;
          width: ${2 + Math.random() * 4}px;
          height: ${2 + Math.random() * 4}px;
          background: rgba(135, 206, 235, 0.4);
          border-radius: 50%;
          left: ${Math.random() * 100}%;
          top: ${Math.random() * 100}%;
          animation: snail-particle-float ${8 + Math.random() * 4}s infinite ease-in-out;
          animation-delay: ${Math.random() * 5}s;
        `;
        particleContainer.appendChild(particle);
      }
      
      snailVisionOverlay.appendChild(particleContainer);
      document.body.appendChild(snailVisionOverlay);
      
      // 添加相應的CSS動畫
      if (!document.getElementById('snail-vision-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'snail-vision-styles';
        styleElement.textContent = `
          @keyframes snail-vision-breathe {
            0%, 100% { 
              transform: scale(1.18); 
              opacity: 0.7; 
            }
            50% { 
              transform: scale(1.22); 
              opacity: 0.9; 
            }
          }
          
          @keyframes snail-particle-float {
            0%, 100% { 
              transform: translate(0, 0) scale(1); 
              opacity: 0.2; 
            }
            25% { 
              transform: translate(${-20 + Math.random() * 40}px, ${-15 + Math.random() * 30}px) scale(1.2); 
              opacity: 0.6; 
            }
            50% { 
              transform: translate(${-10 + Math.random() * 20}px, ${-25 + Math.random() * 50}px) scale(0.8); 
              opacity: 0.3; 
            }
            75% { 
              transform: translate(${-30 + Math.random() * 60}px, ${-10 + Math.random() * 20}px) scale(1.1); 
              opacity: 0.5; 
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 移除蝸牛視角效果
    function removeSnailPerspectiveEffect() {
      const snailVisionOverlay = document.getElementById('snail-vision-overlay');
      if (snailVisionOverlay) {
        snailVisionOverlay.remove();
      }
      
      // 恢復正常視角
      gameContainer.style.transform = '';
      gameContainer.style.filter = '';
    }
    
    // 添加發光的小蝸牛（場景23開始顯示，持續到第四章結束）
    function addGlowingSnail() {
      // 檢查是否已經存在發光蝸牛，避免重複創建
      if (document.getElementById('glowing-snail')) {
        return;
      }
      
      console.log('🐌 添加發光的小蝸牛');
      
      // 創建發光蝸牛容器
      const glowingSnail = document.createElement('div');
      glowingSnail.id = 'glowing-snail';
      glowingSnail.className = 'glowing-snail-container';
      glowingSnail.style.cssText = `
        position: fixed;
        top: 30%;
        left: 50%;
        transform: translateX(-50%);
        z-index: 1000;
        font-size: 60px;
        text-align: center;
        width: 60px;
        margin-left: -30px;
        filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8)) 
                drop-shadow(0 0 20px rgba(255, 215, 0, 0.6))
                drop-shadow(0 0 30px rgba(255, 215, 0, 0.4));
        animation: snailGlow 2s ease-in-out infinite alternate;
        pointer-events: auto;
        user-select: none;
        cursor: pointer;
        transition: transform 0.2s ease;
      `;
      glowingSnail.textContent = '🐌';
      
      // 添加發光動畫的CSS
      const style = document.createElement('style');
      style.textContent = `
        @keyframes snailGlow {
          0% {
            filter: drop-shadow(0 0 10px rgba(255, 215, 0, 0.8)) 
                    drop-shadow(0 0 20px rgba(255, 215, 0, 0.6))
                    drop-shadow(0 0 30px rgba(255, 215, 0, 0.4));
            transform: scale(1);
          }
          100% {
            filter: drop-shadow(0 0 15px rgba(255, 215, 0, 1)) 
                    drop-shadow(0 0 25px rgba(255, 215, 0, 0.8))
                    drop-shadow(0 0 35px rgba(255, 215, 0, 0.6));
            transform: scale(1.05);
          }
        }
      `;
      document.head.appendChild(style);
      
      // 添加點擊事件
      glowingSnail.addEventListener('click', function() {
        // 點擊反饋效果
        this.style.transform = 'translateX(-50%) scale(1.1)';
        setTimeout(() => {
          this.style.transform = 'translateX(-50%) scale(1)';
        }, 200);
        
        // 顯示座標提示窗
        showSnailCoordinates();
      });
      
      // 添加懸停效果
      glowingSnail.addEventListener('mouseenter', function() {
        this.style.filter = 'drop-shadow(0 0 15px rgba(255, 215, 0, 1)) drop-shadow(0 0 25px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 35px rgba(255, 215, 0, 0.6))';
      });
      
      glowingSnail.addEventListener('mouseleave', function() {
        this.style.filter = 'drop-shadow(0 0 10px rgba(255, 215, 0, 0.8)) drop-shadow(0 0 20px rgba(255, 215, 0, 0.6)) drop-shadow(0 0 30px rgba(255, 215, 0, 0.4))';
      });
      
      // 添加到頁面
      document.body.appendChild(glowingSnail);
      
      console.log('✅ 發光小蝸牛已添加，將持續到第四章結束');
    }
    
    // 顯示蝸牛宇宙座標提示窗
    function showSnailCoordinates() {
      // 檢查是否已經存在座標提示窗，避免重複創建
      if (document.getElementById('snail-coordinates-popup')) {
        return;
      }
      
      // 生成隨機的宇宙座標
      const galaxy = ['銀河系', '仙女座星系', '大麥哲倫星雲', '小麥哲倫星雲', '三角座星系'][Math.floor(Math.random() * 5)];
      const sector = Math.floor(Math.random() * 999) + 1;
      const quadrant = ['α', 'β', 'γ', 'δ'][Math.floor(Math.random() * 4)];
      const coordinates = `${galaxy} - 第${sector}扇區 - ${quadrant}象限`;
      
      // 創建提示窗
      const popup = document.createElement('div');
      popup.id = 'snail-coordinates-popup';
      popup.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(30, 30, 30, 0.95));
        color: #ffd700;
        padding: 20px 30px;
        border-radius: 15px;
        border: 2px solid rgba(255, 215, 0, 0.6);
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5), 0 0 20px rgba(255, 215, 0, 0.3);
        z-index: 1001;
        font-family: 'Courier New', monospace;
        font-size: 14px;
        text-align: center;
        backdrop-filter: blur(10px);
        animation: popupFadeIn 0.3s ease-out;
        max-width: 300px;
        word-wrap: break-word;
      `;
      
      popup.innerHTML = `
        <div style="margin-bottom: 10px; font-size: 16px; font-weight: bold;">🐌 宇宙座標</div>
        <div style="color: #fff; margin-bottom: 15px;">${coordinates}</div>
        <div style="font-size: 12px; color: #ccc; margin-bottom: 15px;">「在浩瀚的宇宙中，每個存在都有其獨特的位置」</div>
        <button id="close-coordinates" style="
          background: linear-gradient(135deg, #ffd700, #ffed4e);
          color: #000;
          border: none;
          padding: 8px 16px;
          border-radius: 8px;
          cursor: pointer;
          font-size: 12px;
          font-weight: bold;
          transition: all 0.2s ease;
        ">關閉</button>
      `;
      
      // 添加彈出動畫的CSS
      const popupStyle = document.createElement('style');
      popupStyle.textContent = `
        @keyframes popupFadeIn {
          from {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
          }
          to {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
          }
        }
      `;
      document.head.appendChild(popupStyle);
      
      // 添加到頁面
      document.body.appendChild(popup);
      
      // 關閉按鈕事件
      document.getElementById('close-coordinates').addEventListener('click', function() {
        popup.style.animation = 'popupFadeOut 0.3s ease-in forwards';
        
        // 添加淡出動畫
        const fadeOutStyle = document.createElement('style');
        fadeOutStyle.textContent = `
          @keyframes popupFadeOut {
            from {
              opacity: 1;
              transform: translate(-50%, -50%) scale(1);
            }
            to {
              opacity: 0;
              transform: translate(-50%, -50%) scale(0.8);
            }
          }
        `;
        document.head.appendChild(fadeOutStyle);
        
        setTimeout(() => {
          popup.remove();
          popupStyle.remove();
          fadeOutStyle.remove();
        }, 300);
      });
      
      // 點擊背景關閉
      popup.addEventListener('click', function(e) {
        if (e.target === popup) {
          document.getElementById('close-coordinates').click();
        }
      });
      
      // 3秒後自動關閉
      setTimeout(() => {
        if (document.getElementById('snail-coordinates-popup')) {
          document.getElementById('close-coordinates').click();
        }
      }, 3000);
    }
    
    // 清理第四章特定的視覺元素
    function cleanupChapter4Effects() {
      // 移除蝸牛相關元素
      document.querySelectorAll('.snail-shell, .kingdom-left, .kingdom-right, .kingdom-label, .kingdom-building').forEach(el => el.remove());
      
      // 移除舊的圓形世界元素（kingdom-circle）- 這是導致性能問題的關鍵
      document.querySelectorAll('.kingdom-circle, .kingdoms-container').forEach(el => el.remove());
      
      // 移除螺旋背景效果
      document.querySelectorAll('.spiral-container, .spiral-effect, .spiral-particle').forEach(el => el.remove());
      
      // 移除視角指示器（宏觀視角/微觀視角文字）
      const scaleIndicator = document.getElementById('snail-perspective-indicator');
      if (scaleIndicator) {
        scaleIndicator.remove();
      }
      
      // 移除並禁用視角控制器
      const controller = document.getElementById('scale-controller');
      if (controller) {
        controller.remove();
      }
      disableScaleControl();
      
      // 重置視角縮放值
      gameState.viewScale = 100;
      
      // 移除蝸牛視角效果
      removeSnailPerspectiveEffect();
      
      // 重置gameContainer的變換和濾鏡
      gameContainer.style.transform = 'scale(1)';
      gameContainer.style.filter = 'none';
      
      // 停止Canvas動畫循環（如果存在）
      const worldCanvas = document.getElementById('world-canvas');
      if (worldCanvas) {
        // 移除Canvas元素會自動停止其動畫循環
        worldCanvas.remove();
        console.log('🛑 Canvas動畫循環已停止');
      }
      
      // 移除發光蝸牛（第四章結束時）
      const glowingSnail = document.getElementById('glowing-snail');
      if (glowingSnail) {
        glowingSnail.remove();
        console.log('🐌 發光小蝸牛已移除');
      }
      
      console.log('第四章視覺元素已清理完成，包括舊的圓形世界元素');
    }
    
    // 清理第五章特定的視覺元素
    function cleanupChapter5Effects() {
      // 移除時間森林相關的視覺效果
      document.querySelectorAll('.time-particle, .time-wave, .time-glow').forEach(el => el.remove());
      
      // 移除時間感知相關的覆蓋層效果
      document.querySelectorAll('.time-overlay, .time-vision-effect').forEach(el => el.remove());
      
      // 重置gameContainer的時間相關變換和濾鏡
      gameContainer.style.filter = 'none';
      gameContainer.style.transform = 'scale(1)';
      
      // 清理時間森林背景特效
      const timeEffects = document.querySelectorAll('.amber-glow, .forest-shimmer');
      timeEffects.forEach(effect => effect.remove());
      
      console.log('第五章視覺元素已清理完成');
    }
    
    // 創建蝸牛視角過渡場景
    function createSnailPerspectiveTransitionScene(scene) {
      const transitionElement = document.createElement('div');
      transitionElement.className = 'max-w-2xl mx-auto p-6 text-left fixed left-1/2 top-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-purple-200 dark:border-purple-700 z-50';
      
      transitionElement.innerHTML = `
        <p class="text-lg md:text-xl leading-relaxed mb-6">${scene.text}</p>
        <div class="text-sm text-gray-600 dark:text-gray-400">視角轉換中...</div>
      `;
      
      gameContent.appendChild(transitionElement);
      
      // 開始視角轉換動畫
      setTimeout(() => {
        // 移除蝸牛視角效果
        removeSnailPerspectiveEffect();
        
        // 創建過渡動畫
        transitionElement.style.transform = 'translate(-50%, -50%) scale(0.8)';
        transitionElement.style.opacity = '0.5';
        
        setTimeout(() => {
          // 不再創建舊的蝸牛實體和視角系統，避免與新的Canvas圓形世界衝突
          // createSnailAndKingdoms(); // 已移除，避免創建舊的圓形世界
          // enableScaleControl(); // 已移除，避免啟用舊的視角控制
          
          // 移除過渡元素
          transitionElement.remove();
          
          // 顯示繼續按鈕
          advanceBtn.style.display = 'block';
        }, 1500);
      }, 2000);
    }
    
    // 創建交互式蝸角之爭場景
    function createSnailWarInteractiveScene(scene) {
      // 進入場景前徹底清理上一場景殘留元素
      cleanupChapter4Effects();
      console.log('🐌 創建交互式蝸角之爭場景');
      
      // 創建場景容器
      const sceneContainer = document.createElement('div');
      sceneContainer.className = 'snail-war-interactive-container';
      sceneContainer.style.cssText = `
        position: relative;
        width: 100%;
        height: 100vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background: transparent;
        overflow: hidden;
      `;
      
                // 創建說明文字
      const instructionText = document.createElement('div');
      instructionText.className = 'max-w-2xl mx-auto p-6 text-left bg-gray-50 dark:bg-gray-700 bg-opacity-90 dark:bg-opacity-90 rounded-lg shadow-lg border border-gray-300 dark:border-gray-600';
      instructionText.style.cssText = `
        position: absolute;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        z-index: 100;
        max-width: 672px;
        width: calc(100% - 200px);
      `;
      instructionText.innerHTML = `
        <p class="text-lg md:text-xl leading-relaxed text-gray-700 dark:text-gray-300">現在，你將親身體驗蝸角上的戰爭。使用右側的視角控制器放大視角，你會發現蝸牛角上的兩個國家。點擊「蠻」和「觸」兩個按鈕，傾聽兩國國王的話語，理解爭執的虛妄本質。</p>
      `;
      
      // 創建蝸牛容器
      const snailContainer = document.createElement('div');
      snailContainer.className = 'snail-container';
      snailContainer.style.cssText = `
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        width: 300px;
        height: 300px;
        transform: scale(1);
        transition: transform 0.2s ease;
        transform-origin: center;
        overflow: visible;
      `;
      
      // 創建蝸牛emoji
      const snailEmoji = document.createElement('span');
      snailEmoji.className = 'snail-emoji';
      snailEmoji.style.cssText = `
        font-size: 60px;
        z-index: 10;
        opacity: 1;
        transition: opacity 0.3s ease;
      `;
      snailEmoji.textContent = '🐌';
      
      // 創建圓形世界容器（獨立於蝸牛容器）- 擴大2.5倍
      const worldContainer = document.createElement('div');
      worldContainer.className = 'world-container';
      worldContainer.style.cssText = `
        position: absolute;
        top: 47%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 550px;
        height: 550px;
        z-index: 5;
        opacity: 0;
        transition: opacity 0.3s ease;
      `;
      
      // 創建Canvas - 擴大2.5倍
      const canvas = document.createElement('canvas');
      canvas.id = 'world-canvas';
      canvas.style.cssText = `
        position: relative;
        width: 550px;
        height: 550px;
        cursor: default;
      `;
      
      // 創建按鈕（放在圓形世界容器內）
      const manButton = document.createElement('button');
      manButton.className = 'territory-button man-button';
      manButton.id = 'man-button';
      manButton.style.cssText = `
        position: absolute;
        width: 100px;
        height: 100px;
        border: none;
        border-radius: 50%;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 15;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        background: linear-gradient(135deg, #fff, #f0f0f0);
        color: black;
        top: 50%;
        left: 0;
        transform: translateX(30px) translateY(-50%);
        animation: buttonGlow 1s ease-in-out infinite alternate;
      `;
      manButton.textContent = '蠻';
      
      const touchButton = document.createElement('button');
      touchButton.className = 'territory-button touch-button';
      touchButton.id = 'touch-button';
      touchButton.style.cssText = `
        position: absolute;
        width: 100px;
        height: 100px;
        border: none;
        border-radius: 50%;
        font-size: 40px;
        font-weight: bold;
        cursor: pointer;
        z-index: 15;
        transition: all 0.3s ease;
        box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        background: linear-gradient(135deg, #333, #000);
        color: white;
        top: 50%;
        left: 0;
        transform: translateX(280px) translateY(-50%);
        animation: buttonGlow 1s ease-in-out infinite alternate;
      `;
      touchButton.textContent = '觸';
      
      // 添加發光動畫的CSS
      const style = document.createElement('style');
      style.textContent = `
        @keyframes buttonGlow {
          0% {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 10px rgba(255, 215, 0, 0.3);
          }
          100% {
            box-shadow: 0 4px 8px rgba(0,0,0,0.3), 0 0 20px rgba(255, 215, 0, 0.8), 0 0 30px rgba(255, 215, 0, 0.4);
          }
        }
      `;
      document.head.appendChild(style);
      
      // 創建縮放控制
      const zoomContainer = document.createElement('div');
      zoomContainer.className = 'zoom-slider-container';
      zoomContainer.style.cssText = `
        position: absolute;
        right: 20px;
        top: 50%;
        transform: translateY(-50%);
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px;
        background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(30, 30, 30, 0.9));
        padding: 25px 15px;
        border-radius: 20px;
        backdrop-filter: blur(15px);
        border: 2px solid rgba(123, 104, 238, 0.3);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3), 
                    inset 0 1px 0 rgba(255, 255, 255, 0.1);
        z-index: 100;
        min-height: 300px;
        width: 80px;
      `;
      
      // 創建放大圖標（上方）
      const zoomInIcon = document.createElement('div');
      zoomInIcon.innerHTML = '🔍';
      zoomInIcon.style.cssText = `
        color: #e0e0e0;
        font-size: 20px;
        text-align: center;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 5px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
      `;
      
      // 創建縮小圖標（下方）
      const zoomOutIcon = document.createElement('div');
      zoomOutIcon.innerHTML = '🌍';
      zoomOutIcon.style.cssText = `
        color: #e0e0e0;
        font-size: 18px;
        text-align: center;
        text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        cursor: pointer;
        transition: all 0.2s ease;
        padding: 5px;
        border-radius: 50%;
        background: rgba(255, 255, 255, 0.1);
      `;
      
      const zoomSlider = document.createElement('input');
      zoomSlider.type = 'range';
      zoomSlider.min = '1';
      zoomSlider.max = '3';
      zoomSlider.value = '1';
      zoomSlider.step = '0.05';
      zoomSlider.id = 'perspective-slider';
      zoomSlider.style.cssText = `
        -webkit-appearance: none;
        appearance: none;
        width: 200px;
        height: 8px;
        background: linear-gradient(to top, #4a90e2, #7b68ee);
        border-radius: 4px;
        outline: none;
        cursor: pointer;
        transform: rotate(-90deg);
        transform-origin: center;
        margin: 80px 0;
        transition: all 0.2s ease;
      `;
      
      // 為滑塊添加自定義樣式
      const sliderStyle = document.createElement('style');
      sliderStyle.textContent = `
        .zoom-slider-container input[type="range"]::-webkit-slider-thumb {
          -webkit-appearance: none;
          appearance: none;
          width: 20px;
          height: 20px;
          border-radius: 50%;
          background: linear-gradient(135deg, #7b68ee, #4a90e2);
          cursor: pointer;
          border: 2px solid rgba(255, 255, 255, 0.8);
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
          transition: all 0.2s ease;
        }
        
        .zoom-slider-container input[type="range"]::-webkit-slider-thumb:hover {
          transform: scale(1.1);
          box-shadow: 0 4px 12px rgba(123, 104, 238, 0.4);
        }
        
        .zoom-slider-container input[type="range"]::-moz-range-thumb {
          width: 20px;
          height: 20px;
          border-radius: 50%;
          background: linear-gradient(135deg, #7b68ee, #4a90e2);
          cursor: pointer;
          border: 2px solid rgba(255, 255, 255, 0.8);
          box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
          transition: all 0.2s ease;
        }
        
        .zoom-slider-container input[type="range"]:hover {
          background: linear-gradient(to top, #5ba0f2, #8b78fe);
        }
      `;
      document.head.appendChild(sliderStyle);
      
      // 創建對話框
      const dialogOverlay = document.createElement('div');
      dialogOverlay.className = 'dialog-overlay';
      dialogOverlay.id = 'dialog-overlay';
      dialogOverlay.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.6);
        display: none;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      `;
      
      const dialogBox = document.createElement('div');
      dialogBox.className = 'dialog-box';
      dialogBox.style.cssText = `
        background-color: #fff;
        padding: 25px;
        border-radius: 10px;
        box-shadow: 0 5px 25px rgba(0,0,0,0.2);
        width: 80%;
        max-width: 400px;
        text-align: center;
      `;
      
      const dialogTitle = document.createElement('h2');
      dialogTitle.id = 'dialog-title';
      dialogTitle.style.cssText = `
        margin-top: 0;
        color: #333;
      `;
      
      const dialogContent = document.createElement('p');
      dialogContent.id = 'dialog-content';
      dialogContent.style.cssText = `
        color: #555;
        font-size: 1.1em;
        line-height: 1.6;
      `;
      
      const closeButton = document.createElement('button');
      closeButton.id = 'close-dialog';
      closeButton.textContent = '關閉';
      closeButton.style.cssText = `
        margin-top: 15px;
        padding: 10px 20px;
        border: none;
        background-color: #5373a4;
        color: white;
        border-radius: 5px;
        cursor: pointer;
        font-size: 1em;
      `;
      
      // 組裝元素
      dialogBox.appendChild(dialogTitle);
      dialogBox.appendChild(dialogContent);
      dialogBox.appendChild(closeButton);
      dialogOverlay.appendChild(dialogBox);
      
      zoomContainer.appendChild(zoomInIcon);
      zoomContainer.appendChild(zoomSlider);
      zoomContainer.appendChild(zoomOutIcon);
      
      // 蝸牛容器只包含蝸牛emoji
      snailContainer.appendChild(snailEmoji);
      
      // 圓形世界容器包含canvas和按鈕
      worldContainer.appendChild(canvas);
      worldContainer.appendChild(manButton);
      worldContainer.appendChild(touchButton);
      
      sceneContainer.appendChild(instructionText);
      sceneContainer.appendChild(snailContainer);
      sceneContainer.appendChild(worldContainer);
      sceneContainer.appendChild(zoomContainer);
      sceneContainer.appendChild(dialogOverlay);
      
      gameContent.appendChild(sceneContainer);
      
      // 初始化Canvas - 擴大2.5倍
      const ctx = canvas.getContext('2d');
      const size = 550; // 從220擴大到550
      
      // 降低Canvas分辨率以提高性能
      const devicePixelRatio = window.devicePixelRatio || 1;
      const displaySize = size;
      const resolutionMultiplier = 1; // 從3降低到1，大幅提升性能
      canvas.width = displaySize * devicePixelRatio * resolutionMultiplier;
      canvas.height = displaySize * devicePixelRatio * resolutionMultiplier;
      canvas.style.width = displaySize + 'px';
      canvas.style.height = displaySize + 'px';
      
      ctx.scale(devicePixelRatio * resolutionMultiplier, devicePixelRatio * resolutionMultiplier);
      ctx.imageSmoothingEnabled = false;
      ctx.imageSmoothingQuality = 'high';
      
      // 高速戰爭系統配置
      const warConfig = {
        manColor: '#000000',
        touchColor: '#ffffff',
        borderColor: '#ff0000',
        warSpeed: 0.04, // 從0.02增加到0.08，速度提升4倍
        emojiSize: 40
      };
      
      // 增強戰爭狀態 - 包含爆炸效果
      let warState = {
        time: 0,
        borderPosition: 0,
        visualEffects: [], // 戰爭視覺效果
        explosions: [] // 爆炸效果
      };
      
      // 增強視覺效果初始化 - 包含爆炸效果
      function initVisualEffects() {
        // 創建戰爭視覺效果點 - 初始位置設為0，稍後動態更新
        warState.visualEffects = [
          { x: 0, y: 0, phase: 0, emoji: '⚔️', type: 'weapon' },
          { x: 0, y: 0, phase: Math.PI, emoji: '🛡️', type: 'shield' },
          { x: 0, y: 0, phase: Math.PI * 0.5, emoji: '⚔️', type: 'weapon' },
          { x: 0, y: 0, phase: Math.PI * 1.5, emoji: '🛡️', type: 'shield' },
          { x: 0, y: 0, phase: Math.PI * 0.3, emoji: '💀', type: 'skull' },
          { x: 0, y: 0, phase: Math.PI * 0.8, emoji: '💀', type: 'skull' }
        ];
        
        // 創建高速爆炸效果 - 初始位置設為0，稍後動態更新
        warState.explosions = [
          { x: 0, y: 0, life: 0, maxLife: 30, scale: 0, emoji: '💥' },
          { x: 0, y: 0, life: 15, maxLife: 30, scale: 0, emoji: '💥' },
          { x: 0, y: 0, life: 22, maxLife: 30, scale: 0, emoji: '💥' }
        ];
        
        // 初始化位置
        updateEffectPositions();
      }
      
      // 更新效果位置 - 讓它們在國境線附近隨機出現
      function updateEffectPositions() {
        const centerX = size / 2;
        const borderX = centerX + warState.borderPosition * (size / 2) * 0.6;
        
        // 更新戰爭視覺效果位置
        warState.visualEffects.forEach(effect => {
          // 在國境線附近隨機生成位置
          const y = Math.random() * size;
          const sOffset = 60 * Math.sin((y / size) * Math.PI * 2) * Math.sin((y / size) * Math.PI);
          const borderPosX = borderX + sOffset;
          
          // 在國境線兩側隨機偏移
          const sideOffset = (Math.random() - 0.5) * 100; // 左右各50像素範圍
          effect.x = Math.max(50, Math.min(size - 50, borderPosX + sideOffset));
          effect.y = Math.max(50, Math.min(size - 50, y));
        });
        
        // 更新爆炸效果位置
        warState.explosions.forEach(explosion => {
          if (explosion.life >= explosion.maxLife) {
            // 爆炸結束時重新定位到國境線附近
            const y = Math.random() * size;
            const sOffset = 60 * Math.sin((y / size) * Math.PI * 2) * Math.sin((y / size) * Math.PI);
            const borderPosX = borderX + sOffset;
            
            // 在國境線兩側隨機偏移
            const sideOffset = (Math.random() - 0.5) * 80; // 左右各40像素範圍
            explosion.x = Math.max(50, Math.min(size - 50, borderPosX + sideOffset));
            explosion.y = Math.max(50, Math.min(size - 50, y));
          }
        });
      }
      
      // 高速邊界位置更新
      function updateBorder() {
        // 高速正弦波擾動
        warState.borderPosition = Math.sin(warState.time * 3.5) * 0.15; // 從0.5增加到2.0，速度提升4倍
        updateButtonPositions();
      }
      
              // 修正按鈕位置計算 - 讓按鈕真正在國境線兩側
        let lastButtonUpdate = 0;
        function updateButtonPositions() {
          // 限制更新頻率到每100ms一次
          const now = Date.now();
          if (now - lastButtonUpdate < 100) return;
          lastButtonUpdate = now;
          
          const centerX = size / 2;
          const borderX = centerX + warState.borderPosition * (size / 2) * 0.6;
          
          // 修正按鈕距離 - 蠻國按鈕向左偏移，保持固定邊距
          const buttonDistance = 80; // 按鈕到國境線的固定距離
          const manOffset = -100; // 蠻國按鈕向左偏移100像素
          
          const manButtonX = Math.max(50, Math.min(size - 50, borderX - buttonDistance + manOffset));
          const touchButtonX = Math.max(50, Math.min(size - 50, borderX + buttonDistance));
          
          // 直接更新，不使用requestAnimationFrame
          manButton.style.transform = `translateX(${manButtonX}px) translateY(-50%)`;
          touchButton.style.transform = `translateX(${touchButtonX}px) translateY(-50%)`;
        }
      
      // 優化的繪製函數
      let animationId = null; // 用於停止動畫循環
      
      function draw() {
        // 檢查Canvas是否還存在，如果不存在則停止動畫
        if (!canvas || !canvas.parentNode) {
          if (animationId) {
            cancelAnimationFrame(animationId);
            animationId = null;
          }
          return;
        }
        
        ctx.clearRect(0, 0, size, size);
        
        ctx.save();
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI * 2);
        ctx.clip();
        
        // 繪製地球背景
        ctx.font = `${size * 1.2}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('🌏', size / 2, size / 2);
        
        // 靜態S形國境線 - 只進行左右移動
        const centerX = size / 2;
        const borderX = centerX + warState.borderPosition * (size / 2) * 0.6;
        
        // 靜態S形參數
        const sAmplitude = 60; // S形的幅度
        const segments = 25; // 段數
        
        // 蠻國領土
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(0, size);
        
        for (let i = segments; i >= 0; i--) {
          const y = (i / segments) * size;
          // 靜態S形函數 - 使用兩個正弦波組合形成S形
          const sOffset = sAmplitude * Math.sin((y / size) * Math.PI * 2) * Math.sin((y / size) * Math.PI);
          const x = borderX + sOffset;
          ctx.lineTo(x, y);
        }
        
        ctx.lineTo(0, 0);
        ctx.closePath();
        
        ctx.fillStyle = warConfig.manColor;
        ctx.globalAlpha = 0.9;
        ctx.fill();
        
        // 觸國領土
        ctx.beginPath();
        ctx.moveTo(size, 0);
        ctx.lineTo(size, size);
        
        for (let i = segments; i >= 0; i--) {
          const y = (i / segments) * size;
          // 靜態S形函數 - 使用兩個正弦波組合形成S形
          const sOffset = sAmplitude * Math.sin((y / size) * Math.PI * 2) * Math.sin((y / size) * Math.PI);
          const x = borderX + sOffset;
          ctx.lineTo(x, y);
        }
        
        ctx.lineTo(size, 0);
        ctx.closePath();
        
        ctx.fillStyle = warConfig.touchColor;
        ctx.fill();
        
        // 靜態S形邊界線繪製
        ctx.strokeStyle = warConfig.borderColor;
        ctx.lineWidth = 8;
        ctx.globalAlpha = 1.0;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        ctx.beginPath();
        
        for (let i = 0; i <= segments; i++) {
          const y = (i / segments) * size;
          // 靜態S形函數 - 使用兩個正弦波組合形成S形
          const sOffset = sAmplitude * Math.sin((y / size) * Math.PI * 2) * Math.sin((y / size) * Math.PI);
          const x = borderX + sOffset;
          
          if (i === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // 繪製戰爭視覺效果
        ctx.globalAlpha = 1.0;
        ctx.font = `${warConfig.emojiSize}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        warState.visualEffects.forEach(effect => {
          // 大幅減慢閃爍效果速度
          const opacity = 0.3 + 0.7 * Math.abs(Math.sin(warState.time * 0.6 + effect.phase)); // 從1.5減少到0.6，速度再降低60%
          ctx.globalAlpha = opacity;
          
          // 大幅減慢位置擾動速度
          const offsetX = Math.sin(warState.time * 0.4 + effect.phase) * 3; // 從1減少到0.4，速度再降低60%
          const offsetY = Math.cos(warState.time * 0.3 + effect.phase) * 2; // 從0.75減少到0.3，速度再降低60%
          
          ctx.fillText(effect.emoji, effect.x + offsetX, effect.y + offsetY);
        });
        
        // 繪製爆炸效果
        warState.explosions.forEach(explosion => {
          // 更新爆炸生命週期
          explosion.life++;
          
          if (explosion.life < explosion.maxLife) {
            // 計算爆炸動畫進度
            const progress = explosion.life / explosion.maxLife;
            
            // 爆炸縮放動畫
            explosion.scale = progress < 0.5 ? progress * 2 : (1 - progress) * 2;
            
            // 爆炸透明度
            const explosionOpacity = progress < 0.7 ? progress / 0.7 : (1 - progress) / 0.3;
            ctx.globalAlpha = explosionOpacity;
            
            // 繪製爆炸效果
            const fontSize = warConfig.emojiSize * explosion.scale;
            ctx.font = `${fontSize}px sans-serif`;
            ctx.fillText(explosion.emoji, explosion.x, explosion.y);
          } else {
            // 重置爆炸效果
            explosion.life = 0;
            explosion.scale = 0;
            // 位置會在updateEffectPositions中更新到國境線附近
          }
        });
        
        ctx.restore();
        
        // 簡化狀態更新
        updateBorder();
        updateEffectPositions(); // 更新效果位置到國境線附近
        warState.time += warConfig.warSpeed;
        
        animationId = requestAnimationFrame(draw);
      }
      
      // 初始化並開始繪製
      initVisualEffects();
      updateButtonPositions();
      draw();
      
      // 按鈕點擊追蹤狀態
      let manButtonClicked = false;
      let touchButtonClicked = false;
      
      // 按鈕點擊事件
      manButton.addEventListener('click', () => {
        if (!manButtonClicked) {
          manButtonClicked = true;
          // 移除發光動畫
          manButton.style.animation = 'none';
          manButton.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(0, 255, 0, 0.6)';
          manButton.style.transform = 'translateX(30px) translateY(-50%) scale(1.1)';
          setTimeout(() => {
            manButton.style.transform = 'translateX(30px) translateY(-50%) scale(1)';
          }, 200);
        }
        showDialog('蠻氏國君', '我們的軍隊正在推進！每一寸土地都將屬於蠻國！蠻國的榮耀不容侵犯！');
        checkBothButtonsClicked();
      });
      
      touchButton.addEventListener('click', () => {
        if (!touchButtonClicked) {
          touchButtonClicked = true;
          // 移除發光動畫
          touchButton.style.animation = 'none';
          touchButton.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3), 0 0 15px rgba(0, 255, 0, 0.6)';
          touchButton.style.transform = 'translateX(280px) translateY(-50%) scale(1.1)';
          setTimeout(() => {
            touchButton.style.transform = 'translateX(280px) translateY(-50%) scale(1)';
          }, 200);
        }
        showDialog('觸氏國君', '觸國的榮耀不容侵犯！我們將奪回失去的領土！觸國的意志堅不可摧！');
        checkBothButtonsClicked();
      });
      
      // 檢查兩個按鈕是否都已點擊
      function checkBothButtonsClicked() {
        if (manButtonClicked && touchButtonClicked) {
          // 顯示繼續按鈕
          advanceBtn.style.display = 'block';
        }
      }
      
      // Canvas點擊事件
      canvas.addEventListener('click', (e) => {
        const rect = canvas.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        if (x > size * 0.3 && x < size * 0.7 && y > size * 0.4 && y < size * 0.8) {
          showDialog('戰爭觀察者', '在這小小的蝸角之上，兩國為了微不足道的領土而戰。這難道不是莊子所諷刺的嗎？');
        }
      });
      
      // 對話框功能
      function showDialog(title, content) {
        document.getElementById('dialog-title').textContent = title;
        document.getElementById('dialog-content').textContent = content;
        document.getElementById('dialog-overlay').style.display = 'flex';
      }
      
      document.getElementById('close-dialog').addEventListener('click', () => {
        document.getElementById('dialog-overlay').style.display = 'none';
      });
      
            // 雙向視角控制邏輯 - 實現蝸牛和圓形世界的可逆切換
      zoomSlider.addEventListener('input', function() {
        const zoomLevel = parseFloat(this.value);
        
        // 視角控制器控制蝸牛的放大倍數
        const snailScaleFactor = Math.pow(zoomLevel, 4.2);
        snailContainer.style.transform = `scale(${snailScaleFactor})`;
        
        // 定義切換閾值
        const transitionThreshold = 2.5; // 蝸牛和圓形世界切換的閾值
        const maxZoom = 3.0; // 最大縮放值
        
        // 計算蝸牛和圓形世界的透明度（雙向控制）
        let snailOpacity, worldOpacity;
        
        if (zoomLevel <= transitionThreshold) {
          // 拉遠視角：顯示蝸牛，隱藏圓形世界
          snailOpacity = 1;
          worldOpacity = 0;
        } else {
          // 拉近視角：隱藏蝸牛，顯示圓形世界
          const fadeProgress = (zoomLevel - transitionThreshold) / (maxZoom - transitionThreshold);
          const clampedProgress = Math.max(0, Math.min(fadeProgress, 1));
          
          snailOpacity = 1 - clampedProgress;
          worldOpacity = clampedProgress;
        }
        
        // 應用透明度變化
        snailEmoji.style.opacity = snailOpacity;
        worldContainer.style.opacity = worldOpacity;
        
        // 調試信息：顯示當前縮放狀態
        console.log(`🔍 雙向縮放調試 - 滑塊值: ${zoomLevel.toFixed(2)}, 蝸牛放大倍數: ${snailScaleFactor.toFixed(2)}, 蝸牛透明度: ${snailOpacity.toFixed(2)}, 世界透明度: ${worldOpacity.toFixed(2)}`);
      });
      
      // 圖標點擊事件 - 只控制蝸牛的縮放
      zoomInIcon.addEventListener('click', function() {
        const currentValue = parseFloat(zoomSlider.value);
        const newValue = Math.min(3, currentValue + 0.2);
        zoomSlider.value = newValue;
        zoomSlider.dispatchEvent(new Event('input'));
        
        // 添加點擊反饋效果
        zoomInIcon.style.transform = 'scale(1.2)';
        setTimeout(() => {
          zoomInIcon.style.transform = 'scale(1)';
        }, 150);
      });
      
      zoomOutIcon.addEventListener('click', function() {
        const currentValue = parseFloat(zoomSlider.value);
        const newValue = Math.max(1, currentValue - 0.2);
        zoomSlider.value = newValue;
        zoomSlider.dispatchEvent(new Event('input'));
        
        // 添加點擊反饋效果
        zoomOutIcon.style.transform = 'scale(1.2)';
        setTimeout(() => {
          zoomOutIcon.style.transform = 'scale(1)';
        }, 150);
      });
      
      // 添加懸停效果
      [zoomInIcon, zoomOutIcon].forEach(icon => {
        icon.addEventListener('mouseenter', function() {
          this.style.background = 'rgba(255, 255, 255, 0.2)';
          this.style.transform = 'scale(1.05)';
        });
        
        icon.addEventListener('mouseleave', function() {
          this.style.background = 'rgba(255, 255, 255, 0.1)';
          this.style.transform = 'scale(1)';
        });
      });
      
      // 觸發初始縮放事件
      zoomSlider.dispatchEvent(new Event('input'));
      
      // 初始狀態下隱藏繼續按鈕，直到兩個按鈕都被點擊
      advanceBtn.style.display = 'none';
    }
    
    function createDialogScene(scene) {
      dialogText.textContent = scene.text;
      
      // 使用統一的文字顏色：亮色模式用深色文字，暗色模式用淺色文字
      dialogText.className = 'text-gray-800 dark:text-gray-200';
      
      if (scene.speaker) {
        dialogText.innerHTML = `<strong>${scene.speaker}：</strong> ${scene.text}`;
      }
      
      // 检查是否有蜗牛存在，或者是第五章（时间森林），或者是第六章（天地場景）
      const hasSnail = document.querySelector('.snail-shell');
      const isTimeChapter = gameState.currentChapter === 'chapter5';
      const isHeavenEarthChapter = gameState.currentChapter === 'chapter6';
      
      if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
        dialogBox.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-3xl bg-white dark:bg-gray-800 border-2 border-indigo-600 dark:border-indigo-500 rounded-lg p-4 shadow-lg bg-opacity-95 dark:bg-opacity-95';
        dialogBox.style.zIndex = isHeavenEarthChapter ? '9999' : '30'; // 第六章使用極高的z-index確保在最上層
        dialogBox.style.pointerEvents = 'auto'; // 確保對話框可以接收點擊事件
      } else {
        dialogBox.className = 'absolute top-1/2 left-0 right-0 mx-auto max-w-3xl -translate-y-1/2 bg-white dark:bg-gray-800 border-2 border-indigo-600 dark:border-indigo-500 rounded-lg p-4 shadow-lg opacity-0 transition-all duration-300 transform';
      }
      
      // Handle dialog options if present
      if (scene.options && scene.options.length > 0) {
        // 第六章需要確保對話選項容器可以接收點擊事件
        if (isHeavenEarthChapter) {
          dialogOptions.style.pointerEvents = 'auto';
          dialogOptions.style.zIndex = '10000';
        }
        
        // 開始計時選擇思考時間
        startChoiceTimer();
        
        scene.options.forEach((option, index) => {
          const button = document.createElement('button');
          button.className = 'bg-indigo-100 hover:bg-indigo-200 dark:bg-indigo-900 dark:hover:bg-indigo-800 text-indigo-800 dark:text-indigo-200 font-semibold py-2 px-4 rounded text-left relative';
          button.style.zIndex = isHeavenEarthChapter ? '10001' : '102'; // 第六章使用超高z-index確保選項按鈕可點擊
          button.style.pointerEvents = 'auto'; // 確保按鈕可以接收點擊事件
          button.textContent = option.text;
          button.addEventListener('click', () => {
            // 記錄玩家選擇（在場景切換之前）
            const choiceData = {
              text: option.text,
              index: index,
              speaker: scene.speaker || 'unknown',
              situation: getCurrentSituation()
            };
            
            // 處理8維度特質結構
            if (option.traits) {
              console.log('🔍 ===== 選擇處理調試信息 (對話場景) =====');
              console.log('📝 選擇文本:', option.text);
              console.log('🎭 說話者:', scene.speaker);
              console.log('📚 章節:', gameState.currentChapter);
              console.log('🎯 原始特質標記:', option.traits);
              
              // 直接使用8維度特質標記
              choiceData.traits = option.traits;
              
              console.log('✅ 最終選擇數據:', choiceData);
              console.log('========================================');
            } else {
              console.log('⚠️ 選項沒有特質標記，使用默認空值');
              choiceData.traits = {};
            }
            
            recordPlayerChoice(choiceData);
            
            // 原有的場景切換邏輯
            gameState.currentScene = option.next;
            loadScene();
          });
          dialogOptions.appendChild(button);
        });
        
        // Don't show advance button for options
        advanceBtn.style.display = 'none';
      } else {
        advanceBtn.style.display = 'block';
      }
      
      dialogBox.style.opacity = 1;
      if (hasSnail || isTimeChapter || isHeavenEarthChapter) {
        dialogBox.style.transform = 'translateX(-50%)';
      } else {
        dialogBox.style.transform = 'translateY(0)';
      }
    }
    
    function createSegmentationPuzzle(scene) {
      // 在斷句界面時，降低混沌的層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.add('segmentation-mode');
      }
      
      // 在第六章斷句挑戰出現時，清空浮現的古老文字效果，並標記為已禁用
      if (gameState.currentChapter === 'chapter6') {
        document.querySelectorAll('.floating-ancient-text').forEach(el => el.remove());
        // 設置標記，禁止後續再創建浮動古老文字
        gameState.chapter6FloatingTextDisabled = true;
      }
      
      // Reset puzzle state
      gameState.segmentationPuzzleState = {
        solved: false,
        segments: new Array(scene.text.length - 1).fill(false)
      };
      
      // 初始化本次斷句挑戰的內存數據（不涉及localStorage）
      const puzzleKey = `${gameState.currentChapter}_${gameState.currentScene}`;
      
      // 在內存中創建本次斷句的數據結構，不讀取舊數據
      gameState.currentPuzzleData = {
        attempts: 0,
        correctAttempts: 0,
        incorrectAttempts: 0,
        startTime: null, // 將在第一次點擊時設置
        lastAttemptTime: null
      };
      
      console.log('⏱️ 本次斷句挑戰開始:', puzzleKey, '等待第一次點擊開始計時');
      
      // Fix CSS selector issue with previous circles
      document.querySelectorAll('.segment-gap.active').forEach(el => {
        el.classList.remove('active');
      });
      
      const puzzleContainer = document.createElement('div');
      
      // 根據章節設置不同的樣式
      if (gameState.currentChapter === 'chapter4') {
        // 第四章使用螺旋效果的樣式
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center relative z-10 rounded-xl';
        puzzleContainer.style.background = 'transparent'; // 透明背景以顯示粒子
        puzzleContainer.style.border = '1px solid rgba(147, 50, 158, 0.5)';
        puzzleContainer.style.boxShadow = '0 0 40px rgba(147, 50, 158, 0.6)';
        puzzleContainer.style.minHeight = '400px';
        puzzleContainer.style.display = 'flex';
        puzzleContainer.style.flexDirection = 'column';
        puzzleContainer.style.justifyContent = 'center';
        puzzleContainer.style.alignItems = 'center';
      } else if (gameState.currentChapter === 'chapter6') {
        // 第六章使用特殊樣式，創建獨立的頂層懸浮視窗，背景透明，位置向下移動
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center rounded-xl shadow-lg';
        puzzleContainer.style.position = 'fixed'; // 使用fixed定位脫離父容器
        puzzleContainer.style.top = '60%'; // 從50%改為60%，向下移動
        puzzleContainer.style.left = '50%';
        puzzleContainer.style.transform = 'translate(-50%, -50%)';
        puzzleContainer.style.zIndex = '9999'; // 使用極高的z-index確保在所有元素之上
        puzzleContainer.style.maxHeight = '80vh';
        puzzleContainer.style.overflowY = 'auto';
        puzzleContainer.style.width = '90%';
        puzzleContainer.style.maxWidth = '800px';
        puzzleContainer.style.background = 'transparent'; // 設置為透明背景
        puzzleContainer.style.backdropFilter = 'none'; // 移除背景模糊效果
      } else if (gameState.currentChapter === 'chapter7') {
        // 第七章道歸混沌使用透明背景樣式，但確保最高z-index
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center rounded-xl';
        puzzleContainer.style.background = 'transparent'; // 透明背景
        puzzleContainer.style.backdropFilter = 'none'; // 移除背景模糊效果
        puzzleContainer.style.border = 'none'; // 移除邊框
        puzzleContainer.style.boxShadow = 'none'; // 移除陰影
        puzzleContainer.style.position = 'relative'; // 確保z-index生效
        puzzleContainer.style.zIndex = '20000'; // 使用超高z-index確保在氣視覺效果和所有其他元素之上
      } else if (gameState.currentChapter === 'epilogue') {
        // 尾聲章節使用垂直居中樣式
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center rounded-xl';
        puzzleContainer.style.position = 'fixed';
        puzzleContainer.style.top = '50%';
        puzzleContainer.style.left = '50%';
        puzzleContainer.style.transform = 'translate(-50%, -50%)';
        puzzleContainer.style.zIndex = '9999';
        puzzleContainer.style.background = 'rgba(255, 255, 255, 0.9)';
        puzzleContainer.style.border = '2px solid rgba(139, 69, 19, 0.3)';
        puzzleContainer.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.15)';
        puzzleContainer.style.backdropFilter = 'blur(8px)';
      } else {
        // 其他章節使用原有樣式
        puzzleContainer.className = 'max-w-3xl mx-auto p-8 text-center bg-white dark:bg-gray-800 bg-opacity-80 dark:bg-opacity-80 rounded-xl shadow-lg';
      }
      
      // For chapter 2, add special cloud effects
      if (gameState.currentChapter === 'chapter2') {
        // Create a cloud-themed container
        puzzleContainer.classList.add('relative', 'overflow-hidden');
        puzzleContainer.style.borderRadius = '1rem';
        
        // Add cloud top
        const cloudTop = document.createElement('div');
        cloudTop.className = 'absolute top-0 left-0 w-full h-10 opacity-80';
        cloudTop.style.background = 'linear-gradient(to bottom, rgba(255,255,255,0.9), rgba(255,255,255,0))';
        puzzleContainer.appendChild(cloudTop);
        
        // Add cloud bottom
        const cloudBottom = document.createElement('div');
        cloudBottom.className = 'absolute bottom-0 left-0 w-full h-10 opacity-80';
        cloudBottom.style.background = 'linear-gradient(to top, rgba(255,255,255,0.9), rgba(255,255,255,0))';
        puzzleContainer.appendChild(cloudBottom);
        
        // Add cloud animation keyframes if not already present
        if (!document.getElementById('cloud-animations')) {
          const styleElement = document.createElement('style');
          styleElement.id = 'cloud-animations';
          styleElement.textContent = `
            @keyframes cloudMove {
              0% { background-position-x: 0; }
              100% { background-position-x: 1000px; }
            }
            
            @keyframes float-cloud-particle {
              0%, 100% { transform: translateY(0); }
              50% { transform: translateY(-20px); }
            }
            
            @keyframes drift-char {
              0%, 100% { transform: translateY(0) rotate(0deg); }
              25% { transform: translateY(-3px) rotate(1deg); }
              75% { transform: translateY(3px) rotate(-1deg); }
            }
            
            .cloud-char {
              display: inline-block;
              animation: drift-char 5s infinite ease-in-out;
            }
          `;
          document.head.appendChild(styleElement);
        }
        
        // Add some floating cloud particles
        for (let i = 0; i < 10; i++) {
          const cloudParticle = document.createElement('div');
          const size = 20 + Math.random() * 40;
          cloudParticle.className = 'absolute rounded-full bg-white dark:bg-gray-300 bg-opacity-60 dark:bg-opacity-40 pointer-events-none';
          cloudParticle.style.width = size + 'px';
          cloudParticle.style.height = size + 'px';
          cloudParticle.style.filter = 'blur(8px)';
          cloudParticle.style.left = Math.random() * 100 + '%';
          cloudParticle.style.top = Math.random() * 80 + 10 + '%';
          cloudParticle.style.animation = `float-cloud-particle ${8 + Math.random() * 7}s infinite ease-in-out ${Math.random() * 5}s`;
          cloudParticle.style.zIndex = '1';
          puzzleContainer.appendChild(cloudParticle);
        }
      }
      
      // Create hint
      const hintElement = document.createElement('p');
      // 根據章節設置不同的文字顏色
      let hintTextColor;
      if (gameState.currentChapter === 'chapter7') {
        // 第七章使用淺色文字以在深色背景中更明顯
        hintTextColor = 'text-gray-600 dark:text-gray-300';
      } else if (gameState.currentChapter === 'epilogue') {
        // 尾聲章節使用黑色文字以在白色背景中更明顯
        hintTextColor = 'text-black';
      } else {
        // 其他章節使用默認顏色
        hintTextColor = 'text-gray-600 dark:text-gray-300';
      }
      hintElement.className = `text-sm ${hintTextColor} mb-6 relative z-10 text-left`;
      
      // 添加斷句位置數量提示
      const segmentCount = scene.solution.length;
      const baseHint = scene.hint || '仔細閱讀這段古文，理解其含義並找出正確的斷句位置。';
      const enhancedHint = baseHint + ` 本文共有 <span class="inline-block px-2 py-1 bg-indigo-100 dark:bg-indigo-800 text-indigo-800 dark:text-indigo-200 rounded-md font-bold text-base">${segmentCount}</span> 個斷句位置。`;
      
      hintElement.innerHTML = enhancedHint;
      puzzleContainer.appendChild(hintElement);
      
      // Create text segment container
      const textContainer = document.createElement('div');
      // 根據章節設置不同的文字顏色
      let textColor;
      if (gameState.currentChapter === 'chapter7') {
        // 第七章使用淺色文字以在深色背景中更明顯
        textColor = 'text-gray-800 dark:text-gray-200';
      } else if (gameState.currentChapter === 'epilogue') {
        // 尾聲章節使用黑色文字以在白色背景中更明顯
        textColor = 'text-black';
      } else if (gameState.currentChapter === 'chapter6') {
        // 第六章使用空文字顏色類，讓heaven-earth-text樣式完全控制顏色
        textColor = '';
      } else {
        // 其他章節使用默認顏色
        textColor = 'text-gray-800 dark:text-gray-200';
      }
      textContainer.className = `text-segment-container text-2xl ${scene.textStyle} ${textColor} relative`;
      textContainer.style.zIndex = gameState.currentChapter === 'chapter7' ? '15002' : '10';
      
      // Define a fixed width for characters to maintain precise gap positioning
      const CHAR_WIDTH = 30; // Fixed width for each character
      
      // Create text characters and gaps with absolute positioning for precise control
      scene.text.split('').forEach((char, index) => {
        // Add character with fixed width
        const charSpan = document.createElement('span');
        charSpan.className = 'text-char';
        charSpan.style.display = 'inline-block';
        charSpan.style.width = `${CHAR_WIDTH}px`; // Fixed width for consistent spacing
        charSpan.style.textAlign = 'center'; // Center the text within the fixed width
        
        // For Chapter 2 (cloud), add cloud-specific animation to each character
        if (gameState.currentChapter === 'chapter2') {
          charSpan.classList.add('cloud-char');
          // Add slight delay variation for more natural cloud movement
          charSpan.style.animationDelay = (index * 0.08) % 1 + 's';
        }
        

        
        // Apply consistent styling for precise character spacing
        charSpan.style.margin = '0';
        charSpan.style.padding = '0';
        
        charSpan.textContent = char;
        textContainer.appendChild(charSpan);
        
        // Add gap after character (except for the last character)
        if (index < scene.text.length - 1) {
          // Create a completely revised character gap with more precise positioning
          const charGap = document.createElement('div');
          charGap.className = 'char-gap';
          
          // Changed from inline-block to absolute positioning for precise control
          charGap.style.display = 'inline-block';
          charGap.style.width = '18px'; // Narrower gap to ensure it's right between characters
          charGap.style.height = '1.75em'; // Match text height
          charGap.style.position = 'relative';
          charGap.style.verticalAlign = 'middle';
          charGap.style.cursor = 'pointer';
          charGap.style.marginLeft = '-6px'; // 左移6px修正偏右问题
          charGap.style.marginBottom = '2px'; // 轻微上移以确保垂直居中
          charGap.style.zIndex = gameState.currentChapter === 'chapter6' ? '10000' : (gameState.currentChapter === 'chapter7' ? '15005' : (gameState.currentChapter === 'epilogue' ? '10000' : '10000')); // 第六章、第七章和第九章使用超高z-index確保可點擊
          
          // Create the perfectly centered dot with improved positioning
          const dot = document.createElement('span');
          dot.className = 'segment-dot';
          dot.dataset.index = index;
          dot.style.position = 'absolute';
          dot.style.width = '10px';
          dot.style.height = '10px'; 
          dot.style.borderRadius = '50%';
          dot.style.backgroundColor = '#4F46E5';
          dot.style.opacity = gameState.segmentationPuzzleState.segments[index] ? '1' : '0';
          dot.style.transition = 'all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1)';
          dot.style.boxShadow = '0 0 8px 2px rgba(79, 70, 229, 0.7)';
          
          // Force exact centered positioning with explicit transform
          dot.style.top = 'calc(50% - 1px)'; // 微调垂直位置以完全居中
          dot.style.left = '50%';
          dot.style.transform = 'translate(-50%, -50%)';
          dot.style.margin = '0';
          dot.style.padding = '0';
          dot.style.zIndex = gameState.currentChapter === 'chapter6' ? '10005' : (gameState.currentChapter === 'chapter7' ? '15010' : (gameState.currentChapter === 'epilogue' ? '10005' : '10005')); // 第六章、第七章和第九章使用超高z-index確保可見
          
          // Add click-ripple animation
          if (!document.getElementById('click-ripple-animation')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'click-ripple-animation';
            styleEl.textContent = `
              @keyframes click-ripple {
                0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
                100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
              }
            `;
            document.head.appendChild(styleEl);
          }
          
          // Add hover effect animation
          const glowEffect = document.createElement('span');
          glowEffect.className = 'glow-effect';
          glowEffect.style.position = 'absolute';
          glowEffect.style.width = '14px';
          glowEffect.style.height = '14px';
          glowEffect.style.borderRadius = '50%';
          glowEffect.style.backgroundColor = 'rgba(79, 70, 229, 0.4)';
          glowEffect.style.opacity = '0';
          glowEffect.style.transform = 'translate(-50%, -50%) scale(0.8)';
          glowEffect.style.top = '50%';
          glowEffect.style.left = '50%';
          glowEffect.style.transition = 'all 0.2s ease-out';
          glowEffect.style.boxShadow = '0 0 10px 4px rgba(79, 70, 229, 0.3)';
          glowEffect.style.zIndex = gameState.currentChapter === 'chapter6' ? '10004' : (gameState.currentChapter === 'chapter7' ? '15009' : (gameState.currentChapter === 'epilogue' ? '10004' : '10004')); // 第六章、第七章和第九章使用超高z-index確保可見
          
          // Active state styling
          if (gameState.segmentationPuzzleState.segments[index]) {
            dot.classList.add('active');
            dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
          }
          
          // Add hover effects
          charGap.addEventListener('mouseenter', () => {
            if (!gameState.segmentationPuzzleState.segments[index]) {
              dot.style.opacity = '0.8';
              glowEffect.style.opacity = '1';
              glowEffect.style.transform = 'translate(-50%, -50%) scale(1.2)';
            }
          });
          
          charGap.addEventListener('mouseleave', () => {
            if (!gameState.segmentationPuzzleState.segments[index]) {
              dot.style.opacity = '0';
              glowEffect.style.opacity = '0';
              glowEffect.style.transform = 'translate(-50%, -50%) scale(0.8)';
            }
          });
          
          // Add click event to the entire gap
          charGap.addEventListener('click', (e) => {
            // Toggle active state
            toggleSegment(index);
            
            // Add click animation
            const clickAnimation = document.createElement('span');
            clickAnimation.style.position = 'absolute';
            clickAnimation.style.top = '50%';
            clickAnimation.style.left = '50%';
            clickAnimation.style.width = '20px';
            clickAnimation.style.height = '20px';
            clickAnimation.style.backgroundColor = 'rgba(79, 70, 229, 0.3)';
            clickAnimation.style.borderRadius = '50%';
            clickAnimation.style.transform = 'translate(-50%, -50%) scale(0)';
            clickAnimation.style.animation = 'click-ripple 0.6s ease-out forwards';
            clickAnimation.style.zIndex = gameState.currentChapter === 'chapter6' ? '10003' : (gameState.currentChapter === 'chapter7' ? '15008' : (gameState.currentChapter === 'epilogue' ? '10003' : '10003'));
            charGap.appendChild(clickAnimation);
            
            // Remove animation element after it completes
            setTimeout(() => {
              clickAnimation.remove();
            }, 600);
            
            // For Chapter 2, add cloud ripple effect on click
            if (gameState.currentChapter === 'chapter2') {
              createCloudRipple(e.clientX, e.clientY);
            }
          });
          
          // Add elements to the DOM
          charGap.appendChild(glowEffect);
          charGap.appendChild(dot);
          textContainer.appendChild(charGap);
        }
      });
      
      puzzleContainer.appendChild(textContainer);
      
      // Create result element
      const resultElement = document.createElement('p');
      resultElement.id = 'puzzle-result';
      resultElement.className = 'text-lg mt-6 hidden relative z-10';
      puzzleContainer.appendChild(resultElement);
      
      // Add check answer button
      const checkButton = document.createElement('button');
      checkButton.id = 'check-segmentation';
      checkButton.className = 'mt-6 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-6 rounded-full relative z-10';
      checkButton.textContent = '檢查答案';
      checkButton.addEventListener('click', () => checkSegmentationSolution(scene.solution));
      puzzleContainer.appendChild(checkButton);
      
      // 添加AI解讀按鈕
      const aiInterpretButton = document.createElement('button');
      aiInterpretButton.id = 'ai-interpret-button';
      aiInterpretButton.className = 'mt-4 bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-6 rounded-full relative z-10 mx-auto';
      aiInterpretButton.style.display = 'flex';
      aiInterpretButton.style.alignItems = 'center';
      aiInterpretButton.style.gap = '8px';
      aiInterpretButton.style.justifyContent = 'center';
      aiInterpretButton.innerHTML = `
        <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 20 20">
          <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/>
        </svg>
        莊子解讀
      `;
      aiInterpretButton.addEventListener('click', () => openAIInterpretModal(scene));
      puzzleContainer.appendChild(aiInterpretButton);
      
      // Add developer skip button for testing (only in dev mode)
      if (gameState.devMode) {
        const skipButton = document.createElement('button');
        skipButton.id = 'skip-segmentation';
        skipButton.className = 'ml-4 mt-6 bg-yellow-500 hover:bg-yellow-600 text-white font-bold py-2 px-4 rounded-full relative z-10 text-sm';
        skipButton.textContent = '開發者跳過';
        skipButton.title = '僅供開發測試使用';
        skipButton.addEventListener('click', () => {
          // Automatically complete the puzzle for testing
          skipSegmentationPuzzle(scene);
        });
        puzzleContainer.appendChild(skipButton);
      }
      
      // 第六章將斷句挑戰容器直接添加到body，脫離game-content的堆疊上下文
      if (gameState.currentChapter === 'chapter6') {
        document.body.appendChild(puzzleContainer);
      } else {
        gameContent.appendChild(puzzleContainer);
      }
      
      // Hide advance button until puzzle is solved
      advanceBtn.style.display = 'none';
    }
    

    
    // Create cloud ripple effect for Chapter 2
    function createCloudRipple(x, y) {
      const ripple = document.createElement('div');
      ripple.className = 'absolute rounded-full pointer-events-none';
      ripple.style.left = x + 'px';
      ripple.style.top = y + 'px';
      ripple.style.width = '10px';
      ripple.style.height = '10px';
      ripple.style.marginLeft = '-5px';
      ripple.style.marginTop = '-5px';
      ripple.style.border = '2px solid rgba(64, 186, 213, 0.6)';
      ripple.style.animation = 'cloud-ripple 1.5s linear';
      
      document.body.appendChild(ripple);
      
      // Remove the ripple after animation completes
      setTimeout(() => {
        ripple.remove();
      }, 1500);
      
      // Add keyframes for cloud ripple effect
      if (!document.getElementById('cloud-ripple-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'cloud-ripple-animation';
        styleElement.textContent = `
          @keyframes cloud-ripple {
            0% { transform: scale(1); opacity: 1; border-color: rgba(64, 186, 213, 0.6); }
            100% { transform: scale(10); opacity: 0; border-color: rgba(103, 200, 208, 0.3); }
          }

          @keyframes sound-wave {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(7); opacity: 0; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Add necessary keyframes for animations
    if (!document.getElementById('ripple-animation')) {
      const styleElement = document.createElement('style');
      styleElement.id = 'ripple-animation';
      styleElement.textContent = `
        @keyframes ripple {
          0% { transform: scale(1); opacity: 1; }
          100% { transform: scale(10); opacity: 0; }
        }
        
        @keyframes pulse-subtle {
          0%, 100% { opacity: 1; transform: scale(1); }
          50% { opacity: 0.95; transform: scale(0.98); }
        }
        
        @keyframes glow-slide {
          0% { transform: translateX(-100%); }
          100% { transform: translateX(100%); }
        }
        
        @keyframes spin-slow {
          from { transform: rotate(0deg); }
          to { transform: rotate(360deg); }
        }
        
        @keyframes spin-slow-reverse {
          from { transform: rotate(0deg); }
          to { transform: rotate(-360deg); }
        }
        
        @keyframes segment-hover {
          0% { transform: scaleY(1); background-color: rgba(93, 92, 222, 0.05); }
          100% { transform: scaleY(1.05); background-color: rgba(93, 92, 222, 0.15); }
        }
        
        @keyframes segment-active-pulse {
          0%, 100% { box-shadow: 0 0 8px 1px rgba(93, 92, 222, 0.4); }
          50% { box-shadow: 0 0 12px 3px rgba(93, 92, 222, 0.6); }
        }
        
        .segment-clicked {
          animation: segment-click 0.3s cubic-bezier(.17,.67,.83,.67);
        }
        
        @keyframes segment-click {
          0% { transform: scaleY(1); }
          50% { transform: scaleY(0.85); }
          100% { transform: scaleY(1); }
        }
      `;
      document.head.appendChild(styleElement);
    }
    
    function createTutorialScene(scene) {
      const tutorialElement = document.createElement('div');
      
      // 检查是否有蜗牛存在，如果有则调整教程文字位置
      const hasSnail = document.querySelector('.snail-shell');
      if (hasSnail) {
        tutorialElement.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-2xl p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-30 border border-indigo-200 dark:border-indigo-700';
      } else {
        tutorialElement.className = 'max-w-2xl mx-auto p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-90 dark:bg-opacity-90 rounded-lg';
      }
      
      tutorialElement.innerHTML = `
        <p class="text-lg">${scene.text}</p>
      `;
      
      gameContent.appendChild(tutorialElement);
      
      // 如果是视角控制器教程，先显示文字，然后启用控制器
      if (scene.effect === 'unlockViewScale') {
        // 2秒后启用视角控制器，让用户先看到教程文字
        setTimeout(() => {
          enableScaleControl();
        }, 2000);
      }
      
      // Set up event listener based on waitFor condition
      if (scene.waitFor) {
        const [action, target] = scene.waitFor.split(':');
        
        // Hide advance button until transformation is done
        advanceBtn.style.display = 'none';
        
        if (action === 'transform') {
          if (target === 'bird-toggle') {
            // Special case for bird toggle
            const onClick = () => {
              // Listen for bird state toggle
              const currentState = gameState.birdState;
              
              setTimeout(() => {
                if (gameState.birdState !== currentState) {
                  // Bird state was toggled
                  advanceBtn.style.display = 'block';
                  tutorialElement.style.display = 'none';
                  formButtons.bird.removeEventListener('click', onClick);
                }
              }, 1600);
            };
            
            // Add event listeners to both yuanchu and chixiao buttons
            formButtons.yuanchu.addEventListener('click', onClick);
            formButtons.chixiao.addEventListener('click', onClick);
          } else {
            // Regular transformation - for butterfly, fish, etc.
            let targetButton = null;
            
            // 找到目標變身按鈕
            for (const [form, button] of Object.entries(formButtons)) {
              if (form === target) {
                targetButton = button;
                break;
              }
            }
            
            if (targetButton) {
              const onClick = () => {
                // 設置定時器等待變身完成後再檢查
                setTimeout(() => {
                  if (gameState.currentForm === target) {
                    // 顯示繼續按鈕
                    advanceBtn.style.display = 'block';
                    // 隱藏提示信息
                    tutorialElement.style.display = 'none';
                    // 移除事件監聽器
                    targetButton.removeEventListener('click', onClick);
                  }
                }, 1600); // 等待變身動畫完成
              };
              
              // 只監聽目標按鈕而不是所有按鈕
              targetButton.addEventListener('click', onClick);
            }
          }
        } else if (action === 'scale') {
          // Handle scale-related waitFor conditions
          if (target === 'change') {
            // Listen for scale change events
            const scaleChangeHandler = () => {
              advanceBtn.style.display = 'block';
              tutorialElement.style.display = 'none';
              document.removeEventListener('scaleChange', scaleChangeHandler);
            };
            document.addEventListener('scaleChange', scaleChangeHandler);
          } else if (target === 'macro') {
            // Listen for macro scale events
            const scaleMacroHandler = () => {
              advanceBtn.style.display = 'block';
              tutorialElement.style.display = 'none';
              document.removeEventListener('scaleMacro', scaleMacroHandler);
            };
            document.addEventListener('scaleMacro', scaleMacroHandler);
          }
        }
      } else {
        advanceBtn.style.display = 'block';
      }
    }
    
    function toggleSegment(index) {
      // 檢查是否是第一次點擊（開始計時）
      const currentData = gameState.currentPuzzleData;
      
      // 如果是第一次點擊，設置startTime（只使用內存數據，不觸及localStorage）
      if (!currentData.startTime) {
        currentData.startTime = Date.now();
        console.log('⏱️ 斷句挑戰計時開始（第一次點擊）:', 'startTime:', currentData.startTime);
      }
      
      // Toggle segment state
      gameState.segmentationPuzzleState.segments[index] = !gameState.segmentationPuzzleState.segments[index];
      
      // 清除該位置的錯誤標識（如果存在）
      const dot = document.querySelector(`.segment-dot[data-index="${index}"]`);
      if (dot && dot.classList.contains('error-highlight')) {
        dot.classList.remove('error-highlight');
        dot.style.animation = '';
      }
      
      // 添加第六章和第七章的點擊調試log
      if (gameState.currentChapter === 'chapter6') {
        console.log(`第六章點擊調試: 點擊位置 ${index}, 新狀態: ${gameState.segmentationPuzzleState.segments[index]}`);
        console.log('當前所有點擊狀態:', gameState.segmentationPuzzleState.segments);
      }
      
      // 添加第七章的點擊調試log
      if (gameState.currentChapter === 'chapter7') {
        console.log(`第七章點擊調試: 點擊位置 ${index}, 新狀態: ${gameState.segmentationPuzzleState.segments[index]}`);
        console.log('當前所有點擊狀態:', gameState.segmentationPuzzleState.segments);
        
        // 顯示當前已點擊的位置
        const clickedPositions = gameState.segmentationPuzzleState.segments
          .map((val, idx) => val ? idx : null)
          .filter(x => x !== null);
        console.log('第七章已點擊的位置索引:', clickedPositions);
      }
      
      // Update visual state (使用已經獲取的dot元素)
      if (dot) { // Check if dot exists before accessing its properties
        // Update opacity and active state
        if (gameState.segmentationPuzzleState.segments[index]) {
          dot.style.opacity = '1';
          dot.classList.add('active');
          dot.style.backgroundColor = '#4F46E5'; // 確保恢復正確顏色
          dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
          
          // Add pulsating animation for active dot
          if (!document.getElementById('dot-pulse-animation')) {
            const styleEl = document.createElement('style');
            styleEl.id = 'dot-pulse-animation';
            styleEl.textContent = `
              @keyframes dot-pulse {
                0%, 100% { transform: translate(-50%, -50%) scale(1); box-shadow: 0 0 12px 4px rgba(79, 70, 229, 0.8); }
                50% { transform: translate(-50%, -50%) scale(1.15); box-shadow: 0 0 16px 6px rgba(79, 70, 229, 0.9); }
              }
              
              @keyframes click-ripple {
                0% { transform: translate(-50%, -50%) scale(0); opacity: 0.7; }
                100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
              }
              
              .segment-dot.active {
                animation: dot-pulse 2s infinite ease-in-out;
              }
            `;
            document.head.appendChild(styleEl);
          }
        } else {
          dot.style.opacity = '0';
          dot.classList.remove('active');
          dot.style.backgroundColor = '#4F46E5'; // 確保恢復正確顏色
          dot.style.boxShadow = '0 0 8px 2px rgba(79, 70, 229, 0.7)';
        }
      } else {
        console.warn(`No dot found with index ${index}`);
      }
    }
    
    function checkSegmentationSolution(solution) {
      const currentState = gameState.segmentationPuzzleState.segments;
      let isCorrect = true;
      
      // 添加第六章的詳細調試log
      if (gameState.currentChapter === 'chapter6') {
        console.log('=== 第六章斷句調試信息 ===');
        console.log('當前章節:', gameState.currentChapter);
        console.log('當前場景:', gameState.currentScene);
        console.log('正確答案 solution:', solution);
        console.log('用戶點擊狀態 currentState:', currentState);
        console.log('用戶點擊的位置 (true的索引):', currentState.map((val, idx) => val ? idx : null).filter(x => x !== null));
        console.log('正確位置應該是:', solution);
        console.log('currentState長度:', currentState.length);
        console.log('solution長度:', solution.length);
      }
      
      // 添加第七章的詳細調試log
      if (gameState.currentChapter === 'chapter7') {
        console.log('=== 第七章斷句調試信息 ===');
        console.log('當前章節:', gameState.currentChapter);
        console.log('當前場景:', gameState.currentScene);
        console.log('正確答案 solution:', solution);
        console.log('用戶點擊狀態 currentState:', currentState);
        console.log('用戶點擊的位置 (true的索引):', currentState.map((val, idx) => val ? idx : null).filter(x => x !== null));
        console.log('正確位置應該是:', solution);
        console.log('currentState長度:', currentState.length);
        console.log('solution長度:', solution.length);
        
        // 顯示文本內容以便對照
        const currentChapter = gameChapters[gameState.currentChapter];
        const currentScene = currentChapter.scenes[gameState.currentScene];
        console.log('斷句文本:', currentScene.text);
        console.log('文本長度:', currentScene.text.length);
      }
      
      // 添加尾聲章節的詳細調試log
      if (gameState.currentChapter === 'epilogue') {
        console.log('=== 尾聲章節斷句調試信息 ===');
        console.log('當前章節:', gameState.currentChapter);
        console.log('當前場景:', gameState.currentScene);
        console.log('正確答案 solution:', solution);
        console.log('用戶點擊狀態 currentState:', currentState);
        console.log('用戶點擊的位置 (true的索引):', currentState.map((val, idx) => val ? idx : null).filter(x => x !== null));
        console.log('正確位置應該是:', solution);
        console.log('currentState長度:', currentState.length);
        console.log('solution長度:', solution.length);
        
        // 顯示文本內容以便對照
        const currentChapter = gameChapters[gameState.currentChapter];
        const currentScene = currentChapter.scenes[gameState.currentScene];
        console.log('斷句文本:', currentScene.text);
        console.log('文本長度:', currentScene.text.length);
        
        // 特殊功能：當用戶正確完成時，生成可複製的答案
        const userClickedPositions = currentState.map((val, idx) => val ? idx : null).filter(x => x !== null);
        const isUserCorrect = userClickedPositions.length === solution.length && 
                             userClickedPositions.every(pos => solution.includes(pos));
        
        if (isUserCorrect) {
          console.log('🎉 尾聲章節斷句挑戰完成正確！');
          console.log('📋 可複製的答案格式：');
          console.log(`solution: [${userClickedPositions.join(', ')}]`);
          console.log('📝 完整的場景配置建議：');
          console.log(`{
  type: 'segmentation-puzzle',
  text: '${currentScene.text}',
  solution: [${userClickedPositions.join(', ')}],
  hint: '${currentScene.hint || '請根據文意斷句'}',
  success: '${currentScene.success || '斷句正確！'}',
  nextScene: ${currentScene.nextScene || 'NEXT_SCENE_NUMBER'}
}`);
        }
      }
      
      // Check if all correct segments are marked and no incorrect ones
      for (let i = 0; i < currentState.length; i++) {
        const shouldBeMarked = solution.includes(i);
        if (shouldBeMarked !== currentState[i]) {
          if (gameState.currentChapter === 'chapter6') {
            console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 不匹配!`);
          }
          if (gameState.currentChapter === 'chapter7') {
            console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 不匹配!`);
          }
          if (gameState.currentChapter === 'epilogue') {
            console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 不匹配!`);
          }
          isCorrect = false;
          break;
        } else if (gameState.currentChapter === 'chapter6') {
          console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 匹配`);
        } else if (gameState.currentChapter === 'chapter7') {
          console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 匹配`);
        } else if (gameState.currentChapter === 'epilogue') {
          console.log(`位置 ${i}: 應該標記=${shouldBeMarked}, 實際標記=${currentState[i]} - 匹配`);
        }
      }
      
      if (gameState.currentChapter === 'chapter6') {
        console.log('最終判定結果:', isCorrect ? '正確' : '錯誤');
        console.log('=== 調試信息結束 ===');
      }
      
      if (gameState.currentChapter === 'chapter7') {
        console.log('最終判定結果:', isCorrect ? '正確' : '錯誤');
        console.log('=== 第七章調試信息結束 ===');
      }
      
      if (gameState.currentChapter === 'epilogue') {
        console.log('最終判定結果:', isCorrect ? '正確' : '錯誤');
        console.log('=== 尾聲章節調試信息結束 ===');
      }
      
      const resultElement = document.getElementById('puzzle-result');
      const checkButton = document.getElementById('check-segmentation');
      
      if (isCorrect) {
        if (!gameState.segmentationPuzzleState.solved) {
          // Mark as solved
          gameState.segmentationPuzzleState.solved = true;
          
          // 記錄斷句挑戰嘗試數據（確保puzzleRecord被正確初始化）
          recordSegmentationPuzzleAttempt(true);
          
          // 記錄斷句挑戰完成數據
          recordSegmentationPuzzleCompletion(true);
          
          // 恢復混沌的正常層級
          const chaosForm = document.querySelector('.chaos-form');
          if (chaosForm) {
            chaosForm.classList.remove('segmentation-mode');
          }
          
          // 獲取本次斷句的數據
          const currentData = gameState.currentPuzzleData;
          
          // 計算完成時間和嘗試次數
          let completionTime = 0;
          if (currentData && currentData.startTime) {
            completionTime = Date.now() - currentData.startTime;
          } else {
            console.warn('⚠️ 斷句挑戰完成時startTime未設置，使用0作為完成時間');
          }
          const attemptCount = currentData ? currentData.attempts : 1;
          const timeInSeconds = Math.round(completionTime / 1000);
          
          // 調試信息
          console.log('🔍 斷句挑戰計時調試:');
          console.log('  currentData:', currentData);
          console.log('  startTime:', currentData?.startTime);
          console.log('  currentTime:', Date.now());
          console.log('  completionTime (ms):', completionTime);
          console.log('  timeInSeconds:', timeInSeconds);
          console.log('  attemptCount:', attemptCount);
          
          // 生成成功消息，包含時間和嘗試次數
          const successMessage = gameChapters[gameState.currentChapter].scenes[gameState.currentScene].success;
          const statsMessage = `\n\n⏱️ 完成時間：${timeInSeconds}秒\n🎯 嘗試次數：${attemptCount}次`;
          
          // 清除之前的定時器（如果有的話）
          if (gameState.segmentationPuzzleState.hideTimer) {
            clearTimeout(gameState.segmentationPuzzleState.hideTimer);
            gameState.segmentationPuzzleState.hideTimer = null;
          }
          
          // Show success message with stats
          resultElement.innerHTML = `
            <div style="text-align: center;">
              <div style="color: #4F46E5; font-size: 1.2rem; margin-bottom: 1rem;">${successMessage}</div>
              <div style="background: rgba(79, 70, 229, 0.1); border-radius: 10px; padding: 1rem; border: 1px solid rgba(79, 70, 229, 0.3);">
                <div style="display: flex; justify-content: space-around; align-items: center;">
                  <div style="text-align: center;">
                    <div style="font-size: 1.5rem; color: #F59E0B; font-weight: bold;" data-value="${timeInSeconds}">0s</div>
                    <div style="color: #C0C0C0; font-size: 0.9rem;">完成時間</div>
                  </div>
                   <div style="width: 1px; height: 40px; background: rgba(79, 70, 229, 0.3);"></div>
                   <div style="text-align: center;">
                     <div style="font-size: 1.5rem; color: #10B981; font-weight: bold;" data-value="${attemptCount}">0</div>
                     <div style="color: #C0C0C0; font-size: 0.9rem;">嘗試次數</div>
                  </div>
                </div>
              </div>
            </div>
          `;
          resultElement.className = 'text-lg mt-6 text-indigo-600 dark:text-indigo-400';
          resultElement.classList.remove('hidden');
          
          // 添加統計信息的動畫效果
          setTimeout(() => {
            const statsContainer = resultElement.querySelector('div[style*="background: rgba(79, 70, 229, 0.1)"]');
            if (statsContainer) {
              statsContainer.style.opacity = '0';
              statsContainer.style.transform = 'translateY(20px)';
              statsContainer.style.transition = 'all 0.5s ease';
              
              setTimeout(() => {
                statsContainer.style.opacity = '1';
                statsContainer.style.transform = 'translateY(0)';
                
                // 數字計數動畫
                const timeElement = statsContainer.querySelector('div[data-value]');
                const attemptElement = statsContainer.querySelectorAll('div[data-value]')[1];
                
                if (timeElement) {
                  const targetTime = parseInt(timeElement.dataset.value);
                  animateNumber(timeElement, 0, targetTime, 1000, 's');
                }
                
                if (attemptElement) {
                  const targetAttempts = parseInt(attemptElement.dataset.value);
                  animateNumber(attemptElement, 0, targetAttempts, 800);
                }
              }, 100);
            }
          }, 200);
          
          // 在數字動畫完成後立即顯示繼續按鈕
          setTimeout(() => {
            checkButton.textContent = '繼續';
            checkButton.style.background = 'linear-gradient(135deg, #10B981, #059669)';
            checkButton.style.color = '#ffffff';
            checkButton.style.animation = 'gentle-pulse 2s ease-in-out infinite';
            checkButton.addEventListener('click', advanceScene, { once: true });
            
            // 添加提示文字
            const hintElement = document.createElement('div');
            hintElement.style.cssText = `
              text-align: center;
              color: #9CA3AF;
              font-size: 0.9rem;
              margin-top: 1rem;
              opacity: 0;
              transition: opacity 0.5s ease;
            `;
            hintElement.textContent = '統計信息已保存，點擊繼續進入下一個場景';
            
            // 將提示添加到結果元素後面
            resultElement.parentNode.insertBefore(hintElement, resultElement.nextSibling);
            
            // 顯示提示文字
            setTimeout(() => {
              hintElement.style.opacity = '1';
            }, 100);
            
          }, 1200); // 數字動畫完成後立即顯示繼續按鈕
          
          // 確保繼續按鈕有足夠的視覺提示
          if (!document.getElementById('gentle-pulse-animation')) {
            const styleElement = document.createElement('style');
            styleElement.id = 'gentle-pulse-animation';
            styleElement.textContent = `
              @keyframes gentle-pulse {
                0%, 100% { 
                  transform: scale(1);
                  box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
                }
                50% { 
                  transform: scale(1.05);
                  box-shadow: 0 6px 20px rgba(16, 185, 129, 0.6);
                }
              }
            `;
            document.head.appendChild(styleElement);
          }
          
          // Hide advance button since we're using the check button as continue
          advanceBtn.style.display = 'none';
        }
      } else {
        // 記錄斷句挑戰嘗試數據（失敗時也要確保puzzleRecord存在）
        recordSegmentationPuzzleAttempt(false);
        // 標識錯誤的位置
        highlightIncorrectSegments(solution, currentState);
        
        // 計算用戶多標記的錯誤數量
        const incorrectCount = currentState.reduce((count, userMarked, index) => {
          const shouldBeMarked = solution.includes(index);
          // 只計算用戶多標記的錯誤（不應該標記但標記了）
          return count + (!shouldBeMarked && userMarked ? 1 : 0);
        }, 0);
        
        // 計算用戶已正確標記的數量
        const correctlyMarkedCount = solution.reduce((count, correctIndex) => {
          return count + (currentState[correctIndex] ? 1 : 0);
        }, 0);
        
        const totalSegments = solution.length;
        
        // 生成正面鼓勵的提示信息
        let encouragingMessage = '';
        if (incorrectCount === 0) {
          // 沒有多標記錯誤，但還有位置沒標記
          const missingCount = totalSegments - correctlyMarkedCount;
          encouragingMessage = `很好！沒有多餘的標記。還需要找到 ${missingCount} 個正確的斷句位置。`;
        } else if (incorrectCount === 1) {
          encouragingMessage = `很棒！只有一個位置標記錯了。請移除標紅的位置，然後繼續尋找正確的斷句點。`;
        } else if (incorrectCount <= 3) {
          encouragingMessage = `做得不錯！請移除 ${incorrectCount} 個標紅的錯誤位置，然後重新思考正確的斷句點。`;
        } else {
          encouragingMessage = `請仔細思考斷句的邏輯！紅色標記顯示了 ${incorrectCount} 個不應該斷句的位置。`;
        }
        
        // Show error message with encouragement
        resultElement.textContent = encouragingMessage;
        resultElement.className = 'text-lg mt-6 text-orange-600 dark:text-orange-400';
        resultElement.classList.remove('hidden');
        
        // Hide message after 4 seconds (longer for encouragement)
        gameState.segmentationPuzzleState.hideTimer = setTimeout(() => {
          resultElement.classList.add('hidden');
          // 不自動清除錯誤標識，讓玩家主動調整
        }, 4000);
      }
    }
    
    // 標識錯誤的斷句位置
    function highlightIncorrectSegments(solution, currentState) {
      // 清除之前的錯誤標識
      clearErrorHighlights();
      
      console.log('錯誤標識: 正確答案=', solution, '用戶狀態=', currentState);
      
      for (let i = 0; i < currentState.length; i++) {
        const shouldBeMarked = solution.includes(i);
        const userMarked = currentState[i];
        
        // 只標識用戶多標記的錯誤位置：不應該標記但用戶標記了
        if (!shouldBeMarked && userMarked) {
          const dot = document.querySelector(`.segment-dot[data-index="${i}"]`);
          
          if (dot) {
            console.log(`位置 ${i} 標記為錯誤: 用戶多標記了不應該標記的位置`);
            
            // 添加錯誤標識樣式
            dot.classList.add('error-highlight');
            
            // 設置錯誤樣式（只是紅色點，沒有邊框）
            dot.style.backgroundColor = '#EF4444'; // 紅色
            dot.style.boxShadow = '0 0 12px 4px rgba(239, 68, 68, 0.8)';
            dot.style.opacity = '1'; // 確保顯示
            
            // 添加輕微的錯誤動畫
            dot.style.animation = 'error-pulse 2s infinite';
          }
        }
      }
      
      // 添加錯誤動畫樣式（如果不存在）
      if (!document.getElementById('error-animation-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'error-animation-styles';
        styleElement.textContent = `
          @keyframes error-pulse {
            0%, 100% { 
              background-color: #EF4444;
              box-shadow: 0 0 12px 4px rgba(239, 68, 68, 0.8);
            }
            50% { 
              background-color: #DC2626;
              box-shadow: 0 0 16px 6px rgba(239, 68, 68, 1);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 數字計數動畫函數
    function animateNumber(element, start, end, duration, suffix = '') {
      const startTime = performance.now();
      const difference = end - start;
      
      function updateNumber(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // 使用easeOutQuart緩動函數
        const easeProgress = 1 - Math.pow(1 - progress, 4);
        const currentValue = Math.round(start + (difference * easeProgress));
        
        element.textContent = currentValue + suffix;
        
        if (progress < 1) {
          requestAnimationFrame(updateNumber);
        }
      }
      
      requestAnimationFrame(updateNumber);
    }

    // 清除錯誤標識
    function clearErrorHighlights() {
      // 移除所有錯誤標識樣式
      document.querySelectorAll('.segment-dot.error-highlight').forEach(dot => {
        dot.classList.remove('error-highlight');
        dot.style.animation = '';
        
        // 恢復原始樣式
        const index = parseInt(dot.dataset.index);
        const isActive = gameState.segmentationPuzzleState.segments[index];
        
        if (isActive) {
          dot.style.backgroundColor = '#4F46E5'; // 恢復藍色
          dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
          dot.style.opacity = '1';
        } else {
          dot.style.backgroundColor = '#4F46E5';
          dot.style.boxShadow = '0 0 8px 2px rgba(79, 70, 229, 0.7)';
          dot.style.opacity = '0';
        }
      });
    }
    
    function skipSegmentationPuzzle(scene) {
      // Automatically set correct segments for testing
      scene.solution.forEach(index => {
        gameState.segmentationPuzzleState.segments[index] = true;
        // Update visual state
        const dot = document.querySelector(`.segment-dot[data-index="${index}"]`);
        if (dot) {
          dot.style.opacity = '1';
          dot.classList.add('active');
          dot.style.boxShadow = '0 0 12px 4px rgba(79, 70, 229, 0.8)';
        }
      });
      
      // Mark as solved
      gameState.segmentationPuzzleState.solved = true;
      
      // 恢復混沌的正常層級
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('segmentation-mode');
      }
      
      // Show success message
      const resultElement = document.getElementById('puzzle-result');
      const checkButton = document.getElementById('check-segmentation');
      const skipButton = document.getElementById('skip-segmentation');
      
      // 記錄斷句挑戰嘗試數據（開發者跳過的情況）
      recordSegmentationPuzzleAttempt(true);
      
      // 記錄斷句挑戰完成數據（開發者跳過的情況）
      recordSegmentationPuzzleCompletion(true);
      
      // 獲取本次斷句的數據（開發者跳過的情況）
      const currentData = gameState.currentPuzzleData;
      
      // 計算完成時間和嘗試次數
      const completionTime = currentData ? Date.now() - currentData.startTime : 0;
      const attemptCount = currentData ? currentData.attempts : 1;
      const timeInSeconds = Math.round(completionTime / 1000);
      
      resultElement.innerHTML = `
        <div style="text-align: center;">
          <div style="color: #10B981; font-size: 1.2rem; margin-bottom: 1rem;">${scene.success} （開發者跳過）</div>
          <div style="background: rgba(16, 185, 129, 0.1); border-radius: 10px; padding: 1rem; border: 1px solid rgba(16, 185, 129, 0.3);">
            <div style="display: flex; justify-content: space-around; align-items: center;">
                                <div style="text-align: center;">
                    <div style="font-size: 1.5rem; color: #F59E0B; font-weight: bold;" data-value="${timeInSeconds}">0s</div>
                    <div style="color: #C0C0C0; font-size: 0.9rem;">完成時間</div>
                  </div>
                   <div style="width: 1px; height: 40px; background: rgba(16, 185, 129, 0.3);"></div>
                   <div style="text-align: center;">
                     <div style="font-size: 1.5rem; color: #10B981; font-weight: bold;" data-value="${attemptCount}">0</div>
                     <div style="color: #C0C0C0; font-size: 0.9rem;">嘗試次數</div>
              </div>
            </div>
          </div>
        </div>
      `;
      resultElement.className = 'text-lg mt-6 text-green-600 dark:text-green-400';
      resultElement.classList.remove('hidden');
      
      // 添加統計信息的動畫效果（開發者跳過）
      setTimeout(() => {
        const statsContainer = resultElement.querySelector('div[style*="background: rgba(16, 185, 129, 0.1)"]');
        if (statsContainer) {
          statsContainer.style.opacity = '0';
          statsContainer.style.transform = 'translateY(20px)';
          statsContainer.style.transition = 'all 0.5s ease';
          
          setTimeout(() => {
            statsContainer.style.opacity = '1';
            statsContainer.style.transform = 'translateY(0)';
            
            // 數字計數動畫（開發者跳過）
            const timeElement = statsContainer.querySelector('div[data-value]');
            const attemptElement = statsContainer.querySelectorAll('div[data-value]')[1];
            
            if (timeElement) {
              const targetTime = parseInt(timeElement.dataset.value);
              animateNumber(timeElement, 0, targetTime, 1000, 's');
            }
            
            if (attemptElement) {
              const targetAttempts = parseInt(attemptElement.dataset.value);
              animateNumber(attemptElement, 0, targetAttempts, 800);
            }
          }, 100);
        }
      }, 200);
      
      // 在數字動畫完成後立即顯示繼續按鈕（開發者跳過）
      setTimeout(() => {
        checkButton.textContent = '繼續';
        checkButton.style.background = 'linear-gradient(135deg, #10B981, #059669)';
        checkButton.style.color = '#ffffff';
        checkButton.style.animation = 'gentle-pulse 2s ease-in-out infinite';
        checkButton.addEventListener('click', advanceScene, { once: true });
        
        // 添加提示文字
        const hintElement = document.createElement('div');
        hintElement.style.cssText = `
          text-align: center;
          color: #9CA3AF;
          font-size: 0.9rem;
          margin-top: 1rem;
          opacity: 0;
          transition: opacity 0.5s ease;
        `;
        hintElement.textContent = '開發者跳過模式 - 統計信息已保存';
        
        // 將提示添加到結果元素後面
        resultElement.parentNode.insertBefore(hintElement, resultElement.nextSibling);
        
        // 顯示提示文字
        setTimeout(() => {
          hintElement.style.opacity = '1';
        }, 100);
        
      }, 1200); // 數字動畫完成後立即顯示繼續按鈕
      
      skipButton.style.display = 'none';
      
      // Hide advance button since we're using the check button as continue
      advanceBtn.style.display = 'none';
    }
    
    function transformTo(form, isFirstTimeTransformation = false) {
      if (!gameState.unlockedForms.includes(form)) {
        return;
      }
      
      // If already in this form, do nothing
      if (gameState.currentForm === form) {
        return;
      }
      
      // 檢查是否是萬物回響模式或萬物尋氣模式
      if ((gameState.formSequenceGuideActive || gameState.wanwuXunqiActive) && gameState.handleFormSequenceClick) {
        const handled = gameState.handleFormSequenceClick(form);
        if (handled) {
          return; // 特殊模式已處理，不執行常規物化
        }
      }
      
      // Store current form for transition animation
      const fromForm = gameState.currentForm;
      
      // 判斷是否為日常物化：明確排除初次物化按鈕的調用
      const isDailyTransformation = !isFirstTimeTransformation && !gameState.transformationInProgress;
      
      if (isDailyTransformation) {
        // 日常物化：進入特殊視角模式
        
        // 只有在第一次進入日常物化時才保存原始狀態
        if (!gameState.isInDailyTransformation) {
        gameState.dailyTransformationPreviousForm = fromForm;
        
        // 保存當前的繼續按鈕狀態
        gameState.dailyTransformationAdvanceBtnVisible = (advanceBtn && advanceBtn.style.display !== 'none');
        
          console.log(`首次進入日常物化: ${fromForm} -> ${form}，保存的原始形態: ${fromForm}，繼續按鈕可見: ${gameState.dailyTransformationAdvanceBtnVisible}`);
        
        // 隱藏繼續按鈕（如果存在）
        if (advanceBtn) {
          advanceBtn.style.display = 'none';
        }
        
        // 創建退出視角按鈕
        createExitTransformationButton();
        } else {
          console.log(`連續日常物化: ${fromForm} -> ${form}，保持原始形態: ${gameState.dailyTransformationPreviousForm}`);
        }
        
        gameState.isInDailyTransformation = true;
      } else {
        // 劇情物化：設置進行中狀態
        gameState.transformationInProgress = form;
      }
      
      // First, remove active state from all buttons
      Object.values(formButtons).forEach(button => {
        button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
        button.classList.add('bg-gray-500');
      });
      
      // Highlight active form button
      formButtons[form].classList.remove('bg-gray-500');
      formButtons[form].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
      
      // Create the transition animation between current form and target form
      showTransformationTransition(fromForm, form);
      
      // Set timeout to update the game state after animation
      setTimeout(() => {
        // Update game state
        gameState.currentForm = form;
        
        // 記錄物化體驗數據
        recordTransformationData(form, isDailyTransformation, fromForm);
        
        // 更新視圖顯示
        updateFormView(form);
        
        // 檢查是否滿足transformation-required的條件（僅在劇情物化時）
        if (!isDailyTransformation) {
          checkTransformationProgress();
          // Clear transformation in progress flag after animation completes
          gameState.transformationInProgress = null;
        }
      }, 1500);
    }
    
                // 已移除的toggleKunpengForm和updateKunpengView函數 - 現在使用獨立的kun和peng形態
      // 這些函數已不再需要，因為鯤和鵬現在作為獨立的形態來處理
      // kunpeng舊形態已完全清理，所有相關代碼已更新為使用kun和peng
    
    // 創建物化覆蓋層的通用函數
    function createTransformationOverlay(overlayConfig) {
      // 移除現有覆蓋層
      const existingOverlay = document.querySelector('.transformation-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      // 創建新覆蓋層
      const overlay = document.createElement('div');
      overlay.className = 'transformation-overlay';
      overlay.style.background = overlayConfig.background;
      overlay.style.boxShadow = overlayConfig.boxShadow || '';
      
      gameContainer.appendChild(overlay);
      
      // 應用濾鏡和變換到gameContainer
      gameContainer.style.transform = overlayConfig.transform || 'scale(1)';
      gameContainer.style.filter = overlayConfig.filter || 'none';
    }
    
    // 移除物化覆蓋層
    function removeTransformationOverlay() {
      const overlay = document.querySelector('.transformation-overlay');
      if (overlay) {
        overlay.remove();
      }
      gameContainer.style.transform = 'scale(1)';
      gameContainer.style.filter = 'none';
    }
    
    // ===== AI解讀系統 =====
    
    // 獲取斷句挑戰的詳細信息
    function getSegmentationPuzzleInfo(scene) {
      const chapterMappings = {
        'prologue': {
          title: '第一章：夢蝶',
          source: '《莊子·齊物論》',
          theme: '物我兩忘的變化智慧',
          text: '昔者莊周夢為胡蝶栩栩然胡蝶也自喻適志與不知周也俄然覺則蘧蘧然周也',
          interpretation: '這是莊子最著名的故事之一。莊周夢見自己變成蝴蝶，在夢中他完全忘記了自己是莊周，只知道自己是一隻快樂飛舞的蝴蝶。醒來後，他不知道是莊周夢見了蝴蝶，還是蝴蝶夢見了莊周。這個故事揭示了現實與夢境、自我與他物之間界限的模糊性，體現了「物我兩忘」的哲學境界。',
          gameConnection: '在遊戲中，這段古文是你獲得第一次物化能力的關鍵。通過理解夢蝶的智慧，你開啟了在不同形態間自由轉換的可能性，這正是莊子「齊物論」思想的體現——萬物本質相同，形態只是表象。'
        },
                 'chapter1': {
           title: '第二章：子非魚',
           source: '《莊子·秋水》',
           theme: '知魚之樂的認知智慧',
           text: '莊子與惠子遊於濠梁之上莊子曰儵魚出遊從容是魚樂也惠子曰子非魚安知魚之樂莊子曰子非我安知我不知魚之樂',
           interpretation: '這是莊子與惠子的經典辯論。莊子看到魚兒悠遊，說這是魚的快樂；惠子質疑：你不是魚，怎麼知道魚的快樂？莊子反問：你不是我，怎麼知道我不知道魚的快樂？這個對話探討了認知的界限和同理心的可能性，展現了不同的思維方式。',
           gameConnection: '在遊戲的濠梁之上，你親身體驗了這場千古辯論。通過不同的選擇，你展現了自己對認知和同理心的理解。這段古文的解讀將幫助你獲得「左目之竅」的封印，開啟更深層的感知能力。'
         },
        'chapter2': {
          title: '第三章：北冥有魚',
          source: '《莊子·逍遙遊》',
          theme: '鯤鵬變化的逍遙境界',
          text: '北冥有魚其名為鯤鯤之大不知其幾千里也化而為鳥其名為鵬鵬之背不知其幾千里也怒而飛其翼若垂天之雲',
          interpretation: '這段描述了鯤鵬變化的壯闊場面。在北方的大海中有一條巨魚叫鯤，大到不知道有幾千里。它化身為大鳥叫鵬，背部也不知道有幾千里寬。當它振翅高飛時，翅膀就像天邊的雲彩。這體現了莊子對自由變化和超越束縛的嚮往。',
          gameConnection: '在雲海之中，你將親身體驗鯤鵬的變化之道。這種從魚到鳥、從水中到天空的轉換，象徵著突破固有形態的束縛。通過解讀這段古文，你將獲得鯤和鵬的物化能力，體驗真正的逍遙自在。'
        },
        'chapter3': {
          title: '第四章：鴟得腐鼠',
          source: '《莊子·秋水》',
          theme: '價值觀的相對性',
          text: '惠子相梁莊子往見之或謂惠子曰莊子來欲代子相於是惠子恐搜於國中三日三夜莊子往見之曰南方有鳥其名為鵷鶵子知之乎',
          interpretation: '惠子在梁國當宰相，有人告訴他莊子來是要取代他的位置，惠子因此恐慌，在全國搜查了三天三夜。莊子去見他，講了鵷鶵的故事。鵷鶵是神鳥，只吃甘露，不食腐物。這個故事暗示不同的價值觀念，有些人追求的「寶物」，在另一些人眼中可能毫無價值。',
          gameConnection: '在森林深處，你將遇到鵷鶵和鴟鴞這兩種截然不同的鳥類，體驗它們不同的生活方式和價值觀。這段古文揭示了價值判斷的相對性，幫助你獲得「左耳之竅」的封印，學會以更包容的心態看待世界。'
        },
        'chapter4': {
          title: '第五章：蝸角之爭',
          source: '《莊子·則陽》',
          theme: '事物規模的相對性',
          text: '有國於蝸之左角者曰觸氏有國於蝸之右角者曰蠻氏時相與爭地而戰伏尸數萬逐北旬有五日而後反',
          interpretation: '在蝸牛的左角上有個國家叫觸氏，右角上有個國家叫蠻氏。它們經常為了爭奪土地而戰爭，死傷數萬，追擊敗軍十五天才回來。這個寓言揭示了人類爭鬥的荒謬性——從更大的視角看，我們的爭鬥就像蝸牛角上的戰爭一樣微不足道。',
          gameConnection: '在螺旋的幻境中，你將親眼目睹蝸角之爭的荒謬。通過這段古文的理解，你將獲得蝸牛的物化能力，學會從微觀的角度審視世界，同時也理解規模和視角的相對性，最終找到「右耳之竅」的封印。'
        },
        'chapter5': {
          title: '第六章：朝菌大椿',
          source: '《莊子·逍遙遊》',
          theme: '時間感知的相對性',
          text: '朝菌不知晦朔蟪蛄不知春秋此小年也楚之南有冥靈者以五百歲為春五百歲為秋上古有大椿者以八千歲為春八千歲為秋',
          interpretation: '朝菌不知道月亮的陰晴圓缺，蟪蛄不知道春秋的變化，這是短命的生物。楚國南方有一種叫冥靈的樹，以五百年為春季，五百年為秋季。上古時有大椿樹，以八千年為春季，八千年為秋季。這說明了時間感知的相對性。',
          gameConnection: '在時間森林中，你將遇到不同壽命的生物，體驗它們對時間的不同感知。這段古文幫助你理解時間的相對性，獲得朝菌、蟪蛄、大椿的物化能力，最終找到「左鼻之竅」的封印，學會以不同的時間尺度看待生命。'
        },
        'chapter6': {
          title: '第七章：螻蟻星辰',
          source: '《莊子·列禦寇》',
          theme: '生死觀的超脫智慧',
          text: '莊子將死弟子欲厚葬之莊子曰吾以天地為棺槨以日月為連璧星辰為珠璣萬物為齎送吾葬具豈不備邪何以加此弟子曰吾恐烏鳶之食夫子也莊子曰在上為烏鳶食在下為螻蟻食奪彼與此何其偏也',
          interpretation: '莊子將要去世時，弟子們想要厚葬他。莊子說：我以天地為棺材，以日月為陪葬的璧玉，以星辰為珠寶，以萬物為送葬品，我的葬具難道不齊備嗎？弟子擔心他被鳥獸吃掉，莊子說：在上面被鳥吃，在下面被螻蟻吃，偏愛其中一種，豈不是很偏頗嗎？這體現了莊子對生死的超脫態度。',
          gameConnection: '在天地交接的聖地，你將體驗莊子的生死智慧。通過理解這段古文，你將獲得螻蟻和星辰的物化能力，從「在下」和「在上」兩個角度體驗生死的自然性，最終找到「右鼻之竅」的封印。'
        },
        'chapter7': {
          title: '第八章：道歸混沌',
          source: '《莊子·應帝王》',
          theme: '渾沌之死的深刻寓意',
          text: '南海之帝為儵北海之帝為忽中央之帝為渾沌儵與忽時相與遇於渾沌之地渾沌待之甚善儵與忽謀報渾沌之德曰人皆有七竅以視聽食息此獨無有嘗試鑿之日鑿一竅七日而渾沌死',
          interpretation: '南海的帝王叫儵，北海的帝王叫忽，中央的帝王叫渾沌。儵和忽經常在渾沌的地方相遇，渾沌待他們很好。儵和忽商量報答渾沌的恩德，說：人都有七個竅孔用來視聽飲食呼吸，只有渾沌沒有，我們試著為他鑿開。每天鑿一個竅，七天後渾沌就死了。這個故事揭示了善意可能帶來的悲劇後果。',
          gameConnection: '在虛空殿中，你將親身經歷渾沌之死的故事。這段古文是整個遊戲的核心寓意——你的使命就是要修復被鑿開的七竅，讓渾沌重新回到無竅的純真狀態。通過理解這個深刻的哲學寓言，你將獲得最終的智慧。'
        },
        'epilogue': {
          title: '第九章：逍遙遊',
          source: '《莊子·逍遙遊》',
          theme: '無用之用的人生智慧',
          text: '今子有大樹患其無用何不樹之於無何有之鄉廣莫之野徬徨乎無為其側逍遙乎寢臥其下不夭斤斧物無害者無所可用安所困苦哉',
          interpretation: '現在你有一棵大樹，擔心它沒有用處，為什麼不把它種在空曠無物的地方、廣闊的原野上，在它旁邊自由自在地徘徊，在它下面逍遙地躺臥休息？它不會遭受斧頭的砍伐，沒有什麼能傷害它。沒有用處，哪裡會有困苦呢？這體現了莊子「無用之用」的智慧。',
          gameConnection: '在逍遙遊的最終境界中，你已經體驗了所有生物的形態，理解了萬物的本質。這段古文總結了整個遊戲的哲學主題——真正的自由來自於超越世俗的「有用」標準，在「無用」中找到真正的價值和快樂。'
        }
      };
      
      return chapterMappings[gameState.currentChapter] || {
        title: '未知章節',
        source: '《莊子》',
        theme: '莊子哲學',
        text: scene.text,
        interpretation: '這段古文蘊含著深刻的哲學智慧。',
        gameConnection: '通過理解這段古文，你將獲得新的能力和洞察。'
      };
    }
    
    // 打開AI解讀模態窗口
    function openAIInterpretModal(scene) {
      // 移除現有的模態窗口
      const existingModal = document.getElementById('ai-interpret-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      const puzzleInfo = getSegmentationPuzzleInfo(scene);
      
      // 創建模態窗口
      const modal = document.createElement('div');
      modal.id = 'ai-interpret-modal';
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.style.zIndex = '99999'; // 確保在所有元素之上
      
      const modalContent = document.createElement('div');
      modalContent.className = 'bg-white dark:bg-slate-800 rounded-xl shadow-2xl max-w-4xl w-11/12 h-[85vh] overflow-hidden flex flex-col border border-slate-200 dark:border-slate-700';
      
      // 模態窗口頭部
      const modalHeader = document.createElement('div');
      modalHeader.className = 'bg-gradient-to-r from-slate-800 to-slate-700 text-white p-5 flex items-center justify-between flex-shrink-0 border-b border-slate-600';
      modalHeader.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-full flex items-center justify-center shadow-lg">
            <span class="text-white font-bold text-lg">🦋</span>
          </div>
          <div>
            <h2 class="text-2xl font-bold text-white">莊子解讀</h2>
          </div>
        </div>
        <button id="close-modal" class="text-slate-300 hover:text-white transition-colors p-2 hover:bg-slate-600 rounded-full">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      `;
      
      // 模態窗口主體 - 固定高度，不滾動
      const modalBody = document.createElement('div');
      modalBody.className = 'flex-1 flex flex-col overflow-hidden';
      
      // 解讀內容區域 - 自適應高度
      const interpretationSection = document.createElement('div');
      interpretationSection.className = 'border-b border-gray-200 dark:border-gray-600 flex-shrink-0';
      interpretationSection.innerHTML = `
        <div class="p-4 bg-gradient-to-b from-slate-50 to-white dark:from-slate-800 dark:to-slate-700">
          <!-- 解讀內容 -->
          <div id="interpretation-content" class="space-y-4">
            <!-- 古文原文 -->
            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900 dark:to-indigo-900 p-4 rounded-lg border-l-4 border-blue-400 shadow-sm">
              <p class="text-lg text-slate-800 dark:text-slate-200 font-serif leading-relaxed tracking-wide">${puzzleInfo.text}</p>
            </div>
            
            <!-- 莊子解讀 -->
            <div class="bg-gradient-to-r from-emerald-50 to-teal-50 dark:from-emerald-900 dark:to-teal-900 border border-emerald-200 dark:border-emerald-700 rounded-lg p-4 shadow-sm">
              <p class="text-slate-700 dark:text-slate-300 leading-relaxed mb-3">
                <span class="font-medium text-emerald-800 dark:text-emerald-200">這段文字出自${puzzleInfo.source}，探討的是${puzzleInfo.theme}的深刻主題。</span>
              </p>
              <p class="text-slate-700 dark:text-slate-300 leading-relaxed">${puzzleInfo.interpretation}</p>
            </div>
            
            <!-- 遊戲聯繫 -->
            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900 dark:to-indigo-900 border border-blue-200 dark:border-blue-700 rounded-lg p-4 shadow-sm">
              <p class="text-slate-700 dark:text-slate-300 leading-relaxed">${puzzleInfo.gameConnection}</p>
            </div>
          </div>
        </div>
      `;
      

      
      // 聊天記錄區域 - 佔據剩餘空間
      const qaSection = document.createElement('div');
      qaSection.className = 'flex-1 flex flex-col min-h-0';
      qaSection.innerHTML = `
        <!-- 聊天記錄區域 - 佔據剩餘空間 -->
        <div id="chat-history" class="flex-1 bg-gradient-to-b from-slate-50 to-white dark:from-slate-800 dark:to-slate-700 p-4 space-y-3 overflow-y-auto min-h-0">
          <div class="text-center text-slate-500 dark:text-slate-400 text-sm py-8">
            <div class="w-16 h-16 bg-gradient-to-br from-purple-100 to-indigo-100 dark:from-purple-900 dark:to-indigo-900 rounded-full flex items-center justify-center mx-auto mb-3">
              <span class="text-2xl">💬</span>
            </div>
            <p class="font-medium">在這裡與莊子對話，探討古文的智慧</p>
            <p class="text-xs mt-1 text-slate-400">請在下方輸入你的問題</p>
          </div>
        </div>
        
        <!-- 輸入區域 -->
        <div class="p-3 bg-gradient-to-r from-slate-100 to-slate-50 dark:from-slate-700 dark:to-slate-800 flex-shrink-0 border-t border-slate-200 dark:border-slate-600">
          <div class="flex gap-3">
            <input type="text" id="user-question" placeholder="請輸入你想問莊子的問題..." 
                   class="flex-1 px-4 py-3 border border-slate-300 dark:border-slate-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-slate-700 dark:text-white placeholder-slate-400 dark:placeholder-slate-500 shadow-sm">
            <button id="ask-question" class="bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 shadow-sm hover:shadow-md">
              提問
            </button>
          </div>
        </div>
      `;
      
      // 組裝模態窗口
      modalBody.appendChild(interpretationSection);
      modalBody.appendChild(qaSection);
      
      modalContent.appendChild(modalHeader);
      modalContent.appendChild(modalBody);
      modal.appendChild(modalContent);
      
      // 添加到頁面
      document.body.appendChild(modal);
      
      // 綁定事件
      setupModalEvents(modal, scene);
    }
    
    // 設置模態窗口事件
    function setupModalEvents(modal, scene) {
      const closeBtn = modal.querySelector('#close-modal');
      const askBtn = modal.querySelector('#ask-question');
      const questionInput = modal.querySelector('#user-question');
      const chatHistory = modal.querySelector('#chat-history');
      
      // 關閉模態窗口
      const closeModal = () => {
        modal.remove();
      };
      
      closeBtn.addEventListener('click', closeModal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
      });
      
      // ESC鍵關閉
      const handleEsc = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', handleEsc);
        }
      };
      document.addEventListener('keydown', handleEsc);
      
      // 設置解讀內容自適應高度（不滾動）
      const interpretationContent = modal.querySelector('#interpretation-content');
      if (interpretationContent) {
        interpretationContent.style.maxHeight = 'none'; // 移除高度限制，讓內容自適應
        interpretationContent.style.overflowY = 'visible'; // 不添加滾動條
      }
      
      // 確保聊天記錄區域使用剩餘空間並可滾動
      if (chatHistory) {
        // 移除固定高度設置，讓flex布局自動分配剩餘空間
        chatHistory.style.minHeight = '0';
        chatHistory.style.maxHeight = 'none';
        chatHistory.style.overflowY = 'auto';
        chatHistory.style.overflowX = 'hidden';
        
        // 確保滾動區域正確工作
        setTimeout(() => {
          chatHistory.scrollTop = 0; // 重置滾動位置到頂部
        }, 100);
      }
      
      // 添加消息到聊天記錄
      const addMessageToChat = (message, isUser = false) => {
        // 如果是第一條消息，清除提示文字
        const placeholder = chatHistory.querySelector('.text-center');
        if (placeholder) {
          placeholder.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex items-start gap-3 ${isUser ? 'flex-row-reverse' : ''}`;
        
        const avatar = document.createElement('div');
        avatar.className = `w-10 h-10 rounded-full flex items-center justify-center text-white text-sm font-bold flex-shrink-0 shadow-md ${
          isUser ? 'bg-gradient-to-br from-blue-500 to-indigo-600' : 'bg-gradient-to-br from-blue-400 to-indigo-500'
        }`;
        avatar.textContent = isUser ? '你' : '🦋';
        
        const messageContent = document.createElement('div');
        messageContent.className = `flex-1 ${isUser ? 'text-right' : ''}`;
        
        const messageBubble = document.createElement('div');
        messageBubble.className = `inline-block max-w-full px-4 py-3 rounded-lg shadow-sm ${
          isUser 
            ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white' 
            : 'bg-white dark:bg-slate-600 border border-slate-200 dark:border-slate-500 text-slate-700 dark:text-slate-300'
        }`;
        messageBubble.textContent = message;
        
        messageContent.appendChild(messageBubble);
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(messageContent);
        
        chatHistory.appendChild(messageDiv);
        
        // 自動滾動到底部
        chatHistory.scrollTop = chatHistory.scrollHeight;
        
        // 返回創建的消息元素
        return messageDiv;
      };
      
      // 提問功能
      const askQuestion = async () => {
        const question = questionInput.value.trim();
        if (!question) return;
        
        // 收集聊天記錄數據
        recordChatQuestion(question);
        
        // 添加用戶問題到聊天記錄
        addMessageToChat(question, true);
        
        // 在聊天記錄中添加"莊子正在思考..."消息
        const thinkingMessage = addMessageToChat('莊子正在思考...', false);
        thinkingMessage.id = 'thinking-message'; // 添加ID以便後續移除
        
        // 禁用按鈕但保持原始文字
        askBtn.disabled = true;
        
        // 清空輸入框
        questionInput.value = '';
        
        try {
          const puzzleInfo = getSegmentationPuzzleInfo(scene);
          
          // 強制調用AI，如果AI不可用則使用靜態回應
          let response;
          console.log('🔍 AI系統詳細檢查:', {
            'window.zhuangziAI存在': !!window.zhuangziAI,
            'zhuangziAI變量存在': typeof zhuangziAI !== 'undefined',
            'zhuangziAI.isEnabled': window.zhuangziAI?.isEnabled,
            'API密鑰存在': !!window.zhuangziAI?.apiKey,
            'API密鑰長度': window.zhuangziAI?.apiKey?.length || 0,
            'zhuangziAI類型': typeof zhuangziAI,
            'zhuangziAI實例': zhuangziAI
          });
          
          // 檢查AI系統是否可用
          if (window.zhuangziAI && window.zhuangziAI.isEnabled) {
            console.log('🤖 AI系統可用，調用AI生成莊子回應...');
            try {
              response = await generateZhuangziResponse(question, puzzleInfo);
              if (response && response !== getStaticZhuangziResponse(question, puzzleInfo)) {
                console.log('✅ AI調用成功！');
              } else {
                console.log('⚠️ AI調用返回了靜態回應，可能失敗');
              }
            } catch (error) {
              console.error('❌ AI調用出錯:', error);
              response = getStaticZhuangziResponse(question, puzzleInfo);
            }
          } else {
            console.log('📝 AI系統不可用，使用靜態回應...');
            response = getStaticZhuangziResponse(question, puzzleInfo);
          }
          
          // 移除"思考中"消息
          const thinkingMsg = document.getElementById('thinking-message');
          if (thinkingMsg) {
            thinkingMsg.remove();
          }
          
          // 添加AI回應到聊天記錄
          addMessageToChat(response, false);
          
        } catch (error) {
          console.error('AI回應生成失敗:', error);
          
          // 移除"思考中"消息
          const thinkingMsg = document.getElementById('thinking-message');
          if (thinkingMsg) {
            thinkingMsg.remove();
          }
          
          const errorResponse = '抱歉，我現在無法回答你的問題。請稍後再試，或者先專心完成斷句挑戰吧。';
          addMessageToChat(errorResponse, false);
        } finally {
          askBtn.disabled = false;
        }
      };
      
      askBtn.addEventListener('click', askQuestion);
      questionInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          askQuestion();
        }
      });
      
      // 聚焦到輸入框
      setTimeout(() => questionInput.focus(), 100);
    }
    
         // 生成莊子風格的AI回應
     async function generateZhuangziResponse(question, puzzleInfo) {
       try {
         console.log('🤖 ===== generateZhuangziResponse 開始 =====');
         console.log('❓ 問題:', question);
         console.log('📜 古文信息:', puzzleInfo);
         
         // 檢查zhuangziAI是否可用
         console.log('🔍 zhuangziAI狀態檢查:', {
           'window.zhuangziAI存在': !!window.zhuangziAI,
           'zhuangziAI類型': typeof window.zhuangziAI,
           'isEnabled': window.zhuangziAI?.isEnabled,
           'API密鑰': window.zhuangziAI?.apiKey?.substring(0, 10) + '...',
           'generatePersonalizedResponse方法存在': typeof window.zhuangziAI?.generatePersonalizedResponse === 'function'
         });
         
         // 構建正確的context和playerData參數
         const context = {
           chapter: gameState.currentChapter || 'unknown',
           scene: gameState.currentScene || 0,
           sceneType: 'segmentation-interpretation',
           description: `斷句挑戰：${puzzleInfo.title} - ${puzzleInfo.theme}`,
           specificQuestion: question,
           puzzleInfo: puzzleInfo
         };
         
         const playerData = getAIAnalysisData();
         
         // 獲取斷句解讀聊天的對話歷史
         const chatHistory = getChatHistory('segmentation-chat');
         
         console.log('📍 調用上下文:', context);
         console.log('👤 玩家數據類型:', typeof playerData);
         console.log('👤 玩家數據概要:', {
           hasProfile: !!playerData.profile,
           hasPatterns: !!playerData.patterns,
           hasContext: !!playerData.context
         });
         console.log('💬 對話歷史長度:', chatHistory.length);
         
         console.log('🚀 準備調用window.zhuangziAI.generatePersonalizedResponse...');
         const response = await window.zhuangziAI.generatePersonalizedResponse(context, playerData, chatHistory);
         
         console.log('🎯 AI回應結果:', {
           '回應存在': !!response,
           '回應類型': typeof response,
           '回應長度': response?.length || 0,
           '回應預覽': response?.substring(0, 50) + '...'
         });
         
         if (response) {
           console.log('✅ AI回應生成成功:', response);
           
           // 將本次對話添加到歷史中
           addChatToHistory('segmentation-chat', question, response);
           
           return response;
         } else {
           console.log('⚠️ AI回應為空，使用靜態回應');
           return getStaticZhuangziResponse(question, puzzleInfo);
         }
       } catch (error) {
         console.error('🚫 生成莊子回應時出錯:', error);
         console.error('錯誤堆疊:', error.stack);
         return getStaticZhuangziResponse(question, puzzleInfo);
       }
     }
     
         // 靜態莊子回應（當AI不可用時使用）- 新風格
    function getStaticZhuangziResponse(question, puzzleInfo) {
      const lowerQuestion = question.toLowerCase();
      
      // 針對常見問題的直接回應
      if (lowerQuestion.includes('逍遙遊') || lowerQuestion.includes('解讀')) {
        return `逍遙遊講的是自由自在的境界。像鯤鵬那樣，不受限制地變化，這就是真正的逍遙啊。`;
      }
      
      if (lowerQuestion.includes('斷句') || lowerQuestion.includes('怎麼') || lowerQuestion.includes('如何')) {
        return `斷句其實沒有標準答案，重要的是理解文意。你覺得哪裡該停頓，就在哪裡停頓吧。`;
      }
      
      if (lowerQuestion.includes('意思') || lowerQuestion.includes('含義')) {
        return `${puzzleInfo.theme}這個主題很有意思呢。你可以從不同角度去理解，每個人的感受都不同。`;
      }
      
      // 其他情況的多樣化回應
      const responses = [
        // 適度回應式
        `這個問題很有趣，我的理解是文字本來就是流動的，你覺得呢？`,
        `關於${puzzleInfo.theme}，每個人都有自己的看法，這就是哲學的魅力。`,
        `古人寫字時也沒想過後人會這麼認真分析呢，你這態度我很欣賞。`,
        
        // 引導式回應  
        `不如我們從另一個角度思考這個問題？`,
        `你已經在思考了，這比標準答案更重要。`,
        `嗯，${puzzleInfo.theme}確實值得深思，你有什麼想法？`,
        
        // 親切回應式
        `我也在想這個問題呢，或許我們可以一起討論。`,
        `你的問題讓我想起了很多往事，古文真的很有韻味。`,
        `看得出你對哲學很有興趣，這種求知精神很珍貴。`
      ];
      
      // 隨機返回一個回應
      const randomIndex = Math.floor(Math.random() * responses.length);
      return responses[randomIndex];
    }

    // ===== 對話歷史管理 =====
    
    // 為每個聊天窗口維護對話歷史
    const chatHistoryMap = {
      'segmentation-chat': [], // 斷句解讀聊天歷史
      'post-game-chat': []      // 通關後聊天歷史
    };
    
    // 添加對話記錄到歷史
    function addChatToHistory(chatType, userMessage, aiResponse) {
      if (!chatHistoryMap[chatType]) {
        chatHistoryMap[chatType] = [];
      }
      
      // 添加用戶消息
      chatHistoryMap[chatType].push({
        role: 'user',
        content: userMessage
      });
      
      // 添加AI回應
      chatHistoryMap[chatType].push({
        role: 'assistant',
        content: aiResponse
      });
      
      // 限制歷史記錄長度，保持最近的20條對話（10輪）
      if (chatHistoryMap[chatType].length > 20) {
        chatHistoryMap[chatType] = chatHistoryMap[chatType].slice(-20);
      }
      
      console.log(`📝 ${chatType} 對話歷史已更新，當前長度:`, chatHistoryMap[chatType].length);
    }
    
    // 獲取對話歷史
    function getChatHistory(chatType) {
      return chatHistoryMap[chatType] || [];
    }
    
    // 清空對話歷史
    function clearChatHistory(chatType) {
      if (chatHistoryMap[chatType]) {
        chatHistoryMap[chatType] = [];
        console.log(`🗑️ ${chatType} 對話歷史已清空`);
      }
    }
    
    // ===== 通關後聊天功能 =====
    
    // 檢查遊戲通關狀態並顯示聊天按鈕
    function checkGameCompletionAndShowChatButton() {
      try {
        const savedProgress = loadGameProgress();
        if (savedProgress && savedProgress.maxReachedChapter === 'epilogue') {
          console.log('🎉 檢測到玩家已通關，顯示和莊子聊聊按鈕');
          showChatWithZhuangziButton();
        } else {
          console.log('🔒 玩家尚未通關，隱藏聊天按鈕');
          hideChatWithZhuangziButton();
        }
      } catch (error) {
        console.error('❌ 檢查通關狀態時出錯:', error);
        hideChatWithZhuangziButton();
      }
    }

    // 顯示聊天按鈕
    function showChatWithZhuangziButton() {
      const container = document.getElementById('chat-with-zhuangzi-container');
      const chatButton = document.getElementById('chat-with-zhuangzi-btn');
      const breathingButton = document.getElementById('chaos-breathing-btn');
      
      if (container && chatButton) {
        container.style.display = 'flex';
        
        // 綁定聊天按鈕點擊事件（防止重複綁定）
        if (!chatButton.hasAttribute('data-event-bound')) {
          chatButton.addEventListener('click', openChatWithZhuangziModal);
          chatButton.setAttribute('data-event-bound', 'true');
        }
        
        // 綁定呼吸按鈕點擊事件（防止重複綁定）
        if (breathingButton && !breathingButton.hasAttribute('data-event-bound')) {
          breathingButton.addEventListener('click', openChaosBreathingModal);
          breathingButton.setAttribute('data-event-bound', 'true');
        }
      }
    }

    // 隱藏聊天按鈕
    function hideChatWithZhuangziButton() {
      const container = document.getElementById('chat-with-zhuangzi-container');
      if (container) {
        container.style.display = 'none';
      }
    }

    // 打開混沌呼吸體驗（無時間限制版本）
    function openChaosBreathingModal() {
      console.log('打開混沌呼吸體驗');
      
      // 儲存目前的遊戲狀態
      const savedState = {
        chapter: gameState.currentChapter,
        scene: gameState.currentScene,
        fromHomePage: true // 標記這是從首頁進入的
      };
      
      // 隱藏首頁
      document.getElementById('main-menu').style.display = 'none';
      
      // 顯示遊戲內容
      document.getElementById('game-content').style.display = 'block';
      
      // 進入第七章的虛空場景
      gameState.currentChapter = 'chapter7';
      gameState.currentScene = 28; // 呼吸挑戰的前一個場景
      
      // 設置第七章環境
      // 清理之前的章節效果
      cleanupChapterEffects();
      
      // 設置第七章虛空場景背景
      gameContainer.classList.remove('dream-scene', 'water-scene', 'cloud-scene', 'forest-scene', 'spiral-scene', 'time-scene', 'heaven-earth-scene', 'void-scene', 'epilogue-scene');
      gameContainer.classList.add('void-scene');
      
      // 創建虛空場景效果
      createVoidScene();
      
      // 設置特殊標記，表示這是無時間限制的呼吸體驗
      gameState.isBreathingExperience = true;
      gameState.savedHomeState = savedState;
      
      // 直接進入呼吸挑戰場景
      gameState.currentScene = 29; // 呼吸挑戰場景
      loadScene(gameChapters.chapter7.scenes[29]);
    }

    // 打開與莊子聊天的模態窗口
    function openChatWithZhuangziModal() {
      // 移除現有的模態窗口
      const existingModal = document.getElementById('chat-with-zhuangzi-modal');
      if (existingModal) {
        existingModal.remove();
      }
      
      // 創建模態窗口
      const modal = document.createElement('div');
      modal.id = 'chat-with-zhuangzi-modal';
      modal.className = 'fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50';
      modal.style.zIndex = '99999'; // 確保在所有元素之上
      
      const modalContent = document.createElement('div');
      modalContent.className = 'bg-white dark:bg-slate-800 rounded-xl shadow-2xl max-w-4xl w-11/12 h-[85vh] overflow-hidden flex flex-col border border-slate-200 dark:border-slate-700';
      
      // 模態窗口頭部
      const modalHeader = document.createElement('div');
      modalHeader.className = 'bg-gradient-to-r from-blue-600 to-indigo-700 text-white p-5 flex items-center justify-between flex-shrink-0 border-b border-indigo-600';
      modalHeader.innerHTML = `
        <div class="flex items-center gap-3">
          <div class="w-10 h-10 bg-gradient-to-br from-blue-400 to-indigo-500 rounded-full flex items-center justify-center shadow-lg">
            <span class="text-white font-bold text-lg">🦋</span>
          </div>
          <div>
            <h2 class="text-2xl font-bold text-white">和莊子聊聊</h2>
            <p class="text-blue-100 text-sm">基於你的遊戲歷程，與莊子進行深度對話</p>
          </div>
        </div>
        <button id="close-chat-modal" class="text-blue-200 hover:text-white transition-colors p-2 hover:bg-blue-500 rounded-full">
          <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path>
          </svg>
        </button>
      `;
      
      // 模態窗口主體
      const modalBody = document.createElement('div');
      modalBody.className = 'flex-1 flex flex-col overflow-hidden';
      
      // 聊天記錄區域
      const chatArea = document.createElement('div');
      chatArea.className = 'flex-1 flex flex-col min-h-0';
      chatArea.innerHTML = `
        <!-- 聊天記錄區域 -->
        <div id="chat-history" class="flex-1 bg-gradient-to-b from-slate-50 to-white dark:from-slate-800 dark:to-slate-700 p-4 space-y-4 overflow-y-auto min-h-0">
          <div class="text-center text-slate-500 dark:text-slate-400 text-sm py-8">
            <div class="w-16 h-16 bg-gradient-to-br from-blue-100 to-indigo-100 dark:from-blue-900 dark:to-indigo-900 rounded-full flex items-center justify-center mx-auto mb-4">
              <span class="text-3xl">🧘🏻‍♀️</span>
            </div>
            <p class="font-medium text-lg mb-2">歓迎來到莊子的逍遙境界</p>
            <p class="text-sm text-slate-400 dark:text-slate-500 mb-4">基於你完整的遊戲歷程，莊子將與你進行深度哲學對話</p>
            <div class="bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900 dark:to-indigo-900 p-3 rounded-lg text-xs text-slate-600 dark:text-slate-400 mx-auto max-w-md">
              💡 你可以問莊子任何關於人生、哲學、遊戲體驗的問題
            </div>
          </div>
        </div>
        
        <!-- 輸入區域 -->
        <div class="p-4 bg-gradient-to-r from-blue-50 to-indigo-50 dark:from-blue-900 dark:to-indigo-900 flex-shrink-0 border-t border-blue-200 dark:border-blue-700">
          <div class="flex gap-3">
            <input type="text" id="chat-question" placeholder="請輸入你想問莊子的問題..." 
                   class="flex-1 px-4 py-3 border border-blue-300 dark:border-blue-600 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 dark:bg-blue-800 dark:text-white placeholder-blue-400 dark:placeholder-blue-500 shadow-sm">
            <button id="send-chat" class="bg-gradient-to-r from-blue-500 to-indigo-600 hover:from-blue-600 hover:to-indigo-700 text-white px-6 py-3 rounded-lg font-medium transition-all duration-200 shadow-sm hover:shadow-md flex items-center gap-2">
              <span>發送</span>
              <span>💬</span>
            </button>
          </div>
        </div>
      `;
      
      // 組裝模態窗口
      modalBody.appendChild(chatArea);
      modalContent.appendChild(modalHeader);
      modalContent.appendChild(modalBody);
      modal.appendChild(modalContent);
      
      // 添加到頁面
      document.body.appendChild(modal);
      
      // 綁定事件
      setupChatModalEvents(modal);
      
      // 聚焦到輸入框
      setTimeout(() => {
        const questionInput = modal.querySelector('#chat-question');
        if (questionInput) {
          questionInput.focus();
        }
      }, 100);
    }

    // 設置聊天模態窗口事件
    function setupChatModalEvents(modal) {
      const closeBtn = modal.querySelector('#close-chat-modal');
      const sendBtn = modal.querySelector('#send-chat');
      const questionInput = modal.querySelector('#chat-question');
      const chatHistory = modal.querySelector('#chat-history');
      
      // 關閉模態窗口
      const closeModal = () => {
        modal.remove();
      };
      
      closeBtn.addEventListener('click', closeModal);
      modal.addEventListener('click', (e) => {
        if (e.target === modal) closeModal();
      });
      
      // ESC鍵關閉
      const handleEsc = (e) => {
        if (e.key === 'Escape') {
          closeModal();
          document.removeEventListener('keydown', handleEsc);
        }
      };
      document.addEventListener('keydown', handleEsc);
      
      // 添加消息到聊天記錄
      const addMessageToChat = (message, isUser = false) => {
        // 如果是第一條消息，清除提示文字
        const placeholder = chatHistory.querySelector('.text-center');
        if (placeholder) {
          placeholder.remove();
        }
        
        const messageDiv = document.createElement('div');
        messageDiv.className = `flex items-start gap-3 ${isUser ? 'flex-row-reverse' : ''}`;
        
        const avatar = document.createElement('div');
        avatar.className = `w-10 h-10 rounded-full flex items-center justify-center text-white text-sm font-bold flex-shrink-0 shadow-md ${
          isUser ? 'bg-gradient-to-br from-blue-500 to-indigo-600' : 'bg-gradient-to-br from-blue-400 to-indigo-500'
        }`;
        avatar.textContent = isUser ? '你' : '🦋';
        
        const messageContent = document.createElement('div');
        messageContent.className = `flex-1 ${isUser ? 'text-right' : ''}`;
        
        const messageBubble = document.createElement('div');
        messageBubble.className = `inline-block max-w-full px-4 py-3 rounded-lg shadow-sm ${
          isUser 
            ? 'bg-gradient-to-r from-blue-500 to-indigo-600 text-white' 
            : 'bg-white dark:bg-slate-600 border border-blue-200 dark:border-blue-600 text-slate-700 dark:text-slate-200'
        }`;
        messageBubble.innerHTML = message.replace(/\n/g, '<br>');
        
        messageContent.appendChild(messageBubble);
        messageDiv.appendChild(avatar);
        messageDiv.appendChild(messageContent);
        
        chatHistory.appendChild(messageDiv);
        
        // 自動滾動到底部
        chatHistory.scrollTop = chatHistory.scrollHeight;
        
        // 返回創建的消息元素
        return messageDiv;
      };
      
      // 發送消息功能
      const sendMessage = async () => {
        const question = questionInput.value.trim();
        if (!question) return;
        
        // 記錄聊天
        recordChatQuestion(question);
        
        // 添加用戶問題到聊天記錄
        addMessageToChat(question, true);
        
        // 在聊天記錄中添加"莊子正在思考..."消息
        const thinkingMessage = addMessageToChat('莊子正在思考...', false);
        thinkingMessage.id = 'thinking-message';
        
        // 禁用按鈕
        sendBtn.disabled = true;
        
        // 清空輸入框
        questionInput.value = '';
        
        try {
          // 調用AI生成回應
          let response;
          console.log('🤖 準備生成莊子聊天回應...');
          
          // 檢查AI系統是否可用
          if (window.zhuangziAI && window.zhuangziAI.isEnabled) {
            console.log('🤖 AI系統可用，調用AI生成莊子回應...');
            try {
              response = await generateZhuangziChatResponse(question);
              if (response) {
                console.log('✅ AI聊天回應生成成功！');
              } else {
                console.log('⚠️ AI回應為空，使用靜態回應');
                response = getStaticZhuangziChatResponse(question);
              }
            } catch (error) {
              console.error('❌ AI聊天調用出錯:', error);
              response = getStaticZhuangziChatResponse(question);
            }
          } else {
            console.log('📝 AI系統不可用，使用靜態回應...');
            response = getStaticZhuangziChatResponse(question);
          }
          
          // 移除"思考中"消息
          const thinkingMsg = document.getElementById('thinking-message');
          if (thinkingMsg) {
            thinkingMsg.remove();
          }
          
          // 添加AI回應到聊天記錄
          addMessageToChat(response, false);
          
        } catch (error) {
          console.error('❌ 生成莊子聊天回應失敗:', error);
          
          // 移除"思考中"消息
          const thinkingMsg = document.getElementById('thinking-message');
          if (thinkingMsg) {
            thinkingMsg.remove();
          }
          
          const errorResponse = '抱歉，我現在無法回答你的問題。請稍後再試。';
          addMessageToChat(errorResponse, false);
        } finally {
          sendBtn.disabled = false;
        }
      };
      
      sendBtn.addEventListener('click', sendMessage);
      questionInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          sendMessage();
        }
      });
    }

    // 生成莊子聊天回應（AI版本）
    async function generateZhuangziChatResponse(question) {
      try {
        console.log('🤖 ===== generateZhuangziChatResponse 開始 =====');
        console.log('❓ 問題:', question);
        
        // 構建上下文
        const context = {
          chapter: 'post-game-chat',
          scene: 'free-chat',
          sceneType: 'zhuangzi-chat',
          description: '通關後與莊子的自由對話',
          specificQuestion: question
        };
        
        const playerData = getAIAnalysisData();
        
        // 獲取通關後聊天的對話歷史
        const chatHistory = getChatHistory('post-game-chat');
        
        console.log('📍 聊天上下文:', context);
        console.log('👤 玩家數據類型:', typeof playerData);
        console.log('💬 對話歷史長度:', chatHistory.length);
        
        console.log('🚀 準備調用AI生成聊天回應...');
        const response = await window.zhuangziAI.generatePersonalizedResponse(context, playerData, chatHistory);
        
        console.log('🎯 AI聊天回應結果:', {
          '回應存在': !!response,
          '回應類型': typeof response,
          '回應長度': response?.length || 0
        });
        
        if (response) {
          // 將本次對話添加到歷史中
          addChatToHistory('post-game-chat', question, response);
        }
        
        return response;
      } catch (error) {
        console.error('🚫 生成莊子聊天回應時出錯:', error);
        throw error;
      }
    }

    // 靜態莊子聊天回應（當AI不可用時使用）
    function getStaticZhuangziChatResponse(question) {
      const lowerQuestion = question.toLowerCase();
      
      // 基於問題關鍵詞提供相應回答
      if (lowerQuestion.includes('遊戲') || lowerQuestion.includes('體驗') || lowerQuestion.includes('感受')) {
        return '我的朋友，你已經完成了這段奇妙的旅程。遊戲如人生，每個選擇都反映了你的內心。通過七個章節的歷練，你體驗了不同的視角和境界。這些體驗，正是你成長的印記。你覺得在這個過程中，最觸動你的是什麼？';
      }
      
      if (lowerQuestion.includes('人生') || lowerQuestion.includes('生活') || lowerQuestion.includes('現實')) {
        return '人生如夢，夢如人生。你在遊戲中體驗的物化，其實就是生活中的換位思考。當你以鯤的視角看世界，以鵬的高度俯瞰大地，你是否感受到了不同的人生境界？生活中的煩惱，往往源於視角的局限。試著像遊戲中一樣，換個角度看問題吧。';
      }
      
      if (lowerQuestion.includes('哲學') || lowerQuestion.includes('道理') || lowerQuestion.includes('智慧')) {
        return '真正的智慧，不在於知道答案，而在於體驗過程。你在遊戲中收集的每一個封印，完成的每一次物化，都是智慧的積累。哲學不是高深的理論，而是生活的藝術。逍遙，就是在任何境況下都能保持內心的自由。';
      }
      
      if (lowerQuestion.includes('選擇') || lowerQuestion.includes('決定') || lowerQuestion.includes('困惑')) {
        return '選擇從來沒有標準答案，只有適合的答案。你在遊戲中的每個選擇，都展現了你的價值觀和思考方式。面對困惑時，不妨學學混沌 —— 有時候，保持單純和無為，反而能找到最自然的出路。';
      }
      
      if (lowerQuestion.includes('未來') || lowerQuestion.includes('目標') || lowerQuestion.includes('方向')) {
        return '未來如大鵬展翅，需要積蓄足夠的力量。但記住，真正的自由不是到達某個目標，而是在前行的路上保持內心的逍遙。就像遊戲中的物化一樣，每一種形態都有其獨特的美。珍惜當下，順應自然，這就是最好的未來。';
      }
      
      // 默認回應
      return '我的朋友，你的問題讓我想起了那句話：「天地與我並生，萬物與我為一。」在這個遊戲中，你體驗了不同的存在方式，這正是理解世界多樣性的開始。每個人都有自己的道，重要的是找到屬於自己的逍遙方式。你想聊聊什麼特別的體驗嗎？';
    }
    
    // 鵷鶵視角效果函數
    function applyYuanchuView() {
      createTransformationOverlay({
        background: 'linear-gradient(to bottom, rgba(255, 255, 255, 0.1), rgba(173, 216, 230, 0.2), rgba(255, 182, 193, 0.1))',
        boxShadow: 'inset 0 0 50px rgba(255, 255, 255, 0.3)',
        transform: 'scale(0.88)',
        filter: 'brightness(1.3) contrast(0.85) saturate(1.2) hue-rotate(10deg)'
      });
    }
    
    // 鴟鴞視角效果函數
    function applyChixiaoView() {
      createTransformationOverlay({
        background: 'linear-gradient(to bottom, rgba(75, 0, 130, 0.2), rgba(139, 69, 19, 0.3), rgba(0, 0, 0, 0.4))',
        boxShadow: 'inset 0 0 30px rgba(255, 215, 0, 0.2)',
        transform: 'scale(0.88)',
        filter: 'brightness(0.7) contrast(1.4) saturate(0.8) hue-rotate(45deg) sepia(0.3)'
      });
    }
    
    // Function to show transformation transition between two forms
    function showTransformationTransition(fromForm, toForm) {
      // 🔧 修复：确保目标图标在动画前已存在
      ensureIconExists(toForm);
      ensureIconExists(fromForm);
      
      // Remove any existing transformation containers
      const existingTransform = document.querySelector('.transformation-container');
      if (existingTransform) {
        existingTransform.remove();
      }
      
      // Create transformation container
      const transformContainer = document.createElement('div');
      transformContainer.className = 'transformation-container';
      
      // 創建圓形背景，使用漸變色以視覺呈現形態轉換過程
      const transformCircle = document.createElement('div');
      transformCircle.className = 'transformation-circle';
      
      // 基於目標形態設置背景顏色 - 支持所有物化角色
      let bgColor = 'rgba(147, 146, 255, 0.8)'; // 默認人形顏色
      
      // 使用emoji映射系统中的颜色
      const formColorMap = {
        'human': 'rgba(147, 146, 255, 0.8)',
        'butterfly': 'rgba(147, 51, 234, 0.8)',
        'fish': 'rgba(59, 130, 246, 0.8)',
        'kun': 'rgba(6, 182, 212, 0.8)',
        'peng': 'rgba(14, 165, 233, 0.8)',
        'yuanchu': 'rgba(255, 215, 0, 0.8)',
        'chixiao': 'rgba(139, 69, 19, 0.8)',
        'snail': 'rgba(147, 50, 158, 0.8)',
        'morning-fungus': 'rgba(245, 158, 11, 0.8)',
        'cicada': 'rgba(34, 197, 94, 0.8)',
        'great-chun': 'rgba(22, 163, 74, 0.8)',
        'ant': 'rgba(120, 53, 15, 0.8)',
        'star': 'rgba(255, 215, 0, 0.8)'
      };
      
      bgColor = formColorMap[toForm] || bgColor;
      
      transformCircle.style.background = `radial-gradient(circle, ${bgColor.replace('0.8', '0.2')} 0%, ${bgColor} 70%, ${bgColor.replace('0.8', '0.2')} 100%)`;
      transformContainer.appendChild(transformCircle);
      
      // Create particles for transition effect
      const particleContainer = document.createElement('div');
      particleContainer.className = 'particle-container';
      
      // Add particles with color matching the target form
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'particle';
        particle.style.backgroundColor = bgColor;
        
        // Random position and delay
        const angle = Math.random() * Math.PI * 2;
        const distance = 50 + Math.random() * 100;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.left = `calc(50% + ${x}px)`;
        particle.style.top = `calc(50% + ${y}px)`;
        
        // Add animation with random delay
        const delay = Math.random() * 1.5;
        particle.style.animation = `particle-float 1.5s ${delay}s forwards ease-out`;
        
        particleContainer.appendChild(particle);
      }
      
      transformContainer.appendChild(particleContainer);
      
      // 使用現有的形態圖標進行流暢轉換，而不是創建新的SVG
      // 從源圖標淡出並將目標圖標淡入
      const iconContainer = document.createElement('div');
      iconContainer.className = 'icon-transformation';
      iconContainer.style.position = 'absolute';
      iconContainer.style.width = '200px';
      iconContainer.style.height = '200px';
      iconContainer.style.left = '50%';
      iconContainer.style.top = '50%';
      iconContainer.style.transform = 'translate(-50%, -50%)';
      iconContainer.style.zIndex = '10';
      
      // 查找源圖標和目標圖標的內容
      const fromIconId = `${fromForm}-icon`;
      const toIconId = `${toForm}-icon`;
      
      const fromIconElement = document.getElementById(fromIconId);
      const toIconElement = document.getElementById(toIconId);
      
      if (fromIconElement && toIconElement) {
        // 創建克隆用於動畫，這樣不會干擾原始圖標
        const fromIconClone = fromIconElement.cloneNode(true);
        const toIconClone = toIconElement.cloneNode(true);
        
        // 設置起始樣式
        fromIconClone.id = 'from-icon-clone';
        toIconClone.id = 'to-icon-clone';
        
        fromIconClone.style.opacity = '1';
        fromIconClone.style.transform = 'scale(1)';
        fromIconClone.style.position = 'absolute';
        fromIconClone.style.width = '100%';
        fromIconClone.style.height = '100%';
        fromIconClone.style.left = '0';
        fromIconClone.style.top = '0';
        
        toIconClone.style.opacity = '0';
        toIconClone.style.transform = 'scale(0.5)';
        toIconClone.style.position = 'absolute';
        toIconClone.style.width = '100%';
        toIconClone.style.height = '100%';
        toIconClone.style.left = '0';
        toIconClone.style.top = '0';
        
        // 添加到容器
        iconContainer.appendChild(fromIconClone);
        iconContainer.appendChild(toIconClone);
        
        // 動畫淡出源圖標並放大目標圖標
        setTimeout(() => {
          // 源圖標淡出並縮小
          fromIconClone.style.transition = 'all 1.2s ease-in-out';
          fromIconClone.style.opacity = '0';
          fromIconClone.style.transform = 'scale(0.5)';
          
          // 目標圖標淡入並放大 - 使用transformation-emoji類增強效果
          toIconClone.style.transition = 'all 1.2s ease-in-out';
          toIconClone.style.opacity = '1';
          toIconClone.style.transform = 'scale(1)';
          
          // 為emoji添加特殊變身效果
          const emojiElement = toIconClone.querySelector('.emoji-unified');
          if (emojiElement) {
            emojiElement.classList.add('transformation-emoji');
            // 移除原有的動畫類，避免衝突
            emojiElement.style.animation = 'transformation-spin 2s ease-in-out';
          }
          
          // 為所有物化角色添加特殊粒子效果
          addTransformationParticleEffects(toForm, iconContainer);
          
          // 保留原有的特殊效果（向后兼容）
          if (toForm === 'kun' || toForm === 'peng') {
            // 波紋效果
            const ripple = document.createElement('div');
            ripple.style.position = 'absolute';
            ripple.style.width = '100%';
            ripple.style.height = '100%';
            ripple.style.border = '2px solid rgba(64, 186, 213, 0.8)';
            ripple.style.borderRadius = '50%';
            ripple.style.top = '0';
            ripple.style.left = '0';
            ripple.style.animation = 'ripple-effect 1.5s ease-out';
            
            iconContainer.appendChild(ripple);
            
            if (!document.getElementById('kun-peng-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'kun-peng-animation-style';
              styleEl.innerHTML = `
                @keyframes ripple-effect {
                  0% { transform: scale(0.8); opacity: 1; }
                  100% { transform: scale(1.5); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
          
          // 為鳥添加特殊效果
          if (toForm === 'bird') {
            // 羽毛效果
            for (let i = 0; i < 12; i++) {
              const feather = document.createElement('div');
              feather.style.position = 'absolute';
              feather.style.width = '10px';
              feather.style.height = '20px';
              feather.style.backgroundColor = 'rgba(255, 255, 255, 0.7)';
              feather.style.borderRadius = '50% 50% 20% 20% / 70% 70% 30% 30%';
              
              // 隨機位置和角度
              const angle = Math.random() * Math.PI * 2;
              const distance = 40 + Math.random() * 30;
              const x = Math.cos(angle) * distance;
              const y = Math.sin(angle) * distance;
              
              feather.style.left = `calc(50% + ${x}px)`;
              feather.style.top = `calc(50% + ${y}px)`;
              feather.style.transform = `rotate(${Math.random() * 360}deg)`;
              
              // 動畫與延遲
              feather.style.animation = `feather-float 2s ${Math.random() * 0.5}s ease-out forwards`;
              
              iconContainer.appendChild(feather);
            }
            
            if (!document.getElementById('bird-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'bird-animation-style';
              styleEl.innerHTML = `
                @keyframes feather-float {
                  0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
                  10% { opacity: 0.8; }
                  100% { transform: translate(calc(var(--tx, 20px) * 2), calc(var(--ty, -30px) * 2)) rotate(360deg); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
          
          // 為魚添加特殊效果
          if (toForm === 'fish') {
            // 水泡效果
            for (let i = 0; i < 15; i++) {
              const bubble = document.createElement('div');
              bubble.style.position = 'absolute';
              bubble.style.width = `${5 + Math.random() * 10}px`;
              bubble.style.height = bubble.style.width;
              bubble.style.backgroundColor = 'rgba(255, 255, 255, 0.6)';
              bubble.style.borderRadius = '50%';
              
              // 隨機位置
              const angle = Math.random() * Math.PI * 2;
              const distance = 30 + Math.random() * 40;
              const x = Math.cos(angle) * distance;
              const y = Math.sin(angle) * distance;
              
              bubble.style.left = `calc(50% + ${x}px)`;
              bubble.style.top = `calc(50% + ${y}px)`;
              
              // 動畫與延遲
              bubble.style.animation = `bubble-float 1.5s ${Math.random() * 1}s ease-out forwards`;
              
              iconContainer.appendChild(bubble);
            }
            
            if (!document.getElementById('fish-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'fish-animation-style';
              styleEl.innerHTML = `
                @keyframes bubble-float {
                  0% { transform: scale(0.5); opacity: 0; }
                  10% { opacity: 0.8; }
                  100% { transform: translateY(-50px) scale(1.5); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
          
          // 為蝴蝶添加特殊效果
          if (toForm === 'butterfly') {
            // 花粉效果
            for (let i = 0; i < 20; i++) {
              const pollen = document.createElement('div');
              pollen.style.position = 'absolute';
              pollen.style.width = `${3 + Math.random() * 5}px`;
              pollen.style.height = pollen.style.width;
              pollen.style.backgroundColor = 'rgba(255, 255, 150, 0.8)';
              pollen.style.borderRadius = '50%';
              
              // 隨機位置
              const angle = Math.random() * Math.PI * 2;
              const distance = 20 + Math.random() * 60;
              const x = Math.cos(angle) * distance;
              const y = Math.sin(angle) * distance;
              
              pollen.style.left = `calc(50% + ${x}px)`;
              pollen.style.top = `calc(50% + ${y}px)`;
              
              // 動畫與延遲
              pollen.style.animation = `pollen-float 2s ${Math.random() * 1}s ease-out forwards`;
              
              iconContainer.appendChild(pollen);
            }
            
            if (!document.getElementById('butterfly-animation-style')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'butterfly-animation-style';
              styleEl.innerHTML = `
                @keyframes pollen-float {
                  0% { transform: scale(0.5); opacity: 0; }
                  10% { opacity: 0.9; }
                  100% { transform: translate(${Math.random() > 0.5 ? '30px' : '-30px'}, ${Math.random() > 0.5 ? '30px' : '-30px'}) scale(1.2); opacity: 0; }
                }
              `;
              document.head.appendChild(styleEl);
            }
          }
        }, 300);
      } else {
        // 如果找不到圖標，使用通用的能量效果
        const energyEffect = document.createElement('div');
        energyEffect.style.position = 'absolute';
        energyEffect.style.width = '100%';
        energyEffect.style.height = '100%';
        energyEffect.style.borderRadius = '50%';
        energyEffect.style.background = `radial-gradient(circle, rgba(255, 255, 255, 0.9) 0%, ${bgColor} 70%)`;
        energyEffect.style.boxShadow = `0 0 30px ${bgColor}, 0 0 60px ${bgColor.replace('0.8', '0.4')}`;
        energyEffect.style.animation = 'energy-pulse 2s infinite alternate ease-in-out';
        
        iconContainer.appendChild(energyEffect);
        
        if (!document.getElementById('energy-animation-style')) {
          const styleEl = document.createElement('style');
          styleEl.id = 'energy-animation-style';
          styleEl.innerHTML = `
            @keyframes energy-pulse {
              0% { transform: scale(0.8); opacity: 0.8; }
              100% { transform: scale(1.1); opacity: 1; }
            }
          `;
          document.head.appendChild(styleEl);
        }
      }
      
      transformContainer.appendChild(iconContainer);
      
      // Add to page
      document.body.appendChild(transformContainer);
      
      // Trigger animation after a small delay to ensure DOM is updated
      setTimeout(() => {
        transformContainer.classList.add('transform-active');
        
        // Remove the transformation container after animation completes
        setTimeout(() => {
          transformContainer.classList.add('fade-out');
          setTimeout(() => {
            transformContainer.remove();
          }, 800);
        }, 2000);
      }, 50);
    }
    
    function updateFormView(form) {
      // Update the form indicator icon
      const humanIcon = document.getElementById('human-icon');
      const butterflyIcon = document.getElementById('butterfly-icon');
      const fishIcon = document.getElementById('fish-icon');
      const formLabel = document.getElementById('form-label');
      
      // 獲取鯤和鵬的圖標
      const kunIcon = document.getElementById('kun-icon');
      const pengIcon = document.getElementById('peng-icon');
      
      // 使用统一emoji系统创建动态图标
        const formIconContainer = document.querySelector('.form-icon-container');
      
      // 创建缺失的图标（使用emoji系统）
      const iconsToCreate = ['kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      iconsToCreate.forEach(iconForm => {
        if (!document.getElementById(`${iconForm}-icon`) && form === iconForm && formIconContainer) {
          const newIcon = document.createElement('div');
          newIcon.id = `${iconForm}-icon`;
          newIcon.className = 'absolute w-28 h-28 transition-all duration-500 opacity-0 scale-0';
          newIcon.appendChild(createEmojiIcon(iconForm));
          formIconContainer.appendChild(newIcon);
        }
      });
      
      // 重新獲取所有圖標元素（包括可能剛創建的）
      const kunIconUpdated = document.getElementById('kun-icon');
      const pengIconUpdated = document.getElementById('peng-icon');
      const birdIconUpdated = document.getElementById('bird-icon');
      
      // 隱藏所有圖標
      humanIcon.style.opacity = '0';
      humanIcon.style.transform = 'scale(0)';
      butterflyIcon.style.opacity = '0';
      butterflyIcon.style.transform = 'scale(0)';
      fishIcon.style.opacity = '0';
      fishIcon.style.transform = 'scale(0)';
      
      // 隱藏所有動態創建的圖標（如果存在）
      const allFormIcons = ['kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      allFormIcons.forEach(iconForm => {
        const iconElement = document.getElementById(`${iconForm}-icon`);
        if (iconElement) {
          iconElement.style.opacity = '0';
          iconElement.style.transform = 'scale(0)';
        }
      });
      
      // 隱藏鳥圖標（如果存在）
      if (birdIconUpdated) {
        birdIconUpdated.style.opacity = '0';
        birdIconUpdated.style.transform = 'scale(0)';
      }
      
      // 清除所有特殊視覺效果（在設置新效果之前）
      removeAntVisionEffect();
      removeButterflyDreamEffect();
      removeSnailPerspectiveEffect();
      removeQiVisionEffect();
      
      // 顯示當前形態圖標並更新標籤
      switch (form) {
        case 'human':
          humanIcon.style.opacity = '1';
          humanIcon.style.transform = 'scale(1)';
          formLabel.textContent = '人形';
          
          // 移除物化覆蓋層，恢復原始背景
          removeTransformationOverlay();
          break;
          
        case 'butterfly':
          butterflyIcon.style.opacity = '1';
          butterflyIcon.style.transform = 'scale(1)';
          formLabel.textContent = '蝴蝶';
          
          // 蝴蝶的視覺效果 - 夢境般的呼吸縮放和色彩變化
          createTransformationOverlay({
            background: 'linear-gradient(45deg, rgba(147, 51, 234, 0.1), rgba(168, 85, 247, 0.05))',
            transform: 'scale(0.95)',
            filter: 'hue-rotate(20deg) brightness(1.1) saturate(1.2)'
          });
          
          // 添加蝴蝶夢境縮放效果
          addButterflyDreamEffect();
          
          // 尾聲章節中的蝴蝶物化觸發特殊夢境粒子效果
          if (gameState.currentChapter === 'epilogue') {
            setTimeout(() => createButterflyDreamEffect(), 1500);
          }
          break;
          
        case 'fish':
          fishIcon.style.opacity = '1';
          fishIcon.style.transform = 'scale(1)';
          formLabel.textContent = '儵魚';
          
          // 魚的視覺效果 - 統一的水中游弋視角（不再根據章節區分）
          createTransformationOverlay({
            background: 'rgba(0, 100, 255, 0.08)',
            transform: 'scale(0.9)',
            filter: 'hue-rotate(180deg) saturate(1.2)'
          });
          break;
          
        case 'kun':
          // 確保鯤的圖標存在
          if (kunIconUpdated) {
            // 顯示鯤圖標
            kunIconUpdated.style.opacity = '1';
            kunIconUpdated.style.transform = 'scale(1)';
            formLabel.textContent = '鯤';
            
            // 鯤的視覺效果 - 深海巨獸視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(64, 186, 213, 0.3), rgba(103, 200, 208, 0.2))',
              transform: 'scale(0.85)',
              filter: 'hue-rotate(160deg) saturate(1.3)'
            });
          }
          break;
          
        case 'peng':
          // 確保鵬的圖標存在
          if (pengIconUpdated) {
            // 顯示鵬圖標
            pengIconUpdated.style.opacity = '1';
            pengIconUpdated.style.transform = 'scale(1)';
            formLabel.textContent = '鵬';
            
            // 鵬的視覺效果 - 九萬里高空視角
            createTransformationOverlay({
              background: 'linear-gradient(to top, rgba(64, 186, 213, 0.2), rgba(167, 232, 249, 0.3))',
              transform: 'scale(0.7)',
              filter: 'hue-rotate(190deg) brightness(1.2) saturate(0.8)'
            });
          }
          break;
          
        case 'yuanchu':
          // 確保鵷鶵的圖標存在
          let yuanchuIcon = document.getElementById('yuanchu-icon');
          if (yuanchuIcon) {
            yuanchuIcon.style.opacity = '1';
            yuanchuIcon.style.transform = 'scale(1)';
            formLabel.textContent = '鵷鶵';
            
            // 應用鵷鶵視角效果
            applyYuanchuView();
          }
          break;
          
        case 'chixiao':
          // 確保鴟鴞的圖標存在
          let chixiaoIcon = document.getElementById('chixiao-icon');
          if (chixiaoIcon) {
            chixiaoIcon.style.opacity = '1';
            chixiaoIcon.style.transform = 'scale(1)';
            formLabel.textContent = '鴟鴞';
            
            // 應用鴟鴞視角效果
            applyChixiaoView();
          }
          break;
          
        case 'snail':
          // 確保蝸牛的圖標存在
          let snailIconUpdated = document.getElementById('snail-icon');
          if (snailIconUpdated) {
            snailIconUpdated.style.opacity = '1';
            snailIconUpdated.style.transform = 'scale(1)';
            formLabel.textContent = '蝸牛';
            
            // 使用原本的蝸牛視角效果，而不是覆蓋層系統
            createSnailPerspectiveEffect();
          }
          break;
          
        case 'morning-fungus':
          // 獲取或創建朝菌圖標
          let morningFungusIcon = document.getElementById('morning-fungus-icon');
          if (morningFungusIcon) {
            morningFungusIcon.style.opacity = '1';
            morningFungusIcon.style.transform = 'scale(1)';
            formLabel.textContent = '朝菌';
            
            // 朝菌的視覺效果 - 微觀晨露視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(254, 243, 199, 0.4), rgba(251, 191, 36, 0.3))',
              transform: 'scale(0.82)',
              filter: 'hue-rotate(45deg) brightness(1.3) saturate(1.4)'
            });
          }
          break;
          
        case 'cicada':
          // 獲取或創建蟪蛄圖標
          let cicadaIcon = document.getElementById('cicada-icon');
          if (cicadaIcon) {
            cicadaIcon.style.opacity = '1';
            cicadaIcon.style.transform = 'scale(1)';
            formLabel.textContent = '蟪蛄';
            
            // 蟪蛄的視覺效果 - 夏日韻律視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(34, 197, 94, 0.3), rgba(22, 163, 74, 0.2))',
              transform: 'scale(0.8)',
              filter: 'hue-rotate(90deg) brightness(1.1) saturate(1.2)'
            });
          }
          break;
          
        case 'great-chun':
          // 獲取或創建大椿圖標
          let greatChunIcon = document.getElementById('great-chun-icon');
          if (greatChunIcon) {
            greatChunIcon.style.opacity = '1';
            greatChunIcon.style.transform = 'scale(1)';
            formLabel.textContent = '大椿';
            
            // 大椿的視覺效果 - 千年古樹視角
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(120, 53, 15, 0.4), rgba(146, 64, 14, 0.3))',
              transform: 'scale(0.75)',
              filter: 'sepia(0.6) brightness(0.9) saturate(0.8)'
            });
          }
          break;
          
        case 'ant':
          // 確保螻蟻的圖標存在
          let antIcon = document.getElementById('ant-icon');
          if (antIcon) {
            antIcon.style.opacity = '1';
            antIcon.style.transform = 'scale(1)';
            formLabel.textContent = '螻蟻';
            
            // 螻蟻的視覺效果 - 模擬螞蟻的微觀放大視角：黑白、低亮度，放大觀察
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(42, 42, 42, 0.6), rgba(26, 26, 26, 0.8))',
              transform: 'scale(0.65)',
              filter: 'grayscale(0.9) brightness(0.8) contrast(1.1)'
            });
            
            // 添加螻蟻視角的特殊效果
            addAntVisionEffect();
          }
          break;
          
        case 'star':
          // 確保星辰的圖標存在
          let starIcon = document.getElementById('star-icon');
          if (starIcon) {
            starIcon.style.opacity = '1';
            starIcon.style.transform = 'scale(1)';
            formLabel.textContent = '星辰';
            
            // 星辰的視覺效果 - 宇宙無限視角，最大縮小率
            createTransformationOverlay({
              background: 'linear-gradient(to bottom, rgba(25, 25, 112, 0.4), rgba(65, 105, 225, 0.3))',
              transform: 'scale(0.6)',
              filter: 'hue-rotate(240deg) brightness(1.1) saturate(1.3)'
            });
          }
          break;
          
        case 'qi':
          // 確保氣的圖標存在
          let qiIcon = document.getElementById('qi-icon');
          if (qiIcon) {
            qiIcon.style.opacity = '1';
            qiIcon.style.transform = 'scale(1)';
            formLabel.textContent = '氣';
            
            // 氣的視覺效果 - 移除覆蓋層系統，不對gameContainer應用額外滤镜
            // 移除可能存在的覆蓋層
            const existingOverlay = document.querySelector('.transformation-overlay');
            if (existingOverlay) {
              existingOverlay.remove();
            }
            
            // 重置gameContainer样式，不应用额外的滤镜效果
            gameContainer.style.transform = 'scale(1)';
            gameContainer.style.filter = 'none';
            
            // 在尾聲章節中保留背景圖片，其他章節使用氣形態背景
            if (gameState.currentChapter === 'epilogue') {
              // 尾聲章節：保留莊子背景圖片，不应用额外滤镜
              gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
              console.log('尾聲章節氣形態：保留背景圖片，純粹黑白效果');
            } else {
              // 其他章節：使用氣形態的淡藍紫色背景
              gameContainer.style.background = 'linear-gradient(45deg, rgba(147, 146, 255, 0.1), rgba(255, 255, 255, 0.05))';
              console.log('非尾聲章節氣形態：使用氣形態背景，純粹黑白效果');
            }
            
            // 添加氣形態的特殊效果（純粹的黑白濾鏡，不叠加其他滤镜）
            addQiVisionEffect();
          }
          break;
      }
      
      // 图标隐藏逻辑已在函数开头统一处理
      
      // 當改變形態時清理效果（魚形態已統一，不再需要特殊清理）
      
      // 當切換到非螻蟻形態時，移除螻蟻視覺效果
      if (form !== 'ant') {
        removeAntVisionEffect();
      }
      
      // 更新時間感知動畫速度
      updateTimePerceptionAnimations();
    }
    
    // 添加螻蟻視角的特殊視覺效果
    function addAntVisionEffect() {
      // 移除之前的螻蟻視覺效果
      const existingEffect = document.getElementById('ant-vision-overlay');
      if (existingEffect) {
        existingEffect.remove();
      }
      
      // 創建螻蟻視覺覆蓋層
      const antVisionOverlay = document.createElement('div');
      antVisionOverlay.id = 'ant-vision-overlay';
      antVisionOverlay.style.position = 'fixed';
      antVisionOverlay.style.top = '0';
      antVisionOverlay.style.left = '0';
      antVisionOverlay.style.width = '100%';
      antVisionOverlay.style.height = '100%';
      antVisionOverlay.style.pointerEvents = 'none';
      antVisionOverlay.style.zIndex = '500'; // 降低z-index，避免覆蓋重要UI
      
      // 創建放大鏡效果，模擬螞蟻的近視和有限視野
      antVisionOverlay.style.background = `
        radial-gradient(circle at center, 
          transparent 15%, 
          rgba(0, 0, 0, 0.1) 25%, 
          rgba(0, 0, 0, 0.4) 50%, 
          rgba(0, 0, 0, 0.7) 80%, 
          rgba(0, 0, 0, 0.9) 100%)
      `;
      
      // 添加放大效果的CSS變換
      antVisionOverlay.style.transform = 'scale(1.2)';
      antVisionOverlay.style.transformOrigin = 'center center';
      
      // 添加少量動態粒子，模擬螞蟻視覺的不完美，但不過度干擾
      for (let i = 0; i < 4; i++) {
        const particle = document.createElement('div');
        particle.style.position = 'absolute';
        particle.style.width = `${15 + Math.random() * 25}px`;
        particle.style.height = `${15 + Math.random() * 25}px`;
        particle.style.background = 'rgba(0, 0, 0, 0.05)';
        particle.style.borderRadius = '50%';
        particle.style.filter = 'blur(2px)';
        particle.style.left = `${20 + Math.random() * 60}%`; // 避免在中心區域
        particle.style.top = `${20 + Math.random() * 60}%`;
        particle.style.animation = `ant-vision-float ${4 + Math.random() * 6}s infinite ease-in-out`;
        particle.style.animationDelay = `${Math.random() * 3}s`;
        
        antVisionOverlay.appendChild(particle);
      }
      
      document.body.appendChild(antVisionOverlay);
      
      // 添加螻蟻視覺類到body
      document.body.classList.add('ant-vision');
      
      // 添加螻蟻視覺動畫樣式
      if (!document.getElementById('ant-vision-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'ant-vision-styles';
        styleElement.textContent = `
          @keyframes ant-vision-float {
            0%, 100% { 
              transform: translate(0, 0) scale(1); 
              opacity: 0.3; 
            }
            50% { 
              transform: translate(${-10 + Math.random() * 20}px, ${-10 + Math.random() * 20}px) scale(1.2); 
              opacity: 0.1; 
            }
          }
          
          /* 為螻蟻視角添加視覺效果，但保持文字清晰 */
          body.ant-vision {
            /* 移除blur效果，保持文字清晰 */
          }
          
          body.ant-vision * {
            /* 為所有元素添加輕微陰影增強對比度 */
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
          }
          
          /* 確保重要UI元素在螻蟻視角下保持清晰和可見 */
          body.ant-vision .transformation-experience-text,
          body.ant-vision .transformation-experience-text *,
          body.ant-vision #advance-btn,
          body.ant-vision #advance-btn *,
          body.ant-vision .typewriter-text,
          body.ant-vision .typewriter-text *,
          body.ant-vision button,
          body.ant-vision button *,
          body.ant-vision .max-w-2xl,
          body.ant-vision .max-w-3xl,
          body.ant-vision p,
          body.ant-vision div[class*="text"] {
            filter: none !important;
            text-shadow: 2px 2px 6px rgba(0, 0, 0, 0.9) !important;
            color: #ffffff !important;
            position: relative !important;
            z-index: 1000 !important;
          }
          
          /* 為按鈕和重要容器添加背景 */
          body.ant-vision #advance-btn,
          body.ant-vision button,
          body.ant-vision .transformation-experience-text {
            background: rgba(0, 0, 0, 0.85) !important;
            border: 2px solid #888 !important;
            border-radius: 12px !important;
            padding: 12px 20px !important;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.3) !important;
          }
          
          /* 確保文字容器有足夠的對比度 */
          body.ant-vision .max-w-2xl,
          body.ant-vision .max-w-3xl {
            background: rgba(0, 0, 0, 0.8) !important;
            border: 1px solid #666 !important;
            border-radius: 12px !important;
            padding: 20px !important;
            backdrop-filter: none !important;
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      // 為body添加螻蟻視覺類
      document.body.classList.add('ant-vision');
    }
    
    // 移除螻蟻視覺效果
    function removeAntVisionEffect() {
      const antVisionOverlay = document.getElementById('ant-vision-overlay');
      if (antVisionOverlay) {
        antVisionOverlay.remove();
      }
      
      document.body.classList.remove('ant-vision');
    }
    
    // 添加蝴蝶夢境縮放效果
    function addButterflyDreamEffect() {
      // 移除之前的蝴蝶夢境效果
      const existingEffect = document.getElementById('butterfly-dream-overlay');
      if (existingEffect) {
        existingEffect.remove();
      }
      
      // 移除之前的樣式
      const existingStyles = document.getElementById('butterfly-dream-styles');
      if (existingStyles) {
        existingStyles.remove();
      }
      
      // 創建蝴蝶夢境覆蓋層
      const butterflyDreamOverlay = document.createElement('div');
      butterflyDreamOverlay.id = 'butterfly-dream-overlay';
      butterflyDreamOverlay.style.position = 'fixed';
      butterflyDreamOverlay.style.top = '0';
      butterflyDreamOverlay.style.left = '0';
      butterflyDreamOverlay.style.width = '100%';
      butterflyDreamOverlay.style.height = '100%';
      butterflyDreamOverlay.style.pointerEvents = 'none';
      butterflyDreamOverlay.style.zIndex = '400';
      
      // 創建夢境粒子效果
      for (let i = 0; i < 8; i++) {
        const dreamParticle = document.createElement('div');
        dreamParticle.style.position = 'absolute';
        dreamParticle.style.width = `${20 + Math.random() * 30}px`;
        dreamParticle.style.height = `${20 + Math.random() * 30}px`;
        dreamParticle.style.background = `rgba(147, 51, 234, ${0.1 + Math.random() * 0.2})`;
        dreamParticle.style.borderRadius = '50%';
        dreamParticle.style.filter = 'blur(15px)';
        dreamParticle.style.left = `${10 + Math.random() * 80}%`;
        dreamParticle.style.top = `${10 + Math.random() * 80}%`;
        dreamParticle.style.animation = `butterfly-dream-float ${6 + Math.random() * 8}s infinite ease-in-out`;
        dreamParticle.style.animationDelay = `${Math.random() * 4}s`;
        
        butterflyDreamOverlay.appendChild(dreamParticle);
      }
      
      document.body.appendChild(butterflyDreamOverlay);
      
      // 添加蝴蝶夢境動畫樣式
      const styleElement = document.createElement('style');
      styleElement.id = 'butterfly-dream-styles';
      styleElement.textContent = `
        @keyframes butterfly-dream-float {
          0%, 100% { 
            transform: translate(0, 0) scale(0.8); 
            opacity: 0.1; 
          }
          25% { 
            transform: translate(${-30 + Math.random() * 60}px, ${-20 + Math.random() * 40}px) scale(1.2); 
            opacity: 0.3; 
          }
          50% { 
            transform: translate(${-20 + Math.random() * 40}px, ${-30 + Math.random() * 60}px) scale(1.0); 
            opacity: 0.2; 
          }
          75% { 
            transform: translate(${-40 + Math.random() * 80}px, ${-10 + Math.random() * 20}px) scale(1.1); 
            opacity: 0.25; 
          }
        }
        
        @keyframes butterfly-dream-breath {
          0%, 100% { transform: scale(0.95); }
          50% { transform: scale(1.02); }
        }
        
        /* 為遊戲容器添加呼吸縮放效果 */
        body.butterfly-dream #game-container {
          animation: butterfly-dream-breath 8s infinite ease-in-out;
          transform-origin: center center;
        }
        
        /* 為重要元素添加夢境光暈 */
        body.butterfly-dream .transformation-experience-text,
        body.butterfly-dream #advance-btn,
        body.butterfly-dream .typewriter-text,
        body.butterfly-dream button {
          box-shadow: 0 0 20px rgba(147, 51, 234, 0.3) !important;
          border: 1px solid rgba(147, 51, 234, 0.4) !important;
          backdrop-filter: blur(5px) !important;
        }
      `;
      document.head.appendChild(styleElement);
      
      // 為body添加蝴蝶夢境類
      document.body.classList.add('butterfly-dream');
    }
    
    // 移除蝴蝶夢境效果
    function removeButterflyDreamEffect() {
      const butterflyDreamOverlay = document.getElementById('butterfly-dream-overlay');
      if (butterflyDreamOverlay) {
        butterflyDreamOverlay.remove();
      }
      
      const butterflyDreamStyles = document.getElementById('butterfly-dream-styles');
      if (butterflyDreamStyles) {
        butterflyDreamStyles.remove();
      }
      
      document.body.classList.remove('butterfly-dream');
    }
    
    // 添加氣視覺效果
    // 简化版气形态效果 - 只保留黑白效果
    function addQiVisionEffect() {
      // 清理之前的效果
      const existingStyles = document.getElementById('simple-qi-vision-styles');
      if (existingStyles) {
        existingStyles.remove();
      }
      
      // 确保基本的qi-vision样式存在
        const styleElement = document.createElement('style');
      styleElement.id = 'simple-qi-vision-styles';
        styleElement.textContent = `
                     /* 氣化視角：純粹黑白濾鏡效果 */
           body.qi-vision {
             filter: grayscale(100%) contrast(1.5);
          cursor: crosshair;
        }
        
        /* 第八章虚空背景特殊处理：直接覆盖背景颜色 */
        body.qi-vision.chapter7-qi-vision #game-container.void-scene {
          background: radial-gradient(ellipse at center, #f8f9fa 0%, #e9ecef 30%, #ffffff 100%) !important;
        }
        
        /* 第八章虚空粒子在气形态下变黑色 */
        body.qi-vision.chapter7-qi-vision .void-particle {
          background: #000000 !important;
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.6) !important;
        }
        
        /* 第八章八卦符号变黑色 */
        body.qi-vision.chapter7-qi-vision .bagua-symbol {
             color: #000000 !important;
             text-shadow: 
               0 0 8px #000000,
               0 0 16px #000000,
               0 0 24px #000000 !important;
          filter: drop-shadow(0 0 10px #000000) drop-shadow(0 0 20px #000000) !important;
          opacity: 1 !important;
          visibility: visible !important;
          display: block !important;
        }
        
        /* 太极符号在气视野中保持原生状态 - 无需额外效果 */
        body.qi-vision.chapter7-qi-vision .taiji-container {
          filter: none !important;
          opacity: 1 !important;
          visibility: visible !important;
          display: block !important;
        }
        
        /* 太极符号在气视野中保持原有旋转动画，只移除发光效果 */
        body.qi-vision.chapter7-qi-vision .taiji-container .yin-yang-emoji {
          opacity: 1 !important;
          visibility: visible !important;
            color: #000000 !important;
          filter: none !important;
          text-shadow: none !important;
          /* 保持原有的发光动画，让☯符号自然显示 */
        }
        
        /* 添加float-glow动画支持预生成的粒子 */
        @keyframes float-glow {
          0%, 100% {
            opacity: 0.6;
            transform: translateY(0px);
          }
          50% {
            opacity: 1;
            transform: translateY(-10px);
          }
        }
        
        /* 第八章混沌形体在气形态下变黑白 */
        body.qi-vision.chapter7-qi-vision .chaos-form {
          background: radial-gradient(ellipse, rgba(255, 255, 255, 0.7) 0%, rgba(0, 0, 0, 0.5) 50%, transparent 100%) !important;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5), 0 0 80px rgba(255, 255, 255, 0.3) !important;
          }
          
        /* 文字確保清晰可讀 */
          body.qi-vision .transformation-experience-text,
          body.qi-vision .transformation-experience-text *,
          body.qi-vision #advance-btn,
          body.qi-vision #advance-btn *,
          body.qi-vision .typewriter-text,
          body.qi-vision .typewriter-text *,
          body.qi-vision button,
          body.qi-vision button *,
          body.qi-vision .max-w-2xl,
          body.qi-vision .max-w-3xl,
          body.qi-vision p,
          body.qi-vision div[class*="text"] {
            color: #000000 !important;
            text-shadow: none !important;
            font-weight: bold !important;
          }
          
                     /* 重要容器背景確保對比度 */
           body.qi-vision .transformation-experience-text {
             background: rgba(255, 255, 255, 0.2) !important;
             border: 2px solid rgba(0, 0, 0, 0.4) !important;
             border-radius: 12px !important;
             padding: 2rem !important;
             box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3) !important;
             backdrop-filter: blur(15px) !important;
             -webkit-backdrop-filter: blur(15px) !important;
           }
           
           body.qi-vision #advance-btn,
           body.qi-vision button {
             background: rgba(255, 255, 255, 0.9) !important;
             border: 2px solid #000000 !important;
             border-radius: 12px !important;
             padding: 12px 20px !important;
             box-shadow: 0 0 20px rgba(0, 0, 0, 0.5) !important;
           }
           
           /* 文字容器背景 */
           body.qi-vision .max-w-2xl,
           body.qi-vision .max-w-3xl {
             background: rgba(255, 255, 255, 0.95) !important;
             border: 2px solid #000000 !important;
             border-radius: 12px !important;
             padding: 20px !important;
           }
        
        /* 通用八卦符号样式（第八章有专用样式） */
        body.qi-vision .bagua-symbol,
        body.qi-vision .bagua-qian,
        body.qi-vision .bagua-dui,
        body.qi-vision .bagua-li,
        body.qi-vision .bagua-zhen,
        body.qi-vision .bagua-xun,
        body.qi-vision .bagua-kan,
        body.qi-vision .bagua-gen,
        body.qi-vision .bagua-kun {
          color: #000000 !important;
          text-shadow: 
            0 0 8px #000000,
            0 0 16px #000000,
            0 0 24px #000000 !important;
          filter: drop-shadow(0 0 10px #000000) !important;
        }
        
        /* 通用虚空粒子样式（第八章有专用样式） */
        body.qi-vision .void-particle {
          background: radial-gradient(circle, rgba(0, 0, 0, 0.8), transparent) !important;
          box-shadow: 0 0 15px rgba(0, 0, 0, 0.6) !important;
        }
        
        /* 通用太极符号样式 - 保持原有动画，只移除发光效果 */
        body.qi-vision .yin-yang-emoji {
          opacity: 1 !important;
          visibility: visible !important;
          color: #000000 !important;
          filter: none !important;
          text-shadow: none !important;
          /* 保持原有的 taiji-glow 动画，让☯符号自然显示 */
        }
        
        /* 重置通用太极符号容器的滤镜效果 */
        body.qi-vision .taiji-container {
          filter: none !important;
          opacity: 1 !important;
          visibility: visible !important;
        }
        
        /* 通用混沌形体样式（第八章有专用样式） */
        body.qi-vision .chaos-form {
          background: radial-gradient(ellipse, rgba(255, 255, 255, 0.4) 0%, rgba(0, 0, 0, 0.3) 50%, transparent 100%) !important;
          box-shadow: 0 0 40px rgba(0, 0, 0, 0.5), 0 0 80px rgba(255, 255, 255, 0.3) !important;
        }
      `;
      document.head.appendChild(styleElement);
      
      // 只添加CSS类，不创建复杂的粒子效果
      document.body.classList.add('qi-vision');
      
      // 第八章特殊处理：添加额外的class来触发虚空背景反转
      if (gameState.currentChapter === 'chapter7') {
        document.body.classList.add('chapter7-qi-vision');
        console.log('第八章气形态：应用虚空背景反转效果');
      }
      
      console.log('简化版气形态效果已启用：纯黑白视觉（无粒子动画）');
    }
    
    // 移除简化版氣視覺效果
    function removeQiVisionEffect() {
      console.log('🧹 開始清理简化版氣視覺效果...');
      
      try {
        // 移除简化版氣視覺樣式
        const simpleQiVisionStyles = document.getElementById('simple-qi-vision-styles');
        if (simpleQiVisionStyles) {
          console.log('移除简化版氣視覺樣式');
          simpleQiVisionStyles.remove();
        }
        
        // 移除body上的氣視覺類
        document.body.classList.remove('qi-vision');
        document.body.classList.remove('chapter7-qi-vision');
        console.log('移除body上的qi-vision類和chapter7-qi-vision類');
        
        // 清理gameContainer的氣形態樣式
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
        
        // 在尾聲章節中保留背景圖片，其他章節清空背景
        if (gameState.currentChapter === 'epilogue') {
          // 尾聲章節：保留莊子背景圖片和濾鏡
          gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
          gameContainer.style.filter = 'sepia(0.15) saturate(1.2) brightness(1.1)';
          console.log('尾聲章節：保留背景圖片，重置其他樣式');
        } else {
          // 其他章節：清空背景
          gameContainer.style.background = '';
          console.log('非尾聲章節：重置所有gameContainer樣式');
        }
        
        console.log('✅ 简化版氣視覺效果清理完成');
      } catch (error) {
        console.error('❌ 清理氣視覺效果時發生錯誤:', error);
        // 至少嘗試移除body類，防止視覺效果殘留
        document.body.classList.remove('qi-vision');
        document.body.classList.remove('chapter7-qi-vision');
        // 重置基本樣式
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
        
        // 在尾聲章節中保留背景圖片
        if (gameState.currentChapter === 'epilogue') {
          gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
          gameContainer.style.filter = 'sepia(0.15) saturate(1.2) brightness(1.1)';
        } else {
          gameContainer.style.background = '';
        }
      }
    }
    
    // 根據當前形態更新時間感知動畫速度
    function updateTimePerceptionAnimations() {
      let speedMultiplier = 1; // 正常速度
      
      switch(gameState.currentForm) {
        case 'morning-fungus':
          speedMultiplier = 0.15; // 朝菌視角：生命短暫，感受時間很快，動畫變得很快（持續時間變短）
          break;
        case 'cicada':
          speedMultiplier = 0.4; // 蟪蛄視角：生命較短，感受時間較快，動畫比正常快（持續時間較短）
          break;
        case 'great-chun':
          speedMultiplier = 4.0; // 大椿視角：生命漫長，感受時間很慢，動畫變得很慢（持續時間變長）
          break;
        default:
          speedMultiplier = 1; // 其他形態保持正常速度
          break;
      }
      
      console.log(`更新時間感知動畫 - 當前形態: ${gameState.currentForm}, 速度倍數: ${speedMultiplier}`);
      
      // 更新時間粒子動畫速度
      const timeParticles = document.querySelectorAll('.time-particle-global');
      console.log(`找到 ${timeParticles.length} 個時間粒子`);
      
      timeParticles.forEach((particle, index) => {
        const originalDuration = particle.dataset.originalDuration;
        const delay = particle.dataset.delay;
        const animationType = particle.dataset.animationType;
        const easing = particle.dataset.easing;
        
        if (originalDuration && animationType) {
          const newDuration = parseFloat(originalDuration) * speedMultiplier;
          const oldAnimation = particle.style.animation;
          particle.style.animation = `${animationType} ${newDuration}s ${delay}s infinite ${easing}`;
          console.log(`粒子 ${index}: ${originalDuration}s -> ${newDuration}s (${animationType})`);
        } else {
          console.log(`粒子 ${index}: 缺少數據屬性`, {originalDuration, animationType, easing});
        }
      });
      
      // 更新蟪蛄飛行動畫速度
      const flyingCicadas = document.querySelectorAll('[data-original-flight-duration]');
      console.log(`找到 ${flyingCicadas.length} 個飛行蟪蛄`);
      
      flyingCicadas.forEach((cicada, index) => {
        const originalDuration = cicada.dataset.originalFlightDuration;
        const delay = cicada.dataset.flightDelay;
        
        if (originalDuration) {
          const newDuration = parseFloat(originalDuration) * speedMultiplier;
          cicada.style.animation = `cicada-flight ${newDuration}s ${delay}s infinite linear`;
          console.log(`蟪蛄飛行 ${index}: ${originalDuration}s -> ${newDuration}s`);
        }
      });
      
      // 更新蟪蛄翅膀扇動速度
      const cicadaWings = document.querySelectorAll('[data-original-wing-duration]');
      console.log(`找到 ${cicadaWings.length} 個蟪蛄翅膀`);
      
      cicadaWings.forEach((wing, index) => {
        const originalDuration = wing.dataset.originalWingDuration;
        const animationType = wing.style.animation.includes('left') ? 'cicada-wing-left' : 'cicada-wing-right';
        
        if (originalDuration) {
          const newDuration = parseFloat(originalDuration) * speedMultiplier;
          wing.style.animation = `${animationType} ${newDuration}s infinite ease-in-out`;
          console.log(`蟪蛄翅膀 ${index}: ${originalDuration}s -> ${newDuration}s (${animationType})`);
        }
      });
    }
    
    function processEffect(effect) {
      const [effectType, effectValue] = effect.split(':');
      
      switch (effectType) {
        case 'unlockButterfly':
          unlockForm('butterfly');
          break;
        case 'unlockFish':
          unlockForm('fish');
          break;
        case 'unlockKun':
          unlockForm('kun');
          break;
        case 'unlockPeng':
          unlockForm('peng');
          break;
        case 'unlockBird':
          unlockForm('yuanchu');
          unlockForm('chixiao');
          break;
        case 'collectAperture':
          collectAperture(effectValue);
          break;
        case 'unlockSnail':
          unlockForm('snail');
          break;
        case 'unlockViewScale':
          enableScaleControl();
          break;
        case 'unlockForm':
          unlockForm(effectValue);
          break;
        case 'switchToHuman':
          // 劇情專用：直接切換到人形，不觸發日常物化邏輯
          returnToHumanForStory();
          break;
        case 'cleanupChapter4':
          cleanupChapter4Effects();
          break;
        case 'cleanupChapter5':
          cleanupChapter5Effects();
          break;
        case 'addGlowingSnail':
          addGlowingSnail();
          break;
      }
    }
    
    // 劇情專用：回到人形，不觸發日常物化邏輯
    function returnToHumanForStory() {
      console.log('🎭 劇情切換：回到人形');
      
      // 儲存當前形態用於轉換動畫
      const fromForm = gameState.currentForm;
      
      // 更新按鈕狀態：移除所有按鈕的活躍狀態
      Object.values(formButtons).forEach(button => {
        button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
        button.classList.add('bg-gray-500');
      });
      
      // 高亮人形按鈕
      if (formButtons['human']) {
        formButtons['human'].classList.remove('bg-gray-500');
        formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
      }
      
      // 顯示物化轉換動畫（從當前形態轉換到人形）
      if (fromForm !== 'human') {
        showTransformationTransition(fromForm, 'human');
      }
      
      // 設置動畫完成後的邏輯（1.5秒後執行，與正常物化轉換保持一致）
      setTimeout(() => {
        // 設置當前形態為人形
        gameState.currentForm = 'human';
        
        // 更新物化指示器和視覺效果
        updateFormView('human');
        
        // 檢查是否在AI章節總結場景中，如果是則不強制顯示繼續按鈕
        const currentScene = gameChapters[gameState.currentChapter]?.scenes[gameState.currentScene];
        const isChapterSummaryScene = currentScene?.type === 'personalized-summary' && currentScene?.sceneType === 'chapter_summary';
        
        if (!isChapterSummaryScene) {
          // 確保繼續按鈕正常顯示（不隱藏）- 但排除AI章節總結場景
          if (advanceBtn) {
            advanceBtn.style.display = 'block';
          }
        } else {
          console.log('🔒 AI章節總結場景：保持繼續按鈕隱藏狀態');
        }
        
        // 確保不處於日常物化狀態
        gameState.isInDailyTransformation = false;
        gameState.dailyTransformationPreviousForm = null;
        
        // 移除退出視角按鈕（如果存在）
        const exitButton = document.querySelector('.exit-transformation-btn');
        if (exitButton) {
          exitButton.remove();
        }
        
        console.log('✅ 已回到人形，物化指示器已更新，不觸發日常物化邏輯');
      }, fromForm !== 'human' ? 1500 : 0); // 如果已經是人形，立即執行
    }
    
    // 移除所有物化視覺效果的函數
    function removeAllTransformationEffects() {
      // 移除所有可能的視覺效果
      const effects = [
        'removeTransformationOverlay',
        'removeQiVisionEffect', 
        'removeKunView',
        'removePengView',
        'removeHumanView',
        'removeButterflyView',
        'removeFishView',
        'removeAntView',
        'removeStarView'
      ];
      
      effects.forEach(effectName => {
        if (typeof window[effectName] === 'function') {
          try {
            window[effectName]();
          } catch (e) {
            // 靜默忽略不存在的效果函數
          }
        }
      });
      
      // 通用清理：移除變換覆蓋層和重置容器樣式
      const overlay = document.querySelector('.transformation-overlay');
      if (overlay) {
        overlay.remove();
      }
      
      // 重置gameContainer的樣式
      if (gameContainer) {
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
      }
    }
    
    function unlockForm(form) {
      // 特殊處理：第一章中的蝴蝶形態應該立即顯示
      const isFirstChapterButterfly = (form === 'butterfly' && (gameState.currentChapter === 'prologue' || gameState.currentChapter === 'chapter1'));
      
      // 檢查是否是新章節的物化能力解鎖（但排除第一章的蝴蝶）
      const newChapterForms = ['fish', 'kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star', 'qi'];
      const deferredUnlock = newChapterForms.includes(form) || (form === 'butterfly' && !isFirstChapterButterfly);
      
      // 檢查是否已經解鎖過該形態
      const alreadyUnlocked = gameState.unlockedForms.includes(form);
      
      if (deferredUnlock && !alreadyUnlocked) {
        // 新章節形態首次解鎖：只解鎖，不立即顯示按鈕（延遲到收集場景完成）
          gameState.unlockedForms.push(form);
          
          // 立即保存遊戲進度，確保形態解鎖數據不丟失
          saveGameProgress();
          
          console.log(`預備解鎖新形態: ${form}，按鈕將在收集場景後顯示`);
        
        // 確保按鈕保持隱藏狀態
        if (formButtons[form]) {
          formButtons[form].style.visibility = 'hidden';
          formButtons[form].classList.add('hidden');
        }
        
        return; // 不執行下面的立即顯示邏輯
      } else if (alreadyUnlocked) {
        // 已經解鎖的形態：重新進入章節時應該立即顯示按鈕
        console.log(`重新顯示已解鎖形態按鈕: ${form}`);
        if (formButtons[form]) {
          formButtons[form].classList.remove('hidden');
          formButtons[form].style.visibility = 'visible';
        }
        return;
      }
      
      if (!alreadyUnlocked) {
        gameState.unlockedForms.push(form);
        
        // 立即保存遊戲進度，確保形態解鎖數據不丟失
        saveGameProgress();
        
        console.log(`解鎖形態並立即顯示按鈕: ${form}`);
        
        // 一般形態處理（包括第一章的蝴蝶）
        // 顯示形態按鈕
        if (formButtons[form]) {
          formButtons[form].classList.remove('hidden');
          formButtons[form].style.visibility = 'visible';
          
          // 添加動畫效果
          formButtons[form].classList.add('animate-pulse');
          setTimeout(() => {
            formButtons[form].classList.remove('animate-pulse');
          }, 2000);
        }
      }
    }
    
    function collectAperture(aperture) {
      if (!gameState.collectedApertures.includes(aperture)) {
        // 創建一個互動式封印場景，讓玩家點擊收集
        createInteractiveApertureScene(aperture);
      }
    }
    
    // 創建互動式收集封印的場景
    function createInteractiveApertureScene(apertureType) {
      // 隱藏繼續按鈕，直到玩家收集封印
      advanceBtn.style.display = 'none';
      
      // 創建一個覆蓋層，增加儀式感
      const overlayEl = document.createElement('div');
      overlayEl.className = 'fixed inset-0 bg-black bg-opacity-60 z-50 flex items-center justify-center';
      
      // 創建中央容器
      const containerEl = document.createElement('div');
      containerEl.className = 'relative max-w-md w-full p-8 flex flex-col items-center';
      
      // 創建標題
      const titleEl = document.createElement('h2');
      titleEl.className = 'text-2xl md:text-3xl text-white font-bold mb-8 text-center';
      titleEl.textContent = '混沌七竅封印';
      
      // 創建封印描述
      const descEl = document.createElement('p');
      descEl.className = 'text-white text-center mb-8';
      
      // 根據不同封印顯示不同描述
      switch(apertureType) {
        case 'left-eye':
          descEl.textContent = '你找到了左目之竅的封印！它將封閉你的左眼視覺，讓你不再被外在形象所迷惑，回歸內在的清明無分別。點擊封印將其收集。';
          break;
        case 'right-eye':
          descEl.textContent = '你找到了右目之竅的封印！它將封閉你的右眼分辨，讓你不再執著於大小差別，回歸平等心的本源。點擊封印將其收集。';
          break;
        case 'left-ear':
          descEl.textContent = '你找到了左耳之竅的封印！它將封閉你的左耳聽聞，讓你不再被外聲所擾，回歸內在的純然寧靜。點擊封印將其收集。';
          break;
        case 'right-ear':
          descEl.textContent = '你找到了右耳之竅的封印！它將封閉你的右耳判斷，讓你不再分辨真偽是非，回歸混沌的純真本性。點擊封印將其收集。';
          break;
        case 'left-nose':
          descEl.textContent = '你找到了左鼻之竅的封印！它將封閉你的嗅覺分別，讓你不再追求香臭好惡，回歸無分別的自然狀態。點擊封印將其收集。';
          break;
        case 'right-nose':
          descEl.textContent = '你找到了右鼻之竅的封印！它將封閉你的鼻息執著，讓你不再依賴氣味指引，回歸內在的無為智慧。點擊封印將其收集。';
          break;
        case 'mouth':
          descEl.textContent = '你找到了口之竅的封印！它將封閉你的言語分別，讓你不再用言語區分萬物，回歸無言大道的境界。點擊封印將其收集。';
          break;
        default:
          descEl.textContent = '你找到了一個神秘的封印！它將幫助混沌回歸原初的純真狀態。點擊將其收集。';
      }
      
      // 創建可點擊的封印
      const sealContainer = document.createElement('div');
      sealContainer.className = 'relative mb-8 cursor-pointer transform transition-all duration-500 hover:scale-110';
      sealContainer.style.width = '150px';
      sealContainer.style.height = '150px';
      
      // 創建發光效果背景
      const glowEffect = document.createElement('div');
      glowEffect.className = 'absolute inset-0 rounded-full';
      glowEffect.style.background = 'radial-gradient(circle, rgba(147, 146, 255, 0.7) 0%, rgba(93, 92, 222, 0) 70%)';
      glowEffect.style.filter = 'blur(15px)';
      glowEffect.style.animation = 'pulse-glow 2s infinite ease-in-out';
      
      // 添加脈衝動畫
      if (!document.getElementById('pulse-glow-animation')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'pulse-glow-animation';
        styleEl.textContent = `
          @keyframes pulse-glow {
            0%, 100% { opacity: 0.7; transform: scale(0.95); }
            50% { opacity: 1; transform: scale(1.05); }
          }
          
          @keyframes rotate-seal {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
          }
          
          @keyframes floating-particles {
            0% { transform: translateY(0) rotate(0deg); opacity: 0.8; }
            100% { transform: translateY(-80px) rotate(360deg); opacity: 0; }
          }
          
          @keyframes celebration-ring {
            0% { transform: scale(0.3); opacity: 0.8; }
            100% { transform: scale(2); opacity: 0; }
          }
        `;
        document.head.appendChild(styleEl);
      }
      
      // 創建封印圖案
      const sealEl = document.createElement('div');
      sealEl.className = 'scene-seal absolute inset-0 ' + apertureType;
      sealEl.style.width = '100%';
      sealEl.style.height = '100%';
      sealEl.style.boxShadow = '0 0 20px rgba(93, 92, 222, 0.8), 0 0 40px rgba(93, 92, 222, 0.4) inset';
      
      // 添加浮動粒子
      for (let i = 0; i < 12; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full bg-indigo-300';
        
        // 隨機大小和位置
        const size = 3 + Math.random() * 4;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 圍繞封印放置粒子
        const angle = Math.random() * Math.PI * 2;
        const distance = 60 + Math.random() * 20;
        const x = Math.cos(angle) * distance;
        const y = Math.sin(angle) * distance;
        
        particle.style.left = `calc(50% + ${x}px)`;
        particle.style.top = `calc(50% + ${y}px)`;
        
        // 添加動畫，延遲不同
        const delay = Math.random() * 2;
        const duration = 2 + Math.random() * 2;
        particle.style.animation = `floating-particles ${duration}s ${delay}s infinite linear`;
        
        sealContainer.appendChild(particle);
      }
      
      // 添加提示文字
      const hintEl = document.createElement('p');
      hintEl.className = 'text-white text-opacity-80 mt-4 text-sm animate-pulse';
      hintEl.textContent = '點擊封印收集';
      
      // 組合元素
      sealContainer.appendChild(glowEffect);
      sealContainer.appendChild(sealEl);
      
      containerEl.appendChild(titleEl);
      containerEl.appendChild(descEl);
      containerEl.appendChild(sealContainer);
      containerEl.appendChild(hintEl);
      
      overlayEl.appendChild(containerEl);
      document.body.appendChild(overlayEl);
      
      // 為封印添加點擊事件
      sealContainer.addEventListener('click', () => {
        // 移除點擊事件
        sealContainer.style.pointerEvents = 'none';
        
        // 收集動畫 - 傳遞containerEl變數
        collectApertureWithAnimation(apertureType, sealEl, overlayEl, containerEl);
        
        // 移除提示
        hintEl.style.display = 'none';
        
        // 更新描述
        descEl.textContent = `你已獲得${getApertureName(apertureType)}的封印！`;
        descEl.className = 'text-white text-center mb-8 font-bold';
      });
    }
    
    // 根據封印類型返回封印名稱
    function getApertureName(apertureType) {
      switch(apertureType) {
        case 'left-eye': return '左目之竅';
        case 'right-eye': return '右目之竅';
        case 'left-ear': return '左耳之竅';
        case 'right-ear': return '右耳之竅';
        case 'left-nose': return '左鼻之竅';
        case 'right-nose': return '右鼻之竅';
        case 'mouth': return '口之竅';
        default: return '神秘';
      }
    }
    
    // 收集封印的動畫
    function collectApertureWithAnimation(apertureType, sealEl, overlayEl, containerEl) {
      // 播放收集動畫（加速）
      sealEl.style.animation = 'rotate-seal 0.8s ease-in-out';
      
      // 創建慶祝效果 - 脈衝環
      for (let i = 0; i < 3; i++) {
        const ring = document.createElement('div');
        ring.className = 'absolute rounded-full border-2 border-indigo-400 top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2';
        ring.style.width = '100%';
        ring.style.height = '100%';
        ring.style.animation = `celebration-ring 0.8s ${i * 0.2}s ease-out forwards`;
        sealEl.parentNode.appendChild(ring);
      }
      
      // 添加慶祝粒子
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full bg-white';
        
        // 隨機大小
        const size = 2 + Math.random() * 3;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 放置在中心
        particle.style.left = '50%';
        particle.style.top = '50%';
        
        // 計算隨機方向
        const angle = Math.random() * Math.PI * 2;
        const speed = 100 + Math.random() * 100;
        const xSpeed = Math.cos(angle) * speed;
        const ySpeed = Math.sin(angle) * speed;
        
        // 設置動畫
        particle.style.transform = 'translate(-50%, -50%)';
        particle.animate([
          { transform: 'translate(-50%, -50%)', opacity: 1 },
          { transform: `translate(calc(-50% + ${xSpeed}px), calc(-50% + ${ySpeed}px))`, opacity: 0 }
        ], {
          duration: 800 + Math.random() * 700,
          easing: 'cubic-bezier(0.1, 0.8, 0.2, 1)',
          fill: 'forwards'
        });
        
        sealEl.parentNode.appendChild(particle);
      }
      
      // 0.8秒後執行飛向七竅容器的動畫
      setTimeout(() => {
        // 獲取七竅容器中目標位置
        const targetAperture = document.querySelector(`.aperture-${apertureType}`);
        
        // 如果找到目標，執行飛行動畫
        if (targetAperture) {
          // 計算位置
          const sealRect = sealEl.getBoundingClientRect();
          const targetRect = targetAperture.getBoundingClientRect();
          
          // 計算封印到目標的向量
          const endX = targetRect.left - sealRect.left + (targetRect.width / 2 - sealRect.width / 2);
          const endY = targetRect.top - sealRect.top + (targetRect.height / 2 - sealRect.height / 2);
          
          // 設置動畫路徑
          sealEl.style.setProperty('--end-x', `${endX}px`);
          sealEl.style.setProperty('--end-y', `${endY}px`);
          sealEl.style.animation = 'seal-path 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
          
          // 路徑動畫結束後
          setTimeout(() => {
            // 將封印添加到已收集列表
            if (!gameState.collectedApertures.includes(apertureType)) {
              gameState.collectedApertures.push(apertureType);
              
              // 立即保存遊戲進度，確保封印收集數據不丟失
              saveGameProgress();
            }
            
            // 在七竅容器中激活目標封印
            targetAperture.classList.add('collecting');
            
            // 添加激活粒子
            createActivationParticles(targetAperture);
            
            // 添加音波效果
            const soundWaveContainer = document.createElement('div');
            soundWaveContainer.className = 'absolute pointer-events-none';
            soundWaveContainer.style.left = `${targetRect.left + targetRect.width / 2}px`;
            soundWaveContainer.style.top = `${targetRect.top + targetRect.height / 2}px`;
            soundWaveContainer.style.zIndex = '60';
            
            for (let i = 0; i < 3; i++) {
              const wave = document.createElement('div');
              wave.className = 'rounded-full absolute';
              wave.style.border = '1px solid rgba(147, 146, 255, 0.8)';
              wave.style.width = '10px';
              wave.style.height = '10px';
              wave.style.left = '-5px';
              wave.style.top = '-5px';
              wave.style.animation = `sound-wave 1s ${i * 0.2}s ease-out`;
              
              soundWaveContainer.appendChild(wave);
            }
            
            document.body.appendChild(soundWaveContainer);
            
            // 添加動畫 keyframes 以實現黑洞慢慢消失的效果
            if (!document.getElementById('aperture-fade-animation')) {
              const styleEl = document.createElement('style');
              styleEl.id = 'aperture-fade-animation';
              styleEl.textContent = `
                @keyframes aperture-fade {
                  0% { 
                    animation: none !important; /* 立即停止流動動畫 */
                    transform: scale(1); 
                    opacity: 1; 
                    background: rgba(0, 0, 0, 0.85);
                    box-shadow: 0 0 4px rgba(0, 0, 0, 0.7) inset, 0 0 8px rgba(93, 92, 222, 0.3);
                  }
                  30% { 
                    transform: scale(0.9); 
                    opacity: 0.8; 
                    background: rgba(20, 20, 40, 0.8);
                    box-shadow: 0 0 6px rgba(0, 0, 0, 0.7) inset, 0 0 15px rgba(93, 92, 222, 0.6);
                  }
                  70% { 
                    transform: scale(0.5); 
                    opacity: 0.4; 
                    background: rgba(40, 40, 80, 0.7);
                    box-shadow: 0 0 8px rgba(0, 0, 0, 0.7) inset, 0 0 20px rgba(93, 92, 222, 0.8);
                  }
                  100% { 
                    transform: scale(0.1); 
                    opacity: 0; 
                    background: rgba(60, 60, 120, 0.3);
                    box-shadow: 0 0 2px rgba(0, 0, 0, 0.5) inset, 0 0 5px rgba(93, 92, 222, 0.2);
                  }
                }
              `;
              document.head.appendChild(styleEl);
            }
            
            // 執行收集動畫結束後（加速）
            setTimeout(() => {
              // 移除收集動畫類
              targetAperture.classList.remove('collecting');
              
              // 由於我們想要有一個平滑消失的動畫，我們不立即加上active類
              // 先設置滿足消失動畫（加速動畫）
              targetAperture.style.animation = 'aperture-fade 1s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
              
              // 動畫結束後才真正添加active類（加速）
              setTimeout(() => {
                // 添加激活類
                targetAperture.classList.add('active');
                
                // 自動繼續遊戲，不需要用戶點擊額外按鈕
                setTimeout(() => {
                  // 移除遮罩層
                  overlayEl.remove();
                  // 顯示繼續按鈕
                  advanceBtn.style.display = 'block';
                  // 清除音波效果
                  if (soundWaveContainer && soundWaveContainer.parentNode) {
                    soundWaveContainer.remove();
                  }
                  
                  // 檢查是否收集了所有7個封印
                  if (gameState.collectedApertures.length === 7) {
                    console.log('🌟 所有封印已收集完成，創建轉動的太極emoji覆蓋混沌指示器');
                    createTaijiOverlay();
                  }
                  
                  console.log('✅ 封印收集完成，自動繼續遊戲流程');
                }, 1500); // 給玩家1.5秒時間欣賞收集效果
              }, 1000); // 等待aperture-fade動畫完成（加速）
            }, 500); // 加速收集動畫
            
          }, 1000); // 加速路徑動畫
        }
      }, 800); // 加速初始延遲
    }
    
    function createSceneSeal(sealType) {
      // Create a scene seal that floats in the scene
      const sceneSeal = document.createElement('div');
      sceneSeal.className = `scene-seal ${sealType}`;
      
      // Position in the center bottom of the screen initially
      sceneSeal.style.left = '50%';
      sceneSeal.style.top = '70%';
      sceneSeal.style.transform = 'translate(-50%, -50%)';
      sceneSeal.style.zIndex = '50';
      
      // Add to game content
      gameContent.appendChild(sceneSeal);
      
      // Get the target aperture on the tracker
      const targetAperture = document.querySelector(`.aperture-${sealType}`);
      
      // Animate collection after a short delay
      setTimeout(() => {
        // Calculate path to the aperture tracker
        const sealRect = sceneSeal.getBoundingClientRect();
        const targetRect = targetAperture.getBoundingClientRect();
        
        // Calculate the vector from seal to target
        const endX = targetRect.left - sealRect.left + (targetRect.width / 2 - sealRect.width / 2);
        const endY = targetRect.top - sealRect.top + (targetRect.height / 2 - sealRect.height / 2);
        
        // Set animation path variables
        sceneSeal.style.setProperty('--end-x', `${endX}px`);
        sceneSeal.style.setProperty('--end-y', `${endY}px`);
        
        // Apply path animation
        sceneSeal.style.animation = 'seal-path 2s cubic-bezier(0.34, 1.56, 0.64, 1) forwards';
        
        // Add shimmering light effect
        const shimmerEffect = document.createElement('div');
        shimmerEffect.className = 'absolute inset-0 pointer-events-none';
        shimmerEffect.style.background = 'radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0) 70%)';
        shimmerEffect.style.opacity = '0';
        shimmerEffect.style.animation = 'shimmer 2s ease-in-out';
        
        gameContainer.appendChild(shimmerEffect);
        
        // Remove shimmer after animation
        setTimeout(() => {
          shimmerEffect.remove();
        }, 2000);
        
        // Add keyframes for shimmer effect
        if (!document.getElementById('shimmer-animation')) {
          const styleElement = document.createElement('style');
          styleElement.id = 'shimmer-animation';
          styleElement.textContent = `
            @keyframes shimmer {
              0% { opacity: 0; }
              50% { opacity: 0.5; }
              100% { opacity: 0; }
            }
          `;
          document.head.appendChild(styleElement);
        }
        
        // After path animation completes, animate the target aperture
        setTimeout(() => {
          // Remove the seal from scene
          sceneSeal.remove();
          
          // Add collecting animation to the target aperture
          targetAperture.classList.add('collecting');
          
          // Add activation particles
          createActivationParticles(targetAperture);
          
          // Add sound wave effect
          const soundWaveContainer = document.createElement('div');
          soundWaveContainer.className = 'absolute pointer-events-none';
          soundWaveContainer.style.left = `${targetRect.left + targetRect.width / 2}px`;
          soundWaveContainer.style.top = `${targetRect.top + targetRect.height / 2}px`;
          soundWaveContainer.style.zIndex = '60';
          
          for (let i = 0; i < 3; i++) {
            const wave = document.createElement('div');
            wave.className = 'rounded-full absolute';
            wave.style.border = '1px solid rgba(147, 146, 255, 0.8)';
            wave.style.width = '10px';
            wave.style.height = '10px';
            wave.style.left = '-5px';
            wave.style.top = '-5px';
            wave.style.animation = `sound-wave 1.5s ${i * 0.3}s ease-out`;
            
            soundWaveContainer.appendChild(wave);
          }
          
          document.body.appendChild(soundWaveContainer);
          
          // Add keyframes for sound wave effect
          if (!document.getElementById('wave-animation')) {
            const styleElement = document.createElement('style');
            styleElement.id = 'wave-animation';
            styleElement.textContent = `
              @keyframes sound-wave {
                0% { transform: scale(1); opacity: 1; }
                100% { transform: scale(7); opacity: 0; }
              }
            `;
            document.head.appendChild(styleElement);
          }
          
          // After collecting animation finishes (1.5s), add active class to make aperture disappear
          setTimeout(() => {
            // Remove the collecting animation class
            targetAperture.classList.remove('collecting');
            // Add the active class that makes it disappear
            targetAperture.classList.add('active');
            
            // Create a visual indicator that the aperture is filled
            const filledIndicator = document.createElement('div');
            filledIndicator.className = 'aperture filled';
            filledIndicator.style.position = 'absolute';
            filledIndicator.style.width = '30px';
            filledIndicator.style.height = '30px';
            filledIndicator.style.top = targetAperture.style.top;
            filledIndicator.style.left = targetAperture.style.left;
            filledIndicator.style.borderRadius = '50%';
            filledIndicator.style.background = 'linear-gradient(135deg, rgba(93, 92, 222, 0.8), rgba(147, 146, 255, 0.6))';
            filledIndicator.style.boxShadow = '0 0 15px rgba(93, 92, 222, 0.8)';
            filledIndicator.style.animation = 'seal-glow-pulse 3s ease-in-out infinite';
            filledIndicator.style.zIndex = '1';
            filledIndicator.style.display = 'flex';
            filledIndicator.style.justifyContent = 'center';
            filledIndicator.style.alignItems = 'center';
            filledIndicator.style.color = 'white';
            filledIndicator.innerHTML = '✓'; // Checkmark symbol
            
            // Add filled indicator to aperture tracker
            aperturesTracker.appendChild(filledIndicator);
          }, 2000);
          
          // Remove sound wave after animation
          setTimeout(() => {
            soundWaveContainer.remove();
          }, 2000);
          
        }, 2000);
      }, 1000);
    }
    
    // 創建轉動的太極emoji覆蓋混沌指示器
    function createTaijiOverlay() {
      const aperturesTracker = document.getElementById('apertures-tracker');
      if (!aperturesTracker) return;
      
      // 檢查是否已經創建了太極覆蓋層
      let taijiOverlay = document.getElementById('taiji-overlay');
      if (taijiOverlay) return; // 已經存在，不重複創建
      
      // 創建太極覆蓋層
      taijiOverlay = document.createElement('div');
      taijiOverlay.id = 'taiji-overlay';
      taijiOverlay.className = 'absolute inset-0 flex items-center justify-center';
      taijiOverlay.style.cssText = `
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 10;
        pointer-events: none;
      `;
      
      // 創建太極emoji
      const taijiEmoji = document.createElement('div');
      taijiEmoji.className = 'taiji-emoji';
      taijiEmoji.textContent = '☯';
      taijiEmoji.style.cssText = `
        font-size: 80px;
        color: rgba(255, 255, 255, 0.9);
        animation: taiji-rotate-overlay 20s infinite linear;
        filter: drop-shadow(0 0 20px rgba(255, 255, 255, 0.4));
        transform-origin: center;
        line-height: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        width: 100%;
        height: 100%;
      `;
      
      taijiOverlay.appendChild(taijiEmoji);
      aperturesTracker.appendChild(taijiOverlay);
      
      // 添加太極轉動動畫（與第七章虛空背景速度一致）
      if (!document.getElementById('taiji-overlay-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'taiji-overlay-animation';
        styleElement.textContent = `
          @keyframes taiji-rotate-overlay {
            0% {
              transform: rotate(0deg);
            }
            100% {
              transform: rotate(-360deg);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      console.log('✨ 太極覆蓋層已創建，開始逆時針轉動');
    }
    
    // Create particles around the activated aperture
    function createActivationParticles(target) {
      const rect = target.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;
      
      for (let i = 0; i < 10; i++) {
        const particle = document.createElement('div');
        particle.className = 'absolute rounded-full bg-indigo-400 dark:bg-indigo-300 pointer-events-none';
        
        // Random particle size
        const size = 3 + Math.random() * 4;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // Initial position at target center
        particle.style.left = `${centerX}px`;
        particle.style.top = `${centerY}px`;
        
        // Random direction
        const angle = Math.random() * Math.PI * 2;
        const speed = 10 + Math.random() * 20;
        const dx = Math.cos(angle) * speed;
        const dy = Math.sin(angle) * speed;
        
        // Animation properties
        particle.style.animation = `activation-particle 1s ease-out forwards`;
        particle.style.setProperty('--dx', `${dx}px`);
        particle.style.setProperty('--dy', `${dy}px`);
        
        document.body.appendChild(particle);
        
        // Clean up the particle after animation
        setTimeout(() => {
          particle.remove();
        }, 1000);
      }
      
      // Add keyframes for activation particles
      if (!document.getElementById('particle-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'particle-animation';
        styleElement.textContent = `
          @keyframes activation-particle {
            0% { transform: translate(0, 0) scale(1); opacity: 1; }
            100% { transform: translate(var(--dx), var(--dy)) scale(0); opacity: 0; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create dream effects for the prologue
    function createDreamEffects() {
      // Check if dream effects already exist
      if (document.querySelector('.dream-particles')) {
        return;
      }
      
      // Create dream particles container
      const dreamContainer = document.createElement('div');
      dreamContainer.className = 'dream-particles absolute inset-0 overflow-hidden pointer-events-none';
      dreamContainer.style.zIndex = '1';
      
      // Create floating dream particles
      for (let i = 0; i < 20; i++) {
        const particle = document.createElement('div');
        particle.className = 'dream-particle absolute';
        
        const size = 3 + Math.random() * 8;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.borderRadius = '50%';
        particle.style.background = `rgba(${100 + Math.random() * 155}, ${150 + Math.random() * 105}, ${200 + Math.random() * 55}, ${0.3 + Math.random() * 0.7})`;
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // Add glow effect
        particle.style.boxShadow = `0 0 ${size * 2}px rgba(255, 255, 255, 0.5)`;
        
        // Set animation
        particle.style.animation = `dream-float ${8 + Math.random() * 12}s infinite ease-in-out`;
        particle.style.animationDelay = `${Math.random() * 10}s`;
        
        dreamContainer.appendChild(particle);
      }
      
      // Create butterfly silhouettes
      for (let i = 0; i < 3; i++) {
        const butterfly = document.createElement('div');
        butterfly.className = 'dream-butterfly absolute';
        butterfly.innerHTML = '🦋';
        butterfly.style.fontSize = `${20 + Math.random() * 15}px`;
        butterfly.style.left = `${Math.random() * 80 + 10}%`;
        butterfly.style.top = `${Math.random() * 80 + 10}%`;
        butterfly.style.opacity = '0.6';
        butterfly.style.animation = `butterfly-flutter ${15 + Math.random() * 10}s infinite ease-in-out`;
        butterfly.style.animationDelay = `${Math.random() * 8}s`;
        
        dreamContainer.appendChild(butterfly);
      }
      
      // Add to game container
      gameContainer.appendChild(dreamContainer);
      
      // Add CSS animations if not already present
      if (!document.getElementById('dream-effects-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'dream-effects-style';
        styleElement.textContent = `
          @keyframes dream-float {
            0%, 100% { 
              transform: translate(0, 0) scale(1);
              opacity: 0.3;
            }
            25% { 
              transform: translate(10px, -15px) scale(1.2);
              opacity: 0.8;
            }
            50% { 
              transform: translate(-8px, -25px) scale(0.9);
              opacity: 0.5;
            }
            75% { 
              transform: translate(15px, -10px) scale(1.1);
              opacity: 0.9;
            }
          }
          
          @keyframes butterfly-flutter {
            0%, 100% { 
              transform: translate(0, 0) rotate(0deg);
              opacity: 0.4;
            }
            25% { 
              transform: translate(30px, -20px) rotate(5deg);
              opacity: 0.8;
            }
            50% { 
              transform: translate(-20px, -40px) rotate(-3deg);
              opacity: 0.6;
            }
            75% { 
              transform: translate(40px, -15px) rotate(8deg);
              opacity: 0.9;
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create water effects for chapter 1
    function createWaterEffects() {
      // Check if water effects already exist
      if (document.querySelector('.water-ripples')) {
        return;
      }
      
      // Create water effects container
      const waterContainer = document.createElement('div');
      waterContainer.className = 'water-ripples absolute inset-0 overflow-hidden pointer-events-none';
      waterContainer.style.zIndex = '1';
      
      // Create ripple effects
      for (let i = 0; i < 8; i++) {
        const ripple = document.createElement('div');
        ripple.className = 'water-ripple absolute';
        
        const size = 100 + Math.random() * 200;
        ripple.style.width = `${size}px`;
        ripple.style.height = `${size}px`;
        ripple.style.borderRadius = '50%';
        ripple.style.border = '2px solid rgba(255, 255, 255, 0.3)';
        ripple.style.left = `${Math.random() * 80 + 10}%`;
        ripple.style.top = `${Math.random() * 80 + 10}%`;
        
        // Set animation
        ripple.style.animation = `water-ripple ${6 + Math.random() * 8}s infinite ease-out`;
        ripple.style.animationDelay = `${Math.random() * 12}s`;
        
        waterContainer.appendChild(ripple);
      }
      
      // Create floating bubbles
      for (let i = 0; i < 15; i++) {
        const bubble = document.createElement('div');
        bubble.className = 'water-bubble absolute';
        
        const size = 5 + Math.random() * 15;
        bubble.style.width = `${size}px`;
        bubble.style.height = `${size}px`;
        bubble.style.borderRadius = '50%';
        bubble.style.background = 'rgba(255, 255, 255, 0.4)';
        bubble.style.left = `${Math.random() * 100}%`;
        bubble.style.top = `${Math.random() * 100}%`;
        
        // Add subtle glow
        bubble.style.boxShadow = `0 0 ${size}px rgba(255, 255, 255, 0.3)`;
        
        // Set animation
        bubble.style.animation = `bubble-float ${10 + Math.random() * 15}s infinite ease-in-out`;
        bubble.style.animationDelay = `${Math.random() * 10}s`;
        
        waterContainer.appendChild(bubble);
      }
      
      // Create fish silhouettes
      for (let i = 0; i < 4; i++) {
        const fish = document.createElement('div');
        fish.className = 'water-fish absolute';
        fish.innerHTML = '🐟';
        fish.style.fontSize = `${15 + Math.random() * 10}px`;
        fish.style.left = `${Math.random() * 70 + 15}%`;
        fish.style.top = `${Math.random() * 70 + 15}%`;
        fish.style.opacity = '0.5';
        fish.style.animation = `fish-swim ${12 + Math.random() * 8}s infinite ease-in-out`;
        fish.style.animationDelay = `${Math.random() * 6}s`;
        
        waterContainer.appendChild(fish);
      }
      
      // Add to game container
      gameContainer.appendChild(waterContainer);
      
      // Add CSS animations if not already present
      if (!document.getElementById('water-effects-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'water-effects-style';
        styleElement.textContent = `
          @keyframes water-ripple {
            0% { 
              transform: scale(0);
              opacity: 0.8;
            }
            50% { 
              transform: scale(1);
              opacity: 0.4;
            }
            100% { 
              transform: scale(1.5);
              opacity: 0;
            }
          }
          
          @keyframes bubble-float {
            0%, 100% { 
              transform: translateY(0) scale(1);
              opacity: 0.3;
            }
            25% { 
              transform: translateY(-20px) scale(1.2);
              opacity: 0.7;
            }
            50% { 
              transform: translateY(-40px) scale(0.9);
              opacity: 0.5;
            }
            75% { 
              transform: translateY(-15px) scale(1.1);
              opacity: 0.8;
            }
          }
          
          @keyframes fish-swim {
            0%, 100% { 
              transform: translateX(0) scaleX(1);
              opacity: 0.4;
            }
            25% { 
              transform: translateX(50px) scaleX(1);
              opacity: 0.7;
            }
            50% { 
              transform: translateX(100px) scaleX(-1);
              opacity: 0.6;
            }
            75% { 
              transform: translateX(25px) scaleX(-1);
              opacity: 0.8;
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create clouds for the cloud scene
    function createClouds() {
      // Check if clouds already exist
      if (document.querySelector('.background-cloud')) {
        return;
      }
      
      // Create cloud container
      const cloudContainer = document.createElement('div');
      cloudContainer.className = 'absolute inset-0 overflow-hidden pointer-events-none';
      cloudContainer.style.zIndex = '0';
      
      // Create multiple background clouds
      for (let i = 0; i < 15; i++) {
        const cloud = document.createElement('div');
        const size = 100 + Math.random() * 200;
        const opacity = 0.5 + Math.random() * 0.4;
        
        cloud.className = 'background-cloud absolute';
        cloud.style.width = `${size}px`;
        cloud.style.height = `${size * 0.6}px`;
        cloud.style.borderRadius = '50%';
        cloud.style.backgroundColor = 'rgba(255, 255, 255, 0.8)';
        cloud.style.filter = 'blur(25px)';
        cloud.style.opacity = opacity.toString();
        cloud.style.left = `${Math.random() * 120 - 10}%`;
        cloud.style.top = `${Math.random() * 120 - 10}%`;
        
        // Set random cloud animation parameters
        cloud.style.setProperty('--cloud-dx', `${(Math.random() * 60 - 30)}px`);
        cloud.style.setProperty('--cloud-dy', `${(Math.random() * 20 - 10)}px`);
        cloud.style.animation = `float-cloud ${10 + Math.random() * 15}s infinite ease-in-out alternate`;
        cloud.style.animationDelay = `${Math.random() * 10}s`;
        
        cloudContainer.appendChild(cloud);
      }
      
      // Add to game container
      gameContainer.appendChild(cloudContainer);
    }
    
    function createPerspectiveChallengeScene(scene) {
      const challengeElement = document.createElement('div');
      
      // 检查是否有蜗牛存在，如果有则调整文字位置到上方
      const hasSnail = document.querySelector('.snail-shell');
      if (hasSnail) {
        challengeElement.className = 'fixed top-8 left-1/2 transform -translate-x-1/2 max-w-2xl p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-30 border border-indigo-200 dark:border-indigo-700';
      } else {
        challengeElement.className = 'max-w-2xl mx-auto p-6 text-center bg-indigo-100 dark:bg-indigo-900 bg-opacity-90 dark:bg-opacity-90 rounded-lg';
      }
      
      challengeElement.innerHTML = `
        <p class="text-lg">${scene.text}</p>
      `;
      
      gameContent.appendChild(challengeElement);
      
      // 不再創建舊的蝸牛和王國，避免與新的Canvas圓形世界衝突
      // if (!document.querySelector('.snail-shell')) {
      //   createSnailAndKingdoms();
      // }
      
      // 不再啟用舊的視角縮放功能，避免與新的視角控制器衝突
      // if (!gameState.scaleEnabled) {
      //   enableScaleControl();
      // }
      
      // 添加两国交互计数
      let visitedTouch = false;
      let visitedSavage = false;
      
      // 显示切换视角提示
      function showScaleHint() {
        const hint = document.createElement('div');
        hint.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-70 text-white p-4 rounded text-left z-50';
        hint.innerHTML = `
          <p>需要切換到微觀視角才能與國家互動</p>
          <p class="text-sm mt-2 text-indigo-300">使用右側的視角控制器向下滑動</p>
        `;
        document.body.appendChild(hint);
        
        setTimeout(() => {
          hint.remove();
        }, 3000);
      }
      
      // 显示国家对话框
      function showKingdomDialog(kingdom) {
        // 移除已有对话框
        document.querySelectorAll('.kingdom-dialog').forEach(el => el.remove());
        
        const dialog = document.createElement('div');
        dialog.className = 'kingdom-dialog fixed z-50 bg-gray-900 bg-opacity-95 p-4 rounded-md text-white max-w-sm';
        dialog.style.top = '50%';
        dialog.style.left = '50%';
        dialog.style.transform = 'translate(-50%, -50%)';
        
        // 根据国家显示不同内容
        if (kingdom === 'touch') {
          dialog.innerHTML = `
            <h3 class="text-lg font-bold text-indigo-300 mb-2">觸氏國國王</h3>
            <p class="mb-4">歡迎來到觸氏國，偉大的蝸牛左角之國！我們是智慧與藝術的民族。</p>
            <p class="mb-4">那些蠻氏國的野蠻人竟敢侵犯我們的邊境，搶奪我們的土地。祖先留下的領土，我們絕不能讓步！</p>
            <p class="mb-4">我們已經打了十五年，這五年是我們的反攻期，我們必將收復失地！</p>
            <button class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded block ml-auto">關閉</button>
          `;
        } else {
          dialog.innerHTML = `
            <h3 class="text-lg font-bold text-blue-300 mb-2">蠻氏國國王</h3>
            <p class="mb-4">哼！陌生人，這裡是強大的蠻氏國，蝸牛右角的唯一合法政權！</p>
            <p class="mb-4">那些觸氏國的詭計多端的懦夫，明明是他們先侵佔了邊境地帶！那片土地自古以來就是我們的！</p>
            <p class="mb-4">我們已經反擊十五年了，這五年我們要一舉殲滅他們！為了蠻氏國的榮耀！</p>
            <button class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded block ml-auto">關閉</button>
          `;
        }
        
        document.body.appendChild(dialog);
        
        // 关闭按钮事件
        dialog.querySelector('button').addEventListener('click', () => {
          dialog.remove();
        });
      }
      
      // 检查是否访问了两个国家
      function checkVisitedBoth() {
        if (visitedTouch && visitedSavage) {
          // 更新提示内容
          const tipElement = challengeElement.querySelector('.text-sm');
          if (tipElement) {
            tipElement.textContent = '你已經探索了兩個國家！現在可以繼續遊戲了';
            tipElement.classList.remove('animate-pulse');
            tipElement.classList.add('font-bold');
          }
          
          // 显示继续按钮
          advanceBtn.style.display = 'block';
        }
      }
      
      // 等待蝸牛和王國創建完成後再添加事件監聽器
      setTimeout(() => {
        // 在一秒後檢查並添加與國家交互的提示
        if (gameState.viewScale >= 30) {
          const tipElement = document.createElement('div');
          tipElement.className = 'mt-4 text-sm text-indigo-600 dark:text-indigo-300 animate-pulse';
          tipElement.textContent = '使用視角控制器切換到微觀視角探索蝸牛上的王國';
          challengeElement.appendChild(tipElement);
          
          // 為視角控制器添加發光效果
          highlightScaleController();
        } else {
          const tipElement = document.createElement('div');
          tipElement.className = 'mt-4 text-sm text-indigo-600 dark:text-indigo-300 animate-pulse';
          tipElement.textContent = '點擊觸角上的國家圓形或居民人物進行互動';
          challengeElement.appendChild(tipElement);
        }
        
        // 添加点击监听器到国家圆形
        const touchKingdomCircle = document.getElementById('touch-kingdom-circle');
        const savageKingdomCircle = document.getElementById('savage-kingdom-circle');
        
        if (touchKingdomCircle) {
          touchKingdomCircle.style.cursor = 'pointer';
          
          // 移除之前的事件監聽器（如果有）
          touchKingdomCircle.replaceWith(touchKingdomCircle.cloneNode(true));
          const newTouchKingdom = document.getElementById('touch-kingdom-circle');
          
          newTouchKingdom.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameState.viewScale < 30) {
              visitedTouch = true;
              showKingdomDialog('touch');
              checkVisitedBoth();
            } else {
              showScaleHint();
            }
          });
        }
        
        if (savageKingdomCircle) {
          savageKingdomCircle.style.cursor = 'pointer';
          
          // 移除之前的事件監聽器（如果有）
          savageKingdomCircle.replaceWith(savageKingdomCircle.cloneNode(true));
          const newSavageKingdom = document.getElementById('savage-kingdom-circle');
          
          newSavageKingdom.addEventListener('click', (e) => {
            e.stopPropagation();
            if (gameState.viewScale < 30) {
              visitedSavage = true;
              showKingdomDialog('savage');
              checkVisitedBoth();
            } else {
              showScaleHint();
            }
          });
        }
      }, 1500);
      
      // 初始不显示继续按钮，需要完成目标才显示
      advanceBtn.style.display = 'none';
    }
    
    // 创建蜗牛角上的居民
    function createCitizens() {
      // 获取两个王国元素作为容器
      const touchKingdom = document.querySelector('.kingdom.left');
      const savageKingdom = document.querySelector('.kingdom.right');
      
      if (!touchKingdom || !savageKingdom) {
        console.log("找不到王國元素，無法創建居民");
        return;
      }
      
      // 创建触氏国居民
      createKingdomCitizens(touchKingdom, 'touch', 3);
      
      // 创建蛮氏国居民
      createKingdomCitizens(savageKingdom, 'savage', 3);
    }
    
    // 为特定王国创建居民
    function createKingdomCitizens(kingdomElement, kingdomId, count) {
      const kingdomRect = kingdomElement.getBoundingClientRect();
      
      // 清除现有居民
      kingdomElement.querySelectorAll('.citizen').forEach(citizen => citizen.remove());
      
      // 创建新居民
      for (let i = 0; i < count; i++) {
        const citizen = document.createElement('div');
        citizen.className = `citizen ${kingdomId}`;
        citizen.setAttribute('data-citizen-id', `${kingdomId}-${i}`);
        
        // 设置居民在王国内的随机位置
        const offsetX = 5 + Math.random() * (kingdomElement.offsetWidth - 10);
        citizen.style.left = `${offsetX}px`;
        
        // 添加到王国元素
        kingdomElement.appendChild(citizen);
        
        // 添加点击事件监听器
        citizen.addEventListener('click', (event) => {
          event.stopPropagation(); // 防止触发王国点击事件
          const citizenId = citizen.getAttribute('data-citizen-id');
          
          // 检查是否在微观视角
          if (gameState.viewScale < 30) {
            // 打开居民对话
            showCitizenDialog(citizenId, citizen, 0);
          } else {
            // 提示需要切换到微观视角
            showScaleHint();
          }
        });
      }
    }
    
    // 显示切换视角提示
    function showScaleHint() {
      const hint = document.createElement('div');
                hint.className = 'fixed top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-black bg-opacity-70 text-white p-4 rounded text-left z-50';
      hint.innerHTML = `
        <p>需要切換到微觀視角才能與居民互動</p>
        <p class="text-sm mt-2 text-indigo-300">使用右側的視角控制器向下滑動</p>
      `;
      document.body.appendChild(hint);
      
      setTimeout(() => {
        hint.remove();
      }, 3000);
    }
    
    function createForestBackground() {
      // 检查森林元素是否已存在
      if (document.querySelector('.forest-background')) {
        return;
      }

      // 创建森林容器
      const forestContainer = document.createElement('div');
      forestContainer.className = 'forest-background absolute inset-0 overflow-hidden pointer-events-none';
      forestContainer.style.zIndex = '-1'; // 設置為負值，確保在所有內容之下
      
      // 创建Three.js 2D森林场景
      createThreeJSForestScene(forestContainer);

      // 创建八棵抽象树形 - 重新分佈避免遮擋中心文字區域
      // 左側4棵樹(5-35%)，右側4棵樹(65-95%)，中間(35-65%)留給文字
      const treePositions = [5, 15, 25, 35, 65, 75, 85, 95]; // 中間留出30%空間給文字
      
      for (let i = 0; i < 8; i++) {
        const tree = document.createElement('div');
        tree.className = 'tree';
        
        // 使用預定義的位置陣列
        const position = treePositions[i];
        
        tree.style.left = `${position}%`;
        tree.style.zIndex = '0';
        
        // 简化的树干 - 整體放大1.5-2倍，增加錯落感
        const trunk = document.createElement('div');
        trunk.className = 'tree-trunk';
        // 樹木大小縮放因子：1.5-2倍隨機變化
        const sizeMultiplier = 1.5 + (Math.random() * 0.5) + (i % 3) * 0.15; // 1.5-2.15倍
        const baseHeight = (160 + (i * 20) + Math.sin(i * 0.7) * 35) * sizeMultiplier;
        trunk.style.height = `${baseHeight}px`;
        const baseWidth = (7 + (i % 3) + Math.cos(i * 1.1) * 1.5) * sizeMultiplier;
        trunk.style.width = `${baseWidth}px`;
        trunk.style.left = '50%';
        trunk.style.marginLeft = `-${baseWidth/2}px`; // 動態居中
        trunk.style.background = 'rgba(75, 54, 33, 0.7)'; // 半透明效果
        trunk.style.zIndex = '-1'; // 修復：樹幹應該在樹冠後面
        tree.appendChild(trunk);
        
        // 简化的树冠 - 使用相同的縮放比例
        for (let j = 0; j < 3; j++) {
          const crown = document.createElement('div');
          crown.className = 'tree-crown';
          // 樹冠也使用相同的縮放因子
          const baseCrownSize = (70 + j * 18 + (i % 4) * 8) * sizeMultiplier;
          crown.style.width = `${baseCrownSize}px`;
          crown.style.height = `${baseCrownSize}px`;
          crown.style.left = '50%';
          crown.style.marginLeft = `-${baseCrownSize/2}px`;
          
          // 修復樹冠位置：確保最頂層樹冠高於樹幹頂部，也按比例縮放
          const crownBottomPosition = Math.max(
            (50 + j * 35 + (i % 3) * 10) * sizeMultiplier, // 原始位置縮放
            baseHeight * 0.6 + j * 25 * sizeMultiplier    // 確保在樹幹高度的60%以上
          );
          crown.style.bottom = `${crownBottomPosition}px`;
          
          // 為新樹木提供稍微不同的顏色變化
          const greenVariation = 60 + j * 15 + (i % 5) * 8;
          const lightGreenVariation = 130 + j * 10 + (i % 4) * 12;
          const darkGreenVariation = 40 + j * 10 + (i % 3) * 6;
          crown.style.background = `rgba(${greenVariation}, ${lightGreenVariation}, ${darkGreenVariation}, 0.${6 + j})`;
          crown.style.zIndex = `${1 + j}`; // 修復：樹冠應該在樹幹前面，層次遞增
          
          // 添加微小的动态效果 - 為新樹木提供不同的動畫時間
          const swayDuration = 5 + j + (i % 4) * 0.8;
          crown.style.animation = `leaf-sway-animation ${swayDuration}s infinite ease-in-out`;
          crown.style.animationDelay = `${(j * 0.5) + (i * 0.3)}s`; // 錯開動畫時間
          tree.appendChild(crown);
        }
        
        forestContainer.appendChild(tree);
      }
      
      // 创建少量象征性的落叶 - 不需要太多详细的逻辑
      const leafContainer = document.createElement('div');
      leafContainer.className = 'leaf-container';
      
      // 仅添加几片象征性的落叶，定期更新
      const leafInterval = setInterval(() => {
        // 检查是否还在森林场景中
        if (!document.querySelector('.forest-background')) {
          clearInterval(leafInterval);
          return;
        }
        
        if (document.querySelectorAll('.falling-leaf').length < 5) { // 限制数量
          const leaf = document.createElement('div');
          leaf.className = 'falling-leaf';
          
          // 简化的叶子形状
          const size = 10;
          leaf.style.width = `${size}px`;
          leaf.style.height = `${size}px`;
          leaf.style.left = `${20 + Math.random() * 60}%`; // 控制在可见区域
          leaf.style.backgroundColor = 'rgba(44, 119, 68, 0.6)';
          leaf.style.borderRadius = '50% 20% 50% 20%'; // 简单的象征性形状
          
          // 简化的动画
          leaf.style.animationDuration = '12s';
          
          leafContainer.appendChild(leaf);
          
          // 动画结束后移除
          setTimeout(() => {
            if (leaf && leaf.parentNode) {
              leaf.remove();
            }
          }, 12000);
        }
      }, 3000);
      
      // 将定时器ID存储到容器上，便于清理
      forestContainer.leafInterval = leafInterval;
      
      // 初始添加3片落叶
      for (let i = 0; i < 3; i++) {
        setTimeout(() => {
          const leaf = document.createElement('div');
          leaf.className = 'falling-leaf';
          
          const size = 10;
          leaf.style.width = `${size}px`;
          leaf.style.height = `${size}px`;
          leaf.style.left = `${20 + Math.random() * 60}%`;
          leaf.style.backgroundColor = 'rgba(44, 119, 68, 0.6)';
          leaf.style.borderRadius = '50% 20% 50% 20%';
          
          leaf.style.animationDuration = '12s';
          leaf.style.animationDelay = `${i}s`;
          
          leafContainer.appendChild(leaf);
          
          setTimeout(() => leaf.remove(), 12000);
        }, i * 1000);
      }
      
      forestContainer.appendChild(leafContainer);
      
      // 创建4個陽光光暈效果 - 沿對角線分佈減少卡頓
      const diagonalPositions = [
        { left: 15, top: 10 },  // 左上
        { left: 35, top: 25 },  // 中左上
        { left: 55, top: 40 },  // 中右下
        { left: 75, top: 55 }   // 右下
      ];
      
      for (let i = 0; i < 4; i++) {
        const light = document.createElement('div');
        light.className = 'forest-sunlight';
        
        // 漸進的光暈大小
        const size = 140 + i * 40;
        light.style.width = `${size}px`;
        light.style.height = `${size}px`;
        
        // 對角線位置分佈
        light.style.left = `${diagonalPositions[i].left}%`;
        light.style.top = `${diagonalPositions[i].top}%`;
        
        // 錯開的動畫時序
        light.style.animationDelay = `${i * 3}s`;
        light.style.animationDuration = `${15 + i * 2}s`;
        
        forestContainer.appendChild(light);
      }
      

      

      
      // 创建树叶摇摆效果（增强现有树冠动画）
      const windContainer = document.createElement('div');
      windContainer.className = 'wind-effects absolute inset-0 pointer-events-none';
      
      // 创建风的粒子效果
      for (let i = 0; i < 8; i++) {
        const windParticle = document.createElement('div');
        windParticle.className = 'wind-particle absolute';
        
        const size = 2 + Math.random() * 4;
        windParticle.style.width = `${size}px`;
        windParticle.style.height = `${size}px`;
        windParticle.style.borderRadius = '50%';
        windParticle.style.background = 'rgba(255, 255, 255, 0.4)';
        windParticle.style.left = `${Math.random() * 100}%`;
        windParticle.style.top = `${Math.random() * 100}%`;
        windParticle.style.animation = `wind-drift ${8 + Math.random() * 12}s infinite ease-in-out`;
        windParticle.style.animationDelay = `${Math.random() * 8}s`;
        
        windContainer.appendChild(windParticle);
      }
      
      forestContainer.appendChild(windContainer);
      
      // 添加到游戏容器
      gameContainer.appendChild(forestContainer);
      
      // 设置简化的CSS样式
      if (!document.getElementById('forest-effects-style')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'forest-effects-style';
        styleElement.textContent = `
          .forest-scene {
            background: linear-gradient(135deg, #2c7744, #8fc866);
          }
          
          .tree-trunk {
            position: absolute;
            bottom: 0;
            border-radius: 2px;
            z-index: -1; /* 樹幹在樹冠後面 */
          }
          
          .tree-crown {
            position: absolute;
            border-radius: 50%;
            opacity: 0.8;
            z-index: 1; /* 樹冠在樹幹前面，基礎層級為1 */
          }
          
          .falling-leaf {
            position: absolute;
            z-index: 1;
            opacity: 0;
            animation: leaf-falling linear forwards;
            transform-origin: center center;
          }
          
          @keyframes leaf-falling {
            0% { transform: translateY(-20px) rotate(0deg); opacity: 0; }
            10% { opacity: 0.7; }
            100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
          }
          
          @keyframes leaf-sway-animation {
            0%, 100% { transform: rotate(-2deg) translateX(0); }
            50% { transform: rotate(2deg) translateX(5px); }
          }
          
          /* 增強的陽光光暈效果 */
          .forest-sunlight {
            position: absolute;
            background: radial-gradient(circle, 
              rgba(255, 223, 0, 0.6) 0%,     /* 金黃色中心 */
              rgba(255, 140, 0, 0.4) 25%,    /* 橙黃色 */
              rgba(255, 215, 0, 0.3) 50%,    /* 金色 */
              rgba(255, 255, 255, 0.2) 70%,  /* 白色邊緣 */
              transparent 100%
            );
            border-radius: 50%;
            filter: blur(15px);
            pointer-events: none;
            opacity: 0;
            animation: enhanced-sunlight-fade 12s infinite ease-in-out;
            z-index: 4; /* 確保顯示在樹冠之上 */
            box-shadow: 
              0 0 30px rgba(255, 223, 0, 0.4),
              0 0 60px rgba(255, 140, 0, 0.2),
              inset 0 0 20px rgba(255, 255, 255, 0.1);
          }
          

          
          @keyframes enhanced-sunlight-fade {
            0%, 100% { 
              opacity: 0; 
              transform: scale(0.8) rotate(0deg); 
              filter: blur(15px) brightness(1);
            }
            25% { 
              opacity: 0.4; 
              transform: scale(1.1) rotate(5deg); 
              filter: blur(12px) brightness(1.2);
            }
            50% { 
              opacity: 0.7; 
              transform: scale(1.2) rotate(10deg); 
              filter: blur(10px) brightness(1.4);
            }
            75% { 
              opacity: 0.5; 
              transform: scale(1.0) rotate(15deg); 
              filter: blur(13px) brightness(1.1);
            }
          }
          

          

          
          @keyframes wind-drift {
            0%, 100% { 
              transform: translate(0, 0) scale(1);
              opacity: 0.2;
            }
            25% { 
              transform: translate(50px, -20px) scale(1.2);
              opacity: 0.5;
            }
            50% { 
              transform: translate(100px, -10px) scale(0.8);
              opacity: 0.3;
            }
            75% { 
              transform: translate(150px, -30px) scale(1.1);
              opacity: 0.6;
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // Create Three.js 2D Forest Scene
    function createThreeJSForestScene(container) {
      // 创建Three.js场景
      const scene = new THREE.Scene();
      const camera = new THREE.OrthographicCamera(
        -window.innerWidth / 2, window.innerWidth / 2,
        window.innerHeight / 2, -window.innerHeight / 2,
        1, 1000
      );
      
      const renderer = new THREE.WebGLRenderer({ 
        alpha: true, 
        antialias: true 
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0); // 透明背景
      
      // 创建canvas容器
      const threeContainer = document.createElement('div');
      threeContainer.className = 'three-forest-scene absolute inset-0';
      threeContainer.style.zIndex = '0';
      threeContainer.appendChild(renderer.domElement);
      container.appendChild(threeContainer);
      
      camera.position.z = 100;
      
      // 存储所有动画对象
      const animatedObjects = [];
      
      // 创建自定义叶子形状
      function createCustomLeafGeometry() {
        const leafShape = new THREE.Shape();
        
        // 创建叶子轮廓 - 使用贝塞尔曲线
        leafShape.moveTo(0, 0); // 叶子底部中心
        
        // 左侧叶片
        leafShape.bezierCurveTo(-3, 2, -5, 8, -2, 12); // 左下到左上
        leafShape.bezierCurveTo(-1, 14, 1, 14, 2, 12);  // 左上到右上
        
        // 右侧叶片
        leafShape.bezierCurveTo(5, 8, 3, 2, 0, 0);      // 右上到底部
        
        return new THREE.ShapeGeometry(leafShape);
      }
      
      // 创建2D叶子粒子系统
      function createCustomLeafParticles() {
        const leafGeometry = createCustomLeafGeometry();
        const leafCount = 25; // 减少数量以保持性能
        
        for (let i = 0; i < leafCount; i++) {
          // 创建叶子材质（使用不同的绿色和黄色调）
          const hue = 0.15 + Math.random() * 0.15; // 黄绿色调
          const saturation = 0.6 + Math.random() * 0.3;
          const lightness = 0.3 + Math.random() * 0.4;
          
          const leafMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(hue, saturation, lightness),
            transparent: true,
            opacity: 0.7 + Math.random() * 0.3,
            side: THREE.DoubleSide // 确保叶子两面都可见
          });
          
          const leaf = new THREE.Mesh(leafGeometry, leafMaterial);
          
          // 随机位置
          leaf.position.x = (Math.random() - 0.5) * window.innerWidth;
          leaf.position.y = window.innerHeight / 2 + Math.random() * 200;
          leaf.position.z = Math.random() * 30;
          
          // 随机初始旋转
          leaf.rotation.x = Math.random() * Math.PI * 2;
          leaf.rotation.y = Math.random() * Math.PI * 2;
          leaf.rotation.z = Math.random() * Math.PI * 2;
          
          // 随机缩放
          const scale = 0.8 + Math.random() * 0.6;
          leaf.scale.setScalar(scale);
          
          // 存储动画属性 - 非常缓慢的速度
          leaf.userData = {
            fallSpeed: 0.1 + Math.random() * 0.2,        // 非常慢的下降速度
            swaySpeed: 0.003 + Math.random() * 0.007,    // 非常慢的摇摆速度
            swayAmount: 15 + Math.random() * 25,         // 摇摆幅度
            rotationSpeedX: 0.002 + Math.random() * 0.008, // X轴旋转速度
            rotationSpeedY: 0.001 + Math.random() * 0.005, // Y轴旋转速度
            rotationSpeedZ: 0.003 + Math.random() * 0.007, // Z轴旋转速度
            initialX: leaf.position.x,
            phase: Math.random() * Math.PI * 2           // 随机相位偏移
          };
          
          scene.add(leaf);
          animatedObjects.push(leaf);
        }
      }
      
      // 创建2D风的粒子效果
      function createWindParticles() {
        const windGeometry = new THREE.PlaneGeometry(3, 3);
        const windCount = 30;
        
        for (let i = 0; i < windCount; i++) {
          const windMaterial = new THREE.MeshBasicMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.3 + Math.random() * 0.4
          });
          
          const windParticle = new THREE.Mesh(windGeometry, windMaterial);
          
          // 随机位置
          windParticle.position.x = (Math.random() - 0.5) * window.innerWidth;
          windParticle.position.y = (Math.random() - 0.5) * window.innerHeight;
          windParticle.position.z = Math.random() * 30;
          
          // 存储动画属性
          windParticle.userData = {
            driftSpeed: 0.1 + Math.random() * 0.3, // 降低水平漂移速度
            verticalSpeed: 0.05 + Math.random() * 0.15, // 降低垂直波動速度
            resetX: -window.innerWidth / 2 - 50
          };
          
          scene.add(windParticle);
          animatedObjects.push(windParticle);
        }
      }
      
      // 初始化效果
      createCustomLeafParticles();
      createWindParticles();
      
      // 动画循环
      let animationId;
      function animate() {
        animationId = requestAnimationFrame(animate);
        
        const time = Date.now() * 0.001;
        
        animatedObjects.forEach(obj => {
          if (obj.userData.fallSpeed !== undefined) {
            // 自定义叶子动画
            obj.position.y -= obj.userData.fallSpeed;
            
            // 左右摇摆（使用相位偏移让每片叶子不同步）
            obj.position.x = obj.userData.initialX + 
              Math.sin(time * obj.userData.swaySpeed + obj.userData.phase) * obj.userData.swayAmount;
            
            // 多轴旋转，模拟叶子在空中翻滚
            obj.rotation.x += obj.userData.rotationSpeedX;
            obj.rotation.y += obj.userData.rotationSpeedY;
            obj.rotation.z += obj.userData.rotationSpeedZ;
            
            // 重置叶子位置
            if (obj.position.y < -window.innerHeight / 2 - 50) {
              obj.position.y = window.innerHeight / 2 + 50;
              obj.position.x = (Math.random() - 0.5) * window.innerWidth;
              obj.userData.initialX = obj.position.x;
              
              // 重新随机化一些属性，增加变化
              obj.userData.phase = Math.random() * Math.PI * 2;
              obj.rotation.x = Math.random() * Math.PI * 2;
              obj.rotation.y = Math.random() * Math.PI * 2;
              obj.rotation.z = Math.random() * Math.PI * 2;
            }
          } else if (obj.userData.driftSpeed !== undefined) {
            // 风粒子动画
            obj.position.x += obj.userData.driftSpeed;
            obj.position.y += Math.sin(time * 2 + obj.position.x * 0.01) * obj.userData.verticalSpeed;
            
            // 重置风粒子位置
            if (obj.position.x > window.innerWidth / 2 + 50) {
              obj.position.x = obj.userData.resetX;
              obj.position.y = (Math.random() - 0.5) * window.innerHeight;
            }
          }
        });
        
        renderer.render(scene, camera);
      }
      
      animate();
      
      // 窗口大小调整处理
      function handleResize() {
        camera.left = -window.innerWidth / 2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = -window.innerHeight / 2;
        camera.updateProjectionMatrix();
        
        renderer.setSize(window.innerWidth, window.innerHeight);
      }
      
      window.addEventListener('resize', handleResize);
      
      // 存储清理函数
      container.threeCleanup = function() {
        cancelAnimationFrame(animationId);
        window.removeEventListener('resize', handleResize);
        
        // 清理Three.js对象
        animatedObjects.forEach(obj => {
          scene.remove(obj);
          if (obj.geometry) obj.geometry.dispose();
          if (obj.material) obj.material.dispose();
        });
        
        renderer.dispose();
        threeContainer.remove();
      };
    }
    
    // Initialize the Hunlun aperture positions
    function initializeHunlunApertures() {
      // Set up face pattern
      const facePattern = document.getElementById('face-pattern');
      facePattern.innerHTML = `
        <svg width="100%" height="100%" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
          <circle cx="50" cy="50" r="45" fill="none" stroke="rgba(255,255,255,0.3)" stroke-width="0.5" stroke-dasharray="2,3" />
          <ellipse cx="50" cy="46" rx="30" ry="36" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.5" stroke-dasharray="1,2" />
          <path d="M35,40 Q50,60 65,40" fill="none" stroke="rgba(255,255,255,0.2)" stroke-width="0.5" stroke-dasharray="1,2" />
        </svg>
      `;
      
      // Initialize aperture positions
      randomizeAperturePositions();
      
      // Set up aperture animation intervals
      setInterval(() => {
        const random = Math.random();
        if (random < 0.3) {
          // 30% chance to show face pattern
          showFacePattern();
        } else {
          // 70% chance to randomize positions
          randomizeAperturePositions();
        }
      }, 8000);
    }
    
    // Physics-based aperture positioning to avoid overlap
    function randomizeAperturePositions() {
      const apertures = document.querySelectorAll('.aperture-random');
      const facePattern = document.getElementById('face-pattern');
      const apertureDiameter = 30; // Aperture size in pixels
      const containerSize = 150; // Container size in pixels
      
      // Skip filled apertures
      const visibleApertures = Array.from(apertures).filter(aperture => 
        !gameState.collectedApertures.includes(aperture.className.match(/aperture-([\w-]+)/)[1])
      );
      
      // Hide face pattern
      facePattern.classList.remove('visible');
      
      // Remove face position class if present
      apertures.forEach(aperture => {
        aperture.classList.remove('face-position');
      });
      
      // Physics-based positioning
      const minDistance = (apertureDiameter * 1.3) / containerSize * 100; // Minimum distance as percentage
      const positions = [];
      
      // Create initial random positions for simulation
      visibleApertures.forEach(() => {
        const randomAngle = Math.random() * Math.PI * 2;
        const randomDistance = 15 + Math.random() * 30; // Range from 15% to 45% from center
        
        const x = 50 + Math.cos(randomAngle) * randomDistance;
        const y = 50 + Math.sin(randomAngle) * randomDistance;
        
        positions.push({ x, y, vx: 0, vy: 0 });
      });
      
      // Run physics simulation to settle positions for visible apertures
      for (let iteration = 0; iteration < 50; iteration++) {
        let stable = true;
        
        // Apply forces between apertures
        for (let i = 0; i < positions.length; i++) {
          for (let j = i + 1; j < positions.length; j++) {
            const dx = positions[j].x - positions[i].x;
            const dy = positions[j].y - positions[i].y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < minDistance) {
              stable = false;
              
              // Calculate repulsion force
              const force = 0.5 * (minDistance - distance) / distance;
              const fx = force * dx;
              const fy = force * dy;
              
              // Apply force to both apertures in opposite directions
              positions[i].vx -= fx;
              positions[i].vy -= fy;
              positions[j].vx += fx;
              positions[j].vy += fy;
            }
          }
          
          // Apply boundary constraint - keep within the circle
          const centerDist = Math.sqrt(
            Math.pow(positions[i].x - 50, 2) + 
            Math.pow(positions[i].y - 50, 2)
          );
          
          const maxRadius = 42; // Max distance from center as percentage
          if (centerDist > maxRadius) {
            stable = false;
            // Push back towards center
            const angle = Math.atan2(positions[i].y - 50, positions[i].x - 50);
            const pushback = 0.1 * (centerDist - maxRadius);
            positions[i].vx -= Math.cos(angle) * pushback;
            positions[i].vy -= Math.sin(angle) * pushback;
          }
          
          // Apply velocity with damping
          positions[i].x += positions[i].vx * 0.6;
          positions[i].y += positions[i].vy * 0.6;
          positions[i].vx *= 0.5; // Damping
          positions[i].vy *= 0.5; // Damping
        }
        
        // If system is stable, exit early
        if (stable && iteration > 10) break;
      }
      
      // Apply final positions with smooth transition - only to visible apertures
      visibleApertures.forEach((aperture, i) => {
        aperture.style.left = `${positions[i].x}%`;
        aperture.style.top = `${positions[i].y}%`;
        // Reset any transforms
        aperture.style.transform = '';
      });
    }
    
    // Show face pattern
    function showFacePattern() {
      const apertures = document.querySelectorAll('.aperture-random');
      const facePattern = document.getElementById('face-pattern');
      
      // Show face pattern
      facePattern.classList.add('visible');
      
      // Add face position class
      apertures.forEach(aperture => {
        aperture.classList.add('face-position');
      });
    }
    
    // 根據章節設置必要的前置條件
    function setupChapterPrerequisites(chapter) {
      // 開發者模式標記，用於強制顯示物化按鈕
      const isDevMode = document.documentElement.classList.contains('dev-mode');
      
      // 先清空所有已收集的封印，然後根據章節重新設置
      gameState.collectedApertures = [];
      
      switch (chapter) {
        case 'prologue':
          // 序章特殊處理：重置所有解鎖的形態狀態，只保留人形
          gameState.unlockedForms = ['human'];
          
          // 隱藏所有物化按鈕（除了人形）
          Object.keys(formButtons).forEach(formType => {
            if (formType !== 'human' && formButtons[formType]) {
              formButtons[formType].classList.add('hidden');
              formButtons[formType].style.visibility = 'hidden';
            } else if (formType === 'human' && formButtons[formType]) {
              // 確保人形按鈕始終可見
              formButtons[formType].classList.remove('hidden');
              formButtons[formType].style.visibility = 'visible';
            }
          });
          break;
          
        case 'chapter1':
          // 第一章開始時不解鎖蝴蝶形態，要等到劇情中獲得
          if (isDevMode) forceShowFormButton('butterfly');
          break;
          
        case 'chapter2':
          // 第二章進入時有序章的蝴蝶 + 第一章的鯈魚
          unlockForm('butterfly');  // 序章解鎖
          unlockForm('fish');       // 第一章解鎖
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
          }
          // 收集左目封印
          if (!gameState.collectedApertures.includes('left-eye')) {
            gameState.collectedApertures.push('left-eye');
          }
          break;
          
        case 'chapter3':
          // 第三章進入時有序章的蝴蝶 + 第一章的鯈魚 + 第二章的鯤、鵬
          unlockForm('butterfly');  // 序章解鎖
          unlockForm('fish');       // 第一章解鎖
          unlockForm('kun');        // 第二章解鎖
          unlockForm('peng');       // 第二章解鎖
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
          }
          // 收集前面的封印
          if (!gameState.collectedApertures.includes('left-eye')) {
            gameState.collectedApertures.push('left-eye');
          }
          if (!gameState.collectedApertures.includes('right-eye')) {
            gameState.collectedApertures.push('right-eye');
          }
          break;
          
        case 'chapter4':
          // 第四章進入時有序章的蝴蝶 + 第一章的鯈魚 + 第二章的鯤、鵬 + 第三章的鵷鶵、鴟鴞
          unlockForm('butterfly');  // 序章解鎖
          unlockForm('fish');       // 第一章解鎖
          unlockForm('kun');        // 第二章解鎖
          unlockForm('peng');       // 第二章解鎖
          unlockForm('yuanchu');    // 第三章解鎖
          unlockForm('chixiao');    // 第三章解鎖
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            // 開發者模式下直接啟用視角縮放功能
            enableScaleControl();
          }
          // 收集前面所有的封印
          const previousApertures = ['left-eye', 'right-eye', 'left-ear'];
          previousApertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          // 注意：第四章開始時不啟用視角縮放功能，要等到劇情引導
          break;
          
        case 'chapter5':
          // 第五章進入時有序章的蝴蝶 + 第一章的鯈魚 + 第二章的鯤、鵬 + 第三章的鵷鶵、鴟鴞 + 第四章的蝸牛
          unlockForm('butterfly');  // 序章解鎖
          unlockForm('fish');       // 第一章解鎖
          unlockForm('kun');        // 第二章解鎖
          unlockForm('peng');       // 第二章解鎖
          unlockForm('yuanchu');    // 第三章解鎖
          unlockForm('chixiao');    // 第三章解鎖
          unlockForm('snail');      // 第四章解鎖
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
          }
          // 收集前面所有的封印
          const chapter5Apertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear'];
          chapter5Apertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
          
        case 'chapter6':
          // 第六章進入時有序章的蝴蝶 + 第一章的鯈魚 + 第二章的鯤、鵬 + 第三章的鵷鶵、鴟鴞 + 第四章的蝸牛 + 第五章的朝菌、蟪蛄、大椿
          unlockForm('butterfly');      // 序章解鎖
          unlockForm('fish');           // 第一章解鎖
          unlockForm('kun');            // 第二章解鎖
          unlockForm('peng');           // 第二章解鎖
          unlockForm('yuanchu');        // 第三章解鎖
          unlockForm('chixiao');        // 第三章解鎖
          unlockForm('snail');          // 第四章解鎖
          unlockForm('morning-fungus'); // 第五章解鎖
          unlockForm('cicada');         // 第五章解鎖
          unlockForm('great-chun');     // 第五章解鎖
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
            forceShowFormButton('morning-fungus');
            forceShowFormButton('cicada');
            forceShowFormButton('great-chun');
          }
          // 收集前面所有的封印
          const chapter6Apertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear', 'left-nose'];
          chapter6Apertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
          
        case 'chapter7':
          // 第七章進入時有序章的蝴蝶 + 第一章的鯈魚 + 第二章的鯤、鵬 + 第三章的鵷鶵、鴟鴞 + 第四章的蝸牛 + 第五章的朝菌、蟪蛄、大椿 + 第六章的螻蟻、星辰
          unlockForm('butterfly');      // 序章解鎖
          unlockForm('fish');           // 第一章解鎖
          unlockForm('kun');            // 第二章解鎖
          unlockForm('peng');           // 第二章解鎖
          unlockForm('yuanchu');        // 第三章解鎖
          unlockForm('chixiao');        // 第三章解鎖
          unlockForm('snail');          // 第四章解鎖
          unlockForm('morning-fungus'); // 第五章解鎖
          unlockForm('cicada');         // 第五章解鎖
          unlockForm('great-chun');     // 第五章解鎖
          unlockForm('ant');            // 第六章解鎖
          unlockForm('star');           // 第六章解鎖
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
            forceShowFormButton('morning-fungus');
            forceShowFormButton('cicada');
            forceShowFormButton('great-chun');
            forceShowFormButton('ant');
            forceShowFormButton('star');
            // 開發者模式下自動完成八卦學習和激活萬物尋氣
            gameState.baguaLearningCompleted = true;
            console.log('開發者模式：自動完成八卦學習');
          }
          // 收集前面所有的封印
          const chapter7Apertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear', 'left-nose', 'right-nose'];
          chapter7Apertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
          
        case 'epilogue':
          // 尾聲章節需要所有形態和封印
          unlockForm('butterfly');
          unlockForm('fish');
          unlockForm('kun');
          unlockForm('peng');
          unlockForm('yuanchu');
          unlockForm('chixiao');
          unlockForm('snail');
          unlockForm('morning-fungus');
          unlockForm('cicada');
          unlockForm('great-chun');
          unlockForm('ant');
          unlockForm('star');
          unlockForm('qi');
          if (isDevMode) {
            forceShowFormButton('butterfly');
            forceShowFormButton('fish');
            forceShowFormButton('kun');
            forceShowFormButton('peng');
            forceShowFormButton('yuanchu');
            forceShowFormButton('chixiao');
            forceShowFormButton('snail');
            forceShowFormButton('morning-fungus');
            forceShowFormButton('cicada');
            forceShowFormButton('great-chun');
            forceShowFormButton('ant');
            forceShowFormButton('star');
            forceShowFormButton('qi');
          }
          // 收集所有封印
          const allApertures = ['left-eye', 'right-eye', 'left-ear', 'right-ear', 'left-nose', 'right-nose', 'mouth'];
          allApertures.forEach(aperture => {
            if (!gameState.collectedApertures.includes(aperture)) {
              gameState.collectedApertures.push(aperture);
            }
          });
          break;
      }
      
      // 先清除所有七竅指示器的狀態，然後重新設置
      document.querySelectorAll('.aperture').forEach(aperture => {
        aperture.classList.remove('active');
      });
      
      // 移除可能存在的太極覆蓋層
      const existingTaijiOverlay = document.getElementById('taiji-overlay');
      if (existingTaijiOverlay) {
        existingTaijiOverlay.remove();
      }
      
      // 更新已收集封印的視覺狀態
      gameState.collectedApertures.forEach(apertureType => {
        const targetAperture = document.querySelector(`.aperture-${apertureType}`);
        if (targetAperture && !targetAperture.classList.contains('active')) {
          targetAperture.classList.add('active');
        }
      });
      
      // 如果已收集所有7個封印，創建太極覆蓋層
      if (gameState.collectedApertures.length === 7) {
        setTimeout(() => {
          createTaijiOverlay();
        }, 1000); // 延遲1秒確保DOM元素已準備好
      }
    }
    
    // 開發者模式下強制顯示物化按鈕
    function forceShowFormButton(form) {
      if (formButtons[form]) {
        formButtons[form].style.visibility = 'visible';
        formButtons[form].classList.remove('hidden');
        console.log(`開發者模式：強制顯示 ${form} 按鈕`);
      }
    }

    // Initialize the game
    // 開發者工具相關函數
    
    function initDevTools() {
      // 重置玩家數據按鈕
      const resetPlayerDataBtn = document.getElementById('reset-player-data-btn');
      if (resetPlayerDataBtn) {
        resetPlayerDataBtn.addEventListener('click', () => {
          const confirmReset = confirm('確認要重置所有玩家選擇數據嗎？\n\n這將清除：\n• 所有選擇記錄\n• 特質分數\n• AI分析數據\n• 物化體驗數據\n• 斷句挑戰數據\n• 場景停留時間\n• 聊天記錄\n\n注意：遊戲進度（章節解鎖、形態解鎖、封印收集）將保留。');
          
          if (confirmReset) {
            const result = window.resetPlayerChoicesOnly();
            if (result && result.success) {
              showDevMessage('✅ 玩家數據重置完成！遊戲進度已保留。');
            } else {
              showDevMessage('❌ 重置失敗，請檢查控制台錯誤信息。');
            }
          }
        });
      }
      
      // 查看所有數據按鈕
      const viewAllDataBtn = document.getElementById('view-all-data-btn');
      if (viewAllDataBtn) {
        viewAllDataBtn.addEventListener('click', () => {
          showAllGameData();
        });
      }
    }
    


    // 顯示開發者信息提示
    function showDevMessage(message) {
      // 檢查是否已存在提示
      let toast = document.getElementById('dev-toast');
      
      if (!toast) {
        // 創建新提示
        toast = document.createElement('div');
        toast.id = 'dev-toast';
        toast.className = 'fixed bottom-4 left-4 bg-indigo-600 text-white px-4 py-2 rounded-lg shadow-lg z-50 transition-all duration-300 opacity-0 transform translate-y-2';
        document.body.appendChild(toast);
      }
      
      // 更新消息
      toast.textContent = message;
      
      // 顯示提示
      setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateY(0)';
        
        // 自動隱藏
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateY(2px)';
          
          // 移除元素
          setTimeout(() => {
            toast.remove();
          }, 300);
        }, 2000);
      }, 10);
    }
    
    // 顯示遊戲消息提示
    function showMessage(message) {
      // 檢查是否已存在提示
      let toast = document.getElementById('game-message-toast');
      
      if (!toast) {
        // 創建新提示
        toast = document.createElement('div');
        toast.id = 'game-message-toast';
        toast.className = 'fixed top-20 left-1/2 transform -translate-x-1/2 bg-green-600 text-white px-6 py-3 rounded-lg shadow-lg z-50 transition-all duration-300 opacity-0 translate-y-2';
        document.body.appendChild(toast);
      }
      
      // 更新消息
      toast.textContent = message;
      
      // 顯示提示
      setTimeout(() => {
        toast.style.opacity = '1';
        toast.style.transform = 'translateX(-50%) translateY(0)';
        
        // 自動隱藏
        setTimeout(() => {
          toast.style.opacity = '0';
          toast.style.transform = 'translateX(-50%) translateY(-10px)';
          
          // 移除元素
          setTimeout(() => {
            toast.remove();
          }, 300);
        }, 3000);
      }, 10);
    }
    

    
    // 創建時間效果場景
    function createTimeEffectScene(scene) {
      // 创建全屏时间背景效果
      const timeBackgroundContainer = document.createElement('div');
      timeBackgroundContainer.className = 'time-background-container';
      timeBackgroundContainer.style.position = 'fixed';
      timeBackgroundContainer.style.top = '0';
      timeBackgroundContainer.style.left = '0';
      timeBackgroundContainer.style.width = '100%';
      timeBackgroundContainer.style.height = '100%';
      timeBackgroundContainer.style.pointerEvents = 'none';
      timeBackgroundContainer.style.zIndex = '-1';
      timeBackgroundContainer.style.overflow = 'hidden';
      
      // 创建多层琥珀色光晕效果
      for (let layer = 0; layer < 4; layer++) {
        const amberGlow = document.createElement('div');
        amberGlow.className = 'time-amber-glow';
        amberGlow.style.position = 'absolute';
        amberGlow.style.borderRadius = '50%';
        amberGlow.style.filter = `blur(${20 + layer * 10}px)`;
        
        // 不同大小和位置的光晕
        const size = 300 + layer * 200;
        const posX = 20 + layer * 20;
        const posY = 15 + layer * 15;
        
        amberGlow.style.width = `${size}px`;
        amberGlow.style.height = `${size}px`;
        amberGlow.style.left = `${posX}%`;
        amberGlow.style.top = `${posY}%`;
        amberGlow.style.transform = 'translate(-50%, -50%)';
        
        // 渐变色彩从深到浅
        const opacity = 0.4 - layer * 0.08;
        amberGlow.style.background = `radial-gradient(circle, rgba(255, 191, 0, ${opacity}) 0%, rgba(255, 143, 0, ${opacity * 0.6}) 40%, transparent 70%)`;
        
        // 不同速度的脉动动画
        const duration = 6 + layer * 2;
        amberGlow.style.animation = `amber-pulse-${layer} ${duration}s infinite ease-in-out`;
        
        timeBackgroundContainer.appendChild(amberGlow);
      }
      
      // 创建中央的大椿树 - 位于画面正中心
      const dachunTree = document.createElement('div');
      dachunTree.className = 'dachun-tree-emoji';
      dachunTree.style.position = 'absolute';
      dachunTree.style.left = '50%';
      dachunTree.style.top = '50%';
      dachunTree.style.transform = 'translate(-50%, -50%)';
      dachunTree.style.zIndex = '10';
      dachunTree.style.pointerEvents = 'none';
      dachunTree.style.fontSize = '500px';
      dachunTree.style.filter = `
        drop-shadow(0 0 40px rgba(139, 69, 19, 0.8))
        drop-shadow(0 0 80px rgba(255, 191, 0, 0.5))
        opacity(0.9)
        contrast(1.3)
        sepia(0.4)
      `;
      dachunTree.style.animation = 'dachun-dreamlike 20s infinite ease-in-out';
      dachunTree.textContent = '🌳';
      
      // 添加多層光暈效果
      const glowLayers = document.createElement('div');
      glowLayers.style.position = 'absolute';
      glowLayers.style.left = '50%';
      glowLayers.style.top = '50%';
      glowLayers.style.transform = 'translate(-50%, -50%)';
      glowLayers.style.pointerEvents = 'none';
      
      for (let i = 0; i < 3; i++) {
        const glow = document.createElement('div');
        glow.style.position = 'absolute';
        glow.style.width = `${500 + i * 200}px`;
        glow.style.height = `${400 + i * 160}px`;
        glow.style.borderRadius = '50%';
        glow.style.background = `radial-gradient(circle, rgba(139, 69, 19, ${0.3 - i * 0.08}) 0%, transparent 70%)`;
        glow.style.filter = `blur(${30 + i * 20}px)`;
        glow.style.left = '50%';
        glow.style.top = '50%';
        glow.style.transform = 'translate(-50%, -50%)';
        glow.style.animation = `glow-pulse-${i} ${15 + i * 5}s infinite ease-in-out`;
        glowLayers.appendChild(glow);
      }
      
      dachunTree.appendChild(glowLayers);
      timeBackgroundContainer.appendChild(dachunTree);
      
      // 在大椿脚下创建朝菌群落 - 使用emoji，位于画面中心大椿根部
      for (let i = 0; i < 15; i++) {
        const morningFungus = document.createElement('div');
        morningFungus.className = 'morning-fungus-emoji';
        morningFungus.style.position = 'absolute';
        morningFungus.style.fontSize = `${15 + Math.random() * 25}px`;
        morningFungus.style.filter = `
          drop-shadow(0 0 8px rgba(255, 228, 181, 0.6))
          opacity(${0.7 + Math.random() * 0.3})
          sepia(0.2)
        `;
        
        // 围绕画面中心的大椿树根部分布
        const angle = (i / 15) * Math.PI * 2;
        const distance = 120 + Math.random() * 160; // 距离中心的像素距离，增大兩倍
        const x = 50 + Math.cos(angle) * (distance / 8); // 转换为百分比，缩小分布范围
        const y = 50 + Math.sin(angle) * (distance / 12) + 8; // 在中心稍下方分布
        
        morningFungus.style.left = `${x}%`;
        morningFungus.style.top = `${y}%`;
        morningFungus.style.transform = 'translate(-50%, -50%)';
        morningFungus.textContent = '🍄';
        
        // 朝菌的快速生长动画
        morningFungus.style.animation = `fungus-lifecycle ${2 + Math.random() * 3}s infinite ease-in-out`;
        morningFungus.style.animationDelay = `${Math.random() * 2}s`;
        
        timeBackgroundContainer.appendChild(morningFungus);
      }
      
      // 创建飞舞的蟪蛄
      for (let i = 0; i < 8; i++) {
        const flyingCicada = document.createElement('div');
        flyingCicada.className = 'flying-cicada';
        flyingCicada.style.position = 'absolute';
        flyingCicada.style.width = '20px';
        flyingCicada.style.height = '12px';
        flyingCicada.style.left = `${20 + Math.random() * 60}%`;
        flyingCicada.style.top = `${20 + Math.random() * 40}%`;
        flyingCicada.style.pointerEvents = 'none';
        
        // 蟪蛄身体
        const body = document.createElement('div');
        body.style.position = 'absolute';
        body.style.width = '16px';
        body.style.height = '8px';
        body.style.background = 'linear-gradient(90deg, rgba(139, 90, 43, 0.9), rgba(160, 100, 50, 0.8))';
        body.style.borderRadius = '8px 8px 3px 3px';
        body.style.left = '2px';
        body.style.top = '2px';
        
        // 蟪蛄翅膀
        const leftWing = document.createElement('div');
        leftWing.style.position = 'absolute';
        leftWing.style.width = '18px';
        leftWing.style.height = '10px';
        leftWing.style.background = 'rgba(255, 255, 255, 0.4)';
        leftWing.style.borderRadius = '50% 20% 50% 20%';
        leftWing.style.left = '-2px';
        leftWing.style.top = '1px';
        leftWing.style.transformOrigin = '80% 50%';
        leftWing.dataset.originalWingDuration = '0.3';
        leftWing.style.animation = 'cicada-wing-left 0.3s infinite ease-in-out';
        
        const rightWing = document.createElement('div');
        rightWing.style.position = 'absolute';
        rightWing.style.width = '18px';
        rightWing.style.height = '10px';
        rightWing.style.background = 'rgba(255, 255, 255, 0.4)';
        rightWing.style.borderRadius = '20% 50% 20% 50%';
        rightWing.style.right = '-2px';
        rightWing.style.top = '1px';
        rightWing.style.transformOrigin = '20% 50%';
        rightWing.dataset.originalWingDuration = '0.3';
        rightWing.style.animation = 'cicada-wing-right 0.3s infinite ease-in-out';
        
        flyingCicada.appendChild(body);
        flyingCicada.appendChild(leftWing);
        flyingCicada.appendChild(rightWing);
        
        // 飞行路径动画
        const flightDuration = 15 + Math.random() * 20;
        const flightDelay = Math.random() * 10;
        
        // 保存原始動畫參數作為數據屬性
        flyingCicada.dataset.originalFlightDuration = flightDuration;
        flyingCicada.dataset.flightDelay = flightDelay;
        
        flyingCicada.style.animation = `cicada-flight ${flightDuration}s ${flightDelay}s infinite linear`;
        
        timeBackgroundContainer.appendChild(flyingCicada);
      }
      

      
      // 创建时间粒子效果 - 增加数量并覆盖全屏
      for (let i = 0; i < 40; i++) {
        const particle = document.createElement('div');
        particle.className = 'time-particle-global';
        
        const size = 3 + Math.random() * 8;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.position = 'absolute';
        particle.style.borderRadius = '50%';
        particle.style.pointerEvents = 'none';
        
        // 琥珀色粒子的多种变化
        const colorVariant = Math.random();
        if (colorVariant < 0.3) {
          particle.style.backgroundColor = `rgba(255, 191, 0, ${0.6 + Math.random() * 0.4})`;
          particle.style.boxShadow = '0 0 8px rgba(255, 191, 0, 0.8)';
        } else if (colorVariant < 0.6) {
          particle.style.backgroundColor = `rgba(245, 158, 11, ${0.5 + Math.random() * 0.4})`;
          particle.style.boxShadow = '0 0 6px rgba(245, 158, 11, 0.7)';
        } else {
          particle.style.backgroundColor = `rgba(217, 119, 6, ${0.4 + Math.random() * 0.4})`;
          particle.style.boxShadow = '0 0 10px rgba(217, 119, 6, 0.6)';
        }
        
        // 随机位置覆盖全屏
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // 多种时间流动模式
        const flowType = Math.floor(Math.random() * 3);
        const duration = 15 + Math.random() * 25;
        const delay = Math.random() * 15;
        
        // 保存原始動畫參數作為數據屬性
        particle.dataset.originalDuration = duration;
        particle.dataset.delay = delay;
        
        if (flowType === 0) {
          particle.style.animation = `time-flow-up ${duration}s ${delay}s infinite linear`;
          particle.dataset.animationType = 'time-flow-up';
          particle.dataset.easing = 'linear';
        } else if (flowType === 1) {
          particle.style.animation = `time-flow-spiral ${duration}s ${delay}s infinite linear`;
          particle.dataset.animationType = 'time-flow-spiral';
          particle.dataset.easing = 'linear';
        } else {
          particle.style.animation = `time-flow-drift ${duration}s ${delay}s infinite ease-in-out`;
          particle.dataset.animationType = 'time-flow-drift';
          particle.dataset.easing = 'ease-in-out';
        }
        
        timeBackgroundContainer.appendChild(particle);
      }
      
      // 将背景效果添加到游戏容器
      gameContainer.appendChild(timeBackgroundContainer);
      
      // 添加时间动画样式
      if (!document.getElementById('time-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'time-animations';
        styleElement.textContent = `
          /* 多层琥珀光晕脉动 */
          @keyframes amber-pulse-0 {
            0%, 100% { opacity: 0.4; transform: translate(-50%, -50%) scale(1); }
            50% { opacity: 0.6; transform: translate(-50%, -50%) scale(1.1); }
          }
          
          @keyframes amber-pulse-1 {
            0%, 100% { opacity: 0.32; transform: translate(-50%, -50%) scale(0.95); }
            50% { opacity: 0.48; transform: translate(-50%, -50%) scale(1.05); }
          }
          
          @keyframes amber-pulse-2 {
            0%, 100% { opacity: 0.24; transform: translate(-50%, -50%) scale(1.05); }
            50% { opacity: 0.36; transform: translate(-50%, -50%) scale(0.9); }
          }
          
          @keyframes amber-pulse-3 {
            0%, 100% { opacity: 0.16; transform: translate(-50%, -50%) scale(0.9); }
            50% { opacity: 0.24; transform: translate(-50%, -50%) scale(1.15); }
          }
          
          /* 树木生长阶段动画 */
          @keyframes seedling-growth {
            0%, 100% { transform: scaleY(0.8) rotate(-1deg); }
            50% { transform: scaleY(1.2) rotate(1deg); }
          }
          
          @keyframes mature-sway {
            0%, 100% { transform: rotate(-2deg) scaleY(1); }
            50% { transform: rotate(2deg) scaleY(1.05); }
          }
          
          @keyframes ancient-stillness {
            0%, 100% { transform: rotate(-0.5deg) scaleY(1); }
            50% { transform: rotate(0.5deg) scaleY(1.02); }
          }
          
          /* 时间粒子流动动画 */
          @keyframes time-flow-up {
            0% { transform: translateY(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.6; }
            100% { transform: translateY(-120vh) rotate(180deg); opacity: 0; }
          }
          
          @keyframes time-flow-spiral {
            0% { transform: rotate(0deg) translateX(0) rotate(0deg); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.6; }
            100% { transform: rotate(720deg) translateX(100px) rotate(-720deg); opacity: 0; }
          }
          
          @keyframes time-flow-drift {
            0% { transform: translate(0, 0) rotate(0deg); opacity: 0; }
            25% { transform: translate(20px, -30px) rotate(90deg); opacity: 0.8; }
            50% { transform: translate(-20px, -60px) rotate(180deg); opacity: 0.9; }
            75% { transform: translate(30px, -90px) rotate(270deg); opacity: 0.7; }
            100% { transform: translate(0, -120px) rotate(360deg); opacity: 0; }
          }
          
          /* 文字发光效果 */
          .time-text {
            color: #d97706;
            text-shadow: 0 0 10px rgba(217, 119, 6, 0.5);
            animation: text-glow-amber 4s infinite ease-in-out;
            background: rgba(0, 0, 0, 0.7);
            padding: 1.5rem;
            border-radius: 12px;
            backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 191, 0, 0.3);
          }
          
          @keyframes text-glow-amber {
            0%, 100% { text-shadow: 0 0 10px rgba(217, 119, 6, 0.5); }
            50% { text-shadow: 0 0 20px rgba(217, 119, 6, 0.8), 0 0 30px rgba(255, 191, 0, 0.4); }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      // 创建文本容器
      const timeEffectElement = document.createElement('div');
      timeEffectElement.className = 'max-w-2xl mx-auto p-6 text-left relative z-10';
      
      // 添加文本
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed time-text';
      textElement.textContent = scene.text;
      timeEffectElement.appendChild(textElement);
      
      gameContent.appendChild(timeEffectElement);
      advanceBtn.style.display = 'block';
    }
    
    // 創建時間體驗場景
    // 創建物化體驗場景（帶打字機效果）
    function createTransformationExperienceScene(scene) {
      // 進入新的物化場景時，清除螻蟻視覺效果
      removeAntVisionEffect();
      
      // 如果是氣形態，進行徹底的視覺清理
      if (scene.formType === 'qi') {
        // 清理所有可能的視覺殘留
        const existingOverlay = document.querySelector('.transformation-overlay');
        if (existingOverlay) {
          existingOverlay.remove();
        }
        
        // 清理萬物尋氣引導界面
        const wanwuGuideContainer = document.querySelector('.max-w-2xl.mx-auto.p-6.text-center.fixed');
        if (wanwuGuideContainer) {
          wanwuGuideContainer.remove();
        }
        
        // 清理萬物尋氣相關的狀態
        gameState.wanwuXunqiActive = false;
        gameState.handleFormSequenceClick = null;
        gameState.wanwuXunqiGuideContainer = null;
        
        // 移除所有物化按鈕的高亮效果
        Object.values(formButtons).forEach(btn => {
          if (btn) {
            btn.style.boxShadow = '';
            btn.style.animation = '';
          }
        });
        
        // 重置gameContainer的樣式
        gameContainer.style.transform = 'scale(1)';
        gameContainer.style.filter = 'none';
        gameContainer.style.background = '';
        
        console.log('氣形態物化體驗：已清理所有視覺殘留');
      }
      
      // 隱藏底部日常物化按鈕，避免在打字機體驗中的混亂
      hideFormButtons();
      
      const experienceElement = document.createElement('div');
      experienceElement.className = 'max-w-2xl mx-auto p-6 text-left relative z-10';
      
      // 根據不同的形態創建不同的視覺效果
      const formType = scene.formType || 'default';
      let backgroundColor, particleColor, particleCount;
      
      switch (formType) {
        case 'butterfly':
          backgroundColor = 'rgba(147, 51, 234, 0.15)'; // 紫色，代表夢境
          particleColor = 'rgba(147, 51, 234, 0.8)';
          particleCount = 15;
          break;
        case 'fish':
          backgroundColor = 'rgba(59, 130, 246, 0.15)'; // 藍色，代表水中
          particleColor = 'rgba(59, 130, 246, 0.8)';
          particleCount = 20;
          break;
        case 'kun':
          backgroundColor = 'rgba(30, 64, 175, 0.15)'; // 深藍色，代表深海
          particleColor = 'rgba(30, 64, 175, 0.8)';
          particleCount = 25;
          break;
        case 'peng':
          backgroundColor = 'rgba(14, 165, 233, 0.15)'; // 天藍色，代表高空
          particleColor = 'rgba(14, 165, 233, 0.8)';
          particleCount = 30;
          break;
        case 'yuanchu':
          backgroundColor = 'rgba(255, 215, 0, 0.15)'; // 金色，代表聖潔
          particleColor = 'rgba(255, 215, 0, 0.8)';
          particleCount = 20;
          break;
        case 'chixiao':
          backgroundColor = 'rgba(75, 0, 130, 0.15)'; // 紫色，代表夜晚
          particleColor = 'rgba(255, 215, 0, 0.6)';
          particleCount = 16;
          break;
        case 'snail':
          backgroundColor = 'rgba(168, 85, 247, 0.15)'; // 紫色，代表螺旋
          particleColor = 'rgba(168, 85, 247, 0.8)';
          particleCount = 12;
          break;
        case 'morning-fungus':
          backgroundColor = 'rgba(255, 230, 153, 0.2)'; // 淺黃色，代表晨光
          particleColor = 'rgba(255, 255, 0, 0.8)';
          particleCount = 30;
          break;
        case 'cicada':
          backgroundColor = 'rgba(34, 197, 94, 0.2)'; // 綠色，代表夏日
          particleColor = 'rgba(34, 197, 94, 0.8)';
          particleCount = 20;
          break;
        case 'great-chun':
          backgroundColor = 'rgba(120, 53, 15, 0.2)'; // 棕色，代表古老
          particleColor = 'rgba(120, 53, 15, 0.8)';
          particleCount = 10;
          break;
        case 'ant':
          backgroundColor = 'rgba(50, 50, 50, 0.3)'; // 深灰色，代表螻蟻的黑白視覺
          particleColor = 'rgba(100, 100, 100, 0.6)';
          particleCount = 12;
          break;
        case 'star':
          backgroundColor = 'rgba(25, 25, 112, 0.2)'; // 深藍色，代表宇宙
          particleColor = 'rgba(255, 215, 0, 0.8)';
          particleCount = 20;
          break;
        case 'qi':
          backgroundColor = 'transparent'; // 气形态不使用背景色，依靠body.qi-vision的黑白滤镜
          particleColor = 'rgba(0, 0, 0, 0.6)'; // 黑色粒子，符合陰陽概念
          particleCount = 0; // 气形态不使用额外粒子，依靠addQiVisionEffect的内建粒子
          break;
        default:
          backgroundColor = 'rgba(255, 191, 0, 0.2)';
          particleColor = 'rgba(255, 191, 0, 0.8)';
          particleCount = 15;
      }
      
      // 創建體驗背景（气形态除外，使用body.qi-vision的黑白滤镜）
      let experienceBackground = null;
      if (formType !== 'qi') {
        experienceBackground = document.createElement('div');
      experienceBackground.className = 'fixed inset-0 pointer-events-none z-0';
      experienceBackground.style.background = backgroundColor;
      experienceBackground.style.animation = 'transformation-experience-fade 4s infinite ease-in-out';
      document.body.appendChild(experienceBackground);
      }
      
      // 創建粒子效果（气形态使用自己的内建粒子系统）
      const particleContainer = document.createElement('div');
      particleContainer.className = 'absolute inset-0 pointer-events-none';
      
      for (let i = 0; i < particleCount; i++) {
        const particle = document.createElement('div');
        particle.className = 'transformation-particle';
        
        const size = 4 + Math.random() * 8;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.backgroundColor = particleColor;
        particle.style.borderRadius = '50%';
        particle.style.position = 'absolute';
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        const duration = 8 + Math.random() * 12;
        const delay = Math.random() * duration;
        particle.style.animation = `transformation-float ${duration}s ${delay}s infinite ease-in-out`;
        
        particleContainer.appendChild(particle);
      }
      
      // 添加動畫樣式
      if (!document.getElementById('transformation-experience-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'transformation-experience-animations';
        styleElement.textContent = `
          @keyframes transformation-experience-fade {
            0%, 100% { opacity: 0.1; }
            50% { opacity: 0.3; }
          }
          
          @keyframes transformation-float {
            0%, 100% { transform: translateY(0) rotate(0deg); opacity: 0.6; }
            25% { transform: translateY(-20px) rotate(90deg); opacity: 1; }
            50% { transform: translateY(0) rotate(180deg); opacity: 0.8; }
            75% { transform: translateY(20px) rotate(270deg); opacity: 0.6; }
          }
          
          .transformation-experience-text {
            background: rgba(0, 0, 0, 0.7);
            border-radius: 12px;
            padding: 2rem;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            text-align: left;
          }
          
          .typewriter-cursor {
            display: inline-block;
            width: 2px;
            height: 1.2em;
            background-color: currentColor;
            animation: cursor-blink 1s infinite;
            margin-left: 2px;
          }
          
          @keyframes cursor-blink {
            0%, 50% { opacity: 1; }
            51%, 100% { opacity: 0; }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
      experienceElement.appendChild(particleContainer);
      
      // 添加文本容器
      const textContainer = document.createElement('div');
      textContainer.className = 'transformation-experience-text relative z-20 text-left';
      
      const textElement = document.createElement('p');
      textElement.className = 'text-lg md:text-xl leading-relaxed text-left';
      
      textContainer.appendChild(textElement);
      experienceElement.appendChild(textContainer);
      
      gameContent.appendChild(experienceElement);
      
      // 如果是氣形態，立即激活氣視覺效果（在打字機效果開始前）
      if (formType === 'qi') {
        addQiVisionEffect();
        console.log('氣形態：已在打字機效果開始前設置黑白視野');
      }
      
      // 開始打字機效果
      startTypewriterEffect(textElement, scene.text, () => {
        // 如果是蝸牛形態，激活蝸牛視角效果
        if (formType === 'snail') {
          createSnailPerspectiveEffect();
        }
        
        // 氣形態的視覺效果已經在前面設置，這裡不需要重複調用
        // if (formType === 'qi') {
        //   addQiVisionEffect(); // 已經在前面調用過了
        // }
        
        // 打字完成後顯示繼續按鈕
        advanceBtn.style.display = 'block';
        // 移除背景效果（如果存在）
        setTimeout(() => {
          if (experienceBackground) {
        experienceBackground.remove();
          }
        }, 1000);
      });
    }
    
    // 打字機效果函數
    function startTypewriterEffect(element, text, onComplete) {
      let index = 0;
      const speed = 100; // 打字速度（毫秒）- 降低兩倍速度
      let typewriterActive = true; // 添加狀態標記
      
      // 創建光標
      const cursor = document.createElement('span');
      cursor.className = 'typewriter-cursor';
      element.appendChild(cursor);
      
      // 存儲到全局變量以便清理
      window.currentTypewriterState = {
        active: true,
        element: element,
        cursor: cursor,
        stop: () => {
          typewriterActive = false;
          if (cursor && cursor.parentNode) {
            cursor.remove();
          }
          // 清空元素內容，移除所有文本節點
          if (element) {
            element.innerHTML = '';
          }
        }
      };
      
      function typeNextCharacter() {
        if (!typewriterActive || index >= text.length) {
          // 打字完成或被停止
          setTimeout(() => {
            if (cursor && cursor.parentNode) {
              cursor.remove();
            }
            if (typewriterActive && onComplete) onComplete();
            window.currentTypewriterState = null;
          }, 500);
          return;
        }
        
        // 在光標前插入字符
        const textNode = document.createTextNode(text[index]);
        element.insertBefore(textNode, cursor);
        index++;
        setTimeout(typeNextCharacter, speed);
      }
      
      typeNextCharacter();
    }
    
    function createTransformationRequiredScene(scene) {
      const transformationElement = document.createElement('div');
      transformationElement.className = 'max-w-2xl mx-auto p-6 text-left fixed top-8 left-1/2 transform -translate-x-1/2 bg-yellow-100 dark:bg-yellow-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-20 border-2 border-yellow-400 dark:border-yellow-600';
      
      transformationElement.innerHTML = `
        <div class="flex items-center justify-center mb-4">
          <div class="w-8 h-8 bg-yellow-500 rounded-full flex items-center justify-center mr-3">
            <span class="text-white font-bold">!</span>
          </div>
          <h3 class="text-xl font-bold text-yellow-800 dark:text-yellow-200">需要物化形態</h3>
        </div>
        <p class="text-lg leading-relaxed text-yellow-800 dark:text-yellow-200">${scene.text}</p>
        <div class="mt-4 p-3 bg-yellow-200 dark:bg-yellow-800 rounded-lg">
          <p class="text-sm text-yellow-700 dark:text-yellow-300">
            請使用底部的物化按鈕切換到所需形態後，場景將自動繼續。
          </p>
        </div>
      `;
      
      gameContent.appendChild(transformationElement);
      
      // 設置當前需要的物化形態
      gameState.transformationInProgress = scene.requiredForm;
      
      // 隱藏繼續按鈕，直到玩家切換到正確形態
      advanceBtn.style.display = 'none';
      
      // 監聽形態變化
      checkTransformationProgress();
    }
    
    function checkTransformationProgress() {
      if (gameState.transformationInProgress && gameState.currentForm === gameState.transformationInProgress) {
        // 移除所有按鈕的高亮效果
        Object.values(formButtons).forEach(btn => {
          btn.classList.remove('form-button-highlight', 'animate-pulse');
          btn.style.animation = '';
          btn.style.boxShadow = '';
        });
        
        // 檢查是否是初次物化
        if (gameState.firstTimeUnlockInProgress && gameState.pendingFormUnlock) {
          // 初次物化完成，先進入物化體驗場景
          showFirstTimeTransformationExperience(gameState.pendingFormUnlock);
        } else {
          // 常規物化完成，直接進入下一場景
          gameState.transformationInProgress = null;
          setTimeout(() => {
            advanceScene();
          }, 1000);
        }
      }
    }
    
    function createFormUnlockGuideScene(scene) {
      // 立即強制隱藏繼續按鈕，避免時序問題
      advanceBtn.style.display = 'none';
      
      // 隱藏底部日常物化按鈕，避免初次物化流程中的混亂
      hideFormButtons();
      
      const guideElement = document.createElement('div');
      guideElement.className = 'max-w-2xl mx-auto p-6 text-center fixed top-8 left-1/2 transform -translate-x-1/2 bg-gradient-to-br from-amber-50 to-orange-100 dark:from-amber-900 dark:to-orange-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg z-20 border-2 border-amber-400 dark:border-amber-600';
      
      guideElement.innerHTML = `
        <div class="flex items-center justify-center mb-4">
          <div class="w-10 h-10 bg-amber-500 rounded-full flex items-center justify-center mr-3 animate-pulse">
            <span class="text-white font-bold text-lg">✨</span>
          </div>
          <h3 class="text-xl font-bold text-amber-800 dark:text-amber-200">新的物化能力已解鎖！</h3>
        </div>
        <p class="text-lg leading-relaxed text-amber-800 dark:text-amber-200 mb-4 text-left">${scene.text}</p>
        <div class="mt-4 p-3 bg-amber-200 dark:bg-amber-800 rounded-lg">
          <p class="text-sm text-amber-700 dark:text-amber-300 flex items-center justify-center">
            <span class="animate-bounce mr-2">👇</span>
            點擊下方按鈕體驗新的物化能力
            <span class="animate-bounce ml-2">👇</span>
          </p>
        </div>
      `;
      
      gameContent.appendChild(guideElement);
      
      // 再次確保隱藏底部的繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 設置初次物化狀態
      gameState.firstTimeUnlockInProgress = true;
      gameState.pendingFormUnlock = scene.highlightForm;
      
      // 創建初次物化按鈕（替代繼續按鈕的位置）
      createFirstTimeTransformationButton(scene.highlightForm);
      
      // 設置持續監控，確保當場景中有新物化按鈕時，繼續按鈕保持隱藏
      const hideAdvanceBtnInterval = setInterval(() => {
        const firstTimeButton = document.getElementById('first-time-transform-btn');
        if (firstTimeButton) {
          // 當新物化按鈕存在時，強制隱藏繼續按鈕
          if (advanceBtn.style.display !== 'none') {
            advanceBtn.style.display = 'none';
            console.log('檢測到新物化按鈕存在，強制隱藏繼續按鈕');
          }
        } else if (gameState.firstTimeUnlockInProgress === false) {
          // 當初次物化流程完成且新物化按鈕不存在時，停止監控
          clearInterval(hideAdvanceBtnInterval);
          console.log('初次物化流程完成，停止繼續按鈕監控');
        }
      }, 50);
      
      // 保存監控器ID到gameState，以便在需要時可以手動清理
      gameState.advanceBtnHideInterval = hideAdvanceBtnInterval;
      
      // 添加延遲檢查，確保繼續按鈕保持隱藏
      setTimeout(() => {
        if (gameState.firstTimeUnlockInProgress) {
          advanceBtn.style.display = 'none';
          console.log('延遲檢查：確保繼續按鈕在初次物化引導期間保持隱藏');
        }
      }, 100);
    }
    
    // 創建初次物化按鈕（在繼續按鈕位置）
    function createFirstTimeTransformationButton(formType) {
      // 移除已存在的初次物化按鈕
      const existingButton = document.getElementById('first-time-transform-btn');
      if (existingButton) {
        existingButton.remove();
      }
      
      // 獲取形態的中文名稱
      const formNames = {
        human: '人形',
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰',
        qi: '氣'
      };
      
      const formName = formNames[formType] || formType;
      
      // 創建初次物化按鈕
      const firstTimeButton = document.createElement('button');
      firstTimeButton.id = 'first-time-transform-btn';
      firstTimeButton.className = 'first-time-transform-button';
      
      // 設置位置和樣式（不使用cssText避免覆蓋）
      firstTimeButton.style.position = 'fixed';
      firstTimeButton.style.top = '50%';
      firstTimeButton.style.left = '50%';
      firstTimeButton.style.transform = 'translate(-50%, -50%)';
      firstTimeButton.style.marginTop = '100px'; // 微調位置，避免與引導窗口重疊
      firstTimeButton.style.zIndex = '30';
      firstTimeButton.style.background = 'linear-gradient(135deg, #fbbf24, #f59e0b)';
      firstTimeButton.style.color = 'white';
      firstTimeButton.style.fontWeight = 'bold';
      firstTimeButton.style.fontSize = '1.1rem';
      firstTimeButton.style.padding = '12px 32px';
      firstTimeButton.style.borderRadius = '50px';
      firstTimeButton.style.border = '3px solid #fcd34d';
      firstTimeButton.style.boxShadow = '0 0 20px rgba(251, 191, 36, 0.6), 0 0 40px rgba(251, 191, 36, 0.3), 0 4px 15px rgba(0, 0, 0, 0.2)';
      firstTimeButton.style.cursor = 'pointer';
      firstTimeButton.style.transition = 'all 0.3s ease';
      firstTimeButton.style.animation = 'first-time-button-glow 2s infinite ease-in-out';
      firstTimeButton.style.overflow = 'hidden';
      
      firstTimeButton.innerHTML = `
        <span class="relative z-10 flex items-center">
          <span class="mr-2 text-xl">✨</span>
          化身為${formName}
          <span class="ml-2 text-xl">✨</span>
        </span>
      `;
      
      // 添加點擊事件
      firstTimeButton.addEventListener('click', () => handleFirstTimeTransformation(formType));
      
      // 添加懸停效果
      firstTimeButton.addEventListener('mouseenter', () => {
        firstTimeButton.style.transform = 'translate(-50%, -50%) scale(1.05)';
        firstTimeButton.style.boxShadow = `
          0 0 30px rgba(251, 191, 36, 0.8),
          0 0 60px rgba(251, 191, 36, 0.4),
          0 6px 20px rgba(0, 0, 0, 0.3)
        `;
      });
      
      firstTimeButton.addEventListener('mouseleave', () => {
        firstTimeButton.style.transform = 'translate(-50%, -50%) scale(1)';
        firstTimeButton.style.boxShadow = `
          0 0 20px rgba(251, 191, 36, 0.6),
          0 0 40px rgba(251, 191, 36, 0.3),
          0 4px 15px rgba(0, 0, 0, 0.2)
        `;
      });
      
      document.body.appendChild(firstTimeButton);
      
      // 添加初次物化按鈕的動畫樣式
      if (!document.getElementById('first-time-button-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'first-time-button-styles';
        styleElement.textContent = `
          @keyframes first-time-button-glow {
            0%, 100% {
              box-shadow: 
                0 0 20px rgba(251, 191, 36, 0.6),
                0 0 40px rgba(251, 191, 36, 0.3),
                0 4px 15px rgba(0, 0, 0, 0.2);
            }
            50% {
              box-shadow: 
                0 0 30px rgba(251, 191, 36, 0.8),
                0 0 60px rgba(251, 191, 36, 0.5),
                0 4px 15px rgba(0, 0, 0, 0.2);
            }
          }
          
          .first-time-transform-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: first-time-button-shine 3s infinite;
          }
          
          @keyframes first-time-button-shine {
            0% { left: -100%; }
            100% { left: 100%; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 處理初次物化
    function handleFirstTimeTransformation(formType) {
      // 執行物化（明確標記為初次物化）
      transformTo(formType, true);
      
      // 移除初次物化按鈕
      const firstTimeButton = document.getElementById('first-time-transform-btn');
      if (firstTimeButton) {
        firstTimeButton.remove();
      }
      
      // 設置物化狀態
      gameState.transformationInProgress = formType;
      
      // 監聽形態變化完成
      checkTransformationProgress();
    }
    
    // 顯示初次物化體驗場景
    function showFirstTimeTransformationExperience(formType) {
      // 獲取對應的物化體驗文本
      const transformationTexts = {
        butterfly: '你化身為蝴蝶，感受到了前所未有的輕盈和自由。世界變得色彩斑斕，每一朵花都散發著誘人的香氣。你的翅膀輕輕扇動，就能在空中自由飛舞。在這夢幻般的體驗中，你開始懷疑：到底是莊周夢見了蝴蝶，還是蝴蝶夢見了莊周？現實與夢境的界限變得模糊，你體會到了什麼叫做「物我兩忘」——在這一刻，你既是人，也是蝶，或者說，你超越了人與蝶的分別。',
        fish: '你化身為儵魚，潛入濠水之中。水下世界與陸地截然不同，所有聲音變得沉悶而遙遠，光線也變得朦朧柔和。水流輕撫著你的魚鰭，你能感受到每一絲水波的律動。在這寧靜的水中世界，時間彷彿變得緩慢而悠長，你終於理解了什麼是真正的「魚之樂」。',
        kun: '你的身體開始膨脹，化為千里之鯤。巨大的魚身讓你能夠感受到海水的每一處細節。你游入漩渦，在北冥的深處暢遊，感受著前所未有的自由。作為鯤，整個海洋都是你的領域，千里之距不過是一個轉身。你體會到了什麼叫做真正的「大」——不是體積的大，而是心境的無限廣闊。',
        peng: '突然，你感到身體劇烈變化，羽翼伸展開來，化身為九萬里大鵬。你騰空而起，風在你的翅膀下咆哮，大地在你腳下快速縮小。你飛得越來越高，直到雲海都在你的下方翻滾。在這無盡的天空中，你感受到了真正的自由——超越一切束縛的自由。你明白了，真正的逍遙不是逃避現實，而是超越現實的局限。',
        yuanchu: '你化身為美麗的鵷鶵，潔白的羽毛在陽光下閃閃發光。你飛翔在清朝的天空中，每一陣風都帶著花香，每一片雲都純淨無瑕。在這聖潔的視角中，你看到了世界最美好的一面。你體會到什麼是真正的純潔與高貴——不是外在的裝飾，而是內在的清明。',
        chixiao: '夜幕降臨，你化身為鴟鴞，在黑暗中翱翔。你的眼睛在夜色中閃閃發光，能夠看清黑暗中的一切。在這靜謐的夜晚，你感受到了不同於白日的寧靜與智慧。你明白了，黑暗並不可怕，它只是另一種光明。在鴟鴞的視角中，夜晚充滿了神秘的美。',
        snail: '你化身為蝸牛，世界突然變得遼闊而深邃。你的觸角上承載著兩個完整的文明——左角是觸氏國，右角是蠻氏國。你能同時感受到兩國的戰爭震動、人民的呼喊、土地的爭奪。在這種承載者的視角中，你體會到了什麼叫做「包容」和「超越」——不是被動地承受，而是以更高的智慧去理解這場爭論的本質。你意識到，對你來說，這不過是觸角上的微小騷動，但對他們而言，卻是整個世界的存亡之戰。',
        'morning-fungus': '你化身為朝菌，體驗著短暫而燦爛的生命。從黎明到日落，就是你的一生。在這短暫的時光中，你感受到了生命的珍貴與美好。你明白了，生命的意義不在於長短，而在於是否活得充實與精彩。',
        cicada: '你化身為蟪蛄，感受著夏日的熱情。你的歌聲響徹樹林，每一聲鳴叫都是對生命的讚美。雖然生命短暫，但你活得熱烈而真實。你體會到了什麼叫做活在當下，珍惜每一刻的美好。',
        'great-chun': '你的意識擴展，化身為大椿樹，感受著千年的時光流逝。你看著四季更替，看著世間變遷，心中充滿了古老的智慧。作為大椿，你體會到了什麼叫做永恆與包容——不是拒絕變化，而是包容一切變化。',
        ant: '你化身為螻蟻，世界突然變得溫暖而踏實。你能感受到大地母親的心跳，泥土的芬芳，根系的力量。作為螻蟻，你明白了什麼叫做「在下」的智慧：不是卑微，而是與大地最親近的連接。死亡對你來說不是恐懼，而是回到這溫暖懷抱的歸宿。在大地的懷抱中，你感受到了生命的踏實和死亡的安詳——它們都是自然循環中不可分割的一部分。',
        star: '你的意識升華，化身為夜空中的星辰。從這無限高遠的視角俯瞰大地，一切都顯得如此渺小而美麗。你感受到了宇宙的廣闊與神秘，體會到了什麼叫做超脫與永恆。在星辰的視角中，你明白了生命的本質是光明。',
        qi: '你化身為氣，身體變得半透明，如雲霧般飄逸。在這超越具象的狀態下，你感受到前所未有的自由。世界在你眼中徹底改變：所有色彩消退，只留下陰陽二氣的純粹對立與統一。每個生命都散發著獨特的氣息，你能感知到它們內在的能量流動。你體會到了「氣者，生之本也」——萬物皆由氣聚散而成，而你已經觸及了存在的根本奧秘。'
      };
      
      const experienceText = transformationTexts[formType] || '你體驗到了全新的物化感受，超越了原有的認知界限。';
      
      // 創建模擬的transformation-experience場景對象
      const experienceScene = {
        type: 'transformation-experience',
        formType: formType,
        text: experienceText
      };
      
      // 清空當前內容並創建物化體驗場景
      gameContent.innerHTML = '';
      advanceBtn.style.display = 'none';
      
      // 隱藏底部日常物化按鈕，避免在體驗打字機效果時的混亂
      hideFormButtons();
      
      // 創建物化體驗場景
      createTransformationExperienceScene(experienceScene);
      
      // 監聽繼續按鈕點擊，結束體驗進入收集場景
      const originalAdvanceHandler = advanceBtn.onclick;
      advanceBtn.onclick = function() {
        // 0. 首先強制停止所有打字機效果
        if (window.currentTypewriterState && window.currentTypewriterState.active) {
          window.currentTypewriterState.stop();
          window.currentTypewriterState = null;
        }
        
        // 1. 移除所有打字機相關元素和背景效果
        const typewriterElements = document.querySelectorAll('.transformation-experience-text, .typewriter-cursor, .transformation-particle');
        typewriterElements.forEach(el => {
          // 清空元素內容以移除文本節點
          if (el.classList.contains('transformation-experience-text')) {
            el.innerHTML = '';
          }
          el.remove();
        });
        
        // 2. 移除物化體驗的背景效果
        const experienceBackgrounds = document.querySelectorAll('.fixed.inset-0.pointer-events-none');
        experienceBackgrounds.forEach(bg => {
          // 只清理物化體驗的背景（包含rgba色彩）
          if ((bg.style.background && bg.style.background.includes('rgba')) || 
              (bg.style.backgroundColor && bg.style.backgroundColor.includes('rgba'))) {
            bg.remove();
            console.log('清理了物化體驗背景');
          }
        });
        
        // 3. 移除包含transformation-particle的容器
        const particleContainers = document.querySelectorAll('.absolute.inset-0.pointer-events-none');
        particleContainers.forEach(container => {
          // 檢查是否真的包含transformation-particle元素
          if (container.querySelector('.transformation-particle')) {
            container.remove();
            console.log('清理了粒子容器');
          }
        });
        
        // 4. 最後清空gameContent，確保所有內容都被移除
        gameContent.innerHTML = '';
        
        // 5. 重置繼續按鈕
        advanceBtn.style.display = 'none';
        advanceBtn.textContent = '繼續';
        
        // 6. 恢復原始的advance處理器
        advanceBtn.onclick = originalAdvanceHandler;
        
        // 7. 立即進入收集場景，不使用requestAnimationFrame避免延遲
        handleFirstTimeTransformationComplete(formType);
      };
    }
    
    // 處理初次物化完成後的效果
    function handleFirstTimeTransformationComplete(formType) {
      // 立即隱藏底部日常物化按鈕，避免在300ms延遲期間閃現
      hideFormButtons();
      
      // 記住收集的形態類型
      gameState.collectedFormType = formType;
      
      // 清除初次物化狀態，但記住當前形態以備日常物化使用
      gameState.firstTimeUnlockInProgress = false;
      gameState.pendingFormUnlock = null;
      gameState.transformationInProgress = null;
      
      // 清理繼續按鈕隱藏監控器
      if (gameState.advanceBtnHideInterval) {
        clearInterval(gameState.advanceBtnHideInterval);
        gameState.advanceBtnHideInterval = null;
        console.log('清理繼續按鈕隱藏監控器');
      }
      
      console.log(`初次物化完成，當前形態: ${gameState.currentForm}，進入物化收集場景`);
      
      // 確保新按鈕在此時還是隱藏的
      const targetButton = formButtons[formType];
      if (targetButton) {
        targetButton.style.visibility = 'hidden';
        targetButton.classList.add('hidden');
      }
      
      // 延遲足夠時間確保所有清理和DOM操作完成，然後創建獨立的物化能力收集場景
      setTimeout(() => {
        console.log('延遲後開始創建收集場景');
        showFormCollectionScene(formType);
      }, 300);
    }
    
    // 顯示物化能力收集場景（作為獨立場景）
    function showFormCollectionScene(formType) {
      const formNames = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰',
        qi: '氣'
      };
      
      const emojiFormMap = {
                    human: '🧘🏻‍♀️',
        butterfly: '🦋',
        fish: '🐟',
        kun: '🐋',
        peng: '🦅',
        yuanchu: '🦚',
        chixiao: '🦉',
        bird: '🦅',
        snail: '🐌',
        'morning-fungus': '🍄',
        cicada: '🦗',
        'great-chun': '🌳',
        ant: '🐜',
        star: '⭐',
        qi: '💨'
      };
      
      const formName = formNames[formType] || formType;
      const formEmoji = emojiFormMap[formType] || '🌟';
      
      // 強化清理邏輯，確保沒有打字機文字殘留
      console.log('開始創建物化收集場景');
      
      // 確保打字機狀態已停止
      if (window.currentTypewriterState && window.currentTypewriterState.active) {
        window.currentTypewriterState.stop();
        window.currentTypewriterState = null;
      }
      
      // 再次清理可能殘留的打字機元素
      const remainingTypewriterElements = document.querySelectorAll('.transformation-experience-text, .typewriter-cursor');
      remainingTypewriterElements.forEach(el => {
        // 清空元素內容以移除文本節點
        if (el.classList.contains('transformation-experience-text')) {
          el.innerHTML = '';
        }
          el.remove();
      });
      
      // 強制清空gameContent確保完全乾淨
      gameContent.innerHTML = '';
      
      // 隱藏底部繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 隱藏segment按鈕
      if (document.getElementById('segment-buttons')) {
        document.getElementById('segment-buttons').style.display = 'none';
      }
      
      // 隱藏底部日常物化按鈕，避免在收集場景中的混亂
      hideFormButtons();
      
      // 注意：不再清空gameContent，因為前面已經精確清理了打字機元素
      
      // 創建物化能力收集場景內容
      const collectionElement = document.createElement('div');
      collectionElement.className = 'max-w-2xl mx-auto p-6 text-left';
      collectionElement.id = 'form-collection-scene'; // 添加ID便於識別
      collectionElement.style.position = 'relative'; // 確保z-index生效
      collectionElement.style.zIndex = '99999'; // 設置超高z-index確保在所有元素之上
      
      collectionElement.innerHTML = `
        <div class="bg-gradient-to-br from-green-50 to-emerald-100 dark:from-green-900 dark:to-emerald-900 
                    border-2 border-green-400 dark:border-green-600 rounded-2xl p-8 shadow-2xl
                    text-center">
          <!-- 頂部圖標區域 -->
          <div class="mb-6">
            <div class="w-20 h-20 mx-auto bg-gradient-to-br from-green-400 to-emerald-500 rounded-full flex items-center justify-center shadow-lg animate-bounce">
              <span class="text-3xl">${formEmoji}</span>
            </div>
          </div>
          
          <!-- 標題 -->
          <h1 class="text-2xl font-bold text-green-800 dark:text-green-200 mb-4">
            🎉 物化能力已收集！🎉
          </h1>
          
          <!-- 形態名稱 -->
          <div class="mb-6">
            <div class="inline-block bg-gradient-to-r from-green-500 to-emerald-500 text-white px-6 py-3 rounded-full font-bold text-lg shadow-lg">
              ${formName}
            </div>
          </div>
          
          <!-- 描述文字 -->
          <p class="text-lg text-green-700 dark:text-green-300 mb-6 leading-relaxed">
            <span class="font-bold">${formName}</span> 的物化能力已成功加入你的日常物化選單！<br>
            從現在開始，你可以隨時體驗這種生物的獨特視角。
          </p>
          
          <!-- 裝飾元素 -->
          <div class="flex justify-center items-center space-x-4 mb-6 text-xl">
            <span class="animate-pulse">✨</span>
            <span class="animate-bounce">🌟</span>
            <span class="animate-pulse delay-75">💫</span>
            <span class="animate-bounce delay-150">⭐</span>
            <span class="animate-pulse delay-300">✨</span>
          </div>
        </div>
      `;
      
      gameContent.appendChild(collectionElement);
      console.log('收集場景已創建');
      
      // 顯示特殊的繼續按鈕
      advanceBtn.style.display = 'block';
      advanceBtn.textContent = '繼續';
      
             // 重新綁定繼續按鈕事件
       const originalAdvanceHandler = advanceBtn.onclick;
       advanceBtn.onclick = function() {
         // 恢復遊戲內容區域和按鈕
         if (document.getElementById('segment-buttons')) {
           document.getElementById('segment-buttons').style.display = 'block';
         }
         
         // 檢查是否為氣形態：氣形態收集完成後不恢復日常物化按鈕
         if (formType !== 'qi') {
           showFormButtons();
         } else {
           console.log('氣形態收集完成，保持日常物化按鈕隱藏');
         }
         
         // 確保新形態在解鎖列表中（可能在 unlockForm 中已添加）
         if (!gameState.unlockedForms.includes(formType)) {
           gameState.unlockedForms.push(formType);
           
           // 立即保存遊戲進度，確保形態解鎖數據不丟失
           saveGameProgress();
           
           console.log(`形態 ${formType} 已添加到解鎖列表`);
         } else {
           console.log(`形態 ${formType} 已在解鎖列表中，現在激活按鈕顯示`);
         }
         
         // 強制顯示新解鎖的按鈕，確保鴟鴞等新形態按鈕能正確顯示
         if (formButtons[formType]) {
           formButtons[formType].classList.remove('hidden');
           formButtons[formType].style.visibility = 'visible';
           formButtons[formType].style.display = 'block';
           console.log(`強制顯示 ${formType} 按鈕`);
         }
         
         // 執行簡化的按鈕出現動畫
         animateSimpleButtonAppearance(formType);
         
         // 恢復原始的advance處理器，讓玩家可以手動繼續
         advanceBtn.onclick = originalAdvanceHandler;
         
         // 顯示繼續按鈕，讓玩家手動控制進度
         setTimeout(() => {
           advanceBtn.style.display = 'block';
           advanceBtn.textContent = '繼續';
         }, 2000); // 按鈕動畫完成後顯示繼續按鈕
       };
    }
    

    
    // 簡化的按鈕出現動畫（淡入+發光效果）
    function animateSimpleButtonAppearance(formType) {
      // 確保目標按鈕存在
      const targetButton = formButtons[formType];
      if (!targetButton) return;
      
      // 確保按鈕初始是隱藏的
      targetButton.style.visibility = 'hidden';
      targetButton.classList.add('hidden');
      
      // 顯示按鈕並添加淡入效果
      targetButton.classList.remove('hidden');
      targetButton.style.visibility = 'visible';
      targetButton.style.opacity = '0';
      targetButton.style.transition = 'all 1s ease-in-out';
      
      // 延遲一點開始淡入
          setTimeout(() => {
        targetButton.style.opacity = '1';
        
        // 添加發光效果
        targetButton.style.boxShadow = '0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3)';
        targetButton.style.animation = 'simple-form-glow 3s ease-in-out';
        
        // 3秒後重置特效
        setTimeout(() => {
          targetButton.style.boxShadow = '';
          targetButton.style.animation = '';
          targetButton.style.transition = '';
        }, 3000);
        
      }, 100);
      
      // 添加簡化的發光動畫樣式
      if (!document.getElementById('simple-form-glow-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'simple-form-glow-styles';
        styleElement.textContent = `
          @keyframes simple-form-glow {
            0% { 
              box-shadow: 0 0 20px rgba(34, 197, 94, 0.6), 0 0 40px rgba(34, 197, 94, 0.3);
            }
            50% { 
              box-shadow: 0 0 30px rgba(34, 197, 94, 0.8), 0 0 60px rgba(34, 197, 94, 0.5);
            }
            100% {
              box-shadow: 0 0 15px rgba(34, 197, 94, 0.4), 0 0 30px rgba(34, 197, 94, 0.2);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 執行按鈕飛入動畫
    function animateButtonFlyIn(formType) {
      // 獲取目標底部按鈕
      const targetButton = formButtons[formType];
      if (!targetButton) return;
      
      // 顯示目標按鈕（如果隱藏的話）
      targetButton.classList.remove('hidden');
      targetButton.style.visibility = 'visible';
      
      // 創建飛行的按鈕副本
      const flyingButton = targetButton.cloneNode(true);
      flyingButton.id = 'flying-button-' + formType;
      flyingButton.style.position = 'fixed';
      flyingButton.style.zIndex = '100';
      flyingButton.style.pointerEvents = 'none';
      
      // 設置起始位置（屏幕中央）
      const startRect = { left: window.innerWidth / 2 - 50, top: window.innerHeight / 2 - 20 };
      flyingButton.style.left = startRect.left + 'px';
      flyingButton.style.top = startRect.top + 'px';
      
      // 添加特殊的飛行效果
      flyingButton.style.boxShadow = '0 0 30px rgba(59, 130, 246, 0.8), 0 0 60px rgba(59, 130, 246, 0.4)';
      flyingButton.style.transform = 'scale(1.2)';
      
      document.body.appendChild(flyingButton);
      
      // 獲取目標位置
      const targetRect = targetButton.getBoundingClientRect();
      
      // 執行飛行動畫
      setTimeout(() => {
        flyingButton.style.transition = 'all 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
        flyingButton.style.left = targetRect.left + 'px';
        flyingButton.style.top = targetRect.top + 'px';
        flyingButton.style.transform = 'scale(1)';
        flyingButton.style.boxShadow = '0 0 15px rgba(59, 130, 246, 0.4)';
        
        // 動畫完成後移除飛行按鈕並突出顯示目標按鈕
        setTimeout(() => {
          flyingButton.remove();
          
          // 突出顯示目標按鈕
          targetButton.style.animation = 'new-form-highlight 2s ease-in-out';
          targetButton.style.boxShadow = '0 0 20px rgba(34, 197, 94, 0.8)';
          
          // 重置按鈕樣式
          setTimeout(() => {
            targetButton.style.animation = '';
            targetButton.style.boxShadow = '';
          }, 2000);
        }, 1500);
      }, 100);
      
      // 添加新形態突出顯示動畫
      if (!document.getElementById('new-form-highlight-styles')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'new-form-highlight-styles';
        styleElement.textContent = `
          @keyframes new-form-highlight {
            0%, 100% { 
              transform: scale(1); 
              box-shadow: 0 0 20px rgba(34, 197, 94, 0.8);
            }
            50% { 
              transform: scale(1.1); 
              box-shadow: 0 0 30px rgba(34, 197, 94, 1), 0 0 60px rgba(34, 197, 94, 0.6);
            }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建退出視角按鈕（日常物化用）
    function createExitTransformationButton() {
      // 移除已存在的退出按鈕
      const existingButton = document.getElementById('exit-transformation-btn');
      if (existingButton) {
        existingButton.remove();
      }
      
      // 創建退出視角按鈕
      const exitButton = document.createElement('button');
      exitButton.id = 'exit-transformation-btn';
      exitButton.className = 'fixed bottom-8 left-1/2 transform -translate-x-1/2 z-30';
      
      // 使用與繼續按鈕相同的樣式和位置
      exitButton.style.cssText = `
        background: linear-gradient(135deg, #6366f1, #4f46e5);
        color: white;
        font-weight: bold;
        font-size: 1rem;
        padding: 10px 24px;
        border-radius: 25px;
        border: 2px solid #818cf8;
        box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
        cursor: pointer;
        transition: all 0.3s ease;
      `;
      
      exitButton.innerHTML = '退出視角';
      
      // 添加點擊事件
      exitButton.addEventListener('click', exitDailyTransformation);
      
      // 添加懸停效果
      exitButton.addEventListener('mouseenter', () => {
        exitButton.style.transform = 'translateX(-50%) scale(1.05)';
        exitButton.style.boxShadow = '0 6px 16px rgba(99, 102, 241, 0.4)';
      });
      
      exitButton.addEventListener('mouseleave', () => {
        exitButton.style.transform = 'translateX(-50%) scale(1)';
        exitButton.style.boxShadow = '0 4px 12px rgba(99, 102, 241, 0.3)';
      });
      
      document.body.appendChild(exitButton);
    }
    
    // 退出日常物化
    function exitDailyTransformation() {
      if (!gameState.isInDailyTransformation) {
        return;
      }
      
      // 獲取應該恢復的形態：直接使用保存的前一形態
      let targetForm = gameState.dailyTransformationPreviousForm || 'human';
      
      console.log(`日常物化退出：從 ${gameState.currentForm} 恢復到 ${targetForm}`);
      
      // 執行返回動畫
      showTransformationTransition(gameState.currentForm, targetForm);
      
      // 移除退出按鈕
      const exitButton = document.getElementById('exit-transformation-btn');
      if (exitButton) {
        exitButton.remove();
      }
      
      // 延遲後恢復狀態
      setTimeout(() => {
        // 恢復之前的形態
        gameState.currentForm = targetForm;
        updateFormView(targetForm);
        
        // 重新激活底部按鈕
        Object.values(formButtons).forEach(button => {
          button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
          button.classList.add('bg-gray-500');
        });
        
        // 高亮當前形態按鈕
        if (formButtons[targetForm]) {
          formButtons[targetForm].classList.remove('bg-gray-500');
          formButtons[targetForm].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }
        
        // 智能恢復繼續按鈕的顯示狀態
        restoreAdvanceBtnAfterDailyTransformation();
        
        // 清除日常物化狀態
        gameState.isInDailyTransformation = false;
        gameState.dailyTransformationPreviousForm = null;
        gameState.dailyTransformationAdvanceBtnVisible = false;
        
        console.log(`日常物化退出完成，恢復到形態: ${targetForm}`);
      }, 1500);
    }
    
    // 智能恢復"繼續"按鈕的顯示狀態
    function restoreAdvanceBtnAfterDailyTransformation() {
      if (!advanceBtn) return;
      
      const currentChapter = gameChapters[gameState.currentChapter];
      if (!currentChapter) return;
      
      const currentScene = currentChapter.scenes[gameState.currentScene];
      if (!currentScene) return;
      
      // 定義哪些場景類型應該顯示"繼續"按鈕
      const sceneTypesThatShowAdvanceBtn = [
        'narrative',
        'cloud-effect', 
        'spiral-effect',
        'time-effect',
        'heaven-earth-effect'
      ];
      
      // 特殊場景類型的處理
      const sceneTypesThatMayShowAdvanceBtn = [
        'dialog' // 對話場景取決於是否有選項
      ];
      
      // 檢查當前場景是否應該顯示"繼續"按鈕
      let shouldShowAdvanceBtn = false;
      
      if (sceneTypesThatShowAdvanceBtn.includes(currentScene.type)) {
        // 這些場景類型通常顯示"繼續"按鈕
        shouldShowAdvanceBtn = true;
      } else if (currentScene.type === 'dialog') {
        // 對話場景：如果沒有選項，顯示"繼續"按鈕
        shouldShowAdvanceBtn = !currentScene.options || currentScene.options.length === 0;
      } else if (currentScene.type === 'segmentation-puzzle') {
        // 斷句挑戰：如果已完成，應該顯示"繼續"按鈕
        shouldShowAdvanceBtn = gameState.segmentationPuzzleState.solved;
      } else {
        // 其他場景類型：檢查是否原本就有"繼續"按鈕
        shouldShowAdvanceBtn = gameState.dailyTransformationAdvanceBtnVisible;
      }
      
      // 根據判斷結果顯示或隱藏按鈕
      if (shouldShowAdvanceBtn) {
        advanceBtn.style.display = 'block';
        console.log(`恢復"繼續"按鈕顯示 - 場景類型: ${currentScene.type}`);
      } else {
        advanceBtn.style.display = 'none';
        console.log(`保持"繼續"按鈕隱藏 - 場景類型: ${currentScene.type}`);
      }
    }
    
    function highlightFormButton(formName) {
      const button = formButtons[formName];
      if (!button) return;
      
      // 移除其他按鈕的高亮效果
      Object.values(formButtons).forEach(btn => {
        btn.classList.remove('form-button-highlight', 'animate-pulse');
        btn.style.animation = '';
        btn.style.boxShadow = '';
      });
      
      // 為指定按鈕添加強烈的高亮效果
      button.classList.add('form-button-highlight');
      
      // 添加呼吸動畫
      button.style.animation = 'form-button-breathe 1.5s infinite ease-in-out';
      
      // 添加發光效果
      button.style.boxShadow = '0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4)';
      
      // 添加CSS動畫樣式（如果還沒有的話）
      if (!document.getElementById('form-highlight-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'form-highlight-animations';
        styleElement.textContent = `
          .form-button-highlight {
            position: relative;
            z-index: 100;
          }
          
          @keyframes form-button-breathe {
            0%, 100% { 
              transform: scale(1); 
              box-shadow: 0 0 20px rgba(59, 130, 246, 0.8), 0 0 40px rgba(59, 130, 246, 0.4);
            }
            50% { 
              transform: scale(1.1); 
              box-shadow: 0 0 30px rgba(59, 130, 246, 1), 0 0 60px rgba(59, 130, 246, 0.6);
            }
          }
          
          .form-button-highlight::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(45deg, #3b82f6, #8b5cf6, #3b82f6);
            border-radius: 12px;
            z-index: -1;
            animation: form-button-glow 2s infinite linear;
          }
          
          @keyframes form-button-glow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建天地特效場景
    function createHeavenEarthEffectScene(scene) {
      const heavenEarthElement = document.createElement('div');
      heavenEarthElement.className = 'max-w-2xl mx-auto p-6 text-left fixed left-1/2 transform -translate-x-1/2 bg-gradient-to-br from-yellow-50 to-blue-100 dark:from-yellow-900 dark:to-blue-900 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border-2 border-yellow-400 dark:border-yellow-600';
      heavenEarthElement.style.top = '1rem'; // 上移文字框位置
      heavenEarthElement.style.zIndex = '70'; // 提高z-index確保在所有背景元素之上
      
      heavenEarthElement.innerHTML = `
        <p class="text-lg md:text-xl leading-relaxed text-yellow-800 dark:text-yellow-200">${scene.text}</p>
      `;
      
      gameContent.appendChild(heavenEarthElement);
      
      // 創建浮現的古老文字效果
      createFloatingAncientText();
      
      // 創建天地背景特效
      createHeavenEarthBackground();
      
        advanceBtn.style.display = 'block';
    }
    
    // 創建浮現的古老文字效果
    function createFloatingAncientText() {
      // 如果第六章斷句挑戰已經出現過，則不再創建浮動文字
      if (gameState.chapter6FloatingTextDisabled) {
        return;
      }
      
      // 清理之前的古老文字
      document.querySelectorAll('.floating-ancient-text').forEach(el => el.remove());
      
      const ancientTextContainer = document.createElement('div');
      ancientTextContainer.className = 'floating-ancient-text';
      ancientTextContainer.style.position = 'fixed';
      ancientTextContainer.style.top = '0';
      ancientTextContainer.style.left = '0';
      ancientTextContainer.style.width = '100%';
      ancientTextContainer.style.height = '100%';
      ancientTextContainer.style.pointerEvents = 'none';
      ancientTextContainer.style.zIndex = '8'; // 在半圓場景上方，但在文字框下方
      ancientTextContainer.style.overflow = 'hidden';
      
      // 古老文字內容 - 莊子的經典語句
      const ancientTexts = [
        '天地為棺槨', '日月為連璧', '星辰為珠璣', '萬物為齎送',
        '在上為烏鳶食', '在下為螻蟻食', '奪彼與此', '何其偏也',
        '生死一如', '物我兩忘', '逍遙自在', '無為而治',
        '道法自然', '齊物論', '莊周夢蝶', '天人合一'
      ];
      
      // 創建多個浮現的文字
      for (let i = 0; i < 12; i++) {
        const textElement = document.createElement('div');
        textElement.className = 'ancient-text-particle';
        
        // 隨機選擇文字
        const text = ancientTexts[Math.floor(Math.random() * ancientTexts.length)];
        textElement.textContent = text;
        
        // 樣式設置
        textElement.style.position = 'absolute';
        textElement.style.fontSize = `${16 + Math.random() * 12}px`; // 16-28px
        textElement.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
        textElement.style.fontWeight = '500';
        textElement.style.color = 'rgba(255, 215, 0, 0.8)'; // 金色，如星光
        textElement.style.textShadow = `
          0 0 10px rgba(255, 215, 0, 0.6),
          0 0 20px rgba(255, 215, 0, 0.4),
          0 0 30px rgba(255, 215, 0, 0.2)
        `;
        textElement.style.whiteSpace = 'nowrap';
        
        // 隨機位置
        textElement.style.left = `${Math.random() * 80 + 10}%`; // 10%-90%
        textElement.style.top = `${Math.random() * 80 + 10}%`; // 10%-90%
        
        // 動畫設置
        textElement.style.opacity = '0';
        textElement.style.transform = 'scale(0.5) translateY(20px)';
        textElement.style.animation = `ancient-text-appear ${4 + Math.random() * 3}s ease-out infinite`;
        textElement.style.animationDelay = `${Math.random() * 5}s`;
        
        ancientTextContainer.appendChild(textElement);
      }
      
      document.body.appendChild(ancientTextContainer);
      
      // 添加古老文字動畫樣式
      if (!document.getElementById('ancient-text-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'ancient-text-animations';
        styleElement.textContent = `
          @keyframes ancient-text-appear {
            0% {
              opacity: 0;
              transform: scale(0.5) translateY(20px);
            }
            20% {
              opacity: 1;
              transform: scale(1) translateY(0);
            }
            80% {
              opacity: 1;
              transform: scale(1) translateY(-10px);
            }
            100% {
              opacity: 0;
              transform: scale(0.8) translateY(-30px);
            }
          }
          
          .ancient-text-particle {
            background: linear-gradient(45deg, 
              rgba(255, 215, 0, 0.1) 0%, 
              rgba(255, 215, 0, 0.05) 50%, 
              rgba(255, 215, 0, 0.1) 100%);
            padding: 4px 8px;
            border-radius: 4px;
            border: 1px solid rgba(255, 215, 0, 0.3);
            backdrop-filter: blur(2px);
          }
        `;
        document.head.appendChild(styleElement);
      }
    }

    function createHeavenEarthBackground() {
      // 清理之前的背景容器
      document.querySelectorAll('.heaven-earth-background-container').forEach(el => el.remove());
      
              // 創建外太空星空
        createSpaceStarfield();
        
        // 創建大氣層粒子
        createAtmosphereParticles();
      
      // 等待半圓形場景類被添加
      setTimeout(() => {
        // 創建日月星辰容器 - 與天空區域完全對應
        const celestialContainer = document.createElement('div');
        celestialContainer.className = 'heaven-earth-celestial-container';
      
      // 創建日月 - 向下移動以配合半圓形的位置調整
      const sun = document.createElement('div');
      sun.style.position = 'absolute';
      sun.style.fontSize = '80px';
              sun.style.left = '20%';
        sun.style.top = '10%'; // 確保在半圓上半部分
        sun.style.animation = 'sun-glow 6s infinite ease-in-out';
        sun.style.zIndex = '20'; // 確保在半圓內顯示
        sun.textContent = '☀️';
        
        const moon = document.createElement('div');
        moon.style.position = 'absolute';
        moon.style.fontSize = '70px';
        moon.style.right = '20%';
        moon.style.top = '15%'; // 確保在半圓上半部分
        moon.style.animation = 'moon-glow 8s infinite ease-in-out';
        moon.style.zIndex = '20'; // 確保在半圓內顯示
        moon.textContent = '🌙';
      
      // 創建星辰 - 向下移動以配合半圓形的位置調整
      for (let i = 0; i < 20; i++) {
        const star = document.createElement('div');
        star.style.position = 'absolute';
        star.style.fontSize = `${8 + Math.random() * 12}px`; // 縮小星星大小：8-20px
        star.style.left = `${Math.random() * 100}%`;
                  star.style.top = `${Math.random() * 50}%`; // 限制在半圓上半部分
          star.style.animation = `star-twinkle ${2 + Math.random() * 3}s infinite ease-in-out`;
          star.style.animationDelay = `${Math.random() * 2}s`;
          star.style.zIndex = '20'; // 確保在半圓內顯示
          star.textContent = '⭐';
        celestialContainer.appendChild(star);
      }
      
              // 創建地面植物容器 - 位於地平線上，限制在半圓範圍內
        const earthContainer = document.createElement('div');
        earthContainer.className = 'earth-elements-container';
        earthContainer.style.position = 'absolute';
        earthContainer.style.bottom = '0px'; // 貼合地平線
        earthContainer.style.left = '50%';
        earthContainer.style.transform = 'translateX(-50%)';
        earthContainer.style.width = '67vw'; // 與半圓寬度相同
        earthContainer.style.height = '50px';
        earthContainer.style.zIndex = '30';
        earthContainer.style.pointerEvents = 'none';
        earthContainer.style.clipPath = 'ellipse(50% 100% at 50% 100%)'; // 限制在半圓範圍內
        

        
        // 創建草原 - 水平方向擺滿麥穗
        for (let i = 0; i < 25; i++) {
          const grass = document.createElement('div');
          grass.style.position = 'absolute';
          grass.style.fontSize = `${18 + Math.random() * 12}px`; // 18-30px隨機大小
          grass.style.left = `${(i * 4) + Math.random() * 3}%`; // 水平均勻分佈，稍加隨機
          grass.style.bottom = '0px'; // 貼合地平線
          grass.style.animation = `earth-sway ${2 + Math.random() * 3}s infinite ease-in-out`;
          grass.style.animationDelay = `${Math.random() * 2}s`;
          grass.style.filter = 'drop-shadow(0 1px 3px rgba(0,0,0,0.2))';
          grass.style.zIndex = '20'; // 在山脈之下
          grass.textContent = '🌾';
          earthContainer.appendChild(grass);
        }
      
      celestialContainer.appendChild(sun);
      celestialContainer.appendChild(moon);
      
      // 添加動畫樣式
      if (!document.getElementById('heaven-earth-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'heaven-earth-animations';
        styleElement.textContent = `
          @keyframes sun-glow {
            0%, 100% { 
              filter: drop-shadow(0 0 20px rgba(255, 215, 0, 0.8));
              transform: scale(1);
            }
            50% { 
              filter: drop-shadow(0 0 40px rgba(255, 215, 0, 1));
              transform: scale(1.1);
            }
          }
          
          @keyframes moon-glow {
            0%, 100% { 
              filter: drop-shadow(0 0 15px rgba(192, 192, 192, 0.8));
              transform: scale(1);
            }
            50% { 
              filter: drop-shadow(0 0 30px rgba(192, 192, 192, 1));
              transform: scale(1.05);
            }
          }
          
          @keyframes star-twinkle {
            0%, 100% { 
              opacity: 0.6;
              transform: scale(1);
            }
            50% { 
              opacity: 1;
              transform: scale(1.2);
            }
          }
          
          @keyframes earth-sway {
            0%, 100% { transform: rotate(-2deg); }
            50% { transform: rotate(2deg); }
          }
        `;
        document.head.appendChild(styleElement);
      }
      
              // 將容器添加到半圓形場景中
        const heavenEarthScene = document.querySelector('.heaven-earth-scene');
        if (heavenEarthScene) {
          heavenEarthScene.appendChild(celestialContainer);
          // 地面容器添加到日月星辰容器中，確保在半圓範圍內
          celestialContainer.appendChild(earthContainer);
        } else {
          gameContainer.appendChild(celestialContainer);
          celestialContainer.appendChild(earthContainer);
        }
      }, 100); // 延遲100ms確保場景類已被添加
    }
    
    // 創建外太空星空粒子動畫
    function createSpaceStarfield() {
      // 清理之前的星空
      document.querySelectorAll('.space-starfield').forEach(el => el.remove());
      
      const starfield = document.createElement('div');
      starfield.className = 'space-starfield';
      
      // 創建不同顏色和大小的星星粒子
      const colors = ['yellow', 'blue', 'white'];
      const starCount = 150; // 星星數量
      
      for (let i = 0; i < starCount; i++) {
        const star = document.createElement('div');
        star.className = `space-star ${colors[Math.floor(Math.random() * colors.length)]}`;
        
        // 隨機大小 (1-4px)
        const size = Math.random() * 3 + 1;
        star.style.width = `${size}px`;
        star.style.height = `${size}px`;
        
        // 隨機位置
        star.style.left = `${Math.random() * 100}%`;
        star.style.top = `${Math.random() * 100}%`;
        
        // 隨機閃爍延遲
        star.style.animationDelay = `${Math.random() * 3}s`;
        
        // 隨機閃爍持續時間
        star.style.animationDuration = `${2 + Math.random() * 4}s`;
        
        starfield.appendChild(star);
      }
      
      document.body.appendChild(starfield);
      
      // 創建大氣層粒子效果
      createAtmosphereParticles();
    }
    
    // 創建大氣層粒子效果
    function createAtmosphereParticles() {
      // 清理之前的大氣層粒子
      document.querySelectorAll('.atmosphere-particles').forEach(el => el.remove());
      
      const atmosphereContainer = document.createElement('div');
      atmosphereContainer.className = 'atmosphere-particles';
      atmosphereContainer.style.position = 'fixed';
      atmosphereContainer.style.top = '0';
      atmosphereContainer.style.left = '0';
      atmosphereContainer.style.width = '100%';
      atmosphereContainer.style.height = '100%';
      atmosphereContainer.style.zIndex = '4'; // 在半圓場景下面，但在外太空背景上面
      atmosphereContainer.style.pointerEvents = 'none';
      atmosphereContainer.style.overflow = 'hidden';
      
      // 創建大氣層粒子
      for (let i = 0; i < 30; i++) {
        const particle = document.createElement('div');
        particle.className = 'atmosphere-particle';
        
        // 隨機大小和位置
        const size = Math.random() * 3 + 1;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        particle.style.position = 'absolute';
        particle.style.borderRadius = '50%';
        particle.style.background = `rgba(135, 206, 235, ${0.3 + Math.random() * 0.4})`;
        particle.style.boxShadow = `0 0 ${size * 2}px rgba(135, 206, 235, 0.5)`;
        
        // 隨機位置（集中在半圓邊緣附近）
        const angle = Math.random() * Math.PI; // 0 到 π 弧度（半圓）
        const radius = 45 + Math.random() * 10; // 在半圓邊緣附近
        const centerX = 50; // 頁面中心
        const centerY = 50; // 調整到合適的垂直位置
        
        const x = centerX + radius * Math.cos(angle);
        const y = centerY - radius * Math.sin(angle) * 0.5; // 壓縮Y軸以匹配橢圓
        
        particle.style.left = `${x}%`;
        particle.style.top = `${y}%`;
        
        // 隨機動畫
        particle.style.animation = `atmosphere-particle-float ${3 + Math.random() * 4}s ease-in-out infinite`;
        particle.style.animationDelay = `${Math.random() * 3}s`;
        
        atmosphereContainer.appendChild(particle);
      }
      
      document.body.appendChild(atmosphereContainer);
    }
    
    // 創建虛空場景
    function createVoidScene() {
      // 清理之前的虛空場景元素
              document.querySelectorAll('.void-particles, .chaos-form, .taiji-container, .bagua-symbols, .bagua-floating-text').forEach(el => el.remove());
      
      // 創建虛空粒子系統
      createVoidParticles();
      
      // 創建八卦符號系統
      createBaguaSymbols();
      
      // 創建八卦中文字懸浮效果
      createBaguaFloatingText();
      
      // 創建中央虛空殿
      createVoidPalace();
      
      // 創建太極符號
      createTaijiSymbol();
    }
    
    // 創建虛空粒子系統
    function createVoidParticles() {
      const particleContainer = document.createElement('div');
      particleContainer.className = 'void-particles';
      
      // 前六章的主色調
      const chapterColors = [
        '#5D5CDE', // 序章 - 靛藍
        '#40BAD5', // 第一章 - 青
        '#2C7744', // 第二章 - 綠  
        '#8B4513', // 第三章 - 棕
        '#DAA520', // 第四章 - 琥珀
        '#DC143C'  // 第五章 - 紅
      ];
      
      // 創建50個粒子
      for (let i = 0; i < 50; i++) {
        const particle = document.createElement('div');
        particle.className = 'void-particle';
        
        // 隨機大小
        const size = Math.random() * 4 + 2;
        particle.style.width = `${size}px`;
        particle.style.height = `${size}px`;
        
        // 隨機位置
        particle.style.left = `${Math.random() * 100}%`;
        particle.style.top = `${Math.random() * 100}%`;
        
        // 隨機顏色（前六章色調）
        const color = chapterColors[Math.floor(Math.random() * chapterColors.length)];
        particle.style.background = color;
        particle.style.boxShadow = `0 0 ${size * 2}px ${color}`;
        
        // 隨機動畫延遲
        particle.style.animationDelay = `${Math.random() * 15}s`;
        particle.style.animationDuration = `${10 + Math.random() * 10}s`;
        
        particleContainer.appendChild(particle);
      }
      
      gameContainer.appendChild(particleContainer);
    }
    
    // 創建中央渾沌形體
    function createVoidPalace() {
      // 直接創建渾沌形體，不需要宮殿容器
      const chaosForm = document.createElement('div');
      chaosForm.className = 'chaos-form';
      chaosForm.title = '點擊觸摸渾沌，感受往事的記憶';
      chaosForm.style.position = 'absolute';
      chaosForm.style.top = '50%';
      chaosForm.style.left = '50%';
      chaosForm.style.transform = 'translate(-50%, -50%)';
      chaosForm.style.zIndex = '10';
      
      gameContainer.appendChild(chaosForm);
    }
    
    // 創建太極符號（只有轉動的太極符號，不包含游動的陰陽魚）
    function createTaijiSymbol() {
      const taijiContainer = document.createElement('div');
      taijiContainer.className = 'taiji-container';
      // 初始時隱藏太極符號，等待太極拼圖完成後顯示
      taijiContainer.style.display = 'none';
      
      const yinYangEmoji = document.createElement('div');
      yinYangEmoji.className = 'yin-yang-emoji';
      yinYangEmoji.textContent = '☯︎';
      
      taijiContainer.appendChild(yinYangEmoji);
      gameContainer.appendChild(taijiContainer);
    }
    
    // 顯示太極符號（太極拼圖完成後調用）
    function showTaijiSymbol() {
      const taijiContainer = document.querySelector('.taiji-container');
      if (taijiContainer) {
        // 創建顯現動畫效果
        taijiContainer.style.display = 'block';
        taijiContainer.style.opacity = '0';
        taijiContainer.style.transform = 'translateX(-50%) scale(0.3)';
        taijiContainer.style.transition = 'all 2s ease-out';
        
        // 延遲一下再開始動畫，讓玩家注意到
        setTimeout(() => {
          taijiContainer.style.opacity = '1';
          taijiContainer.style.transform = 'translateX(-50%) scale(1)';
        }, 100);
        
        // 動畫完成後移除transition，恢復正常的旋轉動畫
        setTimeout(() => {
          taijiContainer.style.transition = '';
        }, 2100);
      }
    }
    
    // 創建八卦符號系統
    function createBaguaSymbols() {
      const baguaContainer = document.createElement('div');
      baguaContainer.className = 'bagua-symbols';
      
      // 八卦符號數據
      const baguaData = [
        { symbol: '☰', name: 'qian', title: '乾-天', element: '天' },
        { symbol: '☱', name: 'dui', title: '兌-澤', element: '澤' },
        { symbol: '☲', name: 'li', title: '離-火', element: '火' },
        { symbol: '☳', name: 'zhen', title: '震-雷', element: '雷' },
        { symbol: '☴', name: 'xun', title: '巽-風', element: '風' },
        { symbol: '☵', name: 'kan', title: '坎-水', element: '水' },
        { symbol: '☶', name: 'gen', title: '艮-山', element: '山' },
        { symbol: '☷', name: 'kun', title: '坤-地', element: '地' }
      ];
      
      // 檢查是否處於萬物尋氣模式
      const isWanwuXunqiMode = gameState.wanwuXunqiActive;
      
      // 創建定期生成八卦符號的函數
      function createBaguaSymbol() {
        let selectedBagua;
        if (isWanwuXunqiMode && gameState.currentBaguaCollection) {
          const neededBagua = gameState.currentBaguaCollection.neededBagua;
          const collected = gameState.currentBaguaCollection.collected || [];
          const stillNeed = neededBagua.filter(element => !collected.includes(element));
          if (stillNeed.length > 0 && Math.random() < 0.7) {
            const neededElement = stillNeed[Math.floor(Math.random() * stillNeed.length)];
            selectedBagua = baguaData.find(bagua => bagua.element === neededElement);
          } else {
            selectedBagua = baguaData[Math.floor(Math.random() * baguaData.length)];
          }
        } else {
          selectedBagua = baguaData[Math.floor(Math.random() * baguaData.length)];
        }
        const symbol = document.createElement('div');
        symbol.className = `bagua-symbol bagua-${selectedBagua.name}`;
        symbol.textContent = selectedBagua.symbol;
        symbol.title = selectedBagua.title;
        
        // 存儲八卦數據到元素上
        symbol.baguaData = selectedBagua;
        
        // 隨機水平位置
        symbol.style.left = `${Math.random() * 100}%`;
        symbol.style.top = `${Math.random() * 100}%`;
        
        // 隨機動畫延遲和持續時間
        const duration = 20 + Math.random() * 10; // 20-30秒
        const delay = Math.random() * 5; // 0-5秒延遲
        symbol.style.animationDuration = `${duration}s`;
        symbol.style.animationDelay = `${delay}s`;
        
        // 如果是萬物尋氣模式，讓符號可點擊
        if (isWanwuXunqiMode) {
          symbol.style.pointerEvents = 'auto';
          symbol.style.cursor = 'pointer';
          symbol.style.zIndex = '15'; // 確保在其他元素之上
          
          // 添加點擊事件
          symbol.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('八卦符號被點擊:', this.baguaData);
            
            // 顯示元素字彈出效果
            showElementPopup(this, this.baguaData.element);
            
            // 處理點擊邏輯
            handleBaguaSymbolClick(this);
          });
          
          // 添加懸停效果
          symbol.addEventListener('mouseenter', function() {
            this.style.transform += ' scale(1.3)';
            this.style.filter += ' brightness(1.5)';
          });
          
          symbol.addEventListener('mouseleave', function() {
            this.style.transform = this.style.transform.replace(' scale(1.3)', '');
            this.style.filter = this.style.filter.replace(' brightness(1.5)', '');
          });
        }
        
        baguaContainer.appendChild(symbol);
        
        // 動畫結束後移除元素
        setTimeout(() => {
          if (symbol.parentNode) {
            symbol.remove();
          }
        }, (duration + delay) * 1000);
      }
      
      // 初始創建一些八卦符號
      for (let i = 0; i < 3; i++) {
        setTimeout(() => createBaguaSymbol(), i * 2000);
      }
      
      // 定期創建新的八卦符號
      const baguaInterval = setInterval(() => {
        // 檢查容器是否還存在
        if (document.contains(baguaContainer)) {
          // 限制同時存在的符號數量
          const existingSymbols = baguaContainer.querySelectorAll('.bagua-symbol');
          if (existingSymbols.length < 6) {
            createBaguaSymbol();
          }
        } else {
          // 如果容器被移除，清除定時器
          clearInterval(baguaInterval);
        }
      }, 2000); // 每2秒嘗試創建一個新符號
      
      // 將定時器ID存儲到容器上，以便清理
      baguaContainer.baguaInterval = baguaInterval;
      
      gameContainer.appendChild(baguaContainer);
    }
    
    // 處理八卦符號點擊事件
    function handleBaguaSymbolClick(symbolElement) {
      console.log('handleBaguaSymbolClick 被調用，wanwuXunqiActive:', gameState.wanwuXunqiActive);
      if (!gameState.wanwuXunqiActive) {
        console.log('萬物尋氣模式未啟動');
        return;
      }
      
      const baguaData = symbolElement.baguaData;
      const currentForm = gameState.currentForm;
      
      // 檢查當前物化形態是否需要這個八卦符號
      const currentCollection = gameState.currentBaguaCollection;
      if (!currentCollection || !currentCollection.neededBagua) {
        showMessage('請先進入物化視野開始收集！');
        return;
      }
      
      // 檢查是否是需要的八卦符號
      const neededBagua = currentCollection.neededBagua;
      const alreadyCollected = currentCollection.collected || [];
      
      if (neededBagua.includes(baguaData.element)) {
        // 檢查是否已經收集過這種氣
        if (alreadyCollected.includes(baguaData.element)) {
          showMessage(`${baguaData.element} 之氣已經收集過了！`);
          return;
        }
        // 收集成功
        collectBaguaSymbol(baguaData, symbolElement);
      } else {
        // 收集錯誤
        showBaguaCollectionError(baguaData, neededBagua);
      }
    }
    
    // 收集八卦符號
    function collectBaguaSymbol(baguaData, symbolElement) {
      // 創建收集動畫
      createBaguaCollectionAnimation(symbolElement, baguaData);
      
      // 更新收集狀態
      if (!gameState.currentBaguaCollection.collected) {
        gameState.currentBaguaCollection.collected = [];
      }
      gameState.currentBaguaCollection.collected.push(baguaData.element);
      gameState.baguaCollectionCount++;
      
      // 移除符號元素
      symbolElement.remove();
      
      // 更新詩意謎題窗口中的進度顯示
      updateRiddleCollectionProgress();
      
      // 檢查是否收集完成
      const collected = gameState.currentBaguaCollection.collected;
      const needed = gameState.currentBaguaCollection.neededBagua;
      
      if (collected.length >= 3) {
        // 完成當前物化形態的收集
        setTimeout(() => {
          completeBaguaCollection();
        }, 1000);
      } else {
        // 顯示進度
        showBaguaCollectionProgress(collected, needed);
      }
    }
    
    // 創建八卦收集動畫
    function createBaguaCollectionAnimation(symbolElement, baguaData) {
      // 創建收集效果
      const collectEffect = document.createElement('div');
      collectEffect.className = 'bagua-collect-effect';
      collectEffect.style.position = 'fixed';
      collectEffect.style.left = symbolElement.getBoundingClientRect().left + 'px';
      collectEffect.style.top = symbolElement.getBoundingClientRect().top + 'px';
      collectEffect.style.fontSize = '48px';
      collectEffect.style.color = symbolElement.style.color || '#FFD700';
      collectEffect.style.textShadow = symbolElement.style.textShadow;
      collectEffect.style.zIndex = '9999';
      collectEffect.style.pointerEvents = 'none';
      collectEffect.textContent = baguaData.symbol;
      
      document.body.appendChild(collectEffect);
      
      // 動畫效果
      collectEffect.style.animation = 'bagua-collect 1.5s ease-out forwards';
      
      // 添加收集動畫樣式
      if (!document.getElementById('bagua-collect-animation')) {
        const styleEl = document.createElement('style');
        styleEl.id = 'bagua-collect-animation';
        styleEl.textContent = `
          @keyframes bagua-collect {
            0% {
              transform: scale(1) rotate(0deg);
              opacity: 1;
            }
            50% {
              transform: scale(1.5) rotate(180deg);
              opacity: 0.8;
            }
            100% {
              transform: scale(0.3) rotate(360deg) translateY(-100px);
              opacity: 0;
            }
          }
        `;
        document.head.appendChild(styleEl);
      }
      
      // 清理動畫元素
      setTimeout(() => {
        collectEffect.remove();
      }, 1500);
      
      // 顯示收集提示
      showMessage(`收集到 ${baguaData.element} 之氣！`);
    }
    
    // 顯示八卦收集錯誤
    function showBaguaCollectionError(baguaData, neededBagua) {
      showMessage(`這不是當前需要的氣。需要：${neededBagua.join('、')}`);
    }
    
    // 顯示八卦收集進度
    function showBaguaCollectionProgress(collected, needed) {
      const remaining = 3 - collected.length;
      showMessage(`已收集 ${collected.length}/3 個氣，還需 ${remaining} 個`);
    }
    
    // 完成八卦收集
    function completeBaguaCollection() {
      const formName = getFormName(gameState.currentBaguaCollection.formType);
      showMessage(`恭喜！已收集完成${formName}的三氣！`);
      
      // 清理可能存在的收集狀態界面
      const statusUI = document.getElementById('collection-status-ui');
      if (statusUI) statusUI.remove();
      
      // 移除詩意謎題窗口
      if (gameState.baguaCollectionGuideOverlay) {
        gameState.baguaCollectionGuideOverlay.remove();
        gameState.baguaCollectionGuideOverlay = null;
      }
      
      // 更新萬物尋氣進度
      if (!gameState.wanwuXunqiProgress) {
        gameState.wanwuXunqiProgress = [];
      }
      gameState.wanwuXunqiProgress.push(gameState.currentBaguaCollection.formType);
      
      // 重置當前收集狀態
      gameState.currentBaguaCollection = null;
      
      // 更新萬物尋氣引導界面進度
      if (gameState.updateWanwuXunqiProgress) {
        gameState.updateWanwuXunqiProgress();
      }
      
      // 檢查是否完成所有收集
      if (gameState.wanwuXunqiProgress.length >= 12) {
        // 完成萬物尋氣，解鎖氣形態
        completeWanwuXunqi();
      } else {
        // 繼續下一個物化形態
        setTimeout(() => {
          // 回到人形
          if (gameState.currentForm !== 'human') {
            gameState.currentForm = 'human';
            updateFormView('human');
            
            // 更新按鈕狀態
            Object.values(formButtons).forEach(button => {
              if (button) {
                button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                button.classList.add('bg-gray-500');
              }
            });
            
            if (formButtons['human']) {
              formButtons['human'].classList.remove('bg-gray-500');
              formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
            }
          }
          
          // 重新顯示物化按鈕，讓用戶可以繼續點擊下一個形態
          const formSelector = document.querySelector('.form-selector');
          if (formSelector) {
            formSelector.style.display = 'flex';
            console.log('回到指引階段：已重新顯示物化按鈕');
          }
          
          // 重新顯示萬物尋氣引導窗口
          if (gameState.wanwuXunqiGuideContainer) {
            gameState.wanwuXunqiGuideContainer.style.display = 'block';
          }
          
          showMessage('請繼續點擊下一個物化形態進行尋氣！');
        }, 2000);
      }
    }
    
    // 完成萬物尋氣
    function completeWanwuXunqi() {
      gameState.wanwuXunqiActive = false;
      
      // 如果玩家目前在星辰視角，自動回歸到人視角
      if (gameState.currentForm === 'star') {
        console.log('萬物尋氣完成：從星辰視角自動回歸到人視角');
        
        // 顯示過渡動畫
        showTransformationTransition('star', 'human');
        
        // 更新遊戲狀態
        setTimeout(() => {
          gameState.currentForm = 'human';
          
          // 更新物化按鈕狀態
          Object.values(formButtons).forEach(button => {
            button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            button.classList.add('bg-gray-500');
          });
          
          // 高亮人形態按鈕
          if (formButtons['human']) {
            formButtons['human'].classList.remove('bg-gray-500');
            formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
          }
          
          // 更新視圖顯示
          updateFormView('human');
          
          console.log('萬物尋氣完成：已自動回歸到人視角');
        }, 1500);
      }
      
      // 重新顯示物化按鈕
      const formSelector = document.querySelector('.form-selector');
      if (formSelector) {
        formSelector.style.display = 'flex';
        console.log('萬物尋氣完成：已重新顯示物化按鈕');
      }
      
      // 移除直接解鎖氣形態的邏輯，讓標準流程處理
      // unlockForm('qi'); // ❌ 刪除此行
      
      showMessage('萬物尋氣完成！萬物之氣已聚，準備解鎖終極物化形態...');
      
      setTimeout(() => {
        advanceBtn.style.display = 'block';
        advanceBtn.textContent = '獲得氣之力量';
      }, 3000);
    }
    
    // 開始八卦收集
    function startBaguaCollection(formType) {
      console.log('startBaguaCollection 被調用，formType:', formType);
      
      // 12個物化形態的八卦收集配置
      const baguaCollectionConfig = {
        butterfly: {
          riddle: '隨氣流起舞花間，追光如炽不倦，翩跹直上雲端。',
          neededBagua: ['風', '火', '天'],
          hint: '蝴蝶象徵變化與自由，需要風的輕盈、火的光明、天的高遠'
        },
        fish: {
          riddle: '游於清波，棲於深潭，依土而安。',
          neededBagua: ['水', '澤', '地'],
          hint: '魚兒生活在水中，需要水的滋養、澤的降臨、地的承載'
        },
        kun: {
          riddle: '潛於滄海，伏於海底，重如峰巒。',
          neededBagua: ['水', '地', '山'],
          hint: '鯤在深海中，需要水的深邃、地的厚重、山的穩固'
        },
        peng: {
          riddle: '翱翔九霄，乘氣流萬里，振翅如轟鳴。',
          neededBagua: ['天', '風', '雷'],
          hint: '鵬鳥飛翔天際，需要天的廣闊、風的助力、雷的威勢'
        },
        yuanchu: {
          riddle: '聖潔如霄，光明似炬，高潔如峰。',
          neededBagua: ['天', '火', '山'],
          hint: '鵷鶵聖潔高貴，需要天的純淨、火的光明、山的正直'
        },
        chixiao: {
          riddle: '夜獵濕處，月下臨流，棲於平野。',
          neededBagua: ['澤', '水', '地'],
          hint: '鴟鴞夜間活動，需要澤的滋潤、水的靈動、地的穩定'
        },
        snail: {
          riddle: '行於厚土，堅如磐石，晨露相伴。',
          neededBagua: ['地', '山', '水'],
          hint: '蝸牛緩慢而堅韌，需要地的承載、山的堅固、水的滋潤'
        },
        'morning-fungus': {
          riddle: '雨後方生，隨氣流搖曳，聞轟響而發。',
          neededBagua: ['澤', '風', '雷'],
          hint: '朝菌生命短暫，需要澤的滋養、風的輕柔、雷的生機'
        },
        cicada: {
          riddle: '應轟鳴而出，借氣流傳聲，聲如烈焰。',
          neededBagua: ['雷', '風', '火'],
          hint: '蟪蛄善鳴，需要雷的震動、風的傳播、火的熱情'
        },
        'great-chun': {
          riddle: '參穹蒼而立，根深厚土，穩若高嶺。',
          neededBagua: ['天', '地', '山'],
          hint: '大椿長壽，需要天的永恆、地的穩固、山的長久'
        },
        ant: {
          riddle: '勤於土下，聚如小丘，共享甘露。',
          neededBagua: ['地', '山', '澤'],
          hint: '螻蟻勤勞團結，需要地的根基、山的堅實、澤的甘露'
        },
        star: {
          riddle: '懸於穹蒼，光如明燭，隨氣流飄搖。',
          neededBagua: ['天', '火', '風'],
          hint: '星辰高遠明亮，需要天的廣闊、火的光芒、風的清新'
        }
      };
      
      const config = baguaCollectionConfig[formType];
      if (!config) {
        console.error('未找到物化形態的八卦配置:', formType);
        return;
      }
      
      // 設置當前收集狀態
      gameState.currentBaguaCollection = {
        formType: formType,
        neededBagua: config.neededBagua,
        collected: [],
        riddle: config.riddle,
        hint: config.hint
      };
      
      // 初始化收集計數器
      if (!gameState.baguaCollectionCount) {
        gameState.baguaCollectionCount = 0;
      }
      
      // 顯示收集引導界面
      showBaguaCollectionGuide(config, formType);
    }
    
    // 顯示八卦收集引導界面
    function showBaguaCollectionGuide(config, formType) {
      // 隱藏物化按鈕，避免在具體尋氣收集階段切換形態造成邏輯混亂
      const formSelector = document.querySelector('.form-selector');
      if (formSelector) {
        formSelector.style.display = 'none';
        console.log('進入尋氣收集階段：已隱藏物化按鈕');
      }
      
      // 創建收集引導窗口（不是覆蓋層，而是頂部固定窗口）
      const guideOverlay = document.createElement('div');
      guideOverlay.className = 'fixed top-4 left-1/2 transform -translate-x-1/2 max-w-lg w-full mx-4';
      guideOverlay.style.zIndex = '80'; // 確保在萬物尋氣引導窗口之上
      guideOverlay.style.pointerEvents = 'none'; // 允許點擊穿透到下方的八卦符號
      guideOverlay.id = 'bagua-collection-guide';
      
      const guideContainer = document.createElement('div');
      guideContainer.className = 'w-full p-4 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-xl border border-indigo-200 dark:border-indigo-700';
      guideContainer.style.pointerEvents = 'auto'; // 只有容器本身可以接收點擊
      
            const formNames = {
        human: '人形',
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      
      // 八卦元素颜色配置
      const baguaColors = {
        '天': '#FFD700',
        '澤': '#C0C0C0', 
        '火': '#FF6347',
        '雷': '#32CD32',
        '風': '#87CEEB',
        '水': '#4169E1',
        '山': '#8B4513',
        '地': '#DAA520'
      };
      
      // 八卦符号配置
      const baguaSymbols = {
        '天': '☰',
        '澤': '☱',
        '火': '☲', 
        '雷': '☳',
        '風': '☴',
        '水': '☵',
        '山': '☶',
        '地': '☷'
      };

      guideContainer.innerHTML = `
        <div class="text-center mb-4">
          <h3 class="text-xl font-bold text-indigo-600 dark:text-indigo-400 mb-3">${formNames[formType]} 尋氣</h3>
          <p class="text-base text-gray-600 dark:text-gray-400 mb-2">解讀謎語，點擊飄浮的八卦符號收集所需之氣</p>
        </div>
        
        <div class="riddle-section mb-4 p-4 bg-indigo-50 dark:bg-indigo-900 rounded-lg">
          <p class="text-gray-700 dark:text-gray-300 leading-relaxed text-center text-base">${config.riddle}</p>
        </div>
        
        <div class="bagua-hints mb-4 p-3 bg-gray-50 dark:bg-gray-800 rounded-lg">
          <div class="flex justify-center gap-6 text-sm">
            ${Object.keys(baguaColors).map(element => `
              <span style="color: ${baguaColors[element]}; text-shadow: 0 0 5px ${baguaColors[element]}; font-weight: 600;">
                ${baguaSymbols[element]} ${element}
              </span>
            `).join('')}
          </div>
        </div>
        
        <div class="collection-status p-4 bg-blue-50 dark:bg-blue-900 rounded-lg" id="riddle-collection-status">
          <div class="progress-display flex justify-center gap-3 mb-3">
            ${config.neededBagua.map((element, index) => `
              <div class="answer-circle w-10 h-10 rounded-full flex items-center justify-center text-sm font-bold bg-gray-200 dark:bg-gray-600 relative" 
                   data-element="${element}" data-index="${index}">
                <div class="front-side absolute inset-0 rounded-full bg-gray-200 dark:bg-gray-600 transition-transform duration-500"></div>
                <div class="back-side absolute inset-0 rounded-full flex items-center justify-center text-sm font-bold transition-transform duration-500 transform rotateY-180" 
                     style="color: ${baguaColors[element]}; background: linear-gradient(135deg, ${baguaColors[element]}20, ${baguaColors[element]}40); backface-visibility: hidden;">
                  ${element}
                </div>
              </div>
            `).join('')}
          </div>
          <div class="progress-text text-sm text-blue-600 dark:text-blue-400 text-center">
            已收集：0 / 3
          </div>
        </div>
      `;
      
      guideOverlay.appendChild(guideContainer);
      document.body.appendChild(guideOverlay);
      
      // 移除了提示按鈕，不需要事件處理
      
      // 保存詩意謎題窗口引用到gameState，以便後續控制
      gameState.baguaCollectionGuideOverlay = guideOverlay;
      
      // 直接進入物化視野並開始收集（不需要點擊開始收集按鈕）
      enterFormVision(formType);
    }
    
    // 進入物化視野
    function enterFormVision(formType) {
      // 執行物化轉換
      if (gameState.currentForm !== formType) {
        gameState.currentForm = formType;
        updateFormView(formType);
        
        // 更新按鈕狀態
        Object.values(formButtons).forEach(button => {
          if (button) {
            button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
            button.classList.add('bg-gray-500');
          }
        });
        
        if (formButtons[formType]) {
          formButtons[formType].classList.remove('bg-gray-500');
          formButtons[formType].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
        }
      }
      
      // 不再顯示右上角的收集狀態界面，因為詩意謎題窗口中已經有了
      // showCollectionStatusUI();
      
      // 重新創建八卦符號（現在它們將是可點擊的）
      document.querySelectorAll('.bagua-symbols').forEach(el => el.remove());
      createBaguaSymbols();
      
      showMessage(`已進入${getFormName(formType)}視野，開始尋找所需的氣！點擊飄浮的八卦符號進行收集。`);
    }
    
    // 顯示收集狀態界面
    function showCollectionStatusUI() {
      // 移除舊的狀態界面
      const oldStatus = document.getElementById('collection-status-ui');
      if (oldStatus) oldStatus.remove();
      
      const currentCollection = gameState.currentBaguaCollection;
      if (!currentCollection) return;
      
      // 確保collected數組存在
      if (!currentCollection.collected) {
        currentCollection.collected = [];
      }
      
      const statusUI = document.createElement('div');
      statusUI.id = 'collection-status-ui';
      statusUI.className = 'fixed top-4 right-4 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 p-4 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700 z-40';
      
      statusUI.innerHTML = `
        <h4 class="font-semibold text-indigo-600 dark:text-indigo-400 mb-2">收集進度</h4>
        <div class="needed-items mb-2">
          <div class="text-sm text-gray-600 dark:text-gray-400 mb-1">需要的氣：</div>
          <div class="flex gap-2">
            ${currentCollection.neededBagua.map(element => {
              const isCollected = currentCollection.collected.includes(element);
              return `
                <div class="w-8 h-8 rounded-full flex items-center justify-center text-xs font-bold ${
                  isCollected 
                    ? 'bg-green-500 text-white' 
                    : 'bg-gray-200 dark:bg-gray-600 text-gray-600 dark:text-gray-400'
                }">
                  ${element}
                </div>
              `;
            }).join('')}
          </div>
        </div>
        <div class="progress-text text-sm text-gray-600 dark:text-gray-400">
          已收集：${currentCollection.collected.length} / 3
        </div>
      `;
      
      document.body.appendChild(statusUI);
    }
    
    // 顯示元素字彈出效果
    function showElementPopup(symbolElement, elementText) {
      const rect = symbolElement.getBoundingClientRect();
      
      const popup = document.createElement('div');
      popup.className = 'element-popup';
      popup.textContent = elementText;
      
      // 設置樣式
      popup.style.position = 'fixed';
      popup.style.left = (rect.left + rect.width / 2) + 'px';
      popup.style.top = (rect.top - 10) + 'px';
      popup.style.transform = 'translateX(-50%) translateY(-100%)';
      popup.style.fontSize = '24px';
      popup.style.fontWeight = 'bold';
      popup.style.color = '#FFD700';
      popup.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.6), 0 0 30px rgba(255, 215, 0, 0.4)';
      popup.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
      popup.style.zIndex = '9999';
      popup.style.pointerEvents = 'none';
      popup.style.opacity = '0';
      popup.style.transition = 'all 0.3s ease-out';
      
      document.body.appendChild(popup);
      
      // 觸發動畫
      requestAnimationFrame(() => {
        popup.style.opacity = '1';
        popup.style.transform = 'translateX(-50%) translateY(-120%)';
      });
      
      // 1.5秒後開始消失動畫
      setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(-140%)';
        
        // 動畫結束後移除元素
        setTimeout(() => {
          popup.remove();
        }, 300);
      }, 1500);
    }
    
    // 更新詩意謎題窗口中的收集進度
    function updateRiddleCollectionProgress() {
      const riddleStatus = document.getElementById('riddle-collection-status');
      if (!riddleStatus || !gameState.currentBaguaCollection) return;
      
      const collected = gameState.currentBaguaCollection.collected || [];
      const needed = gameState.currentBaguaCollection.neededBagua;
      
      // 檢查新收集的元素
      const progressCircles = riddleStatus.querySelectorAll('.answer-circle');
      progressCircles.forEach(circle => {
        const element = circle.getAttribute('data-element');
        const wasFlipped = circle.classList.contains('flipped');
        const shouldBeFlipped = collected.includes(element);
        
        if (shouldBeFlipped && !wasFlipped) {
          // 觸發翻轉動畫
          setTimeout(() => {
            circle.classList.add('flipped');
          }, 300); // 延遲一點時間讓收集動畫完成
        }
      });
      
      // 更新進度文字
      const progressText = riddleStatus.querySelector('.progress-text');
      if (progressText) {
        progressText.textContent = `已收集：${collected.length} / 3`;
      }
    }
    
    // 獲取物化形態中文名稱
    function getFormName(formType) {
      const names = {
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤', 
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      return names[formType] || formType;
    }
    
    // 創建八卦中文字懸浮效果
    function createBaguaFloatingText() {
      // 清理之前的八卦文字
      document.querySelectorAll('.bagua-floating-text').forEach(el => el.remove());
      
      const baguaTextContainer = document.createElement('div');
      baguaTextContainer.className = 'bagua-floating-text';
      baguaTextContainer.style.position = 'fixed';
      baguaTextContainer.style.top = '0';
      baguaTextContainer.style.left = '0';
      baguaTextContainer.style.width = '100%';
      baguaTextContainer.style.height = '100%';
      baguaTextContainer.style.pointerEvents = 'none';
      baguaTextContainer.style.zIndex = '12'; // 在虛空粒子之上，八卦符號之下
      baguaTextContainer.style.overflow = 'hidden';
      
      // 八卦文字內容
      const baguaTexts = [
        { text: '乾', color: '#FFD700', element: '天' },
        { text: '兌', color: '#C0C0C0', element: '澤' },
        { text: '離', color: '#FF6347', element: '火' },
        { text: '震', color: '#32CD32', element: '雷' },
        { text: '巽', color: '#87CEEB', element: '風' },
        { text: '坎', color: '#4169E1', element: '水' },
        { text: '艮', color: '#8B4513', element: '山' },
        { text: '坤', color: '#DAA520', element: '地' }
      ];
      
      // 創建多個浮現的八卦文字
      for (let i = 0; i < 12; i++) {
        const textElement = document.createElement('div');
        textElement.className = 'bagua-text-particle';
        
        // 隨機選擇八卦文字
        const baguaText = baguaTexts[Math.floor(Math.random() * baguaTexts.length)];
        
        // 隨機決定顯示卦名還是自然象徵
        const displayText = Math.random() > 0.5 ? baguaText.text : baguaText.element;
        textElement.textContent = displayText;
        
        // 樣式設置
        textElement.style.position = 'absolute';
        textElement.style.fontSize = `${20 + Math.random() * 16}px`; // 20-36px
        textElement.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
        textElement.style.fontWeight = '600';
        textElement.style.color = baguaText.color;
        textElement.style.textShadow = `
          0 0 15px ${baguaText.color},
          0 0 30px ${baguaText.color}80,
          0 0 45px ${baguaText.color}40
        `;
        textElement.style.whiteSpace = 'nowrap';
        
        // 隨機位置
        textElement.style.left = `${Math.random() * 85 + 7.5}%`; // 7.5%-92.5%
        textElement.style.top = `${Math.random() * 85 + 7.5}%`; // 7.5%-92.5%
        
        // 動畫設置
        textElement.style.opacity = '0';
        textElement.style.transform = 'scale(0.3) translateY(30px)';
        textElement.style.animation = `bagua-text-float ${5 + Math.random() * 4}s ease-in-out infinite`;
        textElement.style.animationDelay = `${Math.random() * 6}s`;
        
        baguaTextContainer.appendChild(textElement);
      }
      
      document.body.appendChild(baguaTextContainer);
      
      // 添加八卦文字動畫樣式
      if (!document.getElementById('bagua-text-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'bagua-text-animations';
        styleElement.textContent = `
          @keyframes bagua-text-float {
            0% {
              opacity: 0;
              transform: scale(0.3) translateY(30px) rotate(-5deg);
            }
            25% {
              opacity: 0.9;
              transform: scale(1.1) translateY(-5px) rotate(2deg);
            }
            50% {
              opacity: 1;
              transform: scale(1) translateY(-15px) rotate(0deg);
            }
            75% {
              opacity: 0.9;
              transform: scale(1.05) translateY(-10px) rotate(-2deg);
            }
            100% {
              opacity: 0;
              transform: scale(0.5) translateY(-40px) rotate(5deg);
            }
          }
          
          .bagua-text-particle {
            /* 移除背景框，只保留純文字效果 */
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    

    

    
    // 第七章新場景函數實現
    
    // 創建太極轉動挑戰
    function createTaijiPuzzle(scene) {
      const rotationContainer = document.createElement('div');
      rotationContainer.className = 'max-w-3xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      rotationContainer.style.top = '2rem';
      rotationContainer.style.zIndex = '9999';
      
      rotationContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4 text-gray-900 dark:text-gray-100">${scene.text}</h3>
        <div class="taiji-rotation-area mb-4" style="position: relative; width: 300px; height: 300px; margin: 0 auto; border: 2px dashed #ccc; border-radius: 50%; background: radial-gradient(circle, rgba(255,255,255,0.1), rgba(99,102,241,0.05));">
          <div class="rotation-taiji" style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 200px; cursor: grab; user-select: none; transition: transform 0.1s ease;">☯︎</div>
        </div>
                 <p class="text-sm text-gray-800 dark:text-gray-200 mb-4">點住太極符號，順時針轉動三圈，讓陰陽魚開始遊動</p>
         <div class="rotation-status text-lg font-semibold text-blue-600 dark:text-blue-400">準備順時針轉動太極...</div>
        <div class="rotation-progress mt-3">
          <div class="text-sm text-gray-500 dark:text-gray-400">轉動進度：<span id="rotation-progress">0</span> / 3 圈</div>
          <div class="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2 mt-2">
            <div class="bg-blue-500 h-2 rounded-full transition-all duration-300" id="progress-bar" style="width: 0%;"></div>
          </div>
        </div>
      `;
      
      document.body.appendChild(rotationContainer);
      
      // 轉動邏輯
      const taijiElement = rotationContainer.querySelector('.rotation-taiji');
      const statusElement = rotationContainer.querySelector('.rotation-status');
      const progressElement = rotationContainer.querySelector('#rotation-progress');
      const progressBar = rotationContainer.querySelector('#progress-bar');
      const rotationArea = rotationContainer.querySelector('.taiji-rotation-area');
      
      let isRotating = false;
      let startAngle = 0;
      let currentRotation = 0;
      let totalRotation = 0;
      let completedCircles = 0;
      let lastAngle = 0;
      
      // 獲取鼠標相對於太極中心的角度
      function getAngle(e, element) {
        const rect = element.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        const deltaX = e.clientX - centerX;
        const deltaY = e.clientY - centerY;
        return Math.atan2(deltaY, deltaX) * 180 / Math.PI;
      }
      
      // 鼠標按下事件
      taijiElement.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isRotating = true;
        startAngle = getAngle(e, taijiElement);
        lastAngle = startAngle;
        taijiElement.style.cursor = 'grabbing';
                 statusElement.textContent = '開始轉動...跟隨鼠標順時針轉動太極！';
        
        // 添加轉動區域發光效果
        rotationArea.style.boxShadow = '0 0 30px rgba(99, 102, 241, 0.3)';
      });
      
             // 鼠標移動事件
       document.addEventListener('mousemove', (e) => {
         if (!isRotating) return;
         
         const currentAngle = getAngle(e, taijiElement);
         let angleDiff = currentAngle - lastAngle;
         
         // 處理角度跨越-180到180的情況
         if (angleDiff > 180) angleDiff -= 360;
         if (angleDiff < -180) angleDiff += 360;
         
         // 只計算順時針旋轉（正值）
         if (angleDiff > 0) {
           totalRotation += angleDiff;
           currentRotation += angleDiff;
         } else {
           // 逆時針旋轉時給予提示
           if (Math.abs(angleDiff) > 5) { // 避免微小抖動觸發提示
             statusElement.textContent = '請順時針旋轉太極，就像背景中的太極符號一樣！';
             rotationArea.style.borderColor = '#ef4444'; // 紅色邊框提示
             setTimeout(() => {
               rotationArea.style.borderColor = '#ccc';
               if (completedCircles < 3) {
                 statusElement.textContent = completedCircles === 0 ? 
                   '開始轉動...跟隨鼠標順時針轉動太極！' : 
                   `很好！繼續順時針轉動...（${completedCircles}/3 圈）`;
               }
             }, 1000);
           }
         }
         
         lastAngle = currentAngle;
         
         // 更新太極符號的旋轉（總是跟隨鼠標，但只有順時針計數）
         taijiElement.style.transform = `translate(-50%, -50%) rotate(${totalRotation}deg)`;
         
         // 檢查是否完成一圈（360度順時針）
         if (currentRotation >= 360) {
           completedCircles++;
           currentRotation = currentRotation % 360;
           
           // 更新進度
           progressElement.textContent = Math.min(completedCircles, 3);
           progressBar.style.width = `${(completedCircles / 3) * 100}%`;
           
           if (completedCircles >= 3) {
             // 完成三圈順時針轉動
             completeRotation();
           } else {
             statusElement.textContent = `很好！繼續順時針轉動...（${completedCircles}/3 圈）`;
           }
         }
       });
      
      // 鼠標抬起事件
      document.addEventListener('mouseup', () => {
        if (isRotating) {
          isRotating = false;
          taijiElement.style.cursor = 'grab';
          rotationArea.style.boxShadow = 'none';
          
                     if (completedCircles < 3) {
             statusElement.textContent = `已順時針轉動 ${completedCircles} 圈，繼續順時針轉動完成挑戰！`;
           }
        }
      });
      
      // 完成轉動挑戰
      function completeRotation() {
        isRotating = false;
        taijiElement.style.cursor = 'default';
        rotationArea.style.boxShadow = 'none';
        statusElement.textContent = '完美！陰陽魚開始遊動，太極循環重新啟動！';
        
        // 添加完成效果
        taijiElement.style.filter = 'drop-shadow(0 0 20px rgba(99, 102, 241, 0.8))';
        rotationArea.style.background = 'radial-gradient(circle, rgba(99,102,241,0.2), rgba(99,102,241,0.05))';
        
        // 太極轉動完成後，顯示虛空場景中的太極符號
        setTimeout(() => {
          showTaijiSymbol();
        }, 1000);
        
        setTimeout(() => {
          rotationContainer.remove();
          advanceBtn.style.display = 'block';
        }, 1500);
      }
      
      // 防止拖拽和選擇
      taijiElement.addEventListener('dragstart', (e) => e.preventDefault());
      taijiElement.addEventListener('selectstart', (e) => e.preventDefault());
    }
    
    // 創建八卦理論解釋場景（莊子的哲學花園）- 優化版
    function createBaguaTheoryExplanationScene(scene) {
      const gardenContainer = document.createElement('div');
      gardenContainer.className = 'mx-auto p-4 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      gardenContainer.style.top = '2rem';
      gardenContainer.style.zIndex = '70';
      gardenContainer.style.width = '600px'; // 固定寬度（原900px的三分之二）
      gardenContainer.style.height = 'auto'; // 自適應高度
      gardenContainer.style.overflow = 'visible';
      gardenContainer.style.minWidth = '600px'; // 最小寬度
      gardenContainer.style.maxWidth = '600px'; // 最大寬度
      gardenContainer.style.minHeight = 'auto'; // 最小高度自適應
      gardenContainer.style.maxHeight = 'none'; // 無最大高度限制
      
      const storyStages = [
        {
          dialogue: '來，隨我進入這座神秘的花園。這裡有一顆種子，蘊含著宇宙生成的奧秘...',
          visual: '<div class="text-9xl">⚫</div>',
          title: '混沌種子',
          description: '看這黑暗的種子，它是無極，無形無象，就像渾沌未死之前的完美狀態。',
          button: '種下種子'
        },
        {
          dialogue: '水滴落下...種子裂開了！陰陽二氣從中湧出，這便是太極的誕生！',
          visual: '<div class="text-9xl">☯</div>',
          title: '太極初現',
          description: '一分為二，陰陽開始分離，就像黑夜白晝、寒暑冷熱。',
          button: '滴下甘露'
        },
        {
          dialogue: '陰陽各自分化...看，兩儀出現了！這些線條叫做"爻"，實線是陽爻，虛線是陰爻。',
          visual: '<div class="flex justify-center gap-8"><div class="text-red-600 text-center"><div class="text-6xl mb-2">⚊</div><div class="text-base">陽爻</div></div><div class="text-blue-600 text-center"><div class="text-6xl mb-2">⚋</div><div class="text-base">陰爻</div></div></div>',
          title: '兩儀誕生',
          description: '⚊ 陽爻代表動、剛、熱，⚋ 陰爻代表靜、柔、冷。',
          button: '灑下陽光'
        },
        {
          dialogue: '陰陽再分...四象綻放！',
          visual: `<div class="flex flex-col items-center gap-6">
            <div class="grid grid-cols-4 gap-4 w-full px-2">
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front spring-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚎</div>
                    <div class="text-xs font-bold">少陽</div>
                  </div>
                  <div class="card-back spring-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">🌸</div>
                    <div class="text-xs font-bold">春</div>
                  </div>
                </div>
              </div>
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front summer-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚌</div>
                    <div class="text-xs font-bold">老陽</div>
                  </div>
                  <div class="card-back summer-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">☀️</div>
                    <div class="text-xs font-bold">夏</div>
                  </div>
                </div>
              </div>
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front autumn-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚍</div>
                    <div class="text-xs font-bold">少陰</div>
                  </div>
                  <div class="card-back autumn-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">🍂</div>
                    <div class="text-xs font-bold">秋</div>
                  </div>
                </div>
              </div>
              <div class="four-seasons-card rounded-lg cursor-pointer shadow-md four-flip-card perspective-1000" onclick="flipCard(this)" style="aspect-ratio: 1; min-height: 100px;">
                <div class="four-flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d">
                  <div class="card-front winter-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg">
                    <div class="text-3xl mb-1">⚏</div>
                    <div class="text-xs font-bold">老陰</div>
                  </div>
                  <div class="card-back winter-card h-full flex flex-col items-center justify-center p-3 absolute w-full backface-hidden rounded-lg transform rotateY-180">
                    <div class="text-3xl mb-1">❄️</div>
                    <div class="text-xs font-bold">冬</div>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <style>
            .spring-card { background: linear-gradient(135deg, #c3f0ca, #e8f8e8); }
            .summer-card { background: linear-gradient(135deg, #ffe066, #fff3cd); }
            .autumn-card { background: linear-gradient(135deg, #ffa500, #ffe4b5); }
            .winter-card { background: linear-gradient(135deg, #add8e6, #e6f3ff); }
            
            /* 四象卡片3D翻轉動畫樣式 */
            .perspective-1000 {
              perspective: 1000px;
            }
            
            .transform-style-preserve-3d {
              transform-style: preserve-3d;
            }
            
            .backface-hidden {
              backface-visibility: hidden;
              -webkit-backface-visibility: hidden;
            }
            
            .rotateY-180 {
              transform: rotateY(180deg);
            }
            
            .four-flip-card-inner.flipped {
              transform: rotateY(180deg);
            }
            
            .four-flip-card:hover {
              transform: scale(1.05);
              transition: transform 0.2s ease;
            }
            
            .four-flip-card .card-front,
            .four-flip-card .card-back {
              transition: all 0.3s ease;
            }
          </style>`,
          title: '四象成形',
          description: '陰陽組合產生四種變化：少陽⚎、老陽⚌、少陰⚍、老陰⚏，對應春夏秋冬四季輪回。點擊卡片查看四象與季節的對應關係！',
          button: '催生四象'
        },
        {
          dialogue: '四象再分，八卦生成...這宇宙生成的奧秘就此揭開！接下來，讓我們仔細學習每個八卦符號的深層含義。',
          visual: '✨',
          title: '八卦奧秘',
          description: '現在你已了解宇宙生成的過程：無極→太極→兩儀→四象→八卦。讓我們進入下一步，詳細學習八卦符號！',
          button: '學習八卦'
        }
      ];
      
      let currentStage = 0;
      
      // 添加卡片翻轉函數到全局
      window.flipCard = function(cardElement) {
        // 檢查是否為四象卡片（有3D翻轉結構）
        const flipCardInner = cardElement.querySelector('.four-flip-card-inner');
        
        if (flipCardInner) {
          // 四象卡片使用3D翻轉動畫
          flipCardInner.classList.toggle('flipped');
        } else {
          // 原有邏輯（兼容性保留）
          const front = cardElement.querySelector('.card-front');
          const back = cardElement.querySelector('.card-back');
          
          if (front && back) {
            front.classList.toggle('hidden');
            back.classList.toggle('hidden');
          }
        }
      };
      
      function createStageContent(stage) {
        return `
          <div class="garden-display flex flex-col items-center" style="padding: 20px 0;">
            <div class="visual-element mb-2">${stage.visual}</div>
            <h3 class="text-xl font-bold mb-2 text-emerald-600 dark:text-emerald-400">${stage.title}</h3>
            <div class="zhuangzi-dialogue p-3 bg-indigo-50 dark:bg-indigo-900 rounded-lg max-w-lg border border-indigo-200 dark:border-indigo-700">
              <p class="text-sm italic leading-relaxed text-indigo-900 dark:text-indigo-100">
                <span class="font-semibold text-indigo-800 dark:text-indigo-200">莊子：</span>${stage.description}
              </p>
            </div>
          </div>
          <div class="garden-controls flex justify-center mt-4 mb-4">
            <button class="stage-button px-8 py-3 bg-emerald-500 hover:bg-emerald-600 text-white rounded-lg font-semibold transition-colors shadow-lg">
              🌱 ${stage.button}
            </button>
          </div>
        `;
      }
      
      gardenContainer.innerHTML = `
        <div class="relative h-full">
          <h3 class="text-lg font-bold mb-3 text-indigo-600 dark:text-indigo-400">莊子的哲學花園</h3>
          <div id="stage-content">${createStageContent(storyStages[0])}</div>
          <div class="progress-indicator flex justify-center pb-2 text-sm text-gray-500 dark:text-gray-400">
            第 <span id="current-stage-num">1</span> 步 / ${storyStages.length}
          </div>
        </div>
      `;
      
      document.body.appendChild(gardenContainer);
      
      function nextStage() {
        currentStage++;
        if (currentStage < storyStages.length) {
          // 更新內容
          const stageContent = gardenContainer.querySelector('#stage-content');
          const stageNum = gardenContainer.querySelector('#current-stage-num');
          
          stageContent.style.opacity = '0';
          setTimeout(() => {
            stageContent.innerHTML = createStageContent(storyStages[currentStage]);
            stageNum.textContent = currentStage + 1;
            stageContent.style.opacity = '1';
            
            // 重新綁定按鈕事件
            const newButton = stageContent.querySelector('.stage-button');
            newButton.addEventListener('click', handleButtonClick);
          }, 300);
        } else {
          // 完成所有階段
          gardenContainer.remove();
          // 清理全局函數
          delete window.flipCard;
          advanceBtn.style.display = 'block';
        }
      }
      
      function handleButtonClick() {
        nextStage();
      }
      
      // 初始化按鈕事件
      const initialButton = gardenContainer.querySelector('.stage-button');
      initialButton.addEventListener('click', handleButtonClick);
      
      // 添加過渡效果
      const stageContent = gardenContainer.querySelector('#stage-content');
      stageContent.style.transition = 'opacity 0.3s ease';
    }
    
    // 創建八卦符號演示場景（翻轉卡片）
    function createBaguaSymbolsDemonstrationScene(scene) {
      const cardContainer = document.createElement('div');
      cardContainer.className = 'max-w-6xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      cardContainer.style.top = '1rem';
      cardContainer.style.zIndex = '70';
      cardContainer.style.height = 'auto';
      cardContainer.style.overflow = 'visible';
      
             // 基於正確八卦理論的通俗解釋
       const baguaCards = [
        { 
          symbol: '☰', 
          name: '乾', 
          pinyin: 'qián',
          element: '天', 
          emoji: '☁️',
          explanation: '三個陽爻，全部都是動的，像天體不停轉動。',
          color: '#FFD700',
          reason: '天地定位：古人認為天在上地在下，天動地靜。三條實線表示完全動。'
        },
        { 
          symbol: '☷', 
          name: '坤', 
          pinyin: 'kūn',
          element: '地', 
          emoji: '🌍',
          explanation: '三個陰爻，全部都是靜的，像大地穩穩不動。',
          color: '#8B4513',
          reason: '天地定位：與天相對，三條虛線表示完全靜，大地安穩承載。'
        },
        { 
          symbol: '☶', 
          name: '艮', 
          pinyin: 'gèn',
          element: '山', 
          emoji: '⛰️',
          explanation: '上面動，下面靜，像山峰聳立大地上。',
          color: '#A0522D',
          reason: '山澤通氣：上爻動（山氣上升），中下爻靜，山氣往上飄。'
        },
        { 
          symbol: '☱', 
          name: '兌', 
          pinyin: 'duì',
          element: '澤', 
          emoji: '🌧️',
          explanation: '上面靜，下面動，像雨水從天空降下。',
          color: '#40E0D0',
          reason: '山澤通氣：上爻靜，中下爻動，表示降雨的樣子。'
        },
        { 
          symbol: '☳', 
          name: '震', 
          pinyin: 'zhèn',
          element: '雷', 
          emoji: '⚡',
          explanation: '下面動，上面靜，像雷聲從地底下冒出來。',
          color: '#9400D3',
          reason: '雷風相薄：古人認為雷從地中起，下爻動，中上爻靜。'
        },
        { 
          symbol: '☴', 
          name: '巽', 
          pinyin: 'xùn',
          element: '風', 
          emoji: '💨',
          explanation: '上面動，下面靜，像風從天上吹下來。',
          color: '#32CD32',
          reason: '雷風相薄：古人認為風起天上，下爻靜，中上爻動。'
        },
        { 
          symbol: '☵', 
          name: '坎', 
          pinyin: 'kǎn',
          element: '水', 
          emoji: '💧',
          explanation: '中間動，周圍靜，像水在固定河道中流動。',
          color: '#1E90FF',
          reason: '水火不相射：中爻動，上下爻靜，周邊靜中間動。又象徵月亮。'
        },
        { 
          symbol: '☲', 
          name: '離', 
          pinyin: 'lí',
          element: '火', 
          emoji: '🔥',
          explanation: '周圍動，中間靜，像火焰外面跳動內心空虛。',
          color: '#FF4500',
          reason: '水火不相射：中爻靜，上下爻動，周邊動中間靜。又象徵太陽。'
        }
      ];
      
      let flippedCards = 0;
      
      cardContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4 text-indigo-600 dark:text-indigo-400">八卦學習卡片</h3>
        <p class="text-base text-gray-800 dark:text-gray-200 mb-6">點擊卡片翻轉查看解釋（已翻轉：<span id="flipped-count">0</span>/${baguaCards.length}）</p>
        <div class="cards-grid grid grid-cols-4 gap-4 p-4">
          ${baguaCards.map((card, index) => `
            <div class="flip-card w-32 h-40 perspective-1000" data-index="${index}">
              <div class="flip-card-inner relative w-full h-full transition-transform duration-600 transform-style-preserve-3d cursor-pointer">
                <div class="flip-card-front absolute w-full h-full bg-gradient-to-br from-blue-400 to-purple-500 rounded-lg shadow-lg flex flex-col items-center justify-center backface-hidden">
                  <div class="text-4xl mb-2" style="color: ${card.color};">${card.symbol}</div>
                  <div class="text-white font-bold text-lg">${card.name}</div>
                  <div class="text-sm text-blue-100 opacity-90">${card.pinyin}</div>
                </div>
                <div class="flip-card-back absolute w-full h-full bg-gradient-to-br from-amber-50 to-orange-100 dark:from-gray-800 dark:to-gray-900 rounded-lg shadow-lg p-3 backface-hidden transform rotateY-180 border-2 border-amber-200 dark:border-gray-600">
                  <div class="text-2xl font-bold mb-1 text-amber-800 dark:text-amber-200 text-center" style="color: ${card.color}; text-shadow: 0 0 4px rgba(0,0,0,0.3);">${card.element}</div>
                  <div class="text-2xl mb-2 text-center">${card.emoji}</div>
                  <div class="text-xs text-gray-800 dark:text-gray-200 leading-tight mb-2 font-medium text-left">${card.explanation}</div>
                </div>
              </div>
            </div>
          `).join('')}
        </div>
        <div class="continue-section mt-4">
          <button id="continue-btn" class="px-6 py-3 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold hidden transition-colors">
            ✨ 繼續學習
          </button>
        </div>
      `;
      
      document.body.appendChild(cardContainer);
      
      // 添加CSS樣式
      const style = document.createElement('style');
      style.textContent = `
        .perspective-1000 {
          perspective: 1000px;
        }
        .transform-style-preserve-3d {
          transform-style: preserve-3d;
        }
        .backface-hidden {
          backface-visibility: hidden;
        }
        .rotateY-180 {
          transform: rotateY(180deg);
        }
        .flip-card-inner.flipped {
          transform: rotateY(180deg);
        }
      `;
      document.head.appendChild(style);
      
      // 綁定卡片點擊事件
      const cards = cardContainer.querySelectorAll('.flip-card');
      const flippedCountSpan = cardContainer.querySelector('#flipped-count');
      const continueBtn = cardContainer.querySelector('#continue-btn');
      
      cards.forEach((card, index) => {
        let hasBeenFlippedOnce = false; // 追蹤是否曾經翻轉過
        
        card.addEventListener('click', () => {
          const inner = card.querySelector('.flip-card-inner');
          
          // 切換翻轉狀態
          inner.classList.toggle('flipped');
          
          // 只在第一次翻轉時計數
          if (!hasBeenFlippedOnce && inner.classList.contains('flipped')) {
            hasBeenFlippedOnce = true;
            flippedCards++;
            flippedCountSpan.textContent = flippedCards;
            
            // 當所有卡片都翻轉過後顯示繼續按鈕
            if (flippedCards === baguaCards.length) {
              setTimeout(() => {
                continueBtn.classList.remove('hidden');
              }, 600);
            }
          }
        });
      });
      
      // 繼續按鈕事件
      continueBtn.addEventListener('click', () => {
        cardContainer.remove();
        style.remove();
        advanceBtn.style.display = 'block';
      });
    }
    
    // 創建八卦學習挑戰場景（優化版）
    function createBaguaLearningChallengeScene(scene) {
      const learningContainer = document.createElement('div');
      learningContainer.className = 'max-w-5xl mx-auto p-4 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      learningContainer.style.top = '1rem';
      learningContainer.style.zIndex = '70';
      learningContainer.style.maxHeight = '95vh';
      learningContainer.style.overflow = 'auto';
      
      learningContainer.innerHTML = `
        <h3 class="text-lg font-bold mb-2 text-gray-900 dark:text-gray-100">${scene.text}</h3>
        <div class="challenge-header flex justify-between items-center mb-2 p-2 bg-gray-50 dark:bg-gray-700 rounded-lg">
          <div class="timer-display text-lg font-bold text-blue-600 dark:text-blue-400">
            ⏱️ <span id="timer-display">00:00</span>
          </div>
          <div class="challenge-info text-sm text-gray-800 dark:text-gray-200">
            <div>最佳記錄: <span id="best-time">--:--</span></div>
            <div>嘗試次數: <span id="attempt-count">1</span></div>
          </div>
        </div>
        <div class="learning-area flex justify-between mb-2">
          <div class="bagua-symbols-area w-1/2 p-2 border-r border-gray-300 dark:border-gray-600">
            <h4 class="text-base font-semibold mb-2 text-indigo-600 dark:text-indigo-400">八卦符號</h4>
            <div class="bagua-symbols-grid grid grid-cols-4 gap-2 justify-items-center"></div>
          </div>
          <div class="bagua-elements-area w-1/2 p-2">
            <h4 class="text-base font-semibold mb-2 text-emerald-600 dark:text-emerald-400">對應元素</h4>
            <div class="bagua-elements-grid grid grid-cols-4 gap-2 justify-items-center"></div>
          </div>
        </div>
        <div class="status-section mb-2">
          <div class="learning-status text-base font-semibold text-blue-600 dark:text-blue-400 mb-1">點擊八卦符號，再點擊對應的元素文字進行配對</div>
          <div class="learning-progress text-sm text-gray-800 dark:text-gray-200">已配對：<span id="matched-count">0</span> / 8</div>
        </div>
        <div class="challenge-controls flex justify-center gap-4 pb-2" style="display: none;" id="challenge-controls">
          <button class="retry-btn px-4 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-lg font-semibold transition-colors">
            🔄 再次挑戰
          </button>
          <button class="continue-btn px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold transition-colors">
            ✅ 繼續遊戲
          </button>
        </div>
      `;
      
      document.body.appendChild(learningContainer);
      
      // 八卦數據
      const baguaData = [
        { symbol: '☰', name: 'qian', element: '天', color: '#FFD700' },
        { symbol: '☱', name: 'dui', element: '澤', color: '#C0C0C0' },
        { symbol: '☲', name: 'li', element: '火', color: '#FF6347' },
        { symbol: '☳', name: 'zhen', element: '雷', color: '#32CD32' },
        { symbol: '☴', name: 'xun', element: '風', color: '#87CEEB' },
        { symbol: '☵', name: 'kan', element: '水', color: '#4169E1' },
        { symbol: '☶', name: 'gen', element: '山', color: '#8B4513' },
        { symbol: '☷', name: 'kun', element: '地', color: '#DAA520' }
      ];
      
      // 遊戲狀態
      let selectedSymbol = null;
      let matchedPairs = 0;
      let startTime = null;
      let timerInterval = null;
      let attemptCount = parseInt(localStorage.getItem('baguaAttemptCount') || '1');
      let bestTime = localStorage.getItem('baguaBestTime') || null;
      let challengeCompleted = false;
      
      // UI元素
      const symbolsGrid = learningContainer.querySelector('.bagua-symbols-grid');
      const elementsGrid = learningContainer.querySelector('.bagua-elements-grid');
      const statusText = learningContainer.querySelector('.learning-status');
      const matchedCount = learningContainer.querySelector('#matched-count');
      const timerDisplay = learningContainer.querySelector('#timer-display');
      const bestTimeDisplay = learningContainer.querySelector('#best-time');
      const attemptCountDisplay = learningContainer.querySelector('#attempt-count');
      const challengeControls = learningContainer.querySelector('#challenge-controls');
      const retryBtn = learningContainer.querySelector('.retry-btn');
      const continueBtn = learningContainer.querySelector('.continue-btn');
      
      // 初始化顯示
      attemptCountDisplay.textContent = attemptCount;
      if (bestTime) {
        bestTimeDisplay.textContent = bestTime;
      }
      
      // 計時器函數
      function startTimer() {
        startTime = Date.now();
        timerInterval = setInterval(() => {
          const elapsed = Date.now() - startTime;
          const minutes = Math.floor(elapsed / 60000);
          const seconds = Math.floor((elapsed % 60000) / 1000);
          timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        }, 100);
      }
      
      function stopTimer() {
        if (timerInterval) {
          clearInterval(timerInterval);
          timerInterval = null;
        }
        return startTime ? Date.now() - startTime : 0;
      }
      
      function formatTime(milliseconds) {
        const minutes = Math.floor(milliseconds / 60000);
        const seconds = Math.floor((milliseconds % 60000) / 1000);
        return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
      }
      
      // 重置遊戲函數
      function resetGame() {
        selectedSymbol = null;
        matchedPairs = 0;
        challengeCompleted = false;
        matchedCount.textContent = '0';
        statusText.textContent = '點擊八卦符號，再點擊對應的元素文字進行配對';
        challengeControls.style.display = 'none';
        
        // 清空網格
        symbolsGrid.innerHTML = '';
        elementsGrid.innerHTML = '';
        
        // 重新創建遊戲元素
        createGameElements();
        
        // 重置並開始計時器
        stopTimer();
        timerDisplay.textContent = '00:00';
        startTimer();
      }
      
      // 創建遊戲元素函數
      function createGameElements() {
        // 打亂元素順序
        const shuffledElements = [...baguaData].sort(() => Math.random() - 0.5);
      
      // 創建八卦符號
      baguaData.forEach((bagua, index) => {
        const symbolElement = document.createElement('div');
          symbolElement.className = 'bagua-symbol-learning cursor-pointer transition-all duration-300 p-3 rounded-lg border-2 border-transparent hover:border-indigo-400 hover:shadow-lg flex items-center justify-center';
          symbolElement.style.minHeight = '60px';
          symbolElement.style.minWidth = '60px';
        symbolElement.dataset.name = bagua.name;
        symbolElement.innerHTML = `
            <div class="text-3xl" style="color: ${bagua.color}; text-shadow: 0 0 8px ${bagua.color};">${bagua.symbol}</div>
        `;
        
        symbolElement.addEventListener('click', () => {
            if (symbolElement.classList.contains('matched') || challengeCompleted) return;
            
            // 開始計時（首次點擊時）
            if (!startTime) {
              startTimer();
            }
          
          // 清除之前的選中狀態
          document.querySelectorAll('.bagua-symbol-learning').forEach(el => {
            el.classList.remove('selected');
            el.style.backgroundColor = '';
          });
          
          // 選中當前符號
          selectedSymbol = bagua.name;
          symbolElement.classList.add('selected');
          symbolElement.style.backgroundColor = 'rgba(99, 102, 241, 0.2)';
          statusText.textContent = '';
        });
        
        symbolsGrid.appendChild(symbolElement);
      });
      
      // 創建元素文字
      shuffledElements.forEach((bagua, index) => {
        const elementElement = document.createElement('div');
          elementElement.className = 'bagua-element-learning cursor-pointer transition-all duration-300 p-3 rounded-lg border-2 border-transparent hover:border-emerald-400 hover:shadow-lg flex items-center justify-center';
          elementElement.style.minHeight = '60px';
          elementElement.style.minWidth = '60px';
        elementElement.dataset.name = bagua.name;
        elementElement.innerHTML = `
            <div class="text-3xl font-bold text-gray-700 dark:text-gray-300">${bagua.element}</div>
        `;
        
        elementElement.addEventListener('click', () => {
            if (elementElement.classList.contains('matched') || challengeCompleted) return;
          
          if (!selectedSymbol) {
            statusText.textContent = '請先選擇一個八卦符號';
            elementElement.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => {
              elementElement.style.animation = '';
            }, 500);
            return;
          }
          
          if (selectedSymbol === bagua.name) {
            // 配對成功
            const symbolEl = document.querySelector(`.bagua-symbol-learning[data-name="${selectedSymbol}"]`);
            symbolEl.classList.add('matched');
            symbolEl.style.backgroundColor = 'rgba(34, 197, 94, 0.3)';
            symbolEl.style.pointerEvents = 'none';
            
            elementElement.classList.add('matched');
            elementElement.style.backgroundColor = 'rgba(34, 197, 94, 0.3)';
            elementElement.style.pointerEvents = 'none';
            
            // 成功動畫
            [symbolEl, elementElement].forEach(el => {
              el.style.animation = 'bagua-match-success 1s ease-in-out';
            });
            
            matchedPairs++;
            matchedCount.textContent = matchedPairs;
            selectedSymbol = null;
            
            if (matchedPairs === 8) {
                // 挑戰完成
                challengeCompleted = true;
                const completionTime = stopTimer();
                const formattedTime = formatTime(completionTime);
                
                // 更新最佳記錄
                if (!bestTime || completionTime < parseInt(localStorage.getItem('baguaBestTimeMs') || '999999999')) {
                  bestTime = formattedTime;
                  localStorage.setItem('baguaBestTime', bestTime);
                  localStorage.setItem('baguaBestTimeMs', completionTime.toString());
                  bestTimeDisplay.textContent = bestTime;
                  statusText.innerHTML = `🎉 恭喜！新記錄：${formattedTime}！你已經掌握了八卦與元素的對應關係`;
                } else {
                  statusText.innerHTML = `✅ 完成！用時：${formattedTime}。你已經掌握了八卦與元素的對應關係`;
                }
                
                // 顯示控制按鈕
                challengeControls.style.display = 'flex';
              gameState.baguaLearningCompleted = true;
            } else {
              statusText.textContent = '配對成功！請繼續選擇下一組';
            }
          } else {
            // 配對錯誤
            statusText.textContent = '配對錯誤，請重新選擇';
            elementElement.style.animation = 'shake 0.5s ease-in-out';
            setTimeout(() => {
              elementElement.style.animation = '';
              statusText.textContent = '點擊八卦符號，再點擊對應的元素文字進行配對';
            }, 1000);
          }
        });
        
        elementsGrid.appendChild(elementElement);
      });
      }
      
      // 事件監聽器
      retryBtn.addEventListener('click', () => {
        attemptCount++;
        localStorage.setItem('baguaAttemptCount', attemptCount.toString());
        attemptCountDisplay.textContent = attemptCount;
        resetGame();
      });
      
      continueBtn.addEventListener('click', () => {
        learningContainer.remove();
        advanceBtn.style.display = 'block';
      });
      
      // 初始化遊戲
      createGameElements();
      
      // 添加動畫樣式
      if (!document.getElementById('bagua-learning-animations')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'bagua-learning-animations';
        styleElement.textContent = `
          @keyframes bagua-match-success {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
          }
          
          @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
          }
          
          .bagua-symbol-learning, .bagua-element-learning {
            transition: all 0.3s ease;
          }
          
          .bagua-symbol-learning.selected {
            transform: scale(1.1);
          }
        `;
        document.head.appendChild(styleElement);
      }
    }
    
    // 創建萬物尋氣引導
    function createWanwuXunqiGuide(scene) {
      const guideContainer = document.createElement('div');
      guideContainer.className = 'max-w-2xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      guideContainer.style.top = '2rem';
      guideContainer.style.zIndex = '70';
      guideContainer.id = 'wanwu-xunqi-guide'; // 添加ID以便控制
      
      const sequence = scene.sequence || ['butterfly', 'fish', 'kun', 'peng', 'yuanchu', 'chixiao', 'snail', 'morning-fungus', 'cicada', 'great-chun', 'ant', 'star'];
      let currentIndex = 0;
      
      // 保存引導窗口引用到gameState
      gameState.wanwuXunqiGuideContainer = guideContainer;
      
      // 設置萬物尋氣模式標記
      gameState.wanwuXunqiActive = true;
      gameState.wanwuXunqiCurrentFormIndex = 0;
      gameState.wanwuXunqiProgress = [];
      
      // 重新創建八卦符號以啟用點擊功能
      document.querySelectorAll('.bagua-symbols').forEach(el => el.remove());
      createBaguaSymbols();
      
      const formNames = {
        human: '人形',
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      
      guideContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4 text-gray-900 dark:text-gray-100">${scene.text}</h3>
        <div class="sequence-progress mb-4">
          <div class="current-form text-2xl font-bold text-blue-600 dark:text-blue-400" id="current-form-name">請物化為：${formNames[sequence[0]]}</div>
          <div class="progress-bar mt-2 bg-gray-200 dark:bg-gray-700 rounded-full h-2">
            <div class="progress-fill bg-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
          </div>
          <div class="progress-text text-sm text-gray-800 dark:text-gray-200 mt-2">0 / ${sequence.length}</div>
        </div>
        <p class="text-sm text-gray-800 dark:text-gray-200 mb-4">進入每個物化視野，尋找並收集對應的氣（每種需收集3個）</p>
        


      `;
      
      document.body.appendChild(guideContainer);
      
      const currentFormName = guideContainer.querySelector('#current-form-name');
      const progressFill = guideContainer.querySelector('.progress-fill');
      const progressText = guideContainer.querySelector('.progress-text');
      
      // 高亮當前需要點擊的按鈕
      function highlightCurrentForm() {
        // 移除所有高亮
        Object.values(formButtons).forEach(btn => {
          if (btn) {
            btn.style.boxShadow = '';
            btn.style.animation = '';
            btn.style.border = '';
            btn.style.transform = '';
            btn.style.zIndex = '';
            btn.style.position = '';
          }
        });
        
        // 高亮當前按鈕 - 使用強化的萬物尋氣動畫
        const currentForm = sequence[currentIndex];
        const currentButton = formButtons[currentForm];
        if (currentButton) {
          currentButton.style.animation = 'wanwu-highlight 1.5s infinite ease-in-out';
          currentButton.style.zIndex = '10';
          currentButton.style.position = 'relative';
        }
      }
      
      // 處理萬物尋氣中的物化點擊
      gameState.handleFormSequenceClick = function(clickedForm) {
        console.log('萬物尋氣點擊處理:', clickedForm, '期望:', sequence[currentIndex]);
        if (clickedForm === sequence[currentIndex]) {
          // 隱藏萬物尋氣引導窗口
          if (gameState.wanwuXunqiGuideContainer) {
            gameState.wanwuXunqiGuideContainer.style.display = 'none';
          }
          
          // 進入八卦收集模式
          console.log('開始八卦收集:', clickedForm);
          startBaguaCollection(clickedForm);
          return true; // 表示已處理
        } else {
          console.log('點擊的不是當前需要的物化形態');
          showMessage(`請物化為 ${formNames[sequence[currentIndex]]}！`);
          return false; // 表示未處理
        }
      };
      
      // 更新進度的函數
      gameState.updateWanwuXunqiProgress = function() {
        currentIndex++;
        const progress = (currentIndex / sequence.length) * 100;
        progressFill.style.width = `${progress}%`;
        progressText.textContent = `${currentIndex} / ${sequence.length}`;
        
        if (currentIndex < sequence.length) {
          currentFormName.textContent = `請物化為：${formNames[sequence[currentIndex]]}`;
          gameState.wanwuXunqiCurrentFormIndex = currentIndex;
          highlightCurrentForm();
        } else {
          currentFormName.textContent = '完成！萬物之氣已聚';
          // 移除所有高亮
          Object.values(formButtons).forEach(btn => {
            if (btn) {
              btn.style.boxShadow = '';
              btn.style.animation = '';
              btn.style.border = '';
              btn.style.transform = '';
              btn.style.zIndex = '';
              btn.style.position = '';
            }
          });
          
          // 如果玩家目前在星辰視角，自動回歸到人視角
          if (gameState.currentForm === 'star') {
            console.log('萬物尋氣完成：從星辰視角自動回歸到人視角');
            
            // 顯示過渡動畫
            showTransformationTransition('star', 'human');
            
            // 更新遊戲狀態
            setTimeout(() => {
              gameState.currentForm = 'human';
              
              // 更新物化按鈕狀態
              Object.values(formButtons).forEach(button => {
                button.classList.remove('bg-indigo-600', 'hover:bg-indigo-700');
                button.classList.add('bg-gray-500');
              });
              
              // 高亮人形態按鈕
              if (formButtons['human']) {
                formButtons['human'].classList.remove('bg-gray-500');
                formButtons['human'].classList.add('bg-indigo-600', 'hover:bg-indigo-700');
              }
              
              // 更新視圖顯示
              updateFormView('human');
              
              console.log('萬物尋氣完成：已自動回歸到人視角');
            }, 1500);
          }
          
          // 清理萬物尋氣模式
          gameState.wanwuXunqiActive = false;
          gameState.handleFormSequenceClick = null;
          gameState.wanwuXunqiGuideContainer = null;
          
          // 重新顯示物化按鈕
          const formSelector = document.querySelector('.form-selector');
          if (formSelector) {
            formSelector.style.display = 'flex';
            console.log('萬物尋氣完成：已重新顯示物化按鈕');
          }
          
          setTimeout(() => {
            guideContainer.remove();
            advanceBtn.style.display = 'block';
          }, 2000);
        }
      };
      
      // 初始高亮
      highlightCurrentForm();
      


    }
    // 創建萬物回響引導
    function createFormSequenceGuide(scene) {
      const guideContainer = document.createElement('div');
      guideContainer.className = 'max-w-2xl mx-auto p-6 text-center fixed left-1/2 transform -translate-x-1/2 bg-white dark:bg-gray-800 bg-opacity-95 dark:bg-opacity-95 rounded-lg shadow-lg border border-indigo-200 dark:border-indigo-700';
      guideContainer.style.top = '2rem';
      guideContainer.style.zIndex = '70';
      
      const sequence = scene.sequence || ['butterfly', 'fish', 'tree', 'bird', 'snail', 'ant'];
      let currentIndex = 0;
      
      // 設置萬物回響模式標記
      gameState.formSequenceGuideActive = true;
      
      const formNames = {
        human: '人形',
        butterfly: '蝴蝶',
        fish: '儵魚',
        kun: '鯤',
        peng: '鵬',
        yuanchu: '鵷鶵',
        chixiao: '鴟鴞',
        bird: '飛鳥',
        snail: '蝸牛',
        'morning-fungus': '朝菌',
        cicada: '蟪蛄',
        'great-chun': '大椿',
        ant: '螻蟻',
        star: '星辰'
      };
      
      guideContainer.innerHTML = `
        <h3 class="text-xl font-bold mb-4">${scene.text}</h3>
        <div class="sequence-progress mb-4">
          <div class="current-form text-2xl font-bold text-blue-600 dark:text-blue-400" id="current-form-name">請點擊：${formNames[sequence[0]]}</div>
          <div class="progress-bar mt-2 bg-gray-200 dark:bg-gray-700 rounded-full h-2">
            <div class="progress-fill bg-blue-600 h-2 rounded-full transition-all duration-500" style="width: 0%"></div>
          </div>
          <div class="progress-text text-sm text-gray-600 dark:text-gray-400 mt-2">0 / ${sequence.length}</div>
        </div>
        <p class="text-sm text-gray-600 dark:text-gray-400">按照你的旅程順序，依次點擊每個物化形態按鈕</p>
      `;
      
      document.body.appendChild(guideContainer);
      
      const currentFormName = guideContainer.querySelector('#current-form-name');
      const progressFill = guideContainer.querySelector('.progress-fill');
      const progressText = guideContainer.querySelector('.progress-text');
      
      // 高亮當前需要點擊的按鈕
      function highlightCurrentForm() {
        // 移除所有高亮
        Object.values(formButtons).forEach(btn => {
          if (btn) {
            btn.style.boxShadow = '';
            btn.style.animation = '';
          }
        });
        
        // 高亮當前按鈕
        const currentForm = sequence[currentIndex];
        const currentButton = formButtons[currentForm];
        if (currentButton) {
          currentButton.style.boxShadow = '0 0 20px #3B82F6';
          currentButton.style.animation = 'pulse 2s infinite';
        }
      }
      
      // 處理萬物回響中的物化點擊
      gameState.handleFormSequenceClick = function(clickedForm) {
        if (clickedForm === sequence[currentIndex]) {
          // 執行物化動畫但不改變遊戲狀態
          showTransformationTransition(gameState.currentForm, clickedForm);
          
          currentIndex++;
          const progress = (currentIndex / sequence.length) * 100;
          progressFill.style.width = `${progress}%`;
          progressText.textContent = `${currentIndex} / ${sequence.length}`;
          
          if (currentIndex < sequence.length) {
            currentFormName.textContent = `請點擊：${formNames[sequence[currentIndex]]}`;
            highlightCurrentForm();
          } else {
            currentFormName.textContent = '完成！萬物已回響';
            // 移除所有高亮
            Object.values(formButtons).forEach(btn => {
              if (btn) {
                btn.style.boxShadow = '';
                btn.style.animation = '';
              }
            });
            // 清理萬物回響模式
            gameState.formSequenceGuideActive = false;
            gameState.handleFormSequenceClick = null;
            setTimeout(() => {
              guideContainer.remove();
              advanceBtn.style.display = 'block';
            }, 2000);
          }
          return true; // 表示已處理
        }
        return false; // 表示未處理
      };
      
      // 初始高亮
      highlightCurrentForm();
    }
    

    

    
    // 創建混沌呼吸調息引導場景
    function createChaosBreathingGuide(scene) {
      // 在呼吸挑战开始时就隐藏指示器
      const currentFormIndicator = document.getElementById('current-form-indicator');
      if (currentFormIndicator) {
        currentFormIndicator.style.opacity = 0;
        console.log('呼吸挑战开始：隐藏物化指示器');
      }
      
      const aperturesTracker = document.getElementById('apertures-tracker');
      if (aperturesTracker) {
        aperturesTracker.style.opacity = 0;
        console.log('呼吸挑战开始：隐藏七竅指示器');
      }
      
      // 如果是從首頁進入的，播放第七章背景音樂
      if (gameState.isBreathingExperience) {
        handleChapterAudioTransition('chapter7');
      }
      
      // 獲取現有的混沌圖形
      const chaosForm = document.querySelector('.chaos-form');
      if (!chaosForm) {
        console.error('未找到混沌圖形');
        return;
      }
      
      // 為混沌圖形添加呼吸模式
      chaosForm.classList.add('breathing-mode');
      
      // 創建呼吸引導文字容器
      const breathingGuide = document.createElement('div');
      breathingGuide.className = 'breathing-guide-overlay';
      breathingGuide.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 15;
        pointer-events: auto;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      `;
      
      breathingGuide.innerHTML = `
        <!-- 呼吸提示文字放在混沌形體中心 -->
        <div class="breathing-phase-text" style="
          position: absolute;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          font-size: 2rem;
          font-weight: bold;
          color: rgba(255, 255, 255, 0.95);
          text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
          transition: all 0.5s ease;
          text-align: center;
          z-index: 20;
        ">準備開始...</div>
        
        <div class="breathing-progress" style="
          position: absolute;
          bottom: 10%;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.15);
          padding: 1rem 1.5rem;
          border-radius: 20px;
          backdrop-filter: blur(20px);
          border: 1px solid rgba(255, 255, 255, 0.2);
          text-align: center;
          color: rgba(255, 255, 255, 0.9);
          min-width: 300px;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        ">
          <div class="cycle-info" style="font-size: 0.85rem; margin-bottom: 0.5rem; opacity: 0.7;">跟隨混沌的節奏，體驗天人合一</div>
          <div class="cycle-counter" style="font-size: 0.8rem; opacity: 0.8; margin-top: 0.5rem;">第 1 / 6 個週期</div>
          
          <!-- 退出按鈕（僅在從首頁進入時顯示） -->
          <div class="breathing-exit-button" style="
            display: none;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid rgba(255, 255, 255, 0.15);
          ">
            <button onclick="exitBreathingExperience()" style="
              background: rgba(255, 255, 255, 0.15);
              color: rgba(255, 255, 255, 0.9);
              border: 1px solid rgba(255, 255, 255, 0.2);
              padding: 0.75rem 1.5rem;
              border-radius: 15px;
              font-size: 0.9rem;
              font-weight: 500;
              cursor: pointer;
              transition: all 0.3s ease;
              backdrop-filter: blur(10px);
            " onmouseover="this.style.background='rgba(255, 255, 255, 0.25)'" onmouseout="this.style.background='rgba(255, 255, 255, 0.15)'">
              退出呼吸體驗
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(breathingGuide);
      
      const phaseText = breathingGuide.querySelector('.breathing-phase-text');
      const cycleCounter = breathingGuide.querySelector('.cycle-counter');
      
      // 如果是從首頁進入的，顯示退出按鈕
      if (gameState.isBreathingExperience) {
        const exitButton = breathingGuide.querySelector('.breathing-exit-button');
        if (exitButton) {
          exitButton.style.display = 'block';
        }
      }
      
      startGuidedBreathing(phaseText, null, cycleCounter, () => {
        // 完成後清理
        chaosForm.classList.remove('breathing-mode');
        breathingGuide.remove();
        setTimeout(() => {
          advanceBtn.style.display = 'block';
        }, 1000);
      });
    }
    
    // 開始引導呼吸循環
    function startGuidedBreathing(textElement, progressFill, cycleCounter, onComplete) {
      let currentTime = 0;
      const cycleTime = 10000; // 10秒一個週期 (4秒吸氣 + 6秒呼氣)
      
      // 檢查是否是從首頁進入的無時間限制版本
      const isUnlimitedBreathing = gameState.isBreathingExperience;
      
      if (isUnlimitedBreathing) {
        // 無時間限制版本：無限循環
        let currentCycle = 0;
        
        const breathingInterval = setInterval(() => {
          const cycleProgress = (currentTime % cycleTime) / cycleTime;
          
          if (cycleProgress < 0.4) { // 吸氣階段 (4秒)
            showGuidedBreathingText(textElement, 'inhale');
          } else { // 呼氣階段 (6秒)
            showGuidedBreathingText(textElement, 'exhale');
          }
          
          // 每完成一個週期，更新計數
          if (currentTime % cycleTime === 0 && currentTime > 0) {
            currentCycle++;
            cycleCounter.textContent = `已完成 ${currentCycle} 個週期`;
          }
          
          currentTime += 100;
        }, 100);
        
        // 存儲 interval ID 供退出按鈕使用
        gameState.breathingInterval = breathingInterval;
        
      } else {
        // 原有的限時版本（60秒）
        const totalTime = 60000; // 60秒
        const totalCycles = 6; // 總共6個週期
        
        const breathingInterval = setInterval(() => {
          const cycleProgress = (currentTime % cycleTime) / cycleTime;
          const currentCycle = Math.floor(currentTime / cycleTime) + 1;
          
          if (cycleProgress < 0.4) { // 吸氣階段 (4秒)
            showGuidedBreathingText(textElement, 'inhale');
          } else { // 呼氣階段 (6秒)
            showGuidedBreathingText(textElement, 'exhale');
          }
          
          // 更新進度（如果有進度條）
          if (progressFill) {
            const overallProgress = (currentTime / totalTime) * 100;
            progressFill.style.width = `${overallProgress}%`;
          }
          
          if (cycleCounter) {
            cycleCounter.textContent = `第 ${Math.min(currentCycle, totalCycles)} / ${totalCycles} 個週期`;
          }
          
          currentTime += 100;
          
          if (currentTime >= totalTime) {
            clearInterval(breathingInterval);
            showGuidedBreathingText(textElement, 'complete');
            onComplete();
          }
        }, 100);
      }
    }
    
    // 顯示引導呼吸文字
    function showGuidedBreathingText(textElement, phase) {
      switch (phase) {
        case 'inhale':
          textElement.textContent = '用鼻吸氣...';
          textElement.style.color = 'rgba(255, 255, 255, 0.95)';
          textElement.style.transform = 'translate(-50%, -50%) scale(1.2)';
          textElement.style.textShadow = '0 0 40px rgba(255, 255, 255, 0.9)';
          textElement.style.letterSpacing = '0.1em';
          break;
          
        case 'exhale':
          textElement.textContent = '用嘴呼氣...';
          textElement.style.color = 'rgba(147, 146, 255, 0.95)';
          textElement.style.transform = 'translate(-50%, -50%) scale(0.8)';
          textElement.style.textShadow = '0 0 30px rgba(147, 146, 255, 0.8)';
          textElement.style.letterSpacing = '0.05em';
          break;
          
        case 'complete':
          textElement.textContent = '天人合一，調息完成';
          textElement.style.color = '#10b981';
          textElement.style.transform = 'translate(-50%, -50%) scale(1)';
          textElement.style.textShadow = '0 0 25px rgba(16, 185, 129, 0.8)';
          textElement.style.letterSpacing = '0.05em';
          break;
      }
    }
    
    // 退出呼吸體驗，回到首頁
    function exitBreathingExperience() {
      console.log('退出呼吸體驗');
      
      // 清理呼吸動畫
      if (gameState.breathingInterval) {
        clearInterval(gameState.breathingInterval);
        gameState.breathingInterval = null;
      }
      
      // 移除呼吸模式
      const chaosForm = document.querySelector('.chaos-form');
      if (chaosForm) {
        chaosForm.classList.remove('breathing-mode');
      }
      
      // 清理呼吸引導界面
      const breathingGuide = document.querySelector('.breathing-guide-overlay');
      if (breathingGuide) {
        breathingGuide.remove();
      }
      
      // 停止背景音樂
      if (gameState.audioEnabled) {
        audioManager.stopBackgroundMusic(true);
      }
      
      // 清理第七章背景和效果
      cleanupChapterEffects();
      
      // 恢復遊戲狀態
      if (gameState.savedHomeState) {
        gameState.currentChapter = gameState.savedHomeState.chapter;
        gameState.currentScene = gameState.savedHomeState.scene;
        gameState.savedHomeState = null;
      }
      
      // 清理特殊狀態
      gameState.isBreathingExperience = false;
      
      // 恢復首頁背景
      document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
      gameContainer.style.background = 'transparent';
      
      // 隱藏遊戲內容，顯示首頁
      document.getElementById('game-content').style.display = 'none';
      document.getElementById('main-menu').style.display = 'flex';
      
      console.log('已退出呼吸體驗，回到首頁');
    }
    
          // 創建氣注入儀式場景（四次點擊版本）
    function createQiInfusionRitual(scene) {
      // 獲取現有的混沌圖形
      const chaosForm = document.querySelector('.chaos-form');
      if (!chaosForm) {
        console.error('未找到混沌圖形');
        return;
      }
      
      // 移除呼吸模式，恢復正常狀態
      chaosForm.classList.remove('breathing-mode');
      
      // 指示器已在呼吸挑战场景中隐藏，这里不需要重复隐藏
      console.log('气注入仪式场景：指示器已在呼吸挑战中隐藏');
      
      // 在开始时就生成大量粒子，避免动画过程中的生成冲突
      preGenerateParticlesForRitual();
      
      // 四個階段的配置
      const phases = [
        { name: '語言歸復', duration: 5000, description: '語言歸復，萬物之名回歸本源...', particleType: 'bagua-text' },
        { name: '八卦歸復', duration: 5000, description: '八卦歸復，天地之理回歸本源...', particleType: 'bagua-symbols' },
        { name: '陰陽歸復', duration: 4000, description: '陰陽歸復，對立統一回歸本源...', particleType: 'void-particles' },
        { name: '太極歸復', duration: 3000, description: '太極歸復，一切回歸無極之道...', particleType: 'taiji-symbols' }
      ];
      
      let currentPhase = 0;
      let isAnimating = false;
      
      // 創建儀式引導界面
      const ritualGuide = document.createElement('div');
      ritualGuide.className = 'ritual-guide-overlay';
      ritualGuide.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: 15;
        pointer-events: none;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      `;
      
      ritualGuide.innerHTML = `
        <div class="ritual-status" style="
          position: absolute;
          bottom: 10%;
          left: 50%;
          transform: translateX(-50%);
          background: rgba(0, 0, 0, 0.8);
          padding: 1.5rem 2rem;
          border-radius: 12px;
          backdrop-filter: blur(10px);
          border: 1px solid rgba(255, 255, 255, 0.3);
          text-align: center;
          color: white;
          transition: opacity 0.5s ease;
          min-width: 450px;
        ">
          <div class="main-instruction" style="font-size: 1.1rem; margin-bottom: 1rem; opacity: 0.9;">將萬物之氣復歸混沌</div>
          <div class="phase-description" style="font-size: 0.9rem; margin-bottom: 1rem; opacity: 0.8; color: #a0a0a0;">點擊按鈕開始氣注入儀式的四個階段</div>
          <div class="phase-button-container" style="margin-bottom: 1rem;">
            <button class="phase-button" style="
              background: linear-gradient(135deg, #6366f1, #8b5cf6);
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 8px;
              font-size: 1rem;
              font-weight: 600;
              cursor: pointer;
              transition: all 0.3s ease;
              box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
              animation: pulse 2s infinite;
            ">${phases[0].name}</button>
          </div>
          <div class="progress-indicator" style="
            width: 350px;
            height: 10px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 0 auto;
          ">
            <div class="progress-bar" style="
              height: 100%;
              background: linear-gradient(90deg, #ffffff, #cccccc, #999999, #000000);
              border-radius: 5px;
              width: 0%;
              transition: width 0.3s ease;
            "></div>
          </div>
          <div class="phase-counter" style="font-size: 0.8rem; margin-top: 0.5rem; opacity: 0.7;">第 1 / 4 個階段</div>
        </div>
      `;
      
      document.body.appendChild(ritualGuide);
      
      const phaseButton = ritualGuide.querySelector('.phase-button');
      const phaseDescription = ritualGuide.querySelector('.phase-description');
      const progressBar = ritualGuide.querySelector('.progress-bar');
      const phaseCounter = ritualGuide.querySelector('.phase-counter');
      
      // 啟用按鈕點擊功能
      phaseButton.style.pointerEvents = 'auto';
      
      // 處理階段按鈕點擊
      phaseButton.addEventListener('click', () => {
        if (isAnimating) return;
        
        isAnimating = true;
        
        // 按鈕淡出
        phaseButton.style.opacity = '0';
        phaseButton.style.transform = 'scale(0.9)';
        phaseButton.style.pointerEvents = 'none';
        
        // 更新描述
        phaseDescription.textContent = phases[currentPhase].description;
        
        // 開始當前階段的動畫
        startPhaseAnimation(phases[currentPhase], () => {
          // 動畫完成後
          currentPhase++;
          
          // 更新進度條
          const progress = (currentPhase / phases.length) * 100;
          progressBar.style.width = `${progress}%`;
          
          if (currentPhase < phases.length) {
            // 還有階段，顯示下一個按鈕
            phaseCounter.textContent = `第 ${currentPhase + 1} / 4 個階段`;
            phaseButton.textContent = phases[currentPhase].name;
            phaseButton.style.opacity = '1';
            phaseButton.style.transform = 'scale(1)';
            phaseButton.style.pointerEvents = 'auto';
            phaseDescription.textContent = '點擊按鈕繼續下一階段';
            isAnimating = false;
          } else {
            // 所有階段完成
            phaseCounter.textContent = '所有階段完成';
            phaseDescription.textContent = '萬物歸道，氣注入完成！';
            
            // 開始UI清空效果
        setTimeout(() => {
              clearAllUIElements(() => {
                console.log('UI清空完成，清理引導界面並顯示標準繼續按鈕');
                
                // 清理氣注入儀式引導界面
                ritualGuide.remove();
                console.log('氣注入儀式引導界面已清理');
                
                // 指示器保持隱藏，直到尾聲章節斷句挑戰完成後才顯示
                console.log('指示器保持隱藏狀態，等待尾聲章節斷句挑戰完成');
                
                // 顯示標準的繼續按鈕
                advanceBtn.style.display = 'block';
                advanceBtn.textContent = '繼續';
                console.log('標準繼續按鈕已顯示');
              });
            }, 1000);
          }
        });
      });
      
      // 開始階段動畫
      function startPhaseAnimation(phase, onComplete) {
        console.log(`開始階段動畫: ${phase.name}`);
        
        // 提高八卦符號生成速度
        if (phase.particleType === 'bagua-symbols') {
          increaseBaguaSymbolGeneration();
        }
        
        // 觸發對應的粒子動畫
        triggerPhaseParticleAnimation(phase, onComplete);
      }
      
      // 觸發階段粒子動畫
      function triggerPhaseParticleAnimation(phase, onComplete) {
        const chaosForm = document.querySelector('.chaos-form');
        if (!chaosForm) {
          console.error('未找到混沌形體');
          setTimeout(onComplete, phase.duration);
            return;
          }
          
        const rect = chaosForm.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        console.log(`${phase.name} 階段開始，混沌中心位置: (${centerX}, ${centerY})`);
        
        // 找到對應的粒子
        let particles = [];
        
        switch (phase.particleType) {
          case 'bagua-text':
            particles = document.querySelectorAll('.bagua-text-particle');
            console.log(`找到 ${particles.length} 個八卦文字粒子`);
            break;
          case 'bagua-symbols':
            particles = document.querySelectorAll('.bagua-symbol');
            console.log(`找到 ${particles.length} 個八卦符號粒子`);
            break;
          case 'void-particles':
            particles = document.querySelectorAll('.void-particle');
            console.log(`找到 ${particles.length} 個虛空粒子`);
            // 停止虚空粒子的CSS动画，让它们保持在当前位置
            particles.forEach(particle => {
              particle.style.animation = 'none';
              particle.style.opacity = '0.8';
              particle.style.transform = 'none';
              particle.style.position = 'absolute';
            });
            break;
          case 'taiji-symbols':
            // 專門查找場景中心的太極符號（在太極容器中的），排除指示器中的太極符號
            particles = document.querySelectorAll('.taiji-container .yin-yang-emoji');
            console.log(`找到場景中心的太極符號 ${particles.length} 個`);
            
            // 如果沒有找到場景中心的太極符號，檢查太極容器是否存在
            if (particles.length === 0) {
              const taijiContainer = document.querySelector('.taiji-container');
              console.log('太極容器存在:', !!taijiContainer);
              if (taijiContainer) {
                console.log('太極容器樣式:', taijiContainer.style.cssText);
                console.log('太極容器可見性:', taijiContainer.style.display !== 'none' && taijiContainer.style.opacity !== '0');
                
                // 確保太極符號存在並可見
                const yinYangEmoji = taijiContainer.querySelector('.yin-yang-emoji');
                if (!yinYangEmoji) {
                  console.log('創建缺失的太極符號');
                  const newYinYang = document.createElement('div');
                  newYinYang.className = 'yin-yang-emoji';
                  newYinYang.textContent = '☯︎';
                  taijiContainer.appendChild(newYinYang);
                }
                
                // 確保太極容器可見
                taijiContainer.style.display = 'block';
                taijiContainer.style.opacity = '1';
                
                // 重新查找太極符號
                particles = document.querySelectorAll('.taiji-container .yin-yang-emoji');
                console.log(`重新查找後找到場景中心的太極符號 ${particles.length} 個`);
              } else {
                console.log('太極容器不存在，創建新的場景中心太極符號');
                // 創建新的太極容器和符號
                const newTaijiContainer = document.createElement('div');
                newTaijiContainer.className = 'taiji-container';
                newTaijiContainer.style.display = 'block';
                newTaijiContainer.style.opacity = '1';
                
                const newYinYang = document.createElement('div');
                newYinYang.className = 'yin-yang-emoji';
                newYinYang.textContent = '☯︎';
                
                newTaijiContainer.appendChild(newYinYang);
                gameContainer.appendChild(newTaijiContainer);
                
                // 重新查找太極符號
                particles = document.querySelectorAll('.taiji-container .yin-yang-emoji');
                console.log(`創建新太極符號後找到場景中心的太極符號 ${particles.length} 個`);
              }
            }
            
            // 額外檢查：確保我們找到的太極符號確實是場景中心的，而不是指示器中的
            if (particles.length > 0) {
              console.log('驗證太極符號位置:');
              particles.forEach((particle, index) => {
                const container = particle.closest('.taiji-container');
                const isInIndicator = particle.closest('#apertures-tracker');
                console.log(`太極符號 ${index}: 在太極容器中=${!!container}, 在指示器中=${!!isInIndicator}`);
              });
            }
            break;
        }
        
        // 特殊處理太極歸復動畫 - 使用獨立的動畫系統
        if (phase.particleType === 'taiji-symbols') {
          console.log('太極歸復階段：使用獨立動畫系統');
          // 創建太極階段配置
          const taijiPhase = {
            name: 'taiji-symbols',
            duration: 3000,
            existing: '.yin-yang-emoji',
            generationRate: null,
            particlesPerGeneration: 0,
            containerClass: 'taiji-container'
          };
          // 調用獨立的太極歸復動畫
          animateEnhancedParticles(taijiPhase, onComplete);
        } else {
          // 其他階段使用原有的粒子動畫
          if (particles.length > 0) {
            console.log(`開始粒子飛向中心動畫，共 ${particles.length} 個粒子`);
            animateParticlesToCenter(Array.from(particles), centerX, centerY);
          } else {
            console.warn(`${phase.name} 階段沒有找到對應的粒子`);
          }
          
          // 根據階段持續時間等待動畫完成
          setTimeout(onComplete, phase.duration);
        }
      }
      
      // 预生成气注入仪式所需的大量粒子
      function preGenerateParticlesForRitual() {
        console.log('开始预生成气注入仪式的粒子');
        
        // 首先停止八卦符号的自动生成
        stopBaguaSymbolGeneration();
        
        // 停止虚空粒子的持续生成
        stopVoidParticleGeneration();
        
        // 确保有足够的八卦文字粒子
        const baguaTextContainer = document.querySelector('.bagua-floating-text');
        if (baguaTextContainer) {
          const baguaTexts = [
            { text: '乾', color: '#FFD700' }, { text: '兌', color: '#C0C0C0' },
            { text: '離', color: '#FF6347' }, { text: '震', color: '#32CD32' },
            { text: '巽', color: '#87CEEB' }, { text: '坎', color: '#4169E1' },
            { text: '艮', color: '#8B4513' }, { text: '坤', color: '#DAA520' },
            { text: '天', color: '#FFD700' }, { text: '澤', color: '#C0C0C0' },
            { text: '火', color: '#FF6347' }, { text: '雷', color: '#32CD32' },
            { text: '風', color: '#87CEEB' }, { text: '水', color: '#4169E1' },
            { text: '山', color: '#8B4513' }, { text: '地', color: '#DAA520' }
          ];
          
          // 生成30个八卦文字粒子
          for (let i = 0; i < 30; i++) {
            const randomText = baguaTexts[Math.floor(Math.random() * baguaTexts.length)];
            const textParticle = document.createElement('div');
            textParticle.className = 'bagua-text-particle';
            textParticle.textContent = randomText.text;
            textParticle.style.cssText = `
              position: absolute;
              font-size: ${20 + Math.random() * 16}px;
              font-family: "Noto Serif SC", "Source Han Serif SC", serif;
              font-weight: 600;
              color: ${randomText.color};
              text-shadow: 0 0 15px ${randomText.color}, 0 0 30px ${randomText.color}80;
              left: ${Math.random() * 85 + 7.5}%;
              top: ${Math.random() * 85 + 7.5}%;
              z-index: 12;
              pointer-events: none;
              animation: float-glow 4s ease-in-out infinite;
              animation-delay: ${Math.random() * 2}s;
            `;
            baguaTextContainer.appendChild(textParticle);
          }
        }
        
        // 确保有足够的八卦符号粒子
        const baguaContainer = document.querySelector('.bagua-symbols');
        if (baguaContainer) {
          const baguaData = [
            { symbol: '☰', name: 'qian', title: '乾-天' },
            { symbol: '☱', name: 'dui', title: '兌-澤' },
            { symbol: '☲', name: 'li', title: '離-火' },
            { symbol: '☳', name: 'zhen', title: '震-雷' },
            { symbol: '☴', name: 'xun', title: '巽-風' },
            { symbol: '☵', name: 'kan', title: '坎-水' },
            { symbol: '☶', name: 'gen', title: '艮-山' },
            { symbol: '☷', name: 'kun', title: '坤-地' }
          ];
          
          // 生成25个八卦符号粒子
          for (let i = 0; i < 25; i++) {
            const randomBagua = baguaData[Math.floor(Math.random() * baguaData.length)];
            const baguaSymbol = document.createElement('div');
            baguaSymbol.className = 'bagua-symbol';
            baguaSymbol.textContent = randomBagua.symbol;
            baguaSymbol.style.cssText = `
              position: absolute;
              font-size: 24px;
              color: white;
              text-shadow: 0 0 10px rgba(255, 255, 255, 0.8);
              pointer-events: none;
              z-index: 13;
              left: ${Math.random() * 90 + 5}%;
              top: ${Math.random() * 90 + 5}%;
              animation: float-glow 3s ease-in-out infinite;
              animation-delay: ${Math.random() * 2}s;
            `;
            baguaContainer.appendChild(baguaSymbol);
          }
        }
        
        // 确保虚空粒子已经存在（通常在createVoidScene中已生成）
        const voidParticles = document.querySelectorAll('.void-particle');
        console.log(`预生成完成：八卦文字粒子30个，八卦符号粒子25个，虚空粒子${voidParticles.length}个`);
      }
      
      // 停止八卦符号的自动生成
      function stopBaguaSymbolGeneration() {
        console.log('停止八卦符号的自动生成');
        
        // 找到八卦符号容器
        const baguaContainer = document.querySelector('.bagua-symbols');
        if (baguaContainer && baguaContainer.baguaInterval) {
          // 清除定时器
          clearInterval(baguaContainer.baguaInterval);
          baguaContainer.baguaInterval = null;
          console.log('已清除八卦符号生成定时器');
        } else {
          console.log('未找到八卦符号容器或定时器');
        }
      }
      
      // 停止虚空粒子的持续生成
      function stopVoidParticleGeneration() {
        console.log('停止虚空粒子的持续生成');
        
        // 停止所有现有虚空粒子的动画
        const voidParticles = document.querySelectorAll('.void-particle');
        voidParticles.forEach(particle => {
          particle.style.animation = 'none';
          particle.style.opacity = '0.8';
        });
        
        // 查找并清除虚空粒子的定时器
        const voidContainer = document.querySelector('.void-particles');
        if (voidContainer && voidContainer.voidInterval) {
          clearInterval(voidContainer.voidInterval);
          voidContainer.voidInterval = null;
          console.log('已清除虚空粒子生成定时器');
        } else {
          console.log('未找到虚空粒子容器或定时器');
        }
      }
      
      // 提高八卦符號生成速度（现在改为预生成后的清理函数）
      function increaseBaguaSymbolGeneration() {
        // 这个函数现在不再需要，因为我们已经预生成了足够的粒子
        console.log('八卦符号已预生成，无需额外增加生成速度');
      }
      
      // 原 createContinueButton 函數已移除，現在使用標準的 advanceBtn
      
      // 清空所有UI元素並讓它們變為白色
      function clearAllUIElements(onComplete) {
        console.log('開始清空所有UI元素');
        
        // 獲取所有UI元素（不包括繼續按鈕）
        const uiElements = document.querySelectorAll('.ritual-guide-overlay, .void-particles, .taiji-container, .bagua-symbols, .bagua-text-particle, .bagua-symbol, .void-particle, .yin-yang-emoji');
        
        // 逐漸將所有UI元素透明化
        uiElements.forEach((element, index) => {
          if (element) {
            setTimeout(() => {
              element.style.transition = 'opacity 0.8s ease-out, color 0.8s ease-out';
              element.style.opacity = '0';
              element.style.color = 'white';
            }, index * 100);
          }
        });
        
        // 將背景也變為白色
        setTimeout(() => {
          document.body.style.transition = 'background-color 2s ease-out';
          document.body.style.backgroundColor = 'white';
          
          gameContainer.style.transition = 'background-color 2s ease-out';
          gameContainer.style.backgroundColor = 'white';
        }, 500);
        
        // 等待所有動畫完成後調用回調
        setTimeout(() => {
          console.log('所有UI元素已清空');
          if (onComplete) {
            onComplete();
          }
        }, 2000);
      }
    }
    
    // 處理同步的氣注入過程（點按後立即開始粒子動畫和進度條）
    function handleSynchronizedInjection(element, statusText, phaseIndicator, progressBar, onComplete) {
      let isInjecting = false;
      let isPaused = false;
      let injectionTimer = null;
      let currentPhase = 0;
      let phaseProgress = 0;
      
      // 四個階段的配置（氣形態視野下的黑白效果）
      const phases = [
        { name: '語言歸復', duration: 5000, description: '語言歸復，萬物之名回歸本源...' },
        { name: '八卦歸復', duration: 5000, description: '八卦歸復，天地之理回歸本源...' },
        { name: '陰陽歸復', duration: 4000, description: '陰陽歸復，對立統一回歸本源...' },
        { name: '太極歸復', duration: 3000, description: '太極歸復，一切回歸無極之道...' }
      ];
      
      const totalDuration = phases.reduce((sum, phase) => sum + phase.duration, 0); // 13秒總時長
      
      const startInjection = () => {
        if (isInjecting && !isPaused) return;
        
        isInjecting = true;
        isPaused = false;
        statusText.textContent = '正在注入萬物之氣...請保持按住不放';
        
        // 只在初次開始時觸發粒子動畫，繼續時不重新觸發
        if (phaseProgress === 0) {
        triggerSynchronizedParticleSequence();
        }
        
        // 開始進度條和階段指示器更新
        injectionTimer = setInterval(() => {
          phaseProgress += 100; // 每100ms更新一次
          
          // 計算當前階段
          let accumulatedTime = 0;
          let newPhase = 0;
          for (let i = 0; i < phases.length; i++) {
            if (phaseProgress <= accumulatedTime + phases[i].duration) {
              newPhase = i;
              break;
            }
            accumulatedTime += phases[i].duration;
          }
          
          // 更新階段指示器（氣形態視野下保持黑白效果）
          if (newPhase !== currentPhase) {
            currentPhase = newPhase;
            if (currentPhase < phases.length) {
              phaseIndicator.textContent = phases[currentPhase].description;
              // 氣形態視野下不設置額外顏色，保持黑白濾鏡效果
            }
          }
          
          // 更新進度條
          const progress = Math.min(100, (phaseProgress / totalDuration) * 100);
          progressBar.style.width = `${progress}%`;
          
          // 檢查是否完成
          if (phaseProgress >= totalDuration) {
            clearInterval(injectionTimer);
            statusText.textContent = '萬物歸道，氣注入完成！';
            phaseIndicator.textContent = '道生一，一生二，二生三，三生萬物';
            // 氣形態視野下不設置額外顏色，保持黑白濾鏡效果
            setTimeout(onComplete, 1000);
          }
        }, 100);
      };
      
      const pauseInjection = () => {
        if (injectionTimer) {
          clearInterval(injectionTimer);
          injectionTimer = null;
        }
        
        // 標記為暫停狀態，但保留進度
        isInjecting = false;
        isPaused = true;
        
        // 更新狀態提示
        if (phaseProgress > 0 && phaseProgress < totalDuration) {
          statusText.textContent = '儀式已暫停 - 再次點按混沌繼續注入';
          phaseIndicator.textContent = '點按混沌繼續儀式，記住要按住不放';
        } else if (phaseProgress === 0) {
        statusText.textContent = '準備注入萬物之氣';
          phaseIndicator.textContent = '點按混沌開始儀式，按住不放直到完成';
        }
      };
      
      // 鼠標事件
      element.addEventListener('mousedown', startInjection);
      element.addEventListener('mouseup', pauseInjection);
      element.addEventListener('mouseleave', pauseInjection);
      
      // 觸摸事件（移動設備）
      element.addEventListener('touchstart', (e) => {
        e.preventDefault();
        startInjection();
      });
      element.addEventListener('touchend', (e) => {
        e.preventDefault();
        pauseInjection();
      });
      element.addEventListener('touchcancel', (e) => {
        e.preventDefault();
        pauseInjection();
      });
    }

    // 同步的粒子序列動畫（與進度條同步）
    function triggerSynchronizedParticleSequence() {
      let sequenceStep = 0;
      
      // 階段式粒子注入系統（與進度條同步）
      const injectionPhases = [
        {
          name: 'bagua-text',
          duration: 5000,
          existing: '.bagua-text-particle',
          generationRate: 500,
          particlesPerGeneration: 2,
          containerClass: 'bagua-floating-text'
        },
        {
          name: 'bagua-symbols', 
          duration: 5000,
          existing: '.bagua-symbol',
          generationRate: 300,
          particlesPerGeneration: 3,
          containerClass: 'bagua-symbols'
        },
        {
          name: 'void-particles',
          duration: 4000,
          existing: '.void-particle',
          generationRate: null,
          particlesPerGeneration: 0,
          containerClass: 'void-particles'
        },
        {
          name: 'taiji-symbols',
          duration: 3000,
          existing: '.yin-yang-emoji',
          generationRate: null,
          particlesPerGeneration: 0,
          containerClass: 'taiji-container'
        }
      ];
      
      const executePhase = () => {
        if (sequenceStep < injectionPhases.length) {
          const phase = injectionPhases[sequenceStep];
          console.log(`開始第${sequenceStep + 1}階段：${phase.name}`);
          
          // 執行增強的粒子動畫
          animateEnhancedParticles(phase, () => {
            sequenceStep++;
            if (sequenceStep < injectionPhases.length) {
              // 立即開始下一階段，不等待
              executePhase();
            } else {
              // 所有階段完成，開始清空UI
              setTimeout(() => {
                clearAllUIElements(() => {
                  // UI清空完成後，什麼都不做，等待進度條完成
                });
              }, 500);
            }
          });
        }
      };
      
      executePhase();
    }

    // 創建道的顯現場景（三行文字依次顯示）
    function createDaoRevelationScene(scene) {
      console.log('🌟 createDaoRevelationScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      try {
        // 清空所有內容，創建純白背景
        console.log('清空遊戲內容...');
        gameContent.innerHTML = '';
        
        console.log('設置純白背景...');
        gameContainer.style.background = '#ffffff';
        gameContainer.style.transition = 'background 2s ease';
        
        // 重要：保持氣形態的黑白濾鏡效果，讓文字在黑白視野中顯示
        console.log('保持氣形態濾鏡效果...');
        // 不移除氣形態效果，保持黑白濾鏡
        console.log('✅ 氣形態濾鏡已保持');
      } catch (error) {
        console.error('❌ createDaoRevelationScene 初始化失敗:', error);
        console.log('錯誤堆棧:', error.stack);
      }
      
      // 隱藏繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 創建三行文字容器
      const revelationContainer = document.createElement('div');
      revelationContainer.className = 'dao-revelation-container';
      revelationContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 20;
        width: 90%;
        max-width: 600px;
      `;
      
      // 三行文字內容
      const revelationTexts = [
        '道可道，非常道。',
        '道生一，一生二，二生三，三生萬物。',
        '道法自然。' 
      ];
      
      // 創建三行文字元素
      const textElements = revelationTexts.map((text, index) => {
        const textEl = document.createElement('div');
        textEl.className = 'dao-text-line';
        textEl.style.cssText = `
          font-size: 2rem;
          font-family: "Noto Serif SC", "Source Han Serif SC", serif;
          font-weight: 600;
          color: #000000;
          margin: 2rem 0;
          opacity: 0;
          transform: translateY(20px);
          transition: all 1.5s ease;
        `;
        textEl.textContent = text;
        return textEl;
      });
      
      // 添加文字元素到容器
      textElements.forEach(el => revelationContainer.appendChild(el));
      document.body.appendChild(revelationContainer);
      
      // 依次顯示三行文字
      let currentLine = 0;
      const showNextLine = () => {
        if (currentLine < textElements.length) {
          const currentEl = textElements[currentLine];
          setTimeout(() => {
            currentEl.style.opacity = '1';
            currentEl.style.transform = 'translateY(0)';
            currentLine++;
            setTimeout(showNextLine, 3000); // 每行間隔3秒（恢復原來的設計）
          }, 800); // 延長每行顯示前的等待時間（恢復原來的設計）
        } else {
          // 所有文字顯示完畢，顯示標準繼續按鈕
          setTimeout(() => {
            console.log('道的顯現三句話完成，顯示標準繼續按鈕');
            // 不需要自定義按鈕，直接顯示標準按鈕
            advanceBtn.style.display = 'block';
            advanceBtn.textContent = '繼續';
            
            // 添加場景切換時的清理邏輯
            advanceBtn.addEventListener('click', () => {
              console.log('道的顯現場景繼續按鈕被點擊，清理場景元素');
              // 清理道的顯現場景元素
              const daoContainer = document.querySelector('.dao-revelation-container');
              if (daoContainer) {
                daoContainer.remove();
              }
            }, { once: true });
        }, 2000);
        }
      };
      
      // 開始顯示文字
      setTimeout(showNextLine, 1500); // 延遲1.5秒開始（恢復原來的設計）
    }
    
    // 道的顯現場景現在使用標準的繼續按鈕，不需要自定義按鈕函數
    
    // 【已刪除重複函數】第二個showEpilogueTitle函數已刪除，避免衝突
    
    // 觸發增強的粒子序列（按照哲學順序：萬物歸道）
    function triggerExistingParticleSequence(onComplete) {
      let sequenceStep = 0;
      
      // 階段式粒子注入系統（按照用戶要求的順序）
      const injectionPhases = [
        {
          name: 'bagua-text',
          duration: 4000,           // 4秒持續時間
          existing: '.bagua-text-particle',
          generationRate: 500,      // 每0.5秒生成新粒子
          particlesPerGeneration: 2, // 每次生成2個
          containerClass: 'bagua-floating-text'
        },
        {
          name: 'bagua-symbols', 
          duration: 4000,
          existing: '.bagua-symbol',
          generationRate: 800,      // 每0.8秒生成新粒子
          particlesPerGeneration: 1,
          containerClass: 'bagua-symbols'
        },
        {
          name: 'void-particles',
          duration: 3000,
          existing: '.void-particle',
          generationRate: null,     // 不額外生成，50個已足夠
          particlesPerGeneration: 0,
          containerClass: 'void-particles'
        },
        {
          name: 'taiji-symbols',
          duration: 3000,  // 太極動畫需要3秒
          existing: '.yin-yang-emoji',
          generationRate: null,     // 太極符號只有1個
          particlesPerGeneration: 0,
          containerClass: 'taiji-container'
        }
      ];
      
      const executePhase = () => {
        if (sequenceStep < injectionPhases.length) {
          const phase = injectionPhases[sequenceStep];
          console.log(`開始第${sequenceStep + 1}階段：${phase.name}`);
          
          // 執行增強的粒子動畫
          animateEnhancedParticles(phase, () => {
            sequenceStep++;
            setTimeout(executePhase, 800); // 每波間隔0.8秒
          });
        } else {
          // 所有粒子序列完成，開始清空UI
          clearAllUIElements(onComplete);
        }
      };
      
      executePhase();
    }
    
    // 增強的粒子動畫系統（支持動態生成和現有粒子）
    function animateEnhancedParticles(phase, onComplete) {
      // 特殊處理太極歸復動畫 - 完全獨立於其他粒子系統
      if (phase.name === 'taiji-symbols') {
        animateTaijiReturn(phase, onComplete);
        return;
      }
      
      const chaosForm = document.querySelector('.chaos-form');
      const container = document.querySelector(`.${phase.containerClass}`);
      
      if (!chaosForm) {
        console.log('未找到混沌圖形');
        onComplete();
        return;
      }
      
      const chaosRect = chaosForm.getBoundingClientRect();
      const chaosCenterX = chaosRect.left + chaosRect.width / 2;
      const chaosCenterY = chaosRect.top + chaosRect.height / 2;
      
      // 獲取現有粒子 - 改進選擇邏輯，覆蓋更廣範圍
      let existingParticles = [];
        if (phase.existing === '.bagua-text-particle') {
        // 從整個文檔中查找，不限於特定容器
        existingParticles = document.querySelectorAll('.bagua-text-particle');
        } else if (phase.existing === '.bagua-symbol') {
        // 查找所有八卦符號，包括容器內和容器外的
        existingParticles = document.querySelectorAll('.bagua-symbol');
        } else if (phase.existing === '.void-particle') {
        // 查找所有虛空粒子
        existingParticles = document.querySelectorAll('.void-particle');
        } else if (phase.existing === '.yin-yang-emoji') {
        // 查找所有太極符號
        existingParticles = document.querySelectorAll('.yin-yang-emoji');
      }
      
      // 過濾掉已經在動畫中的粒子
      existingParticles = Array.from(existingParticles).filter(particle => {
        return particle && 
               !particle.classList.contains('animating-to-center') && 
               !particle.classList.contains('injection-particle');
      });
      
      console.log(`${phase.name} 階段：找到 ${existingParticles.length} 個現有粒子`);
      
      // 立即開始動畫現有粒子
      if (existingParticles.length > 0) {
        animateParticlesToCenter(existingParticles, chaosCenterX, chaosCenterY);
      }
      
      // 如果需要動態生成新粒子
      if (phase.generationRate && phase.particlesPerGeneration > 0) {
        console.log(`${phase.name} 阶段：开始动态生成粒子`);
        startDynamicParticleGeneration(phase, chaosCenterX, chaosCenterY, container);
      }
      
      // 在階段持續時間結束後完成
      setTimeout(() => {
        // 停止動態生成（如果有的話）
        if (phase.generationInterval) {
          clearInterval(phase.generationInterval);
        }
        
        // 移除容器（如果需要的話）
        if (container && phase.name !== 'void-particles') {
          // 保留虛空粒子容器，因為其他階段可能還需要
          setTimeout(() => {
            if (document.contains(container)) {
              container.remove();
            }
          }, 2000);
        }
        
        onComplete();
      }, phase.duration);
    }
    
    // 完全獨立的太極歸復動畫函數
    function animateTaijiReturn(phase, onComplete) {
      console.log('開始太極歸復動畫');
      
      // 獲取混沌中心位置
      const chaosForm = document.querySelector('.chaos-form');
      if (!chaosForm) {
        console.log('未找到混沌圖形');
        onComplete();
        return;
      }
      
      const chaosRect = chaosForm.getBoundingClientRect();
      const chaosCenterX = chaosRect.left + chaosRect.width / 2;
      const chaosCenterY = chaosRect.top + chaosRect.height / 2;
      
      // 獲取太極容器
      const taijiContainer = document.querySelector('.taiji-container');
      if (!taijiContainer) {
        console.log('未找到太極容器');
        onComplete();
        return;
      }
      
      console.log(`太極容器開始歸復動畫，目標位置: (${chaosCenterX}, ${chaosCenterY})`);
      
      // 停止太極容器的旋轉動畫
      taijiContainer.style.animation = 'none';
      
      // 開始太極歸復動畫
      taijiContainer.style.transition = 'all 3s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
      
      setTimeout(() => {
        // 移動到混沌中心並縮小消失
        taijiContainer.style.left = `${chaosCenterX}px`;
        taijiContainer.style.top = `${chaosCenterY}px`;
        taijiContainer.style.transform = 'translate(-50%, -50%) scale(0.1)';
        taijiContainer.style.opacity = '0.3';
        taijiContainer.style.filter = 'blur(2px)';
        
        console.log('太極容器開始歸復到混沌中心');
        
        // 動畫完成後移除太極容器
        setTimeout(() => {
          if (taijiContainer.parentNode) {
            taijiContainer.parentNode.removeChild(taijiContainer);
            console.log('太極容器歸復完成並移除');
          }
          onComplete();
        }, 3000);
      }, 100);
    }
    
    // 讓粒子飛向混沌中心
    function animateParticlesToCenter(particles, centerX, centerY) {
      console.log(`開始執行粒子飛向中心動畫，共 ${particles.length} 個粒子，目標位置: (${centerX}, ${centerY})`);
      
      particles.forEach((particle, index) => {
        if (particle) {
          // 標記粒子為動畫中，避免重複選擇
          particle.classList.add('animating-to-center');
          
          // 記錄粒子的初始位置
          const initialRect = particle.getBoundingClientRect();
          const initialCenterX = initialRect.left + initialRect.width / 2;
          const initialCenterY = initialRect.top + initialRect.height / 2;
          
          console.log(`粒子 ${index} 初始中心位置: (${initialCenterX}, ${initialCenterY}), 目标位置: (${centerX}, ${centerY})`);
          
          // 停止現有動畫
          particle.style.animation = 'none';
          particle.style.transition = 'none';
          
          // 設置粒子為固定定位，避免被其他元素影響
          particle.style.position = 'fixed';
          particle.style.left = `${initialCenterX}px`;
          particle.style.top = `${initialCenterY}px`;
          particle.style.margin = '0';
          particle.style.zIndex = '35';
          particle.style.transform = 'translate(-50%, -50%)';
          
          // 强制触发重排，确保位置设置生效
          particle.offsetHeight;
          
          // 其他粒子的正常處理
          particle.style.transition = 'all 2s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
          
          setTimeout(() => {
            particle.style.left = `${centerX}px`;
            particle.style.top = `${centerY}px`;
            particle.style.opacity = '0';
            particle.style.transform = 'translate(-50%, -50%) scale(0.3)';
            console.log(`粒子 ${index} 开始飞向中心: (${centerX}, ${centerY})`);
            
            // 動畫完成後移除粒子
            setTimeout(() => {
              if (particle.parentNode) {
                particle.parentNode.removeChild(particle);
                console.log(`粒子 ${index} 飞入完成并移除`);
              }
            }, 2000);
          }, index * 80);
        }
      });
    }
    
    // 動態生成新粒子並讓它們飛向中心
    function startDynamicParticleGeneration(phase, centerX, centerY, container) {
      if (!container) return;
      
      // 初始化全局間隔跟蹤
      if (!window.currentInjectionIntervals) {
        window.currentInjectionIntervals = [];
      }
      
      let generationCount = 0;
      const maxGenerations = Math.floor(phase.duration / phase.generationRate);
      
      phase.generationInterval = setInterval(() => {
        if (generationCount >= maxGenerations) {
          clearInterval(phase.generationInterval);
          // 從跟蹤列表中移除
          const index = window.currentInjectionIntervals.indexOf(phase.generationInterval);
          if (index > -1) {
            window.currentInjectionIntervals.splice(index, 1);
          }
          return;
        }
        
        // 生成新粒子
        for (let i = 0; i < phase.particlesPerGeneration; i++) {
          const newParticle = createInjectionParticle(phase.name);
          if (newParticle) {
            container.appendChild(newParticle);
            
            // 立即讓新粒子飛向中心
            setTimeout(() => {
              animateParticlesToCenter([newParticle], centerX, centerY);
            }, 100);
          }
        }
        
        generationCount++;
      }, phase.generationRate);
      
      // 跟蹤這個間隔，以便在重置時清理
      window.currentInjectionIntervals.push(phase.generationInterval);
    }
    
    // 創建注入專用粒子
    function createInjectionParticle(particleType) {
      let particle;
      
      if (particleType === 'bagua-text') {
        particle = document.createElement('div');
        particle.className = 'bagua-text-particle injection-particle';
        
        // 八卦文字內容
        const baguaTexts = [
          { text: '乾', color: '#FFD700' }, { text: '兌', color: '#C0C0C0' },
          { text: '離', color: '#FF6347' }, { text: '震', color: '#32CD32' },
          { text: '巽', color: '#87CEEB' }, { text: '坎', color: '#4169E1' },
          { text: '艮', color: '#8B4513' }, { text: '坤', color: '#DAA520' },
          { text: '天', color: '#FFD700' }, { text: '澤', color: '#C0C0C0' },
          { text: '火', color: '#FF6347' }, { text: '雷', color: '#32CD32' },
          { text: '風', color: '#87CEEB' }, { text: '水', color: '#4169E1' },
          { text: '山', color: '#8B4513' }, { text: '地', color: '#DAA520' }
        ];
        
        const randomText = baguaTexts[Math.floor(Math.random() * baguaTexts.length)];
        particle.textContent = randomText.text;
        
        // 樣式設置
        particle.style.position = 'absolute';
        particle.style.fontSize = `${20 + Math.random() * 16}px`;
        particle.style.fontFamily = '"Noto Serif SC", "Source Han Serif SC", serif';
        particle.style.fontWeight = '600';
        particle.style.color = randomText.color;
        particle.style.textShadow = `0 0 15px ${randomText.color}, 0 0 30px ${randomText.color}80`;
        particle.style.left = `${Math.random() * 85 + 7.5}%`;
        particle.style.top = `${Math.random() * 85 + 7.5}%`;
        particle.style.zIndex = '12';
        
      } else if (particleType === 'bagua-symbols') {
        particle = document.createElement('div');
        particle.className = 'bagua-symbol injection-particle';
        
        const baguaSymbols = ['☰', '☱', '☲', '☳', '☴', '☵', '☶', '☷'];
        particle.textContent = baguaSymbols[Math.floor(Math.random() * baguaSymbols.length)];
        
        particle.style.position = 'absolute';
        particle.style.fontSize = '24px';
        particle.style.left = `${Math.random() * 90 + 5}%`;
        particle.style.top = `${Math.random() * 90 + 5}%`;
        particle.style.zIndex = '13';
        particle.style.color = '#ffffff';
        particle.style.textShadow = '0 0 10px rgba(255,255,255,0.8)';
      }
      
      return particle;
    }
    
    // 清空所有UI元素
    function clearAllUIElements(onComplete) {
      const elementsToFade = document.querySelectorAll('body > *:not(script)');
      
      elementsToFade.forEach(element => {
        if (element.tagName !== 'SCRIPT') {
          element.style.transition = 'opacity 2s ease-out';
          element.style.opacity = '0';
        }
      });
      
      // 2秒後設置純白背景
      setTimeout(() => {
        document.body.style.background = '#ffffff';
        document.body.style.transition = 'background 1s ease';
        
        // 移除所有可見元素
        elementsToFade.forEach(element => {
          if (element.tagName !== 'SCRIPT') {
            element.style.display = 'none';
          }
        });
        
        onComplete();
      }, 2000);
    }

    // 創建製作人員名單場景
    function createCreditsScene(scene) {
      console.log('🎬 createCreditsScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 設置漸變背景
      gameContainer.style.background = 'linear-gradient(135deg, #1a1a2e, #16213e, #0f3460)';
      gameContainer.style.transition = 'background 2s ease';
      
      // 隱藏繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 創建製作人員名單容器
      const creditsContainer = document.createElement('div');
      creditsContainer.className = 'credits-container';
      creditsContainer.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        text-align: center;
        z-index: 20;
        width: 90%;
        max-width: 500px;
        color: #ffffff;
        padding: 2rem;
        display: flex;
        flex-direction: column;
        align-items: center;
      `;
      
      // 添加遊戲標題
      const titleElement = document.createElement('h1');
      titleElement.className = 'credits-title';
      titleElement.style.cssText = `
        font-size: 3rem;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        font-weight: 700;
        color: #FFD700;
        margin-bottom: 2rem;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        opacity: 0;
        transform: translateY(-30px);
        transition: all 2s ease;
      `;
      titleElement.textContent = scene.title || '萬物逍遙';
      creditsContainer.appendChild(titleElement);
      
      // 添加製作人員名單
      const creditsListElement = document.createElement('div');
      creditsListElement.className = 'credits-list';
      creditsListElement.style.cssText = `
        opacity: 0;
        transform: translateY(30px);
        transition: all 2s ease 1s;
      `;
      
      // 處理製作人員名單
      if (scene.credits && Array.isArray(scene.credits)) {
        scene.credits.forEach((credit, index) => {
          const creditLine = document.createElement('div');
          creditLine.className = 'credit-line';
          creditLine.style.cssText = `
            font-size: ${credit === '' ? '0.5rem' : '1.2rem'};
            font-family: "LXGW WenKai", "Noto Serif TC", serif;
            font-weight: ${credit.includes('開發者') ? '600' : '400'};
            color: ${credit.includes('開發者') ? '#87CEEB' : '#ffffff'};
            margin: ${credit === '' ? '0.5rem 0' : '0.8rem 0'};
            line-height: 1.6;
          `;
          creditLine.textContent = credit === '' ? ' ' : credit;
          creditsListElement.appendChild(creditLine);
        });
      }
      
      creditsContainer.appendChild(creditsListElement);
      
      // 添加感謝文字
      const thanksElement = document.createElement('div');
      thanksElement.className = 'credits-thanks';
      thanksElement.style.cssText = `
        font-size: 1.2rem;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        color: #FFD700;
        margin-top: 2rem;
        opacity: 0;
        transform: translateY(20px);
        transition: all 2s ease 3s;
        text-shadow: 0 2px 8px rgba(255, 215, 0, 0.3);
        font-weight: 600;
      `;
      thanksElement.textContent = '🎉 恭喜通關！​你已獲得「神秘禮物」，請點擊打開。另外，已解鎖「和莊子聊聊」、「和混沌呼吸」功能， 可點擊「返回首頁」體驗。';
      creditsContainer.appendChild(thanksElement);
      
      // 添加到頁面
      document.body.appendChild(creditsContainer);
      
      // 啟動動畫序列
      setTimeout(() => {
        // 顯示標題
        titleElement.style.opacity = '1';
        titleElement.style.transform = 'translateY(0)';
      }, 500);
      
      setTimeout(() => {
        // 顯示製作人員名單
        creditsListElement.style.opacity = '1';
        creditsListElement.style.transform = 'translateY(0)';
      }, 1500);
      
      setTimeout(() => {
        // 顯示感謝文字
        thanksElement.style.opacity = '1';
        thanksElement.style.transform = 'translateY(0)';
      }, 3500);
      
      // 祝贺文字动画完成后（3500ms + 2000ms动画时间 + 500ms延迟）创建按钮
      setTimeout(() => {
        createAIReportButton(creditsContainer);
        createSegmentationReportButton(creditsContainer);
        createCreditsEndButton(creditsContainer);
      }, 6000);
    }
    
    // 創建AI個性化報告按鈕
    function createAIReportButton(container) {
      const reportButton = document.createElement('button');
      reportButton.className = 'ai-report-button';
      reportButton.style.cssText = `
        margin: 2rem 0 1rem 0;
        padding: 1.2rem 2.5rem;
        background: linear-gradient(135deg, #4F46E5, #7C3AED);
        color: #ffffff;
        border: none;
        border-radius: 12px;
        font-size: 1.2rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.4s ease;
        opacity: 0;
        transform: translateY(20px);
        box-shadow: 0 6px 25px rgba(79, 70, 229, 0.6), 
                    0 0 40px rgba(79, 70, 229, 0.3),
                    inset 0 0 20px rgba(255, 255, 255, 0.1);
        position: relative;
        overflow: hidden;
        display: block;
        width: 100%;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
        filter: brightness(1.1) saturate(1.2);
      `;
      reportButton.innerHTML = '🎁 神秘禮物';
      
      // 添加呼吸動畫效果
      const breathingAnimation = `
        @keyframes breathing-glow {
          0%, 100% { 
            box-shadow: 0 6px 25px rgba(79, 70, 229, 0.6), 
                       0 0 40px rgba(79, 70, 229, 0.3),
                       inset 0 0 20px rgba(255, 255, 255, 0.1);
            transform: translateY(0) scale(1);
            filter: brightness(1);
          }
          50% { 
            box-shadow: 0 12px 40px rgba(79, 70, 229, 1), 
                       0 0 60px rgba(124, 58, 237, 0.8),
                       0 0 80px rgba(79, 70, 229, 0.4),
                       inset 0 0 30px rgba(255, 255, 255, 0.2);
            transform: translateY(-3px) scale(1.05);
            filter: brightness(1.2);
          }
        }
      `;
      
      if (!document.getElementById('breathing-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'breathing-animation';
        styleElement.textContent = breathingAnimation;
        document.head.appendChild(styleElement);
      }
      
      // 添加按鈕到容器
      container.appendChild(reportButton);
      
      // 顯示按鈕動畫
      setTimeout(() => {
        reportButton.style.opacity = '1';
        reportButton.style.transform = 'translateY(0)';
        reportButton.style.animation = 'breathing-glow 2s ease-in-out infinite';
      }, 200);
      
      // 懸停效果
      reportButton.addEventListener('mouseenter', () => {
        reportButton.style.background = 'linear-gradient(135deg, #7C3AED, #A855F7)';
        reportButton.style.transform = 'translateY(-4px) scale(1.08)';
        reportButton.style.boxShadow = '0 12px 40px rgba(124, 58, 237, 1), 0 0 60px rgba(124, 58, 237, 0.8)';
        reportButton.style.animation = 'none';
        reportButton.style.filter = 'brightness(1.3) saturate(1.4)';
      });
      
      reportButton.addEventListener('mouseleave', () => {
        reportButton.style.background = 'linear-gradient(135deg, #4F46E5, #7C3AED)';
        reportButton.style.transform = 'translateY(0) scale(1)';
        reportButton.style.boxShadow = '0 6px 25px rgba(79, 70, 229, 0.6), 0 0 40px rgba(79, 70, 229, 0.3), inset 0 0 20px rgba(255, 255, 255, 0.1)';
        reportButton.style.animation = 'breathing-glow 2s ease-in-out infinite';
        reportButton.style.filter = 'brightness(1.1) saturate(1.2)';
      });
      
      // 點擊事件 - 生成莊子的神秘禮物
      reportButton.addEventListener('click', () => {
        console.log('🎁 神秘禮物按鈕被點擊');
        
        // 切換到神秘禮物專用音樂
        switchToMysteriousGiftMusic();
        
        generateAIPersonalizedReport();
      });
    }
    
    // 生成莊子的神秘禮物
    function generateAIPersonalizedReport() {
      console.log('🎁 開始生成莊子的神秘禮物');
      
      // 獲取完整的玩家數據
      const playerData = getCompletePlayerData();
      console.log('📊 玩家數據:', playerData);
      
      // 顯示加載狀態
      showReportLoadingModal();
      
      // 調用AI生成莊子的信
      zhuangziAI.generatePersonalizedReport(playerData)
        .then(report => {
          console.log('✅ 莊子的信生成成功:', report);
          showAIReportModal(report);
        })
        .catch(error => {
          console.error('❌ 莊子的信生成失敗:', error);
          showReportErrorModal();
        });
    }
    

    
    // 顯示報告加載模態框
    function showReportLoadingModal() {
      const modal = document.createElement('div');
      modal.id = 'report-loading-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 20px;
        padding: 3rem;
        text-align: center;
        color: white;
        max-width: 400px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      `;
      
      content.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 1rem;">🎁</div>
        <h2 style="font-family: 'LXGW WenKai', serif; margin-bottom: 1rem;">禮物打開中，請耐心等待...</h2>
        <p style="color: #87CEEB; margin-bottom: 2rem;">穿越時空的智慧正在凝聚</p>
        <div class="loading-spinner" style="
          width: 40px;
          height: 40px;
          border: 4px solid rgba(255, 255, 255, 0.3);
          border-top: 4px solid #4F46E5;
          border-radius: 50%;
          animation: spin 1s linear infinite;
          margin: 0 auto;
        "></div>
      `;
      
      // 添加旋轉動畫
      const spinAnimation = `
        @keyframes spin {
          0% { transform: rotate(0deg); }
          100% { transform: rotate(360deg); }
        }
      `;
      
      if (!document.getElementById('spin-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'spin-animation';
        styleElement.textContent = spinAnimation;
        document.head.appendChild(styleElement);
      }
      
      modal.appendChild(content);
      document.body.appendChild(modal);
    }
    
    // 顯示AI報告模態框
    function showAIReportModal(report) {
      // 移除加載模態框
      const loadingModal = document.getElementById('report-loading-modal');
      if (loadingModal) {
        loadingModal.remove();
      }
      
      const modal = document.createElement('div');
      modal.id = 'ai-report-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
        padding: 2rem;
        box-sizing: border-box;
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 20px;
        padding: 2rem;
        color: white;
        max-width: 800px;
        max-height: 80vh;
        overflow-y: auto;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
        position: relative;
      `;
      
              content.innerHTML = `
          <div style="text-align: center; margin-bottom: 2rem;">
            <div style="font-size: 3rem; margin-bottom: 1rem;">🎁</div>
            <h1 style="font-family: 'LXGW WenKai', serif; color: #FFD700; margin-bottom: 0.5rem;">莊子給您的信</h1>
            <p style="color: #87CEEB; font-size: 1.1rem;">穿越時空的智慧與關懷</p>
          </div>
        <div style="
          background: rgba(255, 255, 255, 0.05);
          border-radius: 15px;
          padding: 2rem;
          margin-bottom: 2rem;
          border-left: 4px solid #4F46E5;
        ">
          <div style="white-space: pre-wrap; line-height: 1.8; font-family: 'LXGW WenKai', serif; font-size: 1.1rem;">
            ${report}
          </div>
        </div>
        <div style="text-align: center;">
          <button id="download-report-btn" style="
            background: linear-gradient(135deg, #4F46E5, #7C3AED);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            margin-right: 1rem;
            transition: all 0.3s ease;
          ">📥 下載信件</button>
          <button id="close-report-btn" style="
            background: linear-gradient(135deg, #6B7280, #4B5563);
            color: white;
            border: none;
            border-radius: 10px;
            padding: 1rem 2rem;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
          ">關閉</button>
        </div>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      // 添加按鈕事件
      document.getElementById('download-report-btn').addEventListener('click', async () => {
        await downloadReportAsImage(report);
      });
      
      document.getElementById('close-report-btn').addEventListener('click', () => {
        modal.remove();
      });
      
      // 點擊背景關閉
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
        }
      });
    }
    
    // 顯示報告錯誤模態框
    function showReportErrorModal() {
      const loadingModal = document.getElementById('report-loading-modal');
      if (loadingModal) {
        loadingModal.remove();
      }
      
      const modal = document.createElement('div');
      modal.id = 'report-error-modal';
      modal.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 10000;
        backdrop-filter: blur(5px);
      `;
      
      const content = document.createElement('div');
      content.style.cssText = `
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        border-radius: 20px;
        padding: 3rem;
        text-align: center;
        color: white;
        max-width: 400px;
        box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
      `;
      
      content.innerHTML = `
        <div style="font-size: 3rem; margin-bottom: 1rem;">⚠️</div>
        <h2 style="font-family: 'LXGW WenKai', serif; margin-bottom: 1rem;">莊子的信生成失敗</h2>
        <p style="color: #FCA5A5; margin-bottom: 2rem;">網路連接問題，請稍後再試</p>
        <button id="retry-report-btn" style="
          background: linear-gradient(135deg, #4F46E5, #7C3AED);
          color: white;
          border: none;
          border-radius: 10px;
          padding: 1rem 2rem;
          font-size: 1.1rem;
          font-weight: 600;
          cursor: pointer;
          transition: all 0.3s ease;
        ">重試</button>
      `;
      
      modal.appendChild(content);
      document.body.appendChild(modal);
      
      document.getElementById('retry-report-btn').addEventListener('click', () => {
        modal.remove();
        generateAIPersonalizedReport();
      });
    }
    
    // 下載莊子的信為圖片
    async function downloadReportAsImage(report) {
      // 預載logo圖片
      const logoImg = new Image();
      logoImg.crossOrigin = 'anonymous';
      
      // 等待logo圖片加載完成
      await new Promise((resolve, reject) => {
        logoImg.onload = resolve;
        logoImg.onerror = () => {
          console.warn('Logo圖片加載失敗，將繼續生成不含logo的信件');
          resolve(); // 即使失敗也繼續執行
        };
        logoImg.src = 'https://raw.githubusercontent.com/chineseclassics/chineseclassics.github.io/main/images/cclogo.png';
      });
      
      // 獲取設備像素比，提高清晰度
      const devicePixelRatio = window.devicePixelRatio || 1;
      const scaleFactor = Math.max(devicePixelRatio, 2); // 至少2倍清晰度
      
      // 設置基礎尺寸
      const baseWidth = 800;
      const baseHeight = 1200; // 初始高度
      
      // 處理文字換行以計算所需高度
      const tempCanvas = document.createElement('canvas');
      const tempCtx = tempCanvas.getContext('2d');
      tempCtx.font = '18px "LXGW WenKai", "Noto Serif TC", serif';
      const lines = wrapText(tempCtx, report, baseWidth - 120, 18);
      const lineHeight = 28;
      const contentHeight = lines.length * lineHeight;
      
      // 精確計算所需的總高度
      const titleHeight = 120; // 標題區域高度
      const separatorHeight = 30; // 分隔線區域高度
      const contentStartY = 190; // 內容開始位置
      const signatureSpacing = 84; // 正文與落款之間的間距（3行文字）
      const bottomMargin = 140; // 底部邊距（logo + 底部文字 + 額外間距）
      
      // 計算精確的所需高度
      const minRequiredHeight = titleHeight + separatorHeight + contentHeight + signatureSpacing + bottomMargin;
      
      // 設置合理的最小和最大高度範圍
      const minHeight = 800; // 最小高度
      const maxHeight = 2000; // 最大高度
      let actualHeight = Math.max(minHeight, Math.min(maxHeight, minRequiredHeight));
      
      // 如果內容很短，適當增加高度以保持視覺平衡
      if (contentHeight < 400) {
        actualHeight = Math.max(actualHeight, 1000);
      }
      
      // 創建最終畫布
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      
      // 設置畫布尺寸
      canvas.width = baseWidth * scaleFactor;
      canvas.height = actualHeight * scaleFactor;
      
      // 設置CSS尺寸
      canvas.style.width = baseWidth + 'px';
      canvas.style.height = actualHeight + 'px';
      
      // 縮放上下文以匹配設備像素比
      ctx.scale(scaleFactor, scaleFactor);
      
      // 啟用高質量文字渲染
      ctx.textRenderingOptimization = 'optimizeQuality';
      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = 'high';
      
      // 使用遊戲中的紫色調背景（莊子故事中蝴蝶的配色）
      const gradient = ctx.createLinearGradient(0, 0, 0, actualHeight);
      gradient.addColorStop(0, '#4C1D95'); // 深紫色
      gradient.addColorStop(0.3, '#6D28D9'); // 主紫色
      gradient.addColorStop(0.7, '#8B5CF6'); // 亮紫色
      gradient.addColorStop(1, '#A855F7'); // 淺紫色
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, baseWidth, actualHeight);
      
      // 添加淺色宣紙質感背景，帶有紫色光暈
      const paperGradient = ctx.createLinearGradient(0, 0, 0, actualHeight);
      paperGradient.addColorStop(0, '#FEF7FF'); // 極淺紫色
      paperGradient.addColorStop(0.2, '#F3E8FF'); // 淺紫色
      paperGradient.addColorStop(0.5, '#EDE9FE'); // 中淺紫色
      paperGradient.addColorStop(0.8, '#F3E8FF'); // 淺紫色
      paperGradient.addColorStop(1, '#FEF7FF'); // 極淺紫色
      ctx.fillStyle = paperGradient;
      ctx.fillRect(30, 50, baseWidth - 60, actualHeight - 100);
      
      // 添加紫色邊框，符合遊戲風格
      ctx.strokeStyle = '#6D28D9'; // 主紫色邊框
      ctx.lineWidth = 3;
      ctx.strokeRect(30, 50, baseWidth - 60, actualHeight - 100);
      
      // 添加內側細邊框，帶有光暈效果
      ctx.strokeStyle = '#A855F7'; // 淺紫色內邊框
      ctx.lineWidth = 1;
      ctx.strokeRect(40, 60, baseWidth - 80, actualHeight - 120);
      
      // 設置標題樣式 - 使用遊戲中的紫色調
      ctx.fillStyle = '#4C1D95'; // 深紫色標題
      ctx.font = 'bold 36px "Noto Serif SC", "Noto Serif TC", serif';
      ctx.textAlign = 'center';
      
      // 繪製標題
      ctx.fillText('莊子給你的信', baseWidth / 2, 120);
      
      // 繪製分隔線 - 使用紫色漸變
      const lineGradient = ctx.createLinearGradient(70, 160, baseWidth - 70, 160);
      lineGradient.addColorStop(0, '#6D28D9');
      lineGradient.addColorStop(0.5, '#A855F7');
      lineGradient.addColorStop(1, '#6D28D9');
      ctx.strokeStyle = lineGradient;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(70, 160);
      ctx.lineTo(baseWidth - 70, 160);
      ctx.stroke();
      
      // 繪製信件內容 - 使用深紫色文字
      ctx.fillStyle = '#4C1D95'; // 深紫色正文
      ctx.font = '18px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'left';
      
      // 繪製所有行
      let y = 190; // 從更靠上的位置開始
      lines.forEach((line, index) => {
        ctx.fillText(line, 60, y);
        y += lineHeight;
      });
      
      // 添加正文與落款之間的間距（3行文字）
      y += lineHeight * 3;
      
      // 繪製莊子落款
      ctx.fillStyle = '#6D28D9'; // 主紫色落款
      ctx.font = 'bold 20px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'right';
      ctx.fillText('莊子', baseWidth - 60, y);
      
      // 動態計算logo位置，確保不超出邊距
      if (logoImg.complete && logoImg.naturalWidth > 0) {
        // 計算logo的原始比例
        const originalWidth = logoImg.naturalWidth;
        const originalHeight = logoImg.naturalHeight;
        const aspectRatio = originalWidth / originalHeight;
        
        // 設置logo的目標寬度，並根據比例計算高度
        const logoWidth = 80; // 稍微縮小logo寬度
        const logoHeight = logoWidth / aspectRatio;
        
        // 確保logo不超出邊距
        const logoX = Math.max(60, baseWidth - logoWidth - 60); // 右對齊，但不超出右邊距
        const logoY = Math.max(60, actualHeight - logoHeight - 80); // 底部對齊，但不超出下邊距，增加間距
        
        // 如果logo會超出邊距，調整位置
        if (logoX < 60) {
          logoX = 60;
        }
        if (logoY < 60) {
          logoY = 60;
        }
        
        ctx.drawImage(logoImg, logoX, logoY, logoWidth, logoHeight);
      }
      
      // 繪製底部信息 - 使用紫色調
      ctx.fillStyle = '#6D28D9'; // 主紫色底部信息
      ctx.font = '14px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'center';
      ctx.fillText('此信件由游戲《萬物逍遙》生成，基於你的游戲歷程數據', baseWidth / 2, actualHeight - 100);
      
      // 添加日期 - 使用深紫色
      const now = new Date();
      const dateStr = `${now.getFullYear()}年${now.getMonth() + 1}月${now.getDate()}日`;
      ctx.fillStyle = '#4C1D95'; // 深紫色日期
      ctx.font = '12px "LXGW WenKai", "Noto Serif TC", serif';
      ctx.textAlign = 'center';
      ctx.fillText(dateStr, baseWidth / 2, actualHeight - 70);
      
      // 下載圖片 - 使用高質量PNG
      canvas.toBlob((blob) => {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `莊子的信_${dateStr}.png`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        showToast('📥 莊子的信已下載完成！高清版本已保存');
      }, 'image/png', 1.0); // 最高質量
    }
    
    // 文字換行輔助函數
    function wrapText(ctx, text, maxWidth, fontSize) {
      const lines = [];
      const paragraphs = text.split('\n');
      
      paragraphs.forEach(paragraph => {
        if (paragraph.trim() === '') {
          lines.push('');
          return;
        }
        
        // 對於中文文字，按字符分割而不是按單詞
        const chars = paragraph.split('');
        let currentLine = '';
        
        for (let i = 0; i < chars.length; i++) {
          const testLine = currentLine + chars[i];
          const metrics = ctx.measureText(testLine);
          
          if (metrics.width > maxWidth && currentLine !== '') {
            lines.push(currentLine);
            currentLine = chars[i];
        } else {
            currentLine = testLine;
          }
        }
        
        if (currentLine !== '') {
          lines.push(currentLine);
        }
      });
      
      return lines;
    }
    
    // 複製到剪貼板
    function copyToClipboard(text) {
      navigator.clipboard.writeText(text).then(() => {
        showToast('莊子的信已複製到剪貼板！');
      }).catch(() => {
        showToast('複製失敗，請手動複製');
      });
    }
    
    // 顯示提示信息
    function showToast(message) {
      const toast = document.createElement('div');
      toast.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: linear-gradient(135deg, #4F46E5, #7C3AED);
        color: white;
        padding: 1rem 2rem;
        border-radius: 10px;
        font-weight: 600;
        z-index: 10001;
        animation: slideIn 0.3s ease;
      `;
      toast.textContent = message;
      
      const slideInAnimation = `
        @keyframes slideIn {
          from { transform: translateX(100%); opacity: 0; }
          to { transform: translateX(0); opacity: 1; }
        }
      `;
      
      if (!document.getElementById('slide-in-animation')) {
        const styleElement = document.createElement('style');
        styleElement.id = 'slide-in-animation';
        styleElement.textContent = slideInAnimation;
        document.head.appendChild(styleElement);
      }
      
      document.body.appendChild(toast);
      
      setTimeout(() => {
        toast.remove();
      }, 3000);
    }
    
    // 創建句讀報告按鈕
    function createSegmentationReportButton(container) {
      const reportButton = document.createElement('button');
      reportButton.className = 'segmentation-report-button';
      reportButton.style.cssText = `
        margin: 1rem 0;
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #10B981, #059669);
        color: #ffffff;
        border: none;
        border-radius: 10px;
        font-size: 1.1rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(20px);
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
        display: block;
        width: 100%;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
        position: relative;
        overflow: hidden;
      `;
      reportButton.innerHTML = '📊 句讀報告';
      
      // 添加按鈕到容器
      container.appendChild(reportButton);
      
      // 顯示按鈕動畫
      setTimeout(() => {
        reportButton.style.opacity = '1';
        reportButton.style.transform = 'translateY(0)';
      }, 700);
      
      // 懸停效果
      reportButton.addEventListener('mouseenter', () => {
        reportButton.style.background = 'linear-gradient(135deg, #059669, #047857)';
        reportButton.style.transform = 'translateY(-2px) scale(1.02)';
        reportButton.style.boxShadow = '0 6px 20px rgba(16, 185, 129, 0.6)';
      });
      
      reportButton.addEventListener('mouseleave', () => {
        reportButton.style.background = 'linear-gradient(135deg, #10B981, #059669)';
        reportButton.style.transform = 'translateY(0) scale(1)';
        reportButton.style.boxShadow = '0 4px 15px rgba(16, 185, 129, 0.4)';
      });
      
      // 點擊事件 - 生成句讀報告
      reportButton.addEventListener('click', () => {
        console.log('📊 句讀報告按鈕被點擊');
        generateSegmentationReport();
      });
    }

    // 生成句讀報告
    function generateSegmentationReport() {
      console.log('📊 開始生成句讀報告');
      
      // 獲取斷句挑戰數據
      const puzzleData = gameState.playerChoices.segmentationPuzzleData;
      const performance = puzzleData.puzzlePerformance;
      
      // 創建報告容器
      const reportContainer = document.createElement('div');
      reportContainer.id = 'segmentation-report-container';
      reportContainer.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.9);
        z-index: 1000;
        display: flex;
        justify-content: center;
        align-items: center;
        padding: 2rem;
        box-sizing: border-box;
      `;
      
             // 創建報告內容
       const reportContent = document.createElement('div');
       reportContent.id = 'segmentation-report-content';
       reportContent.style.cssText = `
         background: linear-gradient(135deg, #1a1a2e, #16213e);
         border-radius: 20px;
         padding: 3rem;
         max-width: 800px;
         width: 100%;
         max-height: 90vh;
         overflow-y: auto;
         color: #ffffff;
         font-family: "LXGW WenKai", "Noto Serif TC", serif;
         box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
         border: 2px solid #4F46E5;
         position: relative;
         opacity: 0;
         transform: translateY(30px);
         transition: all 0.5s ease;
       `;
      
      // 報告標題
      const title = document.createElement('h1');
      title.style.cssText = `
        text-align: center;
        font-size: 2.5rem;
        font-weight: 700;
        color: #FFD700;
        margin-bottom: 2rem;
        text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
      `;
      title.textContent = '句讀挑戰報告';
      reportContent.appendChild(title);
      
      // 總體統計
      const overallStats = document.createElement('div');
      overallStats.style.cssText = `
        background: rgba(79, 70, 229, 0.1);
        border-radius: 15px;
        padding: 2rem;
        margin-bottom: 2rem;
        border: 1px solid rgba(79, 70, 229, 0.3);
      `;
      
      const totalPuzzles = Object.keys(puzzleData.puzzleAttempts).length;
      const totalAttempts = Object.values(puzzleData.puzzleAttempts)
        .reduce((sum, record) => sum + record.attempts, 0);
      const avgCompletionTime = Math.round(performance.averageCompletionTime / 1000);
      const avgAccuracy = Math.round(performance.averageAccuracy * 100);
      
      overallStats.innerHTML = `
        <h2 style="color: #87CEEB; font-size: 1.5rem; margin-bottom: 1rem;">📈 總體表現</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem;">
          <div style="text-align: center; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
            <div style="font-size: 2rem; color: #FFD700; font-weight: bold;">${totalPuzzles}</div>
            <div style="color: #C0C0C0;">完成挑戰</div>
          </div>
          <div style="text-align: center; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
            <div style="font-size: 2rem; color: #10B981; font-weight: bold;">${totalAttempts}</div>
            <div style="color: #C0C0C0;">總嘗試次數</div>
          </div>
          <div style="text-align: center; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
            <div style="font-size: 2rem; color: #F59E0B; font-weight: bold;">${avgCompletionTime}s</div>
            <div style="color: #C0C0C0;">平均完成時間</div>
          </div>
          <div style="text-align: center; padding: 1rem; background: rgba(255, 255, 255, 0.05); border-radius: 10px;">
            <div style="font-size: 2rem; color: #EF4444; font-weight: bold;">${avgAccuracy}%</div>
            <div style="color: #C0C0C0;">平均準確率</div>
          </div>
        </div>
      `;
      reportContent.appendChild(overallStats);
      
      // 學習曲線圖表
      if (performance.learningCurve.length > 0) {
        const learningCurve = document.createElement('div');
        learningCurve.style.cssText = `
          background: rgba(79, 70, 229, 0.1);
          border-radius: 15px;
          padding: 2rem;
          margin-bottom: 2rem;
          border: 1px solid rgba(79, 70, 229, 0.3);
        `;
        
        learningCurve.innerHTML = `
          <h2 style="color: #87CEEB; font-size: 1.5rem; margin-bottom: 1rem;">📊 學習曲線</h2>
          <div style="display: flex; flex-direction: column; gap: 1rem;">
            ${performance.learningCurve.map((puzzle, index) => {
              const chapterId = puzzle.puzzle.split('_')[0];
              const chapterTitles = {
                'prologue': '第一章：莊周夢蝶',
                'chapter1': '第二章：濠梁觀魚',
                'chapter2': '第三章：北冥有魚',
                'chapter3': '第四章：鴟得腐鼠',
                'chapter4': '第五章：蝸角之爭',
                'chapter5': '第六章：朝菌大椿',
                'chapter6': '第七章：螻蟻星辰',
                'chapter7': '第八章：道歸混沌',
                'epilogue': '第九章：逍遙遊'
              };
              const chapterName = chapterTitles[chapterId] || chapterId;
              const completionTime = Math.round(puzzle.completionTime / 1000);
              const accuracy = Math.round(puzzle.accuracy * 100);
              const attempts = puzzle.attempts || 1;
              
              return `
                <div style="background: rgba(255, 255, 255, 0.05); border-radius: 10px; padding: 1rem;">
                  <div style="color: #FFD700; font-weight: bold; margin-bottom: 0.8rem; font-size: 1rem;">
                    ${chapterName}
                  </div>
                  <div style="display: flex; gap: 2.5rem; font-size: 0.95rem; justify-content: space-around;">
                    <span style="color: #10B981; display: flex; align-items: center; gap: 0.3rem;">
                      <span>⏱️</span>
                      <span>${completionTime}s</span>
                    </span>
                    <span style="color: #8B5CF6; display: flex; align-items: center; gap: 0.3rem;">
                      <span>🔄</span>
                      <span>${attempts}次</span>
                    </span>
                    <span style="color: #EF4444; display: flex; align-items: center; gap: 0.3rem;">
                      <span>🎯</span>
                      <span>${accuracy}%</span>
                    </span>
                  </div>
                </div>
              `;
            }).join('')}
          </div>
        `;
        reportContent.appendChild(learningCurve);
      }
      
      // 能力分析
      const abilityAnalysis = document.createElement('div');
      abilityAnalysis.style.cssText = `
        background: rgba(79, 70, 229, 0.1);
        border-radius: 15px;
        padding: 2rem;
        margin-bottom: 2rem;
        border: 1px solid rgba(79, 70, 229, 0.3);
      `;
      
      // 計算能力評分
      const resilienceScore = Math.min(100, Math.round((totalAttempts / totalPuzzles) * 20));
      const speedScore = Math.max(0, Math.round(100 - (avgCompletionTime - 30) * 2));
      
      abilityAnalysis.innerHTML = `
        <h2 style="color: #87CEEB; font-size: 1.5rem; margin-bottom: 1rem;">🎯 能力分析</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1.5rem; max-width: 100%; justify-content: center;">
          <div style="text-align: center; padding: 1.5rem; background: rgba(255, 255, 255, 0.05); border-radius: 12px; min-width: 0;">
            <div style="font-size: 1.8rem; color: #10B981; font-weight: bold;">${resilienceScore}</div>
            <div style="color: #C0C0C0; font-size: 1rem; margin-top: 0.5rem;">韌性</div>
            <div style="background: rgba(255, 255, 255, 0.1); height: 8px; border-radius: 4px; margin-top: 0.8rem; overflow: hidden;">
              <div style="background: #10B981; height: 100%; width: ${resilienceScore}%; border-radius: 4px; transition: width 0.3s ease;"></div>
            </div>
          </div>
          <div style="text-align: center; padding: 1.5rem; background: rgba(255, 255, 255, 0.05); border-radius: 12px; min-width: 0;">
            <div style="font-size: 1.8rem; color: #F59E0B; font-weight: bold;">${speedScore}</div>
            <div style="color: #C0C0C0; font-size: 1rem; margin-top: 0.5rem;">速度</div>
            <div style="background: rgba(255, 255, 255, 0.1); height: 8px; border-radius: 4px; margin-top: 0.8rem; overflow: hidden;">
              <div style="background: #F59E0B; height: 100%; width: ${speedScore}%; border-radius: 4px; transition: width 0.3s ease;"></div>
            </div>
          </div>
        </div>
      `;
      reportContent.appendChild(abilityAnalysis);
      
      // 哲學評價
      const philosophicalComment = document.createElement('div');
      philosophicalComment.style.cssText = `
        background: rgba(255, 215, 0, 0.1);
        border-radius: 15px;
        padding: 2rem;
        margin-bottom: 2rem;
        border: 1px solid rgba(255, 215, 0, 0.3);
        text-align: center;
      `;
      
      let comment = '';
      if (avgAccuracy >= 90) {
        comment = '「你的句讀如庖丁解牛，游刃有餘。對古文的領悟已達化境。」';
      } else if (avgAccuracy >= 80) {
        comment = '「你的句讀如伯樂相馬，慧眼獨具。對古文的理解頗有心得。」';
      } else if (avgAccuracy >= 70) {
        comment = '「你的句讀如匠人琢玉，漸入佳境。對古文的探索值得讚賞。」';
      } else if (avgAccuracy >= 60) {
        comment = '「你的句讀如學徒習藝，勤勉好學。對古文的興趣令人欣慰。」';
      } else {
        comment = '「你的句讀如初學者，雖有不足，但勇於嘗試的精神可嘉。」';
      }
      
      philosophicalComment.innerHTML = `
        <h2 style="color: #FFD700; font-size: 1.5rem; margin-bottom: 1rem;">🏛️ 莊子評價</h2>
        <div style="font-size: 1.2rem; line-height: 1.6; color: #FFD700; font-style: italic;">
          ${comment}
        </div>
      `;
      reportContent.appendChild(philosophicalComment);
      
      // 下載按鈕
      const downloadButton = document.createElement('button');
      downloadButton.style.cssText = `
        background: linear-gradient(135deg, #10B981, #059669);
        color: #ffffff;
        border: none;
        border-radius: 10px;
        padding: 1rem 2rem;
        font-size: 1.1rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 1rem 0.5rem;
        box-shadow: 0 4px 15px rgba(16, 185, 129, 0.4);
      `;
             downloadButton.textContent = '📥 下載報告';
       downloadButton.addEventListener('click', downloadReportAsPNG);
      
      // 關閉按鈕
      const closeButton = document.createElement('button');
      closeButton.style.cssText = `
        background: linear-gradient(135deg, #6B7280, #4B5563);
        color: #ffffff;
        border: none;
        border-radius: 10px;
        padding: 1rem 2rem;
        font-size: 1.1rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.3s ease;
        margin: 1rem 0.5rem;
        box-shadow: 0 4px 15px rgba(107, 114, 128, 0.4);
      `;
      closeButton.textContent = '✕ 關閉';
      closeButton.addEventListener('click', () => {
        reportContainer.remove();
      });
      
      // 按鈕容器
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = `
        text-align: center;
        margin-top: 2rem;
      `;
      buttonContainer.appendChild(downloadButton);
      buttonContainer.appendChild(closeButton);
      reportContent.appendChild(buttonContainer);
      
      // 添加到頁面
      reportContainer.appendChild(reportContent);
      document.body.appendChild(reportContainer);
      
             // 添加shimmer動畫樣式
       if (!document.getElementById('shimmer-animation')) {
         const styleElement = document.createElement('style');
         styleElement.id = 'shimmer-animation';
         styleElement.textContent = `
           @keyframes shimmer {
             0% { transform: translateX(-100%); }
             100% { transform: translateX(100%); }
           }
         `;
         document.head.appendChild(styleElement);
       }
       
       // 動畫效果
       setTimeout(() => {
         reportContent.style.opacity = '1';
         reportContent.style.transform = 'translateY(0)';
         
         // 為各個部分添加漸入動畫
         const sections = reportContent.querySelectorAll('div[style*="background: rgba"]');
         sections.forEach((section, index) => {
           section.style.opacity = '0';
           section.style.transform = 'translateY(20px)';
           section.style.transition = 'all 0.5s ease';
           
           setTimeout(() => {
             section.style.opacity = '1';
             section.style.transform = 'translateY(0)';
           }, 200 + index * 200);
         });
         

       }, 100);
    }
    
         // 下載報告為PNG
     function downloadReportAsPNG() {
       const reportContent = document.getElementById('segmentation-report-content');
       if (!reportContent) return;
       
       // 創建一個乾淨的報告副本用於截圖
       const reportClone = reportContent.cloneNode(true);
       reportClone.id = 'temp-report-for-download';
       
       // 移除克隆中的所有按鈕元素
       const buttons = reportClone.querySelectorAll('button');
       buttons.forEach(button => button.remove());
       
       // 移除克隆中的按鈕容器
       const buttonContainers = reportClone.querySelectorAll('div[style*="text-align: center"]');
       buttonContainers.forEach(container => {
         if (container.querySelector('button') || container.textContent.includes('下載') || container.textContent.includes('關閉')) {
           container.remove();
         }
       });
       
               // 設置克隆的樣式
        reportClone.style.cssText = `
          position: fixed;
          top: -10000px;
          left: -10000px;
          width: ${reportContent.offsetWidth}px;
          background: #1a1a2e;
          z-index: -1000;
          opacity: 1;
          visibility: visible;
          overflow: visible;
          height: auto;
          max-height: none;
        `;
        
        // 將克隆添加到body
        document.body.appendChild(reportClone);
        
        // 更新原始下載按鈕狀態
        const downloadButton = document.querySelector('#segmentation-report-content button');
        let originalButtonText = '';
        if (downloadButton) {
          originalButtonText = downloadButton.textContent;
          downloadButton.textContent = '⏳ 生成中...';
          downloadButton.disabled = true;
        }
        
        // 使用html2canvas庫將乾淨的報告轉換為圖片
        if (typeof html2canvas !== 'undefined') {
          // 等待DOM更新和內容完全渲染
          setTimeout(() => {
            // 強制重新計算佈局
            reportClone.style.display = 'block';
            reportClone.style.position = 'static';
            reportClone.style.top = 'auto';
            reportClone.style.left = 'auto';
            reportClone.style.height = 'auto';
            
            // 等待佈局完成後再次計算高度
            setTimeout(() => {
              const actualHeight = Math.max(
                reportClone.scrollHeight,
                reportClone.offsetHeight,
                reportClone.clientHeight,
                reportClone.getBoundingClientRect().height
              );
              
              // 再次設置為屏幕外位置，但保持完整高度
              reportClone.style.position = 'fixed';
              reportClone.style.top = '-20000px';
              reportClone.style.left = '-20000px';
              reportClone.style.height = actualHeight + 'px';
              
              console.log('📊 報告截圖參數:', {
                width: reportClone.offsetWidth,
                height: actualHeight,
                scrollHeight: reportClone.scrollHeight,
                offsetHeight: reportClone.offsetHeight,
                boundingHeight: reportClone.getBoundingClientRect().height
              });
              
              html2canvas(reportClone, {
                backgroundColor: '#1a1a2e',
                scale: 2,
                useCORS: true,
                allowTaint: true,
                logging: true,
                removeContainer: false,
                width: reportClone.offsetWidth,
                height: actualHeight,
                scrollX: 0,
                scrollY: 0,
                x: 0,
                y: 0,
                windowWidth: reportClone.offsetWidth,
                windowHeight: actualHeight
              }).then(canvas => {
             // 移除臨時克隆
             document.body.removeChild(reportClone);
             
             // 創建下載鏈接
             const link = document.createElement('a');
             const timestamp = new Date().toISOString().slice(0, 10);
             link.download = `莊子遊戲_句讀挑戰報告_${timestamp}.png`;
             link.href = canvas.toDataURL('image/png', 0.95);
             
             // 觸發下載
             document.body.appendChild(link);
             link.click();
             document.body.removeChild(link);
             
             // 恢復按鈕狀態
             if (downloadButton) {
               downloadButton.textContent = '✅ 下載完成';
               setTimeout(() => {
                 downloadButton.textContent = originalButtonText;
                 downloadButton.disabled = false;
               }, 2000);
             }
             
             console.log('📊 句讀報告下載完成');
           }).catch(error => {
             console.error('下載報告時發生錯誤:', error);
             alert('下載報告時發生錯誤，請稍後再試。');
             
             // 移除臨時克隆（如果還存在）
             if (document.body.contains(reportClone)) {
               document.body.removeChild(reportClone);
             }
             
             // 恢復按鈕狀態
             if (downloadButton) {
               downloadButton.textContent = originalButtonText;
               downloadButton.disabled = false;
             }
                       });
            }, 300); // 等待佈局完成
          }, 500);
        } else {
          // 移除臨時克隆
          document.body.removeChild(reportClone);
         
         // 如果沒有html2canvas庫，提示用戶
         alert('下載功能需要html2canvas庫支持，請稍後再試。');
         
         // 恢復按鈕狀態
         if (downloadButton) {
           downloadButton.textContent = originalButtonText;
           downloadButton.disabled = false;
         }
       }
     }

    // 創建製作人員名單的結束按鈕
    function createCreditsEndButton(container) {
      const endButton = document.createElement('button');
      endButton.className = 'credits-end-button';
      endButton.style.cssText = `
        margin: 1rem 0 2rem 0;
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #FFD700, #FFA500);
        color: #000000;
        border: none;
        border-radius: 8px;
        font-size: 1.1rem;
        font-weight: 600;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        cursor: pointer;
        transition: all 0.3s ease;
        opacity: 0;
        transform: translateY(20px);
        box-shadow: 0 4px 15px rgba(255, 215, 0, 0.4);
        display: block;
        width: 100%;
        max-width: 300px;
        margin-left: auto;
        margin-right: auto;
      `;
      endButton.textContent = '返回首頁';
      
      // 添加按鈕到容器
      container.appendChild(endButton);
      
      // 顯示按鈕動畫
      setTimeout(() => {
        endButton.style.opacity = '1';
        endButton.style.transform = 'translateY(0)';
      }, 1200);
      
      // 懸停效果
      endButton.addEventListener('mouseenter', () => {
        endButton.style.background = 'linear-gradient(135deg, #FFA500, #FF8C00)';
        endButton.style.transform = 'translateY(-2px)';
        endButton.style.boxShadow = '0 6px 20px rgba(255, 215, 0, 0.6)';
      });
      
      endButton.addEventListener('mouseleave', () => {
        endButton.style.background = 'linear-gradient(135deg, #FFD700, #FFA500)';
        endButton.style.transform = 'translateY(0)';
        endButton.style.boxShadow = '0 4px 15px rgba(255, 215, 0, 0.4)';
      });
      
      // 點擊事件 - 返回首頁
      endButton.addEventListener('click', () => {
        console.log('🎬 製作人員名單 - 返回首頁按鈕被點擊');
        
        // 清理製作人員名單場景
        container.remove();
        
        // 恢復遊戲背景
        gameContainer.style.background = '';
        gameContainer.style.transition = '';
        
        // 重新開始遊戲
        location.reload();
      });
    }

    // 創建空白浮現場景
    function createBlankEmergenceScene(scene) {
      console.log('🌟 createBlankEmergenceScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 檢查是否還有白色覆蓋層殘留
      const existingOverlay = document.getElementById('white-transition-overlay');
      if (existingOverlay) {
        existingOverlay.remove();
      }
      
      // 清理可能殘留的document.body元素（從第七章場景38、39過渡）
      const chapter7Elements = document.querySelectorAll('.fade-in-container, .dao-revelation-container, .epilogue-title-container');
      chapter7Elements.forEach(el => {
        if (el.parentNode === document.body) {
          console.log('清理殘留的document.body元素:', el);
          el.remove();
        }
      });
      
      // 確保gameContent可見且正確設置
      console.log('確保gameContent正確設置...');
      gameContent.style.display = 'block';
      gameContent.style.opacity = '1';
      gameContent.style.visibility = 'visible';
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 清除所有背景样式，确保白色背景
      gameContainer.classList.remove('epilogue-scene', 'void-scene', 'dream-scene', 'water-scene', 'cloud-scene', 'forest-scene', 'spiral-scene', 'time-scene', 'heaven-earth-scene');
      gameContainer.classList.add('blank-emergence-scene');
      
      // 强制设置白色背景，清除任何内联样式
      gameContainer.style.background = '#ffffff';
      gameContainer.style.backgroundImage = 'none';
      gameContainer.style.filter = 'none';
      gameContainer.style.animation = 'none';
      gameContainer.style.transition = 'none';
      
      // 確保gameContainer可見
      gameContainer.style.display = 'block';
      gameContainer.style.opacity = '1';
      gameContainer.style.visibility = 'visible';
      
      console.log('🌟 gameContainer樣式已重置為白色背景');
      
      // 隱藏繼續按鈕，稍後會顯示
      advanceBtn.style.display = 'none';
      
      // 隱藏物化按鈕
      gameUI.style.opacity = 0;
      
      // 創建浮現文字容器
      const textContainer = document.createElement('div');
      textContainer.className = 'blank-emergence-text';
      textContainer.textContent = scene.text;
      textContainer.style.zIndex = '100';
      textContainer.style.position = 'absolute';
      textContainer.style.color = '#333333';
      
      // 添加到遊戲內容
      gameContent.appendChild(textContainer);
      
      // 強制重繪確保樣式生效
      gameContainer.offsetHeight;
      textContainer.offsetHeight;
      
      // 尾聲章節場景0特殊處理：文字浮現5秒後顯示繼續按鈕
      if (gameState.currentChapter === 'epilogue' && gameState.currentScene === 0) {
        console.log('🌅 尾聲章節場景0：文字浮現5秒後顯示繼續按鈕');
        setTimeout(() => {
          console.log('🌅 尾聲章節場景0：顯示繼續按鈕');
          advanceBtn.style.display = 'block';
          advanceBtn.style.opacity = '0';
          advanceBtn.style.transition = 'opacity 1s ease';
          
          setTimeout(() => {
            advanceBtn.style.opacity = '1';
            console.log('🌅 尾聲章節場景0：繼續按鈕動畫完成');
          }, 100);
        }, 5000); // 延長到5秒，與標題顯示時間協調
      } else {
        // 其他場景：3秒後顯示繼續按鈕
        setTimeout(() => {
          console.log('🌟 空白浮現場景：顯示繼續按鈕');
          advanceBtn.style.display = 'block';
          advanceBtn.style.opacity = '0';
          advanceBtn.style.transition = 'opacity 1s ease';
          
          setTimeout(() => {
            advanceBtn.style.opacity = '1';
            console.log('🌟 空白浮現場景：繼續按鈕動畫完成');
          }, 100);
        }, 3000);
      }
    }

    // 創建最終冥想場景
    function createFinalMeditationScene(scene) {
      console.log('🧘🏻‍♀️ createFinalMeditationScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 隱藏繼續按鈕，稍後顯示
      advanceBtn.style.display = 'none';
      
      // 創建冥想文字容器
      const meditationContainer = document.createElement('div');
      meditationContainer.className = 'final-meditation-container';
      meditationContainer.style.cssText = `
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 90%;
        max-width: 800px;
        text-align: center;
        z-index: 10;
      `;
      
      // 創建文字顯示區域
      const textDisplay = document.createElement('div');
      textDisplay.className = 'meditation-text';
      textDisplay.style.cssText = `
        font-size: 1.4rem;
        line-height: 1.8;
        color: #7c3aed;
        font-family: "LXGW WenKai", "Noto Serif TC", serif;
        text-shadow: 0 2px 8px rgba(124, 58, 237, 0.3);
        letter-spacing: 0.5px;
        text-align: center;
        opacity: 0;
        transform: translateY(20px);
        transition: all 1s ease;
        white-space: pre-line;
      `;
      
      meditationContainer.appendChild(textDisplay);
      gameContent.appendChild(meditationContainer);
      
      // 顯示容器
      setTimeout(() => {
        textDisplay.style.opacity = '1';
        textDisplay.style.transform = 'translateY(0)';
      }, 500);
      
      // 開始緩慢的打字機效果
      setTimeout(() => {
        startSlowTypewriter(textDisplay, scene.text, () => {
          // 打字機效果完成後，等待5秒再顯示繼續按鈕
          setTimeout(() => {
            // 添加輕微的呼吸光效
            textDisplay.style.animation = 'gentle-breathing 6s ease-in-out infinite';
            
            // 顯示繼續按鈕
            advanceBtn.style.display = 'block';
            advanceBtn.style.opacity = '0';
            advanceBtn.style.transform = 'translateY(20px)';
            advanceBtn.style.transition = 'all 1s ease';
            
            setTimeout(() => {
              advanceBtn.style.opacity = '1';
              advanceBtn.style.transform = 'translateY(0)';
            }, 100);
          }, 3000); // 從5秒改為3秒
        });
      }, 1000);
    }
    
    // 緩慢打字機效果函數（優化版：分段顯示、重點字詞高亮）
    function startSlowTypewriter(element, text, callback) {
      element.innerHTML = '';
      const speed = 180; // 每個字符180毫秒
      
      // 完整文本，使用換行符分段
      const fullText = `微風從身邊吹過，你的心變得無比輕鬆。

夢境和現實，已經沒有什麼區別了。

你靠著大樹，看著雲朵來來去去，聽著風聲和鳥鳴。

你的身體、你的心，都在這裡。

在這個自由自在的地方，在這片廣闊的原野上，你終於得到了真正的

逍遙。`;
      
      let i = 0;
      let isInHighlight = false;
      
      function typeNextChar() {
        if (i < fullText.length) {
          const char = fullText.charAt(i);
          
          // 檢查是否到達"逍遙"二字
          if (i === fullText.indexOf('逍遙') && !isInHighlight) {
            // 開始高亮標籤
            element.innerHTML += '<span style="color: #8b5cf6; font-weight: bold; text-shadow: 0 0 12px rgba(139, 92, 246, 0.8); display: inline-block;">';
            isInHighlight = true;
          }
          
          if (char === '\n') {
            // 換行符轉換為<br>
            element.innerHTML += '<br>';
          } else {
            element.innerHTML += char;
          }
          
          // 檢查是否完成"逍遙"二字
          if (isInHighlight && i === fullText.indexOf('逍遙') + 1) {
            element.innerHTML += '</span>';
            isInHighlight = false;
          }
          
          i++;
          
          // 在句號、感嘆號、問號後增加額外停頓
          let nextDelay = speed;
          
          if (char === '。' || char === '！' || char === '？') {
            nextDelay = speed * 3; // 句子結束後停頓3倍時間
          } else if (char === '，' || char === '、') {
            nextDelay = speed * 1.8; // 逗號後停頓1.8倍時間
          } else if (char === '\n') {
            nextDelay = speed * 5; // 段落間停頓5倍時間
          }
          
          setTimeout(typeNextChar, nextDelay);
        } else {
          // 所有文字完成
          if (callback) callback();
        }
      }
      
      typeNextChar();
    }

    // 創建照片顯影場景
    function createPhotoDevelopScene(scene) {
      console.log('📸 createPhotoDevelopScene 開始執行');
      console.log('接收到的場景參數:', scene);
      
      // 保持白色過渡層作為照片顯影的白色背景，不立即清理
      const whiteOverlay = document.getElementById('white-transition-overlay');
      if (whiteOverlay) {
        console.log('📸 保持白色過渡層作為顯影背景');
        // 不立即移除，讓顯影動畫在白色背景上進行
      }
      
      // 清空遊戲內容
      gameContent.innerHTML = '';
      
      // 設置照片顯影背景
      gameContainer.classList.remove('blank-emergence-scene');
      gameContainer.classList.add('photo-develop-scene');
      
      // 隱藏繼續按鈕
      advanceBtn.style.display = 'none';
      
      // 創建顯影覆蓋層
      const developOverlay = document.createElement('div');
      developOverlay.className = 'photo-develop-overlay';
      
      // 創建文字容器
      const textContainer = document.createElement('div');
      textContainer.className = 'photo-develop-text';
      textContainer.textContent = scene.text;
      textContainer.style.textAlign = 'left';
      
      // 添加到遊戲內容
      gameContent.appendChild(developOverlay);
      gameContent.appendChild(textContainer);
      
      // 4秒後（顯影動畫完成）立即處理
      setTimeout(() => {
        console.log('📸 照片顯影動畫完成，開始清理白色過渡層和設置背景');
        
        // 顯影動畫完成後，清理白色過渡層
        const whiteOverlay = document.getElementById('white-transition-overlay');
        if (whiteOverlay) {
          console.log('📸 顯影完成，移除白色過渡層');
          whiteOverlay.style.opacity = '0';
          setTimeout(() => {
            if (whiteOverlay && whiteOverlay.parentNode) {
              whiteOverlay.remove();
              console.log('📸 白色過渡層已移除');
            }
          }, 500);
        }
        
        // 立即移除顯影覆蓋層，避免樣式衝突
        const developOverlay = document.querySelector('.photo-develop-overlay');
        if (developOverlay) {
          console.log('📸 移除照片顯影覆蓋層');
          developOverlay.remove();
        }
        
        // 移除照片顯影樣式
        gameContainer.classList.remove('photo-develop-scene');
        
        // 清除任何現有的transition和樣式，避免動畫衝突
        gameContainer.style.transition = 'none';
        gameContainer.style.background = 'none';
        gameContainer.style.backgroundColor = 'transparent';
        
        // 強制重繪，確保清理生效
        gameContainer.offsetHeight;
        
        // 直接設置尾聲背景圖片和濾鏡，無動畫
        gameContainer.style.background = 'url("https://chineseclassics.github.io/images/zhuangzi.png") center/cover no-repeat';
        gameContainer.style.filter = 'sepia(0.15) saturate(1.2) brightness(1.1)';
        
        // 再次強制重繪，確保背景圖片立即生效
        gameContainer.offsetHeight;
        
        // 確保gameContent不會覆蓋背景
        gameContent.style.background = 'transparent';
        gameContent.style.backgroundColor = 'transparent';
        
        // 保持物化按鈕隱藏
        gameUI.style.opacity = 0;
        
        // 立即顯示繼續按鈕
        advanceBtn.style.display = 'block';
        advanceBtn.style.opacity = '1';
        advanceBtn.style.transition = 'opacity 0.5s ease';
        
        console.log('📸 照片顯影完成，背景已設置，繼續按鈕已顯示');
        console.log('📸 gameContainer背景樣式:', gameContainer.style.background);
        console.log('📸 gameContent背景樣式:', gameContent.style.background);
      }, 4000);
      
      console.log('📸 照片顯影場景創建完成');
    }


    // Start the game
    function init() {
      // Pre-show the main menu
      mainMenu.style.opacity = 1;
      
      // Initialize Hunlun apertures
      initializeHunlunApertures();
      
      // 恢復遊戲進度
      const savedProgress = loadGameProgress();
      if (savedProgress) {
        // 恢復最高章節記錄
        gameState.maxReachedChapter = savedProgress.maxReachedChapter;
        
        // 恢復已收集的封印
        if (savedProgress.collectedApertures) {
          gameState.collectedApertures = savedProgress.collectedApertures;
        }
        
        // 恢復已解鎖的物化形態
        if (savedProgress.unlockedForms) {
          gameState.unlockedForms = savedProgress.unlockedForms;
          console.log('📖 恢復已解鎖物化形態:', gameState.unlockedForms);
        }
        
        // 恢復最後遊戲時間
        if (savedProgress.lastPlayTime) {
          gameState.lastPlayTime = savedProgress.lastPlayTime;
          console.log('📖 恢復最後遊戲時間:', new Date(gameState.lastPlayTime).toLocaleString());
        }
        
        // 恢復當前場景（如果存在）
        if (savedProgress.currentScene !== undefined) {
          gameState.currentScene = savedProgress.currentScene;
          console.log('📖 恢復當前場景:', gameState.currentScene);
        }
        
        // 恢復當前物化形態
        if (savedProgress.currentForm) {
          gameState.currentForm = savedProgress.currentForm;
          console.log('📖 恢復當前物化形態:', gameState.currentForm);
        }
        
        // 恢復音頻設置
        if (savedProgress.audioEnabled !== undefined) {
          gameState.audioEnabled = savedProgress.audioEnabled;
          console.log('📖 恢復音頻設置:', gameState.audioEnabled);
        }
        
        // 恢復八卦學習狀態
        if (savedProgress.baguaLearningCompleted !== undefined) {
          gameState.baguaLearningCompleted = savedProgress.baguaLearningCompleted;
          console.log('📖 恢復八卦學習狀態:', gameState.baguaLearningCompleted);
        }
        
        // 恢復萬物尋氣模式狀態
        if (savedProgress.wanwuXunqiActive !== undefined) {
          gameState.wanwuXunqiActive = savedProgress.wanwuXunqiActive;
          console.log('📖 恢復萬物尋氣模式狀態:', gameState.wanwuXunqiActive);
        }
        
        // 恢復萬物尋氣進度
        if (savedProgress.wanwuXunqiProgress) {
          gameState.wanwuXunqiProgress = savedProgress.wanwuXunqiProgress;
          console.log('📖 恢復萬物尋氣進度:', gameState.wanwuXunqiProgress);
        }
        
        // 恢復聊天記錄
        if (savedProgress.chatHistoryMap) {
          Object.assign(chatHistoryMap, savedProgress.chatHistoryMap);
          console.log('📖 恢復聊天記錄');
          console.log('📖 斷句解讀聊天記錄數:', chatHistoryMap['segmentation-chat']?.length || 0);
          console.log('📖 通關後聊天記錄數:', chatHistoryMap['post-game-chat']?.length || 0);
        }
        
        // 恢復玩家選擇數據（包括斷句數據）
        if (savedProgress.playerChoices) {
          gameState.playerChoices = savedProgress.playerChoices;
          console.log('📖 恢復玩家選擇數據，包括斷句挑戰數據');
          console.log('📖 斷句挑戰完成數:', Object.keys(gameState.playerChoices.segmentationPuzzleData?.puzzleAttempts || {}).length);
        }
        
        console.log('📖 恢復遊戲進度，最高章節:', gameState.maxReachedChapter);
        console.log('📖 恢復已收集封印:', gameState.collectedApertures);
      }
      
      // 初始化默認形態
      updateFormView('human');
      
      // 根據保存的進度更新七竅指示器的顯示狀態
      if (gameState.collectedApertures && gameState.collectedApertures.length > 0) {
        gameState.collectedApertures.forEach(apertureType => {
          const targetAperture = document.querySelector(`.aperture-${apertureType}`);
          if (targetAperture) {
            targetAperture.classList.add('active');
          }
        });
        
        // 如果已收集所有7個封印，創建太極覆蓋層
        if (gameState.collectedApertures.length === 7) {
          setTimeout(() => {
            createTaijiOverlay();
            console.log('🌟 主菜單初始化：檢測到所有封印已收集，創建太極覆蓋層');
          }, 1000);
        }
      }
      
      // Initialize audio controls
      initAudioControls();
      
      // 初始化調試模式（如果需要）
      initDebugForDeveloperMode();
    }
    
    init();

    // ===== Three.js虛空場景增強效果系統 =====

  </script>

</body></html>
