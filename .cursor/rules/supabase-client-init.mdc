---
description: Supabase 客戶端初始化最佳實踐 - 跨平台兼容性與認證穩定性
globs:
  - "**/*.html"
  - "**/*auth*.js"
  - "**/*supabase*.js"
alwaysApply: false
---

# Supabase 客戶端初始化最佳實踐

> **經驗來源**：詩詞組句遠程對戰在 GitHub Pages 上卡在「認證中」問題的排查與修復（2025-10-15）

## 核心問題

### 問題現象
- **GitHub Pages**：遠程對戰建立房間時卡在「認證中」，`getUser()` / `getSession()` 無限掛起
- **Cloudflare Pages**：同樣的代碼正常運行
- **隱身模式**：在 GitHub Pages 上也能正常運行

### 根本原因
Supabase 客戶端初始化時**沒有明確配置 auth 選項**，導致：
1. 在不同託管環境下使用不同的默認存儲策略
2. GitHub Pages 對 localStorage 訪問更嚴格，默認行為可能靜默失敗
3. 舊的或損壞的 session 數據導致認證 API 掛起
4. 不同應用共享同一個 storageKey，可能產生衝突

---

## ✅ 正確的初始化方式

### 基本配置（必需）

```javascript
// ❌ 錯誤：沒有配置選項
window.sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// ✅ 正確：明確配置 auth 選項
window.sb = window.supabase.createClient(
    SUPABASE_URL, 
    SUPABASE_ANON_KEY,
    {
        auth: {
            persistSession: true,          // 持久化 session
            autoRefreshToken: true,        // 自動刷新 token
            detectSessionInUrl: true,      // 檢測 URL 中的 session（OAuth 回調）
            storage: window.localStorage,  // 明確指定使用 localStorage
            storageKey: 'sb-yourapp'       // 🔑 應用專屬 key，避免衝突
        }
    }
);
```

### 關鍵配置說明

#### 1. `persistSession: true`
- **作用**：將 session 保存到 storage，用戶刷新頁面後仍保持登入
- **適用**：需要持久登入的應用（如遠程對戰、用戶賬號系統）

#### 2. `autoRefreshToken: true`
- **作用**：在 token 過期前自動刷新，保持 session 有效
- **適用**：長時間運行的應用

#### 3. `detectSessionInUrl: true`
- **作用**：自動檢測 OAuth 回調 URL 中的 session（如 Google 登入後的重定向）
- **適用**：使用第三方登入（Google、GitHub 等）的應用

#### 4. `storage: window.localStorage`
- **作用**：明確指定使用 localStorage（而非讓 Supabase 自動選擇）
- **重要性**：避免不同環境下默認行為不一致

#### 5. `storageKey: 'sb-yourapp'` ⭐ **最關鍵**
- **作用**：為當前應用指定專屬的 storage key
- **避免**：不同應用共享同一個 key，導致 session 衝突
- **命名**：`sb-應用名稱`（如 `sb-shicizuju`、`sb-storyvocab`）

---

## 🔧 認證流程最佳實踐

### 問題：認證 API 可能掛起

在某些環境下（特別是 GitHub Pages），`getUser()` / `getSession()` 可能無限掛起。

### 解決方案：超時保護 + 清理 + 重試

```javascript
// 超時工具函數
function withTimeout(promise, ms, label) {
    let timer;
    const timeout = new Promise((_, reject) => {
        timer = setTimeout(() => reject(new Error((label || 'operation') + ' 超時')), ms);
    });
    return Promise.race([
        promise.finally(() => clearTimeout(timer)),
        timeout
    ]);
}

// Session 清理函數（移除損壞的 session 數據）
function sanitizeSupabaseSessionStorage() {
    try {
        const ls = window.localStorage;
        if (!ls) return;
        
        const keys = [];
        for (let i = 0; i < ls.length; i++) {
            const k = ls.key(i);
            if (k && k.startsWith('sb-') && k.endsWith('-auth-token')) {
                keys.push(k);
            }
        }
        
        let removed = 0;
        keys.forEach(k => {
            const raw = ls.getItem(k);
            if (!raw) return;
            try {
                const obj = JSON.parse(raw);
                // 檢查基本結構是否完整
                const ok = !!(obj && (obj.currentSession || obj.user || obj.access_token || obj.session));
                if (!ok) {
                    ls.removeItem(k);
                    removed++;
                    console.warn('[auth] 移除無效 session:', k);
                }
            } catch (e) {
                // JSON 解析失敗，視為損壞
                ls.removeItem(k);
                removed++;
                console.warn('[auth] 移除損壞 session:', k);
            }
        });
        
        if (removed > 0) {
            console.warn('[auth] Session 清理完成，移除數量:', removed);
        }
    } catch (e) {
        console.warn('[auth] Session 清理異常:', e);
    }
}

// 穩健的認證流程
async function ensureAuth() {
    if (!sb || !sb.auth) throw new Error('Supabase 未就緒');
    
    try {
        // 0. 清理可能的壞 session
        sanitizeSupabaseSessionStorage();
        
        // 1. 優先使用 getUser（較輕量），加超時保護
        try {
            const { data: { user } } = await withTimeout(
                sb.auth.getUser(), 
                4000, 
                'getUser'
            );
            if (user) {
                console.log('✅ 找到現有會話，用戶ID:', user.id);
                return user;
            }
        } catch (e) {
            console.warn('⚠️ getUser 超時/失敗:', e?.message);
            // 繼續嘗試匿名登入
        }
        
        // 2. 執行匿名登入
        console.log('執行匿名登入...');
        let result = await withTimeout(
            sb.auth.signInAnonymously(), 
            8000, 
            'signInAnonymously'
        );
        
        if (!result?.data?.user) {
            // 登入返回空，清理後重試
            try { await sb.auth.signOut(); } catch(_){}
            sanitizeSupabaseSessionStorage();
            result = await withTimeout(
                sb.auth.signInAnonymously(), 
                8000, 
                'signInAnonymously#retry'
            );
        }
        
        const user = result?.data?.user;
        if (user) {
            console.log('✅ 匿名登入成功，用戶ID:', user.id);
            return user;
        }
        
        // 3. Fallback：嘗試 getSession
        const { data: { session } } = await withTimeout(
            sb.auth.getSession(), 
            8000, 
            'getSession#fallback'
        );
        if (session?.user) {
            console.log('✅ 透過 fallback 找到會話，用戶ID:', session.user.id);
            return session.user;
        }
        
        throw new Error('無法獲取用戶（所有方法均失敗）');
    } catch (err) {
        console.error('❌ 認證失敗:', err);
        throw err;
    }
}
```

---

## 📋 不同應用場景的配置

### 1. 單頁應用（只需匿名認證）

**適用**：詩詞組句遠程對戰、簡單的多人遊戲

```javascript
window.sb = window.supabase.createClient(
    SUPABASE_URL, 
    SUPABASE_ANON_KEY,
    {
        auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: false,     // 不需要 OAuth
            storage: window.localStorage,
            storageKey: 'sb-yourapp'       // 必需！
        }
    }
);
```

### 2. 用戶賬號系統（Google 登入）

**適用**：詞遊記（story-vocab）、需要用戶身份的應用

```javascript
const supabaseClient = createClient(
    SUPABASE_URL,
    SUPABASE_ANON_KEY,
    {
        auth: {
            autoRefreshToken: true,
            persistSession: true,
            detectSessionInUrl: true,      // OAuth 回調需要
            storage: window.localStorage,
            storageKey: 'sb-yourapp'       // 必需！
        }
    }
);
```

### 3. 臨時會話（不持久化）

**適用**：臨時訪客、閱讀模式

```javascript
window.sb = window.supabase.createClient(
    SUPABASE_URL, 
    SUPABASE_ANON_KEY,
    {
        auth: {
            persistSession: false,         // 不持久化
            autoRefreshToken: true,
            detectSessionInUrl: false,
            storage: window.sessionStorage, // 使用 sessionStorage（關閉分頁即清除）
            storageKey: 'sb-yourapp'       // 仍需要，避免衝突
        }
    }
);
```

---

## 🚨 常見錯誤與修復

### 錯誤 1：沒有配置選項

```javascript
// ❌ 錯誤
window.sb = window.supabase.createClient(URL, KEY);

// ✅ 修復
window.sb = window.supabase.createClient(URL, KEY, {
    auth: { /* 明確配置 */ }
});
```

### 錯誤 2：沒有 storageKey

```javascript
// ❌ 錯誤：多個應用共享同一個 key
auth: {
    storage: window.localStorage
    // 沒有 storageKey
}

// ✅ 修復：每個應用使用專屬 key
auth: {
    storage: window.localStorage,
    storageKey: 'sb-shicizuju'  // 應用專屬
}
```

### 錯誤 3：認證 API 沒有超時保護

```javascript
// ❌ 錯誤：可能無限掛起
const { data: { user } } = await sb.auth.getUser();

// ✅ 修復：加超時保護
const { data: { user } } = await withTimeout(
    sb.auth.getUser(), 
    4000, 
    'getUser'
);
```

### 錯誤 4：沒有清理損壞的 session

```javascript
// ❌ 錯誤：直接調用認證 API
async function login() {
    const { data } = await sb.auth.signInAnonymously();
    // ...
}

// ✅ 修復：先清理，再認證
async function login() {
    sanitizeSupabaseSessionStorage();  // 清理損壞數據
    const { data } = await sb.auth.signInAnonymously();
    // ...
}
```

---

## 🔍 診斷與調試

### 檢查 localStorage 中的 session

在瀏覽器控制台執行：

```javascript
// 查看所有 Supabase 相關的 storage keys
Object.keys(localStorage).filter(k => k.includes('sb-') || k.includes('auth-token'))

// 查看當前應用的 session 數據
localStorage.getItem('sb-yourapp-auth-token')

// 清除當前應用的 session
localStorage.removeItem('sb-yourapp-auth-token')
```

### 常見問題排查

| 現象 | 可能原因 | 解決方案 |
|------|----------|----------|
| 認證卡在「認證中」 | localStorage 訪問受限或有損壞數據 | 1. 添加 auth 配置<br>2. 加 storageKey<br>3. 加超時保護 |
| 隱身模式正常，普通模式卡住 | 舊 session 數據損壞 | 1. 清理 localStorage<br>2. 加清理函數 |
| GitHub Pages 卡住，Cloudflare 正常 | 環境默認行為不一致 | 明確配置所有 auth 選項 |
| 多個應用互相干擾 | 共享同一個 storageKey | 每個應用使用專屬 storageKey |

---

## 📚 參考實現

### 太虛幻境平台級認證

**文件**：`/assets/js/cc-auth.js`（全站認證，預留給未來 Google 登入）

```javascript
window.sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
    auth: {
        persistSession: true,
        autoRefreshToken: true,
        detectSessionInUrl: true
    },
    realtime: { params: { eventsPerSecond: 10 } }
});
```

### 詞遊記（story-vocab）

**文件**：`/story-vocab/js/supabase-client.js`

```javascript
const options = {
    auth: {
        autoRefreshToken: true,
        persistSession: true,
        detectSessionInUrl: true,
        storage: window.localStorage
    }
};

supabaseClient = createClient(
    SUPABASE_CONFIG.url,
    SUPABASE_CONFIG.anonKey,
    options
);
```

### 詩詞組句（shicizuju）

**文件**：`/shicizuju.html`

```javascript
window.sb = window.supabase.createClient(
    window.SUPABASE_URL, 
    window.SUPABASE_ANON_KEY,
    {
        auth: {
            persistSession: true,
            autoRefreshToken: true,
            detectSessionInUrl: true,
            storage: window.localStorage,
            storageKey: 'sb-shicizuju'  // 應用專屬 key
        }
    }
);
```

---

## 📝 開發檢查清單

新應用使用 Supabase 時，確保：

- [ ] 明確配置所有 `auth` 選項（不依賴默認值）
- [ ] 設置專屬的 `storageKey`（格式：`sb-應用名稱`）
- [ ] 為認證 API 添加超時保護（4-8 秒）
- [ ] 實現 session 清理函數（移除損壞數據）
- [ ] 在認證流程中添加重試邏輯
- [ ] 在不同環境下測試（GitHub Pages、Cloudflare Pages、隱身模式）
- [ ] 添加詳細的日誌輸出（便於排查問題）

---

## 🎯 總結

### 核心教訓

1. **明確配置優於默認行為**：不同託管環境的默認行為可能不一致
2. **storageKey 隔離必須有**：避免不同應用共享 session 數據
3. **超時保護不可少**：認證 API 在某些環境下可能掛起
4. **清理函數很重要**：損壞的 session 會導致後續認證失敗
5. **多環境測試必需**：問題可能只在特定環境下出現

### 適用範圍

本規範適用於太虛幻境平台上所有使用 Supabase 的應用，包括：
- 單頁應用（HTML + JavaScript）
- ES 模組應用（如 story-vocab）
- 需要匿名認證的遊戲（如詩詞組句遠程對戰）
- 需要用戶賬號的應用（如詞遊記）

---

**最後更新**：2025-10-15  
**經驗來源**：詩詞組句遠程對戰認證問題修復
