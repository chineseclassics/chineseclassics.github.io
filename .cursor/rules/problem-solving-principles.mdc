---
description: 問題解決原則 - 避免過度複雜化，追求簡單有效的方案
globs: ["**/*"]
alwaysApply: true
---

# 問題解決原則

## 核心理念

**簡單優於複雜** - 始終優先考慮最簡單、最直接的解決方案

## 🎯 解決問題的步驟

### 1. 理解業務場景（而非只看技術表面）

**錯誤做法** ❌：
- 看到 RLS 錯誤 → 立即想複雜的策略、RPC 函數
- 只關注技術問題，忽視業務需求

**正確做法** ✅：
- 這是什麼類型的應用？（教學平台 vs 銀行系統）
- 數據的敏感性如何？（姓名郵箱 vs 密碼成績）
- 用戶期望是什麼？（師生互相看到 vs 完全隔離）

**實例**：
```
問題：老師無法查看學生的 users 數據
❌ 立即想：複雜的 RLS 策略、RPC 函數、JOIN 優化
✅ 先想：這是教學平台，姓名郵箱本來就不敏感
    → 簡單方案：允許認證用戶查看基本信息
```

---

### 2. 參考行業慣例和最佳實踐

**問自己**：
- 類似的主流產品怎麼做？（Google Classroom、Canvas、Moodle）
- 業界標準是什麼？
- 有沒有成熟的模式？

**實例**：
```
問題：學校應用中如何處理用戶隱私？
✅ 參考：Google Classroom - 班級成員互相可見
✅ 參考：Canvas - 課程參與者公開
✅ 結論：教學平台的姓名郵箱是可以公開的
```

---

### 3. 從最簡單方案開始

**方案選擇順序**：
1. **最簡單方案**：能用 5 行代碼解決嗎？
2. **簡單方案**：能用單一功能解決嗎？
3. **中等方案**：需要新增模組嗎？
4. **複雜方案**：真的需要重構架構嗎？

**只有在簡單方案確實不可行時，才考慮更複雜的方案**

**實例**：
```
問題：RLS 策略遞歸

❌ 我的做法（由簡到繁，全部嘗試）：
1. 複雜的 JOIN 策略（造成遞歸）
2. 子查詢策略（仍可能遞歸）
3. RPC 函數 + 子查詢（混合方案）
4. 純 RPC 函數（需要改大量前端代碼）

✅ 正確做法（深思熟慮後）：
1. 理解業務場景 → 教學平台
2. 參考慣例 → 成員互相可見
3. 最簡單方案 → 允許認證用戶查看
4. 5 行 SQL 解決 → 完成！
```

---

### 4. 避免為了技術而技術

**常見陷阱**：
- ❌ 過度設計權限系統
- ❌ 過早優化性能
- ❌ 引入不必要的抽象層
- ❌ 使用複雜技術展示能力

**應該問自己**：
- 這個複雜度真的必要嗎？
- 用戶能感知到差異嗎？
- 維護成本值得嗎？

**實例**：
```
❌ 過度設計：
- 創建 3 個 RPC 函數
- 設計複雜的 RLS 策略
- 修改大量前端代碼
- 增加維護負擔

✅ 簡單實用：
- 1 個策略
- 0 行前端修改
- 易於理解和維護
```

---

## 📋 實踐檢查清單

遇到問題時，按順序問自己：

### ☑️ 業務理解
- [ ] 這是什麼類型的應用？
- [ ] 數據的實際敏感度如何？
- [ ] 用戶的真實期望是什麼？

### ☑️ 方案選擇
- [ ] 行業內類似產品怎麼做？
- [ ] 最簡單的方案是什麼？（5 行代碼能解決嗎？）
- [ ] 簡單方案有什麼實際問題嗎？（而非想像的問題）

### ☑️ 複雜度評估
- [ ] 增加的複雜度真的必要嗎？
- [ ] 簡單方案為什麼不行？（需要有確鑿證據）
- [ ] 複雜方案的維護成本值得嗎？

### ☑️ 實施原則
- [ ] 先實施最簡單的方案
- [ ] 驗證是否解決問題
- [ ] 只有在確實不行時才增加複雜度

---

## 🚫 反面案例（本次教訓）

### 問題：老師無法查看學生的 users 數據

**我的錯誤做法**：
1. ❌ 創建複雜的 RLS 策略（JOIN） → 遞歸
2. ❌ 改用子查詢策略 → 仍遞歸
3. ❌ 創建 RPC 函數 → 需要改前端
4. ❌ 創建更完整的 RPC 函數 → 更多代碼
5. ❌ 花費大量時間調試

**正確做法**：
1. ✅ 理解：這是學校教學平台
2. ✅ 參考：Google Classroom 成員互相可見
3. ✅ 結論：姓名郵箱不是敏感信息
4. ✅ 方案：允許認證用戶查看 → **5 行 SQL 解決**

**時間對比**：
- 錯誤做法：30+ 分鐘，創建 4 個遷移文件，修改多個前端文件
- 正確做法：5 分鐘，1 個遷移文件，0 行前端修改

---

## ✅ 正確示例

### 案例 1：性能優化

**問題**：頁面加載慢

**錯誤做法** ❌：
- 立即引入 Redis
- 重構為微服務
- 使用複雜的緩存策略

**正確做法** ✅：
1. 先測量：真的慢嗎？慢在哪裡？
2. 找瓶頸：是查詢慢？渲染慢？網絡慢？
3. 簡單修復：加索引？減少查詢？壓縮資源？
4. 驗證：真的快了嗎？

---

### 案例 2：代碼重構

**問題**：代碼有重複

**錯誤做法** ❌：
- 立即抽象為通用框架
- 引入設計模式
- 過早優化

**正確做法** ✅：
1. 重複幾次？（<3 次不需要抽象）
2. 真的相同嗎？（可能只是看起來像）
3. 抽象後更簡單嗎？（可能更難理解）
4. 延遲決策：等到真正需要時再重構

---

## 📚 推薦閱讀

- **YAGNI 原則**：You Aren't Gonna Need It（你不會需要它）
- **KISS 原則**：Keep It Simple, Stupid（保持簡單）
- **奧卡姆剃刀**：如無必要，勿增實體

---

## 🎓 核心教訓

> **簡單的方案通常就是正確的方案**
> 
> 在增加複雜度之前，先問：
> - 有沒有更簡單的方法？
> - 業務場景真的需要這麼複雜嗎？
> - 我是在解決實際問題，還是在解決想像的問題？

---

**適用範圍**：所有太虛幻境項目和子項目  
**最後更新**：2025-10-19  
**來源**：時文寶鑑開發實踐教訓