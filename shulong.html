<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>è²ªåƒæ•¸å­—è›‡ - ç®—è¡“æ¨‚åœ’</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3498db; /* æ´»æ½‘è— */
            --secondary-color: #2ecc71; /* æ¸…æ–°ç¶  */
            --accent-color: #f1c40f; /* é™½å…‰é»ƒ */
            --danger-color: #e74c3c; /* è­¦å‘Šç´… */
            --light-bg: #ecf0f1; /* æŸ”å’Œç°ç™½ */
            --text-color: #34495e; /* æ·±ç°è— */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "LXGW WenKai TC", 'Microsoft JhengHei', 'å¾®è»Ÿæ­£é»‘é«”', sans-serif;
            background: linear-gradient(135deg, #a29bfe 0%, #74b9ff 50%, #81ecec 100%); /* ç³–æœè‰²èƒŒæ™¯ */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.6);
            padding: 20px;
            display: inline-block;
            max-width: 95vw;
            max-height: 95vh;
            overflow: hidden;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        /* é ‚éƒ¨ç‹€æ…‹æ¬„ */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--primary-color), #8e44ad);
            color: white;
            padding: 15px 25px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
        }
        
        #question-display {
            font-size: 24px;
            font-weight: bold;
            flex-grow: 1;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 15px;
        }

        .score-label {
            font-size: 14px;
            font-weight: 500;
        }

        .score-value {
            font-size: 20px;
            font-weight: bold;
        }
        
        /* éŠæˆ²å€åŸŸ */
        .game-area {
            display: flex;
            gap: 20px;
            height: calc(95vh - 200px);
            max-height: 550px;
            min-height: 400px;
        }

        .game-board-container {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .game-board {
            background: var(--light-bg);
            border: 5px solid var(--primary-color);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .game-cell {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-sizing: border-box;
            color: var(--text-color);
        }

        .snake-head {
            background: var(--secondary-color);
            color: white;
            z-index: 10;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; /* é¾é ­å½¢ç‹€ */
            animation: snakeHeadBob 1s infinite;
        }
        
        @keyframes snakeHeadBob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .snake-body {
            background: #a5d6a7;
            transform: scale(0.9);
        }

        .food {
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            animation: foodPulse 1.5s infinite;
            font-size: 20px;
            line-height: 1; /* For better centering */
        }

        .food.two-digits {
            font-size: 17px;
        }
        .food.three-digits {
            font-size: 13px;
        }

        @keyframes foodPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px var(--accent-color); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px var(--accent-color); }
        }
        
        /* éŠæˆ²ä¿¡æ¯èˆ‡æ§åˆ¶ */
        .game-controls {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-panel {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            width: 280px;
        }

        .info-panel h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 18px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-bg);
        }
        
        #mistake-book {
            overflow-y: auto;
            flex-grow: 1;
        }
        
        #mistake-book::-webkit-scrollbar {
            width: 8px;
        }
        #mistake-book::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        #mistake-book::-webkit-scrollbar-thumb {
            background: #dcdcdc;
            border-radius: 4px;
        }
        #mistake-book::-webkit-scrollbar-thumb:hover {
            background: #c0c0c0;
        }
        
        .mistake-item {
            padding: 10px 0;
            border-bottom: 1px solid var(--light-bg);
        }
        .mistake-item:last-child { border-bottom: none; }
        
        .mistake-text { font-weight: bold; cursor: pointer; }
        .mistake-answer { color: var(--secondary-color); }
        
        .empty-mistakes { text-align: center; color: #999; margin-top: 20px; }

        .controls {
            display: flex;
            flex-direction: row; /* Horizontal layout */
            justify-content: center; /* Center buttons */
            gap: 20px; /* Space between buttons */
        }

        .control-btn {
            background: linear-gradient(135deg, var(--primary-color), #8e44ad);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 15px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .control-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.15); }
        .control-btn:disabled { background: #bdc3c7; cursor: not-allowed; }

        /* é›£åº¦é¸æ“‡ç•Œé¢ */
        .difficulty-selection {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            text-align: center;
        }

        .difficulty-selection h4 {
            font-size: 18px;
            color: var(--text-color);
            margin-bottom: 5px;
        }

        .difficulty-options {
            display: flex;
            flex-direction: row; /* Changed to horizontal */
            justify-content: center;
            gap: 20px; 
            width: 100%;
            align-items: flex-start; /* Align to the top */
        }

        .difficulty-btn-container {
            flex: 0 1 200px; /* Distribute space, with a max-width basis */
            display: flex;
            flex-direction: column;
        }

        .difficulty-btn { padding: 15px; font-size: 18px; }
        .difficulty-desc { font-size: 12px; color: #7f8c8d; margin-top: 5px; }

        /* éŠæˆ²çµæŸ & æ¨¡æ…‹çª—å£é€šç”¨ */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            animation: slideIn 0.4s ease-out;
            width: 90%;
            max-width: 400px;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
        
        .modal-content h2 { color: var(--primary-color); margin-bottom: 20px; }
        .final-stats { margin: 20px 0; font-size: 18px; line-height: 1.6; color: var(--text-color); }
        
        .game-over-options {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .game-over-options h4 {
            margin-bottom: 10px;
        }

        /* --- é“å…·æ¨£å¼ --- */
        .item-cell {
            border-radius: 50%;
            font-size: 20px;
            animation: itemPulse 2s infinite ease-in-out;
            border: 2px solid rgba(255, 255, 255, 0.7);
            z-index: 5;
        }

        .item-cell.shrink_potion { background: #8e44ad; color: white; } /* ç´«è‰² */
        .item-cell.hint_bomb { background: #f39c12; color: white; } /* æ©™è‰² */
        .item-cell.time_freeze { background: #3498db; color: white; } /* è—è‰² */
        .item-cell.mischief_ghost {
            background: #34495e; /* æ·±ç°è— */
            color: white;
            animation-name: itemWobble;
        }

        @keyframes itemPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px currentColor; }
            50% { transform: scale(1.1); box-shadow: 0 0 20px currentColor; }
        }

        @keyframes itemWobble {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-15deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(15deg); }
            100% { transform: rotate(0deg); }
        }

        /* è›‡ç„¡æ•µæ™‚çš„æ¨£å¼ */
        .snake-invincible {
            opacity: 0.6;
            animation: invincibleGlow 0.5s infinite alternate;
        }
        @keyframes invincibleGlow {
            from { filter: drop-shadow(0 0 5px white); }
            to { filter: drop-shadow(0 0 15px white); }
        }

        /* Toast é€šçŸ¥ç³»çµ± */
        #toast-container { position: fixed; top: 20px; right: 20px; z-index: 2000; display: flex; flex-direction: column; gap: 10px; }
        .toast { background: rgba(0,0,0,0.8); color: white; padding: 12px 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transition: all 0.5s ease; transform: translateX(120%); }
        .toast.show { transform: translateX(0); }
        .toast-success { border-left: 5px solid var(--secondary-color); }
        .toast-error { border-left: 5px solid var(--danger-color); }

        /* ç§»å‹•ç«¯å„ªåŒ– */
        @media (max-width: 768px) {
            body { display: block; padding: 10px; overflow-y: auto; }
            .game-container { max-width: 100%; max-height: none; padding: 15px; }
            .status-bar { flex-direction: column; gap: 10px; }
            .game-area { flex-direction: column; height: auto; max-height: none; }
            .game-board { aspect-ratio: 1 / 1; width: 100%; }
            .game-controls { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- é ‚éƒ¨ç‹€æ…‹æ¬„ -->
        <div class="status-bar">
            <div id="question-display">ç®—è¡“æ¨‚åœ’</div>
            <div class="score-display">
                <div class="score-label">åˆ†æ•¸:</div>
                <div class="score-value" id="current-score">0</div>
            </div>
        </div>

        <!-- éŠæˆ²å€åŸŸ -->
        <div class="game-area">
            <div class="game-board-container">
                <div class="game-board" id="game-board">
                     <!-- Content will be generated by JS -->
                </div>
                <!-- Difficulty selection is now inside game-board-container -->
                <div class="difficulty-selection" id="difficulty-selection">
                    <h4>é¸æ“‡éŠæˆ²æ¨¡å¼</h4>
                    <div class="difficulty-options">
                        <div class="difficulty-btn-container">
                            <button class="control-btn difficulty-btn" data-difficulty="easy">å°å°æ¢éšªå®¶</button>
                            <p class="difficulty-desc">é€Ÿåº¦æ…¢ï¼Œç„¡æ‡²ç½°ï¼Œè¼•é¬†å­¸ç¿’</p>
                        </div>
                        <div class="difficulty-btn-container">
                            <button class="control-btn difficulty-btn" data-difficulty="normal">æ•¸å­¸å°èƒ½æ‰‹</button>
                            <p class="difficulty-desc">é€Ÿåº¦é©ä¸­ï¼ŒæŒ‘æˆ°åŠ æ¸›æ³•</p>
                        </div>
                        <div class="difficulty-btn-container">
                            <button class="control-btn difficulty-btn" data-difficulty="hard">ç®—è¡“å¤§å¸«</button>
                            <p class="difficulty-desc">é€Ÿåº¦å¿«ï¼ŒæŒ‘æˆ°æ··åˆé‹ç®—</p>
                        </div>
                    </div>
                </div>

                <!-- In-game controls are also inside game-board-container -->
                <div class="controls" id="ingame-controls" style="display: none;">
                    <button class="control-btn" id="pause-btn">æš«åœ</button>
                    <button class="control-btn" id="restart-btn">é‡æ–°é–‹å§‹</button>
                    <button class="control-btn" id="mute-btn">ğŸ”Š</button>
                </div>
            </div>

            <div class="info-panel">
                 <h3>ğŸ“’ éŒ¯é¡Œæœ¬</h3>
                 <div id="mistake-book">
                     <div class="empty-mistakes">
                         <span>é‚„æ²’æœ‰éŒ¯é¡Œï¼ŒçœŸæ£’ï¼ğŸ‰</span>
                     </div>
                 </div>
            </div>
        </div>
    </div>

    <!-- Toast é€šçŸ¥å®¹å™¨ -->
    <div id="toast-container"></div>

    <script>
        // --- è¼”åŠ©å‡½æ•¸ ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        // --- æ•¸å­¸é¡Œç›®ç”Ÿæˆå™¨ ---
        class EquationGenerator {
            getQuestion(level, difficulty) {
                const questionTypes = this._getAvailableTypes(level, difficulty);
                const type = questionTypes[randInt(0, questionTypes.length - 1)];
                return this[type](level, difficulty);
            }
            
            _getAvailableTypes(level, difficulty) {
                switch(difficulty) {
                    case 'easy':
                        let easyTypes = ['_add_simple', '_emoji_count'];
                        if (level >= 2) easyTypes.push('_emoji_simple_add', '_emoji_transport_counting');
                        if (level >= 3) easyTypes.push('_recognizeShape', '_emoji_transport_addition');
                        if (level >= 4) easyTypes.push('_emoji_comparison');
                        return easyTypes;
                    case 'normal':
                        let normalTypes = ['_add_medium', '_sub_medium'];
                        if (level >= 4) normalTypes.push('_emoji_story_subtraction');
                        if (level >= 5) normalTypes.push('_emoji_making_change');
                        if (level >= 6) normalTypes.push('_find_missing');
                        if (level >= 8) normalTypes.push('_findNextInSequence');
                        return normalTypes;
                    case 'hard':
                        let hardTypes = ['_add_hard', '_sub_hard', '_multiplication', '_division'];
                        if (level >= 5) hardTypes.push('_emoji_logic');
                        if (level >= 7) hardTypes.push('_emoji_story_multiplication');
                        if (level >= 8) hardTypes.push('_emoji_two_step_mixed');
                        if (level >= 10) hardTypes.push('_find_missing');
                        if (level >= 12) hardTypes.push('_findNextInSequence');
                        return hardTypes;
                }
            }

            // ç°¡æ˜“åŠ æ³•: 5 + 3 = ?
            _add_simple(level) {
                const a = randInt(1, 5);
                const b = randInt(1, 5);
                return this._createQuestion(`${a} + ${b} = ?`, a + b);
            }
            
            // ä¸­ç­‰åŠ æ³•: 8 + 9 = ?
            _add_medium(level) {
                const a = randInt(2, 20);
                const b = randInt(2, 20);
                return this._createQuestion(`${a} + ${b} = ?`, a + b);
            }
            
            // å›°é›£åŠ æ³•: 34 + 58 = ?
            _add_hard(level) {
                const a = randInt(10, 80);
                const b = randInt(10, 80);
                return this._createQuestion(`${a} + ${b} = ?`, a + b);
            }
            
            // ä¸­ç­‰æ¸›æ³•: 15 - 7 = ?
            _sub_medium(level) {
                const a = randInt(10, 25);
                const b = randInt(1, a - 1);
                return this._createQuestion(`${a} - ${b} = ?`, a - b);
            }

            // å›°é›£æ¸›æ³•: 81 - 27 = ?
            _sub_hard(level) {
                const a = randInt(30, 99);
                const b = randInt(10, a - 5);
                return this._createQuestion(`${a} - ${b} = ?`, a - b);
            }

            // å°‹æ‰¾æœªçŸ¥æ•¸: 7 + ? = 15
            _find_missing(level) {
                const a = randInt(5, 20);
                const answer = randInt(2, 10);
                const result = a + answer;
                return this._createQuestion(`${a} + ? = ${result}`, answer);
            }

            // å¤§å°æ¯”è¼ƒ: 18 < 21 ?
            _compare(level) {
                const a = randInt(10, 99);
                let b;
                do { b = randInt(10, 99); } while(a === b);
                const isGreater = a > b;
                return {
                    text: `å“ªå€‹æ•¸å­—æ›´å¤§ï¼š ${a} æˆ– ${b} ?`,
                    answer: isGreater ? a : b,
                    options: this._generateOptions(isGreater ? a : b, [a, b])
                };
            }

            _recognizeShape() {
                const shapes = [
                    { name: 'åœ“å½¢', emoji: 'ğŸ”µ' },
                    { name: 'æ­£æ–¹å½¢', emoji: 'ğŸŸ©' },
                    { name: 'ä¸‰è§’å½¢', emoji: 'ğŸ”º' },
                    { name: 'æ˜Ÿæ˜Ÿ', emoji: 'â­' },
                    { name: 'æ„›å¿ƒ', emoji: 'â¤ï¸' }
                ];
                const correctShape = shapes[randInt(0, shapes.length - 1)];
                const options = shapes.map(s => s.emoji).sort(() => Math.random() - 0.5);
                return {
                    text: `å“ªå€‹æ˜¯${correctShape.name}ï¼Ÿ`,
                    answer: correctShape.emoji,
                    options: options
                };
            }

            _findNextInSequence(level, difficulty) {
                const start = randInt(1, 15);
                const diff = difficulty === 'hard' ? randInt(2, 10) : randInt(2, 5);
                const sequence = [start, start + diff, start + diff * 2];
                const answer = start + diff * 3;
                return {
                    text: `${sequence.join(', ')}, ?`,
                    answer: answer,
                    options: this._generateOptions(answer)
                };
            }

            _multiplication() {
                const a = randInt(2, 9);
                const b = randInt(2, 9);
                const answer = a * b;
                return this._createQuestion(`${a} Ã— ${b} = ?`, answer);
            }

            _division() {
                const b = randInt(2, 9);
                const answer = randInt(2, 9);
                const a = b * answer;
                return this._createQuestion(`${a} Ã· ${b} = ?`, answer);
            }

            _createQuestion(text, answer) {
                return { text, answer, options: this._generateOptions(answer) };
            }
            
            _generateOptions(answer, initialOptions = []) {
                const options = new Set(initialOptions);
                options.add(answer);
                while (options.size < 5) {
                    const range = Math.max(5, Math.ceil(answer / 4));
                    const option = randInt(Math.max(0, answer - range), answer + range);
                    if (option !== answer) {
                        options.add(option);
                    }
                }
                return Array.from(options).sort(() => Math.random() - 0.5);
            }

            // --- Emoji é¡Œå‹ ---

            _emoji_comparison(level, difficulty) {
                const items = ['ğŸ“', 'âš½ï¸', 'ğŸš—', 'ğŸ§¸', 'â­', 'ğŸšŒ', 'âœˆï¸', 'ğŸš€'];
                const item = items[randInt(0, items.length - 1)];
                const a = randInt(2, 8);
                let b;
                do {
                    b = randInt(2, 8);
                } while (a === b);
                const questionText = `å“ªé‚Šæ¯”è¼ƒå¤šï¼Ÿ ${item.repeat(a)} æˆ– ${item.repeat(b)}`;
                return this._createQuestion(questionText, Math.max(a, b));
            }

            _emoji_making_change(level, difficulty) {
                const items = [
                    { emoji: 'ğŸ­', price: randInt(3, 8) },
                    { emoji: 'âœï¸', price: randInt(2, 5) },
                    { emoji: 'ğŸ©', price: randInt(5, 9) },
                ];
                const item = items[randInt(0, items.length - 1)];
                const paid = item.price + randInt(1, 10);
                const questionText = `ç”¨ ${paid} å…ƒè²· 1 å€‹ ${item.price} å…ƒçš„ ${item.emoji}ï¼Œè¦æ‰¾å›å¤šå°‘éŒ¢ï¼Ÿ`;
                return this._createQuestion(questionText, paid - item.price);
            }

            _emoji_transport_counting(level, difficulty) {
                const vehicles = ['ğŸš—', 'ğŸšŒ', 'ğŸš•', 'ğŸšš', 'ğŸš²'];
                const distractors = ['ğŸŒ³', 'ğŸ ', 'â­', 'ğŸ', 'âš½ï¸'];
                const targetVehicle = vehicles[randInt(0, vehicles.length - 1)];
                const targetCount = randInt(2, 5);
                
                let displayArray = [];
                for(let i=0; i<targetCount; i++) {
                    displayArray.push(targetVehicle);
                }
                const distractorCount = randInt(2, 4);
                for(let i=0; i<distractorCount; i++) {
                    displayArray.push(distractors[randInt(0, distractors.length - 1)]);
                }

                // Shuffle the array
                displayArray.sort(() => Math.random() - 0.5);

                const questionText = `æ•¸ä¸€æ•¸æœ‰å¤šå°‘è¼› ${targetVehicle}ï¼Ÿ ${displayArray.join(' ')}`;
                return this._createQuestion(questionText, targetCount);
            }

            _emoji_transport_addition(level, difficulty) {
                const vehicles = [
                    { icon: 'ğŸš—', unit: 'è¼›' },
                    { icon: 'ğŸšŒ', unit: 'è¼›' },
                    { icon: 'ğŸš•', unit: 'è¼›' },
                    { icon: 'ğŸš²', unit: 'è¼›' }
                ];
                
                const v1Index = randInt(0, vehicles.length - 1);
                let v2Index;
                do {
                    v2Index = randInt(0, vehicles.length - 1);
                } while (v1Index === v2Index);

                const vehicle1 = vehicles[v1Index];
                const vehicle2 = vehicles[v2Index];
                
                const count1 = randInt(1, 4);
                const count2 = randInt(1, 4);

                const questionText = `æœ‰ ${count1} ${vehicle1.unit} ${vehicle1.icon} å’Œ ${count2} ${vehicle2.unit} ${vehicle2.icon}ï¼Œä¸€å…±æœ‰å¹¾è¼›è»Šï¼Ÿ`;
                return this._createQuestion(questionText, count1 + count2);
            }

            _emoji_count(level, difficulty) {
                const items = ['ğŸ', 'ğŸŒ', 'ğŸš—', 'ğŸ¶', 'âš½ï¸', 'â­', 'ğŸšŒ', 'âœˆï¸', 'ğŸš€'];
                const item = items[randInt(0, items.length - 1)];
                const count = difficulty === 'easy' ? randInt(2, 5) : randInt(3, 9);
                return this._createQuestion(`æ•¸ä¸€æ•¸æœ‰å¤šå°‘å€‹${item}ï¼Ÿ ${item.repeat(count)}`, count);
            }

            _emoji_simple_add(level, difficulty) {
                const items = ['ğŸ', 'ğŸŒ', 'ğŸš—', 'ğŸ¶', 'âš½ï¸', 'â­', 'ğŸšŒ', 'âœˆï¸', 'ğŸš€'];
                const item = items[randInt(0, items.length - 1)];
                const a = randInt(1, 5);
                const b = randInt(1, 5);
                const questionText = `${item.repeat(a)} + ${item.repeat(b)} = ?`;
                return this._createQuestion(questionText, a + b);
            }

            _emoji_story_subtraction(level, difficulty) {
                const stories = [
                    { item: 'ğŸª', verb: 'åƒæ‰äº†', unit: 'å€‹' },
                    { item: 'ğŸˆ', verb: 'é£›èµ°äº†', unit: 'å€‹' },
                    { item: 'ğŸš—', verb: 'é–‹èµ°äº†', unit: 'è¼›' },
                    { item: 'ğŸŸ', verb: 'æ¸¸èµ°äº†', unit: 'æ¢' },
                ];
                const story = stories[randInt(0, stories.length - 1)];
                const total = randInt(5, 12);
                const removed = randInt(1, total - 2);
                const questionText = `æœ‰ ${total} ${story.unit} ${story.item}ï¼Œ${story.verb} ${removed} ${story.unit}ï¼Œé‚„å‰©å¹¾å€‹ï¼Ÿ`;
                return this._createQuestion(questionText, total - removed);
            }
            
            _emoji_story_multiplication(level, difficulty) {
                const stories = [
                    { item: 'ğŸš²', parts: 2, partName: 'å€‹è¼ªå­' },
                    { item: 'ğŸ•·ï¸', parts: 8, partName: 'æ¢è…¿' },
                    { item: 'ğŸ', parts: 6, partName: 'æ¢è…¿' },
                    { item: 'ğŸˆ', parts: 4, partName: 'æ¢è…¿' },
                ];
                const story = stories[randInt(0, stories.length - 1)];
                const count = randInt(2, 5);
                const questionText = `ä¸€éš» ${story.item} æœ‰ ${story.parts} ${story.partName}ï¼Œ${count} éš»å…±æœ‰å¹¾${story.partName}ï¼Ÿ`;
                return this._createQuestion(questionText, story.parts * count);
            }
            
            _emoji_logic(level, difficulty) {
                const items = [
                    { emoji: 'ğŸ©', price: randInt(5, 10) },
                    { emoji: 'ğŸ¦', price: randInt(4, 8) },
                    { emoji: 'ğŸ•', price: randInt(10, 20) },
                    { emoji: 'ğŸ”', price: randInt(8, 15) },
                ];
                const item1 = items[randInt(0, items.length - 1)];
                let item2;
                do {
                    item2 = items[randInt(0, items.length - 1)];
                } while (item1.emoji === item2.emoji);

                const questionText = `è²·ä¸€å€‹ ${item1.emoji} (${item1.price}å…ƒ) å’Œä¸€å€‹ ${item2.emoji} (${item2.price}å…ƒ)ï¼Œä¸€å…±è¦å¤šå°‘éŒ¢ï¼Ÿ`;
                return this._createQuestion(questionText, item1.price + item2.price);
            }
        }
        
        // --- é“å…·ç®¡ç†å™¨ ---
        class ItemManager {
            constructor(game) {
                this.game = game;
                this.itemsDefinition = {
                    'shrink_potion': {
                        id: 'shrink_potion', name: 'ç¸®å°è—¥æ°´', icon: 'ğŸ§ª', type: 'buff',
                        apply: () => {
                            const amount = 3;
                            if (this.game.snake.length > amount) {
                                this.game.snake.splice(this.game.snake.length - amount);
                            } else if (this.game.snake.length > 1) {
                                this.game.snake.length = 1;
                            }
                            this.game._showToast('ğŸ§ª å–ä¸‹è—¥æ°´ï¼Œèº«é«”è®ŠçŸ­äº†ï¼', 'success');
                            this.game.audioManager.play('powerup');
                        }
                    },
                    'hint_bomb': {
                        id: 'hint_bomb', name: 'æç¤ºç‚¸å½ˆ', icon: 'ğŸ’¡', type: 'buff',
                        apply: () => {
                            const incorrectFoods = this.game.foods.filter(f => f.value !== this.game.currentQuestion.answer);
                            const toRemoveCount = Math.floor(incorrectFoods.length / 2);
                            if (toRemoveCount === 0 && incorrectFoods.length > 0) { // å¦‚æœåªæœ‰ä¸€å€‹éŒ¯èª¤ç­”æ¡ˆï¼Œä¹Ÿå¹«å¿™ç§»é™¤
                                toRemoveCount = 1;
                            }
                            for (let i = 0; i < toRemoveCount; i++) {
                                if (incorrectFoods.length > 0) {
                                    const foodToRemove = incorrectFoods.pop();
                                    this.game.foods = this.game.foods.filter(f => f !== foodToRemove);
                                }
                            }
                            this.game._showToast('ğŸ’¡ ç‚¸å½ˆæ¸…æ‰äº†ä¸€äº›éŒ¯èª¤ç­”æ¡ˆï¼', 'success');
                            this.game.audioManager.play('powerup');
                        }
                    },
                    'time_freeze': {
                        id: 'time_freeze', name: 'æ™‚é–“éœæ­¢', icon: 'â³', type: 'buff',
                        apply: () => {
                            if(this.game.isTimeFrozen) return; // é¿å…ç–ŠåŠ 
                            this.game.isTimeFrozen = true;
                            const originalSpeed = this.game.gameSpeed;
                            this.game.gameSpeed *= 1.5; // Slow down
                            this.game._showToast('â³ æ™‚é–“è®Šæ…¢äº†ï¼', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.gameSpeed = originalSpeed;
                                this.game.isTimeFrozen = false;
                                this.game._showToast('æ™‚é–“æ¢å¾©æ­£å¸¸ï¼');
                            }, 7000);
                        }
                    },
                    'mischief_ghost': {
                        id: 'mischief_ghost', name: 'æ—è›‹é¬¼', icon: 'ğŸ‘»', type: 'debuff',
                        apply: () => {
                            if (this.game.difficulty !== 'easy') {
                                this.game.snake.push({...this.game.snake[this.game.snake.length-1]});
                                this.game.snake.push({...this.game.snake[this.game.snake.length-1]});
                                this.game._showToast('ğŸ‘» æ˜¯æ—è›‹é¬¼ï¼èº«é«”è®Šé•·äº†ï¼', 'error');
                                this.game.audioManager.play('debuff');
                            } else {
                                this.game._showToast('ğŸ‘» æ—è›‹é¬¼å‡ºç¾äº†ï¼Œä½†å®ƒæ”¾éäº†ä½ ï¼');
                                this.game.audioManager.play('click');
                            }
                        }
                    },
                    'invincibility_shield': {
                        id: 'invincibility_shield', name: 'ç„¡æ•µè­·ç›¾', icon: 'âœ¨', type: 'buff',
                        apply: () => {
                            this.game.isInvincible = true;
                            this.game._showToast('âœ¨ ç²å¾—è­·ç›¾ï¼Œæš«æ™‚ç„¡æ•µï¼', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.isInvincible = false;
                                this.game._showToast('è­·ç›¾æ¶ˆå¤±äº†ï¼');
                            }, 8000);
                        }
                    },
                    'score_doubler': {
                        id: 'score_doubler', name: 'é›™å€ç©åˆ†', icon: 'ğŸŒŸ', type: 'buff',
                        apply: () => {
                            this.game.scoreMultiplier = 2;
                            this.game._showToast('ğŸŒŸ é›™å€ç©åˆ†é–‹å§‹ï¼', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.scoreMultiplier = 1;
                                this.game._showToast('é›™å€ç©åˆ†çµæŸï¼');
                            }, 10000);
                        }
                    },
                    'number_magnet': {
                        id: 'number_magnet', name: 'æ•¸å­—ç£éµ', icon: 'ğŸ§²', type: 'buff',
                        apply: () => {
                            this.game.isMagnetActive = true;
                            this.game._showToast('ğŸ§² ç£éµé–‹å•Ÿï¼Œå¸ä½ç­”æ¡ˆï¼', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.isMagnetActive = false;
                            }, 6000);
                        }
                    },
                    'question_refresh': {
                        id: 'question_refresh', name: 'å•é¡Œåˆ·æ–°', icon: 'ğŸ”„', type: 'buff',
                        apply: () => {
                            this.game._showToast('ğŸ”„ é¡Œç›®åˆ·æ–°äº†ï¼', 'info');
                            this.game.audioManager.play('click');
                            this.game._generateNewQuestion();
                        }
                    }
                };
                this.availableItemIds = Object.keys(this.itemsDefinition);
            }

            getRandomItemId() {
                return this.availableItemIds[randInt(0, this.availableItemIds.length - 1)];
            }

            applyEffect(itemId) {
                const itemDef = this.itemsDefinition[itemId];
                if (itemDef) {
                    itemDef.apply();
                }
            }
        }

        // --- éŒ¯é¡Œæœ¬ç®¡ç†ç³»çµ± ---
        class MistakeNotebook {
            constructor() {
                this.mistakes = JSON.parse(localStorage.getItem('shulongMistakes') || '[]');
                this.updateDisplay();
            }
            
            add(question) {
                if (!this.mistakes.some(m => m.text === question.text)) {
                    this.mistakes.unshift(question);
                    if (this.mistakes.length > 20) this.mistakes.pop(); // Keep it tidy
                    this.save();
                    this.updateDisplay();
                }
            }

            save() {
                localStorage.setItem('shulongMistakes', JSON.stringify(this.mistakes));
            }
            
            updateDisplay() {
                const bookEl = $('#mistake-book');
                if (this.mistakes.length === 0) {
                    bookEl.innerHTML = '<div class="empty-mistakes"><span>é‚„æ²’æœ‰éŒ¯é¡Œï¼ŒçœŸæ£’ï¼ğŸ‰</span></div>';
                    return;
                }
                bookEl.innerHTML = this.mistakes.map(q => `
                    <div class="mistake-item">
                        <span class="mistake-text">${q.text}</span>
                        <span class="mistake-answer"> æ­£ç¢ºç­”æ¡ˆ: ${q.answer}</span>
                    </div>
                `).join('');
            }
        }

        // --- éŸ³æ•ˆç®¡ç†å™¨ ---
        class AudioManager {
            constructor() {
                this.isMuted = localStorage.getItem('shulongMuted') === 'true';
                this.audioContext = null;
                this.sounds = {};
                this.soundsToLoad = {
                    'eat': 'https://chineseclassics.github.io/files/audio/cilong/eat.mp3',
                    'success': 'https://chineseclassics.github.io/files/audio/cilong/success.mp3',
                    'powerup': 'https://chineseclassics.github.io/files/audio/cilong/powerup.mp3',
                    'debuff': 'https://chineseclassics.github.io/files/audio/cilong/debuff.mp3',
                    'gameover': 'https://chineseclassics.github.io/files/audio/cilong/gameover.mp3',
                    'click': 'https://chineseclassics.github.io/files/audio/cilong/click.mp3'
                };
                $('#mute-btn').textContent = this.isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
            }
            
            _initContext() {
                if (this.audioContext) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this._preload();
                } catch(e) { console.error("AudioContext not supported."); }
            }

            _preload() {
                Object.entries(this.soundsToLoad).forEach(([key, url]) => {
                    fetch(url)
                        .then(response => response.arrayBuffer())
                        .then(buffer => this.audioContext.decodeAudioData(buffer))
                        .then(audioBuffer => { this.sounds[key] = audioBuffer; })
                        .catch(e => console.error(`Failed to load sound: ${key}`, e));
                });
            }

            play(key) {
                if (this.isMuted || !this.audioContext || !this.sounds[key]) return;
                const source = this.audioContext.createBufferSource();
                source.buffer = this.sounds[key];
                source.connect(this.audioContext.destination);
                source.start(0);
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('shulongMuted', this.isMuted);
                $('#mute-btn').textContent = this.isMuted ? 'ğŸ”‡' : 'ğŸ”Š';
                if (!this.isMuted) {
                    this._initContext();
                    this.play('click');
                }
            }
        }
        
        // --- ä¸»éŠæˆ²é¡ ---
        class DigitalSnakeGame {
            constructor() {
                this.board = $('#game-board');
                this.gameState = { score: 0, level: 1, questionsAnswered: 0 };
                this.equationGenerator = new EquationGenerator();
                this.mistakeBook = new MistakeNotebook();
                this.audioManager = new AudioManager();
                this.itemManager = new ItemManager(this);

                this.isMobile = window.innerWidth <= 768;
                this.boardWidth = 20;
                this.boardHeight = 15;
                this.cellSize = 30;
                this.gameLoopId = null;
                this.lastUpdateTime = 0;
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.difficulty = 'easy';
                this.gameSpeed = 350;

                // é“å…·ç‹€æ…‹
                this.items = [];
                this.itemSpawnCounter = 0;
                this.ITEM_SPAWN_THRESHOLD = 25; // é™ä½ç”Ÿæˆé–€æª» (ç´„ 5-7 ç§’)
                this.isInvincible = false;
                this.isTimeFrozen = false;
                this.scoreMultiplier = 1;
                this.isMagnetActive = false;

                this.controls = {
                    pause: $('#pause-btn'),
                    restart: $('#restart-btn'),
                    mute: $('#mute-btn'),
                };

                this.bindEvents();
                this._setupBoard();
                this.showDifficultySelection();
            }

            bindEvents() {
                $$('#difficulty-selection .difficulty-btn').forEach(btn => btn.addEventListener('click', (e) => {
                    const difficulty = e.target.closest('.difficulty-btn').dataset.difficulty;
                    this.start(difficulty);
                }));
                
                this.controls.pause.addEventListener('click', () => this.togglePause());
                this.controls.restart.addEventListener('click', () => this.showDifficultySelection());
                this.controls.mute.addEventListener('click', () => this.audioManager.toggleMute());
                
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Touch controls
                let touchStartX = 0, touchStartY = 0;
                this.board.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }, { passive: true });
                this.board.addEventListener('touchend', (e) => {
                    const dx = e.changedTouches[0].clientX - touchStartX;
                    const dy = e.changedTouches[0].clientY - touchStartY;
                    if (Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                        this.handleTouch(dx, dy);
                    }
                }, { passive: true });
            }

            start(difficulty) {
                this.difficulty = difficulty;
                $('#difficulty-selection').style.display = 'none';
                $('#ingame-controls').style.display = 'flex';

                this.controls.pause.disabled = false;
                this.controls.restart.disabled = false;
                this.audioManager._initContext();

                this._setupBoard();
                this.isPaused = false;
                this.gameState = { score: 0, level: 1, questionsAnswered: 0 };
                this.snake = [{ x: 5, y: 5 }];
                this.items = [];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this._setSpeed();
                this._generateNewQuestion();
                
                this.gameLoopId = requestAnimationFrame(this.mainLoop.bind(this));
            }
            
            _setSpeed() {
                const speeds = { easy: 300, normal: 220, hard: 160 };
                this.gameSpeed = speeds[this.difficulty];
            }

            _setupBoard() {
                const borderWidth = 5; // Match CSS border-width
                if (this.isMobile) {
                    // On mobile, clientWidth correctly gives the content area width (total width - border).
                    // So we can calculate cellSize directly from it.
                    this.cellSize = this.board.clientWidth / this.boardWidth;
                    this.boardHeight = Math.floor(this.board.clientHeight / this.cellSize);
                } else {
                    // On desktop, we set the size. Since we use box-sizing: border-box,
                    // we need to add the border width to our calculation to get the total size.
                    this.board.style.width = (this.boardWidth * this.cellSize) + (borderWidth * 2) + 'px';
                    this.board.style.height = (this.boardHeight * this.cellSize) + (borderWidth * 2) + 'px';
                }
            }

            mainLoop(timestamp) {
                this.gameLoopId = requestAnimationFrame(this.mainLoop.bind(this));
                if (this.isPaused) return;

                const elapsed = timestamp - this.lastUpdateTime;
                if (elapsed > this.gameSpeed) {
                    this.lastUpdateTime = timestamp;
                    this.update();
                    this.render();
                }
            }

            update() {
                // é“å…·ç”Ÿæˆé‚è¼¯
                this.itemSpawnCounter++;
                if (this.itemSpawnCounter > this.ITEM_SPAWN_THRESHOLD) {
                    this.itemSpawnCounter = 0;
                    if (this.items.length < 3 && Math.random() < 0.4) { // æé«˜ç”Ÿæˆæ©Ÿç‡
                        this._spawnItem();
                    }
                }

                // ç£éµæ•ˆæœ
                if (this.isMagnetActive) {
                    this._applyMagnetEffect();
                }

                this.direction = this.nextDirection;
                const head = this.snake[0];
                let newHead = { x: head.x + this.direction.x, y: head.y + this.direction.y };

                // Wraparound logic for easy mode
                if (this.difficulty === 'easy') {
                    if (newHead.x < 0) newHead.x = this.boardWidth - 1;
                    else if (newHead.x >= this.boardWidth) newHead.x = 0;
                    if (newHead.y < 0) newHead.y = this.boardHeight - 1;
                    else if (newHead.y >= this.boardHeight) newHead.y = 0;
                }

                // å„ªå…ˆæª¢æŸ¥æ˜¯å¦åƒåˆ°é“å…·
                const eatenItemIndex = this.items.findIndex(i => i.x === newHead.x && i.y === newHead.y);
                if (eatenItemIndex > -1) {
                    const item = this.items[eatenItemIndex];
                    this.items.splice(eatenItemIndex, 1);
                    this.itemManager.applyEffect(item.id);
                    // åƒåˆ°é“å…·å¾Œï¼Œè›‡æ­£å¸¸ç§»å‹•ä¸€æ ¼
                    this.snake.unshift(newHead);
                    this.snake.pop();
                    return; // æœ¬æ¬¡æ›´æ–°çµæŸ
                }
                
                // æª¢æŸ¥ç¢°æ’ (ç‰†å£æˆ–è‡ªèº«)
                if (this._isCollision(newHead)) {
                    return this.gameOver();
                }

                // æª¢æŸ¥æ˜¯å¦åƒåˆ°é£Ÿç‰©
                const eatenFood = this.foods.findIndex(f => f.x === newHead.x && f.y === newHead.y);
                if (eatenFood > -1) {
                    this.snake.unshift(newHead);
                    this._handleEat(this.foods[eatenFood].value);
                } else {
                    this.snake.unshift(newHead);
                    this.snake.pop();
                }
            }
            
            _isCollision(pos) {
                // Wall collision
                if (pos.x < 0 || pos.x >= this.boardWidth || pos.y < 0 || pos.y >= this.boardHeight) {
                    return this.difficulty !== 'easy'; // Easy mode no wall collision
                }
                // Self collision
                if (!this.isInvincible && this.snake.length > 1 && this.snake.some(seg => seg.x === pos.x && seg.y === pos.y)) {
                    return this.difficulty !== 'easy'; // Easy mode no self collision
                }
                return false;
            }

            _handleEat(answer) {
                if (answer === this.currentQuestion.answer) {
                    this.audioManager.play('success');
                    const points = 10 * this.scoreMultiplier;
                    this.gameState.score += points;
                    this.gameState.questionsAnswered++;
                    // Shrink snake
                    if (this.snake.length > 2) this.snake.pop();
                    this._showToast(`ç­”å°äº†ï¼+${points}åˆ†ï¼ğŸŒŸ`, 'success');
                } else {
                    this.audioManager.play('debuff');
                    this.mistakeBook.add(this.currentQuestion);
                    // Grow snake
                    if (this.difficulty !== 'easy') {
                        this.snake.push({...this.snake[this.snake.length-1]});
                    }
                    this._showToast(`ç­”éŒ¯äº†ï¼Œæ­£ç¢ºç­”æ¡ˆæ˜¯ ${this.currentQuestion.answer}`, 'error');
                }
                
                this.gameState.level = Math.floor(this.gameState.questionsAnswered / 5) + 1;
                this._generateNewQuestion();
                this._updateScore();
            }

            render() {
                this.board.innerHTML = ''; // Clear board
                // Render snake
                this.snake.forEach((seg, i) => {
                    const el = document.createElement('div');
                    el.className = 'game-cell ' + (i === 0 ? 'snake-head' : 'snake-body');
                    if (this.isInvincible) el.classList.add('snake-invincible');
                    el.style.left = seg.x * this.cellSize + 'px';
                    el.style.top = seg.y * this.cellSize + 'px';
                    el.style.width = this.cellSize + 'px';
                    el.style.height = this.cellSize + 'px';
                    if (i === 0) el.textContent = 'ğŸ';
                    this.board.appendChild(el);
                });
                // Render food
                this.foods.forEach(food => {
                    const el = document.createElement('div');
                    el.className = 'game-cell food';
                    el.style.left = food.x * this.cellSize + 'px';
                    el.style.top = food.y * this.cellSize + 'px';
                    el.style.width = this.cellSize + 'px';
                    el.style.height = this.cellSize + 'px';
                    el.textContent = food.value;

                    if (typeof food.value === 'number') {
                        if (food.value >= 100) {
                            el.classList.add('three-digits');
                        } else if (food.value >= 10) {
                            el.classList.add('two-digits');
                        }
                    }
                    
                    this.board.appendChild(el);
                });

                // æ¸²æŸ“é“å…·
                this.items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = `game-cell item-cell ${item.id}`;
                    el.style.left = item.x * this.cellSize + 'px';
                    el.style.top = item.y * this.cellSize + 'px';
                    el.style.width = this.cellSize + 'px';
                    el.style.height = this.cellSize + 'px';
                    el.textContent = item.icon;
                    el.title = item.name;
                    this.board.appendChild(el);
                });
            }

            gameOver() {
                this.audioManager.play('gameover');
                cancelAnimationFrame(this.gameLoopId);
                this.gameLoopId = null;
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal-content">
                        <h2>éŠæˆ²çµæŸï¼</h2>
                        <div class="final-stats">
                            <div>æœ€çµ‚å¾—åˆ†: ${this.gameState.score}</div>
                            <div>ç­”å°é¡Œæ•¸: ${this.gameState.questionsAnswered}</div>
                        </div>
                        <div class="game-over-options">
                            <h4>å†ç©ä¸€å±€ï¼Ÿ</h4>
                            <button class="control-btn difficulty-btn" data-difficulty="easy">å°å°æ¢éšªå®¶</button>
                            <button class="control-btn difficulty-btn" data-difficulty="normal">æ•¸å­¸å°èƒ½æ‰‹</button>
                            <button class="control-btn difficulty-btn" data-difficulty="hard">ç®—è¡“å¤§å¸«</button>
                        </div>
                    </div>
                `;
                $('.game-container').appendChild(overlay); 
                
                overlay.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const newDifficulty = e.target.dataset.difficulty;
                        overlay.remove();
                        this.start(newDifficulty);
                    });
                });
            }
            
            showDifficultySelection() {
                if(this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                    this.gameLoopId = null;
                }
                this.board.innerHTML = '';
                $('#difficulty-selection').style.display = 'flex';
                $('#ingame-controls').style.display = 'none';
                
                this.controls.pause.disabled = true;
                this.controls.restart.disabled = true;
                $('#question-display').textContent = 'ç®—è¡“æ¨‚åœ’';
                this._updateScore(true); // reset score display
            }
            
            _generateNewQuestion() {
                this.currentQuestion = this.equationGenerator.getQuestion(this.gameState.level, this.difficulty);
                $('#question-display').textContent = this.currentQuestion.text;
                
                this.foods = [];
                const occupied = new Set(this.snake.map(s => `${s.x},${s.y}`));
                this.items.forEach(i => occupied.add(`${i.x},${i.y}`));
                this.currentQuestion.options.forEach(option => {
                    let pos;
                    do {
                        pos = { x: randInt(0, this.boardWidth - 1), y: randInt(0, this.boardHeight - 1) };
                    } while (occupied.has(`${pos.x},${pos.y}`));
                    occupied.add(`${pos.x},${pos.y}`);
                    this.foods.push({ ...pos, value: option });
                });
            }
            
            _updateScore(reset = false) {
                if(reset) this.gameState.score = 0;
                $('#current-score').textContent = this.gameState.score;
            }

            _showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.textContent = message;
                $('#toast-container').appendChild(toast);
                setTimeout(() => {
                    toast.classList.add('show');
                    setTimeout(() => {
                        toast.classList.remove('show');
                        toast.addEventListener('transitionend', () => toast.remove());
                    }, 2000);
                }, 10);
            }

            handleKeyPress(e) {
                if (!this.gameLoopId || this.isPaused) return;
                let dir = this.nextDirection;
                switch(e.key) {
                    case 'ArrowUp': if (this.direction.y === 0) dir = { x: 0, y: -1 }; break;
                    case 'ArrowDown': if (this.direction.y === 0) dir = { x: 0, y: 1 }; break;
                    case 'ArrowLeft': if (this.direction.x === 0) dir = { x: -1, y: 0 }; break;
                    case 'ArrowRight': if (this.direction.x === 0) dir = { x: 1, y: 0 }; break;
                    case ' ': this.togglePause(); break;
                }
                this.nextDirection = dir;
            }

            handleTouch(dx, dy) {
                if (Math.abs(dx) > Math.abs(dy)) { // Horizontal
                    this.handleKeyPress({ key: dx > 0 ? 'ArrowRight' : 'ArrowLeft' });
                } else { // Vertical
                    this.handleKeyPress({ key: dy > 0 ? 'ArrowDown' : 'ArrowUp' });
                }
            }

            togglePause() {
                if (!this.gameLoopId) return;
                this.isPaused = !this.isPaused;
                $('#pause-btn').textContent = this.isPaused ? 'ç¹¼çºŒ' : 'æš«åœ';
            }

            _spawnItem() {
                const itemId = this.itemManager.getRandomItemId();
                const itemData = this.itemManager.itemsDefinition[itemId];
                let pos;
                const occupied = new Set(this.snake.map(s => `${s.x},${s.y}`));
                this.foods.forEach(f => occupied.add(`${f.x},${f.y}`));
                this.items.forEach(i => occupied.add(`${i.x},${i.y}`));
                
                let attempts = 0;
                do {
                    pos = { x: randInt(0, this.boardWidth - 1), y: randInt(0, this.boardHeight - 1) };
                    attempts++;
                } while (occupied.has(`${pos.x},${pos.y}`) && attempts < 50);

                if (attempts < 50) {
                    this.items.push({ ...pos, ...itemData });
                }
            }

            _applyMagnetEffect() {
                const head = this.snake[0];
                const magnetRadius = 4; // ç£éµå¸å¼•åŠå¾‘
                this.foods.forEach(food => {
                    const dx = head.x - food.x;
                    const dy = head.y - food.y;
                    if (Math.abs(dx) < magnetRadius && Math.abs(dy) < magnetRadius) {
                        // ç°¡å–®çš„å¸é™„é‚è¼¯
                        food.x += Math.sign(dx);
                        food.y += Math.sign(dy);
                    }
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new DigitalSnakeGame();
        });
    </script>
</body>
</html> 