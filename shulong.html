<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>貪吃數字蛇 - 算術樂園</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=LXGW+WenKai+TC:wght@300;400;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #3498db; /* 活潑藍 */
            --secondary-color: #2ecc71; /* 清新綠 */
            --accent-color: #f1c40f; /* 陽光黃 */
            --danger-color: #e74c3c; /* 警告紅 */
            --light-bg: #ecf0f1; /* 柔和灰白 */
            --text-color: #34495e; /* 深灰藍 */
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: "LXGW WenKai TC", 'Microsoft JhengHei', '微軟正黑體', sans-serif;
            background: linear-gradient(135deg, #a29bfe 0%, #74b9ff 50%, #81ecec 100%); /* 糖果色背景 */
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            position: relative;
        }

        .game-container {
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(15px);
            border-radius: 25px;
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.1),
                0 0 0 1px rgba(255, 255, 255, 0.6);
            padding: 20px;
            display: inline-block;
            max-width: 95vw;
            max-height: 95vh;
            overflow: hidden;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.5);
        }

        /* 頂部狀態欄 */
        .status-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: linear-gradient(135deg, var(--primary-color), #8e44ad);
            color: white;
            padding: 15px 25px;
            border-radius: 20px;
            margin-bottom: 20px;
            box-shadow: 0 8px 20px rgba(52, 152, 219, 0.3);
        }
        
        #question-display {
            font-size: 24px;
            font-weight: bold;
            flex-grow: 1;
            text-align: center;
            text-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .score-display {
            display: flex;
            align-items: center;
            gap: 8px;
            background: rgba(255, 255, 255, 0.2);
            padding: 8px 15px;
            border-radius: 15px;
        }

        .score-label {
            font-size: 14px;
            font-weight: 500;
        }

        .score-value {
            font-size: 20px;
            font-weight: bold;
        }
        
        /* 遊戲區域 */
        .game-area {
            display: flex;
            gap: 20px;
            height: calc(95vh - 200px);
            max-height: 550px;
            min-height: 400px;
        }

        .game-board-container {
            flex-shrink: 0;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        
        .game-board {
            background: var(--light-bg);
            border: 5px solid var(--primary-color);
            border-radius: 20px;
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
            box-shadow: inset 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        .game-cell {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            border-radius: 8px;
            transition: all 0.3s ease;
            box-sizing: border-box;
            color: var(--text-color);
        }

        .snake-head {
            background: var(--secondary-color);
            color: white;
            z-index: 10;
            border-radius: 50% 50% 50% 50% / 60% 60% 40% 40%; /* 龍頭形狀 */
            animation: snakeHeadBob 1s infinite;
        }
        
        @keyframes snakeHeadBob {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        .snake-body {
            background: #a5d6a7;
            transform: scale(0.9);
        }

        .food {
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            animation: foodPulse 1.5s infinite;
            font-size: 20px;
            line-height: 1; /* For better centering */
        }

        .food.two-digits {
            font-size: 17px;
        }
        .food.three-digits {
            font-size: 13px;
        }

        @keyframes foodPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px var(--accent-color); }
            50% { transform: scale(1.1); box-shadow: 0 0 20px var(--accent-color); }
        }
        
        /* 遊戲信息與控制 */
        .game-controls {
            width: 280px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .info-panel {
            background: white;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.05);
            flex-grow: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
            width: 280px;
        }

        .info-panel h3 {
            color: var(--primary-color);
            margin-bottom: 15px;
            font-size: 18px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--light-bg);
        }
        
        #mistake-book {
            overflow-y: auto;
            flex-grow: 1;
        }
        
        #mistake-book::-webkit-scrollbar {
            width: 8px;
        }
        #mistake-book::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.05);
            border-radius: 4px;
        }
        #mistake-book::-webkit-scrollbar-thumb {
            background: #dcdcdc;
            border-radius: 4px;
        }
        #mistake-book::-webkit-scrollbar-thumb:hover {
            background: #c0c0c0;
        }
        
        .mistake-item {
            padding: 10px 0;
            border-bottom: 1px solid var(--light-bg);
        }
        .mistake-item:last-child { border-bottom: none; }
        
        .mistake-text { font-weight: bold; cursor: pointer; }
        .mistake-answer { color: var(--secondary-color); }
        
        .empty-mistakes { text-align: center; color: #999; margin-top: 20px; }

        .controls {
            display: flex;
            flex-direction: row; /* Horizontal layout */
            justify-content: center; /* Center buttons */
            gap: 20px; /* Space between buttons */
        }

        .control-btn {
            background: linear-gradient(135deg, var(--primary-color), #8e44ad);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 15px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }
        .control-btn:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(0,0,0,0.15); }
        .control-btn:disabled { background: #bdc3c7; cursor: not-allowed; }

        /* 難度選擇界面 */
        .difficulty-selection {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            gap: 15px;
            text-align: center;
        }

        .difficulty-selection h4 {
            font-size: 18px;
            color: var(--text-color);
            margin-bottom: 5px;
        }

        .difficulty-options {
            display: flex;
            flex-direction: row; /* Changed to horizontal */
            justify-content: center;
            gap: 20px; 
            width: 100%;
            align-items: flex-start; /* Align to the top */
        }

        .difficulty-btn-container {
            flex: 0 1 200px; /* Distribute space, with a max-width basis */
            display: flex;
            flex-direction: column;
        }

        .difficulty-btn { padding: 15px; font-size: 18px; }
        .difficulty-desc { font-size: 12px; color: #7f8c8d; margin-top: 5px; }

        /* 遊戲結束 & 模態窗口通用 */
        .modal-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 100;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            box-shadow: 0 15px 30px rgba(0,0,0,0.2);
            animation: slideIn 0.4s ease-out;
            width: 90%;
            max-width: 400px;
        }
        @keyframes slideIn { from { opacity: 0; transform: translateY(20px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
        
        .modal-content h2 { color: var(--primary-color); margin-bottom: 20px; }
        .final-stats { margin: 20px 0; font-size: 18px; line-height: 1.6; color: var(--text-color); }
        
        .game-over-options {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .game-over-options h4 {
            margin-bottom: 10px;
        }

        /* --- 道具樣式 --- */
        .item-cell {
            border-radius: 50%;
            font-size: 20px;
            animation: itemPulse 2s infinite ease-in-out;
            border: 2px solid rgba(255, 255, 255, 0.7);
            z-index: 5;
        }

        .item-cell.shrink_potion { background: #8e44ad; color: white; } /* 紫色 */
        .item-cell.hint_bomb { background: #f39c12; color: white; } /* 橙色 */
        .item-cell.time_freeze { background: #3498db; color: white; } /* 藍色 */
        .item-cell.mischief_ghost {
            background: #34495e; /* 深灰藍 */
            color: white;
            animation-name: itemWobble;
        }

        @keyframes itemPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 10px currentColor; }
            50% { transform: scale(1.1); box-shadow: 0 0 20px currentColor; }
        }

        @keyframes itemWobble {
            0% { transform: rotate(0deg); }
            25% { transform: rotate(-15deg); }
            50% { transform: rotate(0deg); }
            75% { transform: rotate(15deg); }
            100% { transform: rotate(0deg); }
        }

        /* 蛇無敵時的樣式 */
        .snake-invincible {
            opacity: 0.6;
            animation: invincibleGlow 0.5s infinite alternate;
        }
        @keyframes invincibleGlow {
            from { filter: drop-shadow(0 0 5px white); }
            to { filter: drop-shadow(0 0 15px white); }
        }

        /* Toast 通知系統 */
        #toast-container { position: fixed; top: 20px; right: 20px; z-index: 2000; display: flex; flex-direction: column; gap: 10px; }
        .toast { background: rgba(0,0,0,0.8); color: white; padding: 12px 20px; border-radius: 10px; box-shadow: 0 5px 15px rgba(0,0,0,0.2); transition: all 0.5s ease; transform: translateX(120%); }
        .toast.show { transform: translateX(0); }
        .toast-success { border-left: 5px solid var(--secondary-color); }
        .toast-error { border-left: 5px solid var(--danger-color); }

        /* 移動端優化 */
        @media (max-width: 768px) {
            body { display: block; padding: 10px; overflow-y: auto; }
            .game-container { max-width: 100%; max-height: none; padding: 15px; }
            .status-bar { flex-direction: column; gap: 10px; }
            .game-area { flex-direction: column; height: auto; max-height: none; }
            .game-board { aspect-ratio: 1 / 1; width: 100%; }
            .game-controls { width: 100%; }
        }
    </style>
</head>
<body>
    <div class="game-container">
        <!-- 頂部狀態欄 -->
        <div class="status-bar">
            <div id="question-display">算術樂園</div>
            <div class="score-display">
                <div class="score-label">分數:</div>
                <div class="score-value" id="current-score">0</div>
            </div>
        </div>

        <!-- 遊戲區域 -->
        <div class="game-area">
            <div class="game-board-container">
                <div class="game-board" id="game-board">
                     <!-- Content will be generated by JS -->
                </div>
                <!-- Difficulty selection is now inside game-board-container -->
                <div class="difficulty-selection" id="difficulty-selection">
                    <h4>選擇遊戲模式</h4>
                    <div class="difficulty-options">
                        <div class="difficulty-btn-container">
                            <button class="control-btn difficulty-btn" data-difficulty="easy">小小探險家</button>
                            <p class="difficulty-desc">速度慢，無懲罰，輕鬆學習</p>
                        </div>
                        <div class="difficulty-btn-container">
                            <button class="control-btn difficulty-btn" data-difficulty="normal">數學小能手</button>
                            <p class="difficulty-desc">速度適中，挑戰加減法</p>
                        </div>
                        <div class="difficulty-btn-container">
                            <button class="control-btn difficulty-btn" data-difficulty="hard">算術大師</button>
                            <p class="difficulty-desc">速度快，挑戰混合運算</p>
                        </div>
                    </div>
                </div>

                <!-- In-game controls are also inside game-board-container -->
                <div class="controls" id="ingame-controls" style="display: none;">
                    <button class="control-btn" id="pause-btn">暫停</button>
                    <button class="control-btn" id="restart-btn">重新開始</button>
                    <button class="control-btn" id="mute-btn">🔊</button>
                </div>
            </div>

            <div class="info-panel">
                 <h3>📒 錯題本</h3>
                 <div id="mistake-book">
                     <div class="empty-mistakes">
                         <span>還沒有錯題，真棒！🎉</span>
                     </div>
                 </div>
            </div>
        </div>
    </div>

    <!-- Toast 通知容器 -->
    <div id="toast-container"></div>

    <script>
        // --- 輔助函數 ---
        const $ = (selector) => document.querySelector(selector);
        const $$ = (selector) => document.querySelectorAll(selector);
        const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        // --- 數學題目生成器 ---
        class EquationGenerator {
            getQuestion(level, difficulty) {
                const questionTypes = this._getAvailableTypes(level, difficulty);
                const type = questionTypes[randInt(0, questionTypes.length - 1)];
                return this[type](level, difficulty);
            }
            
            _getAvailableTypes(level, difficulty) {
                switch(difficulty) {
                    case 'easy':
                        let easyTypes = ['_add_simple', '_emoji_count'];
                        if (level >= 2) easyTypes.push('_emoji_simple_add', '_emoji_transport_counting');
                        if (level >= 3) easyTypes.push('_recognizeShape', '_emoji_transport_addition');
                        if (level >= 4) easyTypes.push('_emoji_comparison');
                        return easyTypes;
                    case 'normal':
                        let normalTypes = ['_add_medium', '_sub_medium'];
                        if (level >= 4) normalTypes.push('_emoji_story_subtraction');
                        if (level >= 5) normalTypes.push('_emoji_making_change');
                        if (level >= 6) normalTypes.push('_find_missing');
                        if (level >= 8) normalTypes.push('_findNextInSequence');
                        return normalTypes;
                    case 'hard':
                        let hardTypes = ['_add_hard', '_sub_hard', '_multiplication', '_division'];
                        if (level >= 5) hardTypes.push('_emoji_logic');
                        if (level >= 7) hardTypes.push('_emoji_story_multiplication');
                        if (level >= 8) hardTypes.push('_emoji_two_step_mixed');
                        if (level >= 10) hardTypes.push('_find_missing');
                        if (level >= 12) hardTypes.push('_findNextInSequence');
                        return hardTypes;
                }
            }

            // 簡易加法: 5 + 3 = ?
            _add_simple(level) {
                const a = randInt(1, 5);
                const b = randInt(1, 5);
                return this._createQuestion(`${a} + ${b} = ?`, a + b);
            }
            
            // 中等加法: 8 + 9 = ?
            _add_medium(level) {
                const a = randInt(2, 20);
                const b = randInt(2, 20);
                return this._createQuestion(`${a} + ${b} = ?`, a + b);
            }
            
            // 困難加法: 34 + 58 = ?
            _add_hard(level) {
                const a = randInt(10, 80);
                const b = randInt(10, 80);
                return this._createQuestion(`${a} + ${b} = ?`, a + b);
            }
            
            // 中等減法: 15 - 7 = ?
            _sub_medium(level) {
                const a = randInt(10, 25);
                const b = randInt(1, a - 1);
                return this._createQuestion(`${a} - ${b} = ?`, a - b);
            }

            // 困難減法: 81 - 27 = ?
            _sub_hard(level) {
                const a = randInt(30, 99);
                const b = randInt(10, a - 5);
                return this._createQuestion(`${a} - ${b} = ?`, a - b);
            }

            // 尋找未知數: 7 + ? = 15
            _find_missing(level) {
                const a = randInt(5, 20);
                const answer = randInt(2, 10);
                const result = a + answer;
                return this._createQuestion(`${a} + ? = ${result}`, answer);
            }

            // 大小比較: 18 < 21 ?
            _compare(level) {
                const a = randInt(10, 99);
                let b;
                do { b = randInt(10, 99); } while(a === b);
                const isGreater = a > b;
                return {
                    text: `哪個數字更大： ${a} 或 ${b} ?`,
                    answer: isGreater ? a : b,
                    options: this._generateOptions(isGreater ? a : b, [a, b])
                };
            }

            _recognizeShape() {
                const shapes = [
                    { name: '圓形', emoji: '🔵' },
                    { name: '正方形', emoji: '🟩' },
                    { name: '三角形', emoji: '🔺' },
                    { name: '星星', emoji: '⭐' },
                    { name: '愛心', emoji: '❤️' }
                ];
                const correctShape = shapes[randInt(0, shapes.length - 1)];
                const options = shapes.map(s => s.emoji).sort(() => Math.random() - 0.5);
                return {
                    text: `哪個是${correctShape.name}？`,
                    answer: correctShape.emoji,
                    options: options
                };
            }

            _findNextInSequence(level, difficulty) {
                const start = randInt(1, 15);
                const diff = difficulty === 'hard' ? randInt(2, 10) : randInt(2, 5);
                const sequence = [start, start + diff, start + diff * 2];
                const answer = start + diff * 3;
                return {
                    text: `${sequence.join(', ')}, ?`,
                    answer: answer,
                    options: this._generateOptions(answer)
                };
            }

            _multiplication() {
                const a = randInt(2, 9);
                const b = randInt(2, 9);
                const answer = a * b;
                return this._createQuestion(`${a} × ${b} = ?`, answer);
            }

            _division() {
                const b = randInt(2, 9);
                const answer = randInt(2, 9);
                const a = b * answer;
                return this._createQuestion(`${a} ÷ ${b} = ?`, answer);
            }

            _createQuestion(text, answer) {
                return { text, answer, options: this._generateOptions(answer) };
            }
            
            _generateOptions(answer, initialOptions = []) {
                const options = new Set(initialOptions);
                options.add(answer);
                while (options.size < 5) {
                    const range = Math.max(5, Math.ceil(answer / 4));
                    const option = randInt(Math.max(0, answer - range), answer + range);
                    if (option !== answer) {
                        options.add(option);
                    }
                }
                return Array.from(options).sort(() => Math.random() - 0.5);
            }

            // --- Emoji 題型 ---

            _emoji_comparison(level, difficulty) {
                const items = ['🍓', '⚽️', '🚗', '🧸', '⭐', '🚌', '✈️', '🚀'];
                const item = items[randInt(0, items.length - 1)];
                const a = randInt(2, 8);
                let b;
                do {
                    b = randInt(2, 8);
                } while (a === b);
                const questionText = `哪邊比較多？ ${item.repeat(a)} 或 ${item.repeat(b)}`;
                return this._createQuestion(questionText, Math.max(a, b));
            }

            _emoji_making_change(level, difficulty) {
                const items = [
                    { emoji: '🍭', price: randInt(3, 8) },
                    { emoji: '✏️', price: randInt(2, 5) },
                    { emoji: '🍩', price: randInt(5, 9) },
                ];
                const item = items[randInt(0, items.length - 1)];
                const paid = item.price + randInt(1, 10);
                const questionText = `用 ${paid} 元買 1 個 ${item.price} 元的 ${item.emoji}，要找回多少錢？`;
                return this._createQuestion(questionText, paid - item.price);
            }

            _emoji_transport_counting(level, difficulty) {
                const vehicles = ['🚗', '🚌', '🚕', '🚚', '🚲'];
                const distractors = ['🌳', '🏠', '⭐', '🍎', '⚽️'];
                const targetVehicle = vehicles[randInt(0, vehicles.length - 1)];
                const targetCount = randInt(2, 5);
                
                let displayArray = [];
                for(let i=0; i<targetCount; i++) {
                    displayArray.push(targetVehicle);
                }
                const distractorCount = randInt(2, 4);
                for(let i=0; i<distractorCount; i++) {
                    displayArray.push(distractors[randInt(0, distractors.length - 1)]);
                }

                // Shuffle the array
                displayArray.sort(() => Math.random() - 0.5);

                const questionText = `數一數有多少輛 ${targetVehicle}？ ${displayArray.join(' ')}`;
                return this._createQuestion(questionText, targetCount);
            }

            _emoji_transport_addition(level, difficulty) {
                const vehicles = [
                    { icon: '🚗', unit: '輛' },
                    { icon: '🚌', unit: '輛' },
                    { icon: '🚕', unit: '輛' },
                    { icon: '🚲', unit: '輛' }
                ];
                
                const v1Index = randInt(0, vehicles.length - 1);
                let v2Index;
                do {
                    v2Index = randInt(0, vehicles.length - 1);
                } while (v1Index === v2Index);

                const vehicle1 = vehicles[v1Index];
                const vehicle2 = vehicles[v2Index];
                
                const count1 = randInt(1, 4);
                const count2 = randInt(1, 4);

                const questionText = `有 ${count1} ${vehicle1.unit} ${vehicle1.icon} 和 ${count2} ${vehicle2.unit} ${vehicle2.icon}，一共有幾輛車？`;
                return this._createQuestion(questionText, count1 + count2);
            }

            _emoji_count(level, difficulty) {
                const items = ['🍎', '🍌', '🚗', '🐶', '⚽️', '⭐', '🚌', '✈️', '🚀'];
                const item = items[randInt(0, items.length - 1)];
                const count = difficulty === 'easy' ? randInt(2, 5) : randInt(3, 9);
                return this._createQuestion(`數一數有多少個${item}？ ${item.repeat(count)}`, count);
            }

            _emoji_simple_add(level, difficulty) {
                const items = ['🍎', '🍌', '🚗', '🐶', '⚽️', '⭐', '🚌', '✈️', '🚀'];
                const item = items[randInt(0, items.length - 1)];
                const a = randInt(1, 5);
                const b = randInt(1, 5);
                const questionText = `${item.repeat(a)} + ${item.repeat(b)} = ?`;
                return this._createQuestion(questionText, a + b);
            }

            _emoji_story_subtraction(level, difficulty) {
                const stories = [
                    { item: '🍪', verb: '吃掉了', unit: '個' },
                    { item: '🎈', verb: '飛走了', unit: '個' },
                    { item: '🚗', verb: '開走了', unit: '輛' },
                    { item: '🐟', verb: '游走了', unit: '條' },
                ];
                const story = stories[randInt(0, stories.length - 1)];
                const total = randInt(5, 12);
                const removed = randInt(1, total - 2);
                const questionText = `有 ${total} ${story.unit} ${story.item}，${story.verb} ${removed} ${story.unit}，還剩幾個？`;
                return this._createQuestion(questionText, total - removed);
            }
            
            _emoji_story_multiplication(level, difficulty) {
                const stories = [
                    { item: '🚲', parts: 2, partName: '個輪子' },
                    { item: '🕷️', parts: 8, partName: '條腿' },
                    { item: '🐞', parts: 6, partName: '條腿' },
                    { item: '🐈', parts: 4, partName: '條腿' },
                ];
                const story = stories[randInt(0, stories.length - 1)];
                const count = randInt(2, 5);
                const questionText = `一隻 ${story.item} 有 ${story.parts} ${story.partName}，${count} 隻共有幾${story.partName}？`;
                return this._createQuestion(questionText, story.parts * count);
            }
            
            _emoji_logic(level, difficulty) {
                const items = [
                    { emoji: '🍩', price: randInt(5, 10) },
                    { emoji: '🍦', price: randInt(4, 8) },
                    { emoji: '🍕', price: randInt(10, 20) },
                    { emoji: '🍔', price: randInt(8, 15) },
                ];
                const item1 = items[randInt(0, items.length - 1)];
                let item2;
                do {
                    item2 = items[randInt(0, items.length - 1)];
                } while (item1.emoji === item2.emoji);

                const questionText = `買一個 ${item1.emoji} (${item1.price}元) 和一個 ${item2.emoji} (${item2.price}元)，一共要多少錢？`;
                return this._createQuestion(questionText, item1.price + item2.price);
            }
        }
        
        // --- 道具管理器 ---
        class ItemManager {
            constructor(game) {
                this.game = game;
                this.itemsDefinition = {
                    'shrink_potion': {
                        id: 'shrink_potion', name: '縮小藥水', icon: '🧪', type: 'buff',
                        apply: () => {
                            const amount = 3;
                            if (this.game.snake.length > amount) {
                                this.game.snake.splice(this.game.snake.length - amount);
                            } else if (this.game.snake.length > 1) {
                                this.game.snake.length = 1;
                            }
                            this.game._showToast('🧪 喝下藥水，身體變短了！', 'success');
                            this.game.audioManager.play('powerup');
                        }
                    },
                    'hint_bomb': {
                        id: 'hint_bomb', name: '提示炸彈', icon: '💡', type: 'buff',
                        apply: () => {
                            const incorrectFoods = this.game.foods.filter(f => f.value !== this.game.currentQuestion.answer);
                            const toRemoveCount = Math.floor(incorrectFoods.length / 2);
                            if (toRemoveCount === 0 && incorrectFoods.length > 0) { // 如果只有一個錯誤答案，也幫忙移除
                                toRemoveCount = 1;
                            }
                            for (let i = 0; i < toRemoveCount; i++) {
                                if (incorrectFoods.length > 0) {
                                    const foodToRemove = incorrectFoods.pop();
                                    this.game.foods = this.game.foods.filter(f => f !== foodToRemove);
                                }
                            }
                            this.game._showToast('💡 炸彈清掉了一些錯誤答案！', 'success');
                            this.game.audioManager.play('powerup');
                        }
                    },
                    'time_freeze': {
                        id: 'time_freeze', name: '時間靜止', icon: '⏳', type: 'buff',
                        apply: () => {
                            if(this.game.isTimeFrozen) return; // 避免疊加
                            this.game.isTimeFrozen = true;
                            const originalSpeed = this.game.gameSpeed;
                            this.game.gameSpeed *= 1.5; // Slow down
                            this.game._showToast('⏳ 時間變慢了！', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.gameSpeed = originalSpeed;
                                this.game.isTimeFrozen = false;
                                this.game._showToast('時間恢復正常！');
                            }, 7000);
                        }
                    },
                    'mischief_ghost': {
                        id: 'mischief_ghost', name: '搗蛋鬼', icon: '👻', type: 'debuff',
                        apply: () => {
                            if (this.game.difficulty !== 'easy') {
                                this.game.snake.push({...this.game.snake[this.game.snake.length-1]});
                                this.game.snake.push({...this.game.snake[this.game.snake.length-1]});
                                this.game._showToast('👻 是搗蛋鬼！身體變長了！', 'error');
                                this.game.audioManager.play('debuff');
                            } else {
                                this.game._showToast('👻 搗蛋鬼出現了，但它放過了你！');
                                this.game.audioManager.play('click');
                            }
                        }
                    },
                    'invincibility_shield': {
                        id: 'invincibility_shield', name: '無敵護盾', icon: '✨', type: 'buff',
                        apply: () => {
                            this.game.isInvincible = true;
                            this.game._showToast('✨ 獲得護盾，暫時無敵！', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.isInvincible = false;
                                this.game._showToast('護盾消失了！');
                            }, 8000);
                        }
                    },
                    'score_doubler': {
                        id: 'score_doubler', name: '雙倍積分', icon: '🌟', type: 'buff',
                        apply: () => {
                            this.game.scoreMultiplier = 2;
                            this.game._showToast('🌟 雙倍積分開始！', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.scoreMultiplier = 1;
                                this.game._showToast('雙倍積分結束！');
                            }, 10000);
                        }
                    },
                    'number_magnet': {
                        id: 'number_magnet', name: '數字磁鐵', icon: '🧲', type: 'buff',
                        apply: () => {
                            this.game.isMagnetActive = true;
                            this.game._showToast('🧲 磁鐵開啟，吸住答案！', 'success');
                            this.game.audioManager.play('powerup');
                            setTimeout(() => {
                                this.game.isMagnetActive = false;
                            }, 6000);
                        }
                    },
                    'question_refresh': {
                        id: 'question_refresh', name: '問題刷新', icon: '🔄', type: 'buff',
                        apply: () => {
                            this.game._showToast('🔄 題目刷新了！', 'info');
                            this.game.audioManager.play('click');
                            this.game._generateNewQuestion();
                        }
                    }
                };
                this.availableItemIds = Object.keys(this.itemsDefinition);
            }

            getRandomItemId() {
                return this.availableItemIds[randInt(0, this.availableItemIds.length - 1)];
            }

            applyEffect(itemId) {
                const itemDef = this.itemsDefinition[itemId];
                if (itemDef) {
                    itemDef.apply();
                }
            }
        }

        // --- 錯題本管理系統 ---
        class MistakeNotebook {
            constructor() {
                this.mistakes = JSON.parse(localStorage.getItem('shulongMistakes') || '[]');
                this.updateDisplay();
            }
            
            add(question) {
                if (!this.mistakes.some(m => m.text === question.text)) {
                    this.mistakes.unshift(question);
                    if (this.mistakes.length > 20) this.mistakes.pop(); // Keep it tidy
                    this.save();
                    this.updateDisplay();
                }
            }

            save() {
                localStorage.setItem('shulongMistakes', JSON.stringify(this.mistakes));
            }
            
            updateDisplay() {
                const bookEl = $('#mistake-book');
                if (this.mistakes.length === 0) {
                    bookEl.innerHTML = '<div class="empty-mistakes"><span>還沒有錯題，真棒！🎉</span></div>';
                    return;
                }
                bookEl.innerHTML = this.mistakes.map(q => `
                    <div class="mistake-item">
                        <span class="mistake-text">${q.text}</span>
                        <span class="mistake-answer"> 正確答案: ${q.answer}</span>
                    </div>
                `).join('');
            }
        }

        // --- 音效管理器 ---
        class AudioManager {
            constructor() {
                this.isMuted = localStorage.getItem('shulongMuted') === 'true';
                this.audioContext = null;
                this.sounds = {};
                this.soundsToLoad = {
                    'eat': 'https://chineseclassics.github.io/files/audio/cilong/eat.mp3',
                    'success': 'https://chineseclassics.github.io/files/audio/cilong/success.mp3',
                    'powerup': 'https://chineseclassics.github.io/files/audio/cilong/powerup.mp3',
                    'debuff': 'https://chineseclassics.github.io/files/audio/cilong/debuff.mp3',
                    'gameover': 'https://chineseclassics.github.io/files/audio/cilong/gameover.mp3',
                    'click': 'https://chineseclassics.github.io/files/audio/cilong/click.mp3'
                };
                $('#mute-btn').textContent = this.isMuted ? '🔇' : '🔊';
            }
            
            _initContext() {
                if (this.audioContext) return;
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this._preload();
                } catch(e) { console.error("AudioContext not supported."); }
            }

            _preload() {
                Object.entries(this.soundsToLoad).forEach(([key, url]) => {
                    fetch(url)
                        .then(response => response.arrayBuffer())
                        .then(buffer => this.audioContext.decodeAudioData(buffer))
                        .then(audioBuffer => { this.sounds[key] = audioBuffer; })
                        .catch(e => console.error(`Failed to load sound: ${key}`, e));
                });
            }

            play(key) {
                if (this.isMuted || !this.audioContext || !this.sounds[key]) return;
                const source = this.audioContext.createBufferSource();
                source.buffer = this.sounds[key];
                source.connect(this.audioContext.destination);
                source.start(0);
            }

            toggleMute() {
                this.isMuted = !this.isMuted;
                localStorage.setItem('shulongMuted', this.isMuted);
                $('#mute-btn').textContent = this.isMuted ? '🔇' : '🔊';
                if (!this.isMuted) {
                    this._initContext();
                    this.play('click');
                }
            }
        }
        
        // --- 主遊戲類 ---
        class DigitalSnakeGame {
            constructor() {
                this.board = $('#game-board');
                this.gameState = { score: 0, level: 1, questionsAnswered: 0 };
                this.equationGenerator = new EquationGenerator();
                this.mistakeBook = new MistakeNotebook();
                this.audioManager = new AudioManager();
                this.itemManager = new ItemManager(this);

                this.isMobile = window.innerWidth <= 768;
                this.boardWidth = 20;
                this.boardHeight = 15;
                this.cellSize = 30;
                this.gameLoopId = null;
                this.lastUpdateTime = 0;
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this.difficulty = 'easy';
                this.gameSpeed = 350;

                // 道具狀態
                this.items = [];
                this.itemSpawnCounter = 0;
                this.ITEM_SPAWN_THRESHOLD = 25; // 降低生成門檻 (約 5-7 秒)
                this.isInvincible = false;
                this.isTimeFrozen = false;
                this.scoreMultiplier = 1;
                this.isMagnetActive = false;

                this.controls = {
                    pause: $('#pause-btn'),
                    restart: $('#restart-btn'),
                    mute: $('#mute-btn'),
                };

                this.bindEvents();
                this._setupBoard();
                this.showDifficultySelection();
            }

            bindEvents() {
                $$('#difficulty-selection .difficulty-btn').forEach(btn => btn.addEventListener('click', (e) => {
                    const difficulty = e.target.closest('.difficulty-btn').dataset.difficulty;
                    this.start(difficulty);
                }));
                
                this.controls.pause.addEventListener('click', () => this.togglePause());
                this.controls.restart.addEventListener('click', () => this.showDifficultySelection());
                this.controls.mute.addEventListener('click', () => this.audioManager.toggleMute());
                
                document.addEventListener('keydown', (e) => this.handleKeyPress(e));
                
                // Touch controls
                let touchStartX = 0, touchStartY = 0;
                this.board.addEventListener('touchstart', (e) => {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }, { passive: true });
                this.board.addEventListener('touchend', (e) => {
                    const dx = e.changedTouches[0].clientX - touchStartX;
                    const dy = e.changedTouches[0].clientY - touchStartY;
                    if (Math.abs(dx) > 30 || Math.abs(dy) > 30) {
                        this.handleTouch(dx, dy);
                    }
                }, { passive: true });
            }

            start(difficulty) {
                this.difficulty = difficulty;
                $('#difficulty-selection').style.display = 'none';
                $('#ingame-controls').style.display = 'flex';

                this.controls.pause.disabled = false;
                this.controls.restart.disabled = false;
                this.audioManager._initContext();

                this._setupBoard();
                this.isPaused = false;
                this.gameState = { score: 0, level: 1, questionsAnswered: 0 };
                this.snake = [{ x: 5, y: 5 }];
                this.items = [];
                this.direction = { x: 1, y: 0 };
                this.nextDirection = { x: 1, y: 0 };
                this._setSpeed();
                this._generateNewQuestion();
                
                this.gameLoopId = requestAnimationFrame(this.mainLoop.bind(this));
            }
            
            _setSpeed() {
                const speeds = { easy: 300, normal: 220, hard: 160 };
                this.gameSpeed = speeds[this.difficulty];
            }

            _setupBoard() {
                const borderWidth = 5; // Match CSS border-width
                if (this.isMobile) {
                    // On mobile, clientWidth correctly gives the content area width (total width - border).
                    // So we can calculate cellSize directly from it.
                    this.cellSize = this.board.clientWidth / this.boardWidth;
                    this.boardHeight = Math.floor(this.board.clientHeight / this.cellSize);
                } else {
                    // On desktop, we set the size. Since we use box-sizing: border-box,
                    // we need to add the border width to our calculation to get the total size.
                    this.board.style.width = (this.boardWidth * this.cellSize) + (borderWidth * 2) + 'px';
                    this.board.style.height = (this.boardHeight * this.cellSize) + (borderWidth * 2) + 'px';
                }
            }

            mainLoop(timestamp) {
                this.gameLoopId = requestAnimationFrame(this.mainLoop.bind(this));
                if (this.isPaused) return;

                const elapsed = timestamp - this.lastUpdateTime;
                if (elapsed > this.gameSpeed) {
                    this.lastUpdateTime = timestamp;
                    this.update();
                    this.render();
                }
            }

            update() {
                // 道具生成邏輯
                this.itemSpawnCounter++;
                if (this.itemSpawnCounter > this.ITEM_SPAWN_THRESHOLD) {
                    this.itemSpawnCounter = 0;
                    if (this.items.length < 3 && Math.random() < 0.4) { // 提高生成機率
                        this._spawnItem();
                    }
                }

                // 磁鐵效果
                if (this.isMagnetActive) {
                    this._applyMagnetEffect();
                }

                this.direction = this.nextDirection;
                const head = this.snake[0];
                let newHead = { x: head.x + this.direction.x, y: head.y + this.direction.y };

                // Wraparound logic for easy mode
                if (this.difficulty === 'easy') {
                    if (newHead.x < 0) newHead.x = this.boardWidth - 1;
                    else if (newHead.x >= this.boardWidth) newHead.x = 0;
                    if (newHead.y < 0) newHead.y = this.boardHeight - 1;
                    else if (newHead.y >= this.boardHeight) newHead.y = 0;
                }

                // 優先檢查是否吃到道具
                const eatenItemIndex = this.items.findIndex(i => i.x === newHead.x && i.y === newHead.y);
                if (eatenItemIndex > -1) {
                    const item = this.items[eatenItemIndex];
                    this.items.splice(eatenItemIndex, 1);
                    this.itemManager.applyEffect(item.id);
                    // 吃到道具後，蛇正常移動一格
                    this.snake.unshift(newHead);
                    this.snake.pop();
                    return; // 本次更新結束
                }
                
                // 檢查碰撞 (牆壁或自身)
                if (this._isCollision(newHead)) {
                    return this.gameOver();
                }

                // 檢查是否吃到食物
                const eatenFood = this.foods.findIndex(f => f.x === newHead.x && f.y === newHead.y);
                if (eatenFood > -1) {
                    this.snake.unshift(newHead);
                    this._handleEat(this.foods[eatenFood].value);
                } else {
                    this.snake.unshift(newHead);
                    this.snake.pop();
                }
            }
            
            _isCollision(pos) {
                // Wall collision
                if (pos.x < 0 || pos.x >= this.boardWidth || pos.y < 0 || pos.y >= this.boardHeight) {
                    return this.difficulty !== 'easy'; // Easy mode no wall collision
                }
                // Self collision
                if (!this.isInvincible && this.snake.length > 1 && this.snake.some(seg => seg.x === pos.x && seg.y === pos.y)) {
                    return this.difficulty !== 'easy'; // Easy mode no self collision
                }
                return false;
            }

            _handleEat(answer) {
                if (answer === this.currentQuestion.answer) {
                    this.audioManager.play('success');
                    const points = 10 * this.scoreMultiplier;
                    this.gameState.score += points;
                    this.gameState.questionsAnswered++;
                    // Shrink snake
                    if (this.snake.length > 2) this.snake.pop();
                    this._showToast(`答對了！+${points}分！🌟`, 'success');
                } else {
                    this.audioManager.play('debuff');
                    this.mistakeBook.add(this.currentQuestion);
                    // Grow snake
                    if (this.difficulty !== 'easy') {
                        this.snake.push({...this.snake[this.snake.length-1]});
                    }
                    this._showToast(`答錯了，正確答案是 ${this.currentQuestion.answer}`, 'error');
                }
                
                this.gameState.level = Math.floor(this.gameState.questionsAnswered / 5) + 1;
                this._generateNewQuestion();
                this._updateScore();
            }

            render() {
                this.board.innerHTML = ''; // Clear board
                // Render snake
                this.snake.forEach((seg, i) => {
                    const el = document.createElement('div');
                    el.className = 'game-cell ' + (i === 0 ? 'snake-head' : 'snake-body');
                    if (this.isInvincible) el.classList.add('snake-invincible');
                    el.style.left = seg.x * this.cellSize + 'px';
                    el.style.top = seg.y * this.cellSize + 'px';
                    el.style.width = this.cellSize + 'px';
                    el.style.height = this.cellSize + 'px';
                    if (i === 0) el.textContent = '🐍';
                    this.board.appendChild(el);
                });
                // Render food
                this.foods.forEach(food => {
                    const el = document.createElement('div');
                    el.className = 'game-cell food';
                    el.style.left = food.x * this.cellSize + 'px';
                    el.style.top = food.y * this.cellSize + 'px';
                    el.style.width = this.cellSize + 'px';
                    el.style.height = this.cellSize + 'px';
                    el.textContent = food.value;

                    if (typeof food.value === 'number') {
                        if (food.value >= 100) {
                            el.classList.add('three-digits');
                        } else if (food.value >= 10) {
                            el.classList.add('two-digits');
                        }
                    }
                    
                    this.board.appendChild(el);
                });

                // 渲染道具
                this.items.forEach(item => {
                    const el = document.createElement('div');
                    el.className = `game-cell item-cell ${item.id}`;
                    el.style.left = item.x * this.cellSize + 'px';
                    el.style.top = item.y * this.cellSize + 'px';
                    el.style.width = this.cellSize + 'px';
                    el.style.height = this.cellSize + 'px';
                    el.textContent = item.icon;
                    el.title = item.name;
                    this.board.appendChild(el);
                });
            }

            gameOver() {
                this.audioManager.play('gameover');
                cancelAnimationFrame(this.gameLoopId);
                this.gameLoopId = null;
                const overlay = document.createElement('div');
                overlay.className = 'modal-overlay';
                overlay.innerHTML = `
                    <div class="modal-content">
                        <h2>遊戲結束！</h2>
                        <div class="final-stats">
                            <div>最終得分: ${this.gameState.score}</div>
                            <div>答對題數: ${this.gameState.questionsAnswered}</div>
                        </div>
                        <div class="game-over-options">
                            <h4>再玩一局？</h4>
                            <button class="control-btn difficulty-btn" data-difficulty="easy">小小探險家</button>
                            <button class="control-btn difficulty-btn" data-difficulty="normal">數學小能手</button>
                            <button class="control-btn difficulty-btn" data-difficulty="hard">算術大師</button>
                        </div>
                    </div>
                `;
                $('.game-container').appendChild(overlay); 
                
                overlay.querySelectorAll('.difficulty-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const newDifficulty = e.target.dataset.difficulty;
                        overlay.remove();
                        this.start(newDifficulty);
                    });
                });
            }
            
            showDifficultySelection() {
                if(this.gameLoopId) {
                    cancelAnimationFrame(this.gameLoopId);
                    this.gameLoopId = null;
                }
                this.board.innerHTML = '';
                $('#difficulty-selection').style.display = 'flex';
                $('#ingame-controls').style.display = 'none';
                
                this.controls.pause.disabled = true;
                this.controls.restart.disabled = true;
                $('#question-display').textContent = '算術樂園';
                this._updateScore(true); // reset score display
            }
            
            _generateNewQuestion() {
                this.currentQuestion = this.equationGenerator.getQuestion(this.gameState.level, this.difficulty);
                $('#question-display').textContent = this.currentQuestion.text;
                
                this.foods = [];
                const occupied = new Set(this.snake.map(s => `${s.x},${s.y}`));
                this.items.forEach(i => occupied.add(`${i.x},${i.y}`));
                this.currentQuestion.options.forEach(option => {
                    let pos;
                    do {
                        pos = { x: randInt(0, this.boardWidth - 1), y: randInt(0, this.boardHeight - 1) };
                    } while (occupied.has(`${pos.x},${pos.y}`));
                    occupied.add(`${pos.x},${pos.y}`);
                    this.foods.push({ ...pos, value: option });
                });
            }
            
            _updateScore(reset = false) {
                if(reset) this.gameState.score = 0;
                $('#current-score').textContent = this.gameState.score;
            }

            _showToast(message, type = 'info') {
                const toast = document.createElement('div');
                toast.className = `toast toast-${type}`;
                toast.textContent = message;
                $('#toast-container').appendChild(toast);
                setTimeout(() => {
                    toast.classList.add('show');
                    setTimeout(() => {
                        toast.classList.remove('show');
                        toast.addEventListener('transitionend', () => toast.remove());
                    }, 2000);
                }, 10);
            }

            handleKeyPress(e) {
                if (!this.gameLoopId || this.isPaused) return;
                let dir = this.nextDirection;
                switch(e.key) {
                    case 'ArrowUp': if (this.direction.y === 0) dir = { x: 0, y: -1 }; break;
                    case 'ArrowDown': if (this.direction.y === 0) dir = { x: 0, y: 1 }; break;
                    case 'ArrowLeft': if (this.direction.x === 0) dir = { x: -1, y: 0 }; break;
                    case 'ArrowRight': if (this.direction.x === 0) dir = { x: 1, y: 0 }; break;
                    case ' ': this.togglePause(); break;
                }
                this.nextDirection = dir;
            }

            handleTouch(dx, dy) {
                if (Math.abs(dx) > Math.abs(dy)) { // Horizontal
                    this.handleKeyPress({ key: dx > 0 ? 'ArrowRight' : 'ArrowLeft' });
                } else { // Vertical
                    this.handleKeyPress({ key: dy > 0 ? 'ArrowDown' : 'ArrowUp' });
                }
            }

            togglePause() {
                if (!this.gameLoopId) return;
                this.isPaused = !this.isPaused;
                $('#pause-btn').textContent = this.isPaused ? '繼續' : '暫停';
            }

            _spawnItem() {
                const itemId = this.itemManager.getRandomItemId();
                const itemData = this.itemManager.itemsDefinition[itemId];
                let pos;
                const occupied = new Set(this.snake.map(s => `${s.x},${s.y}`));
                this.foods.forEach(f => occupied.add(`${f.x},${f.y}`));
                this.items.forEach(i => occupied.add(`${i.x},${i.y}`));
                
                let attempts = 0;
                do {
                    pos = { x: randInt(0, this.boardWidth - 1), y: randInt(0, this.boardHeight - 1) };
                    attempts++;
                } while (occupied.has(`${pos.x},${pos.y}`) && attempts < 50);

                if (attempts < 50) {
                    this.items.push({ ...pos, ...itemData });
                }
            }

            _applyMagnetEffect() {
                const head = this.snake[0];
                const magnetRadius = 4; // 磁鐵吸引半徑
                this.foods.forEach(food => {
                    const dx = head.x - food.x;
                    const dy = head.y - food.y;
                    if (Math.abs(dx) < magnetRadius && Math.abs(dy) < magnetRadius) {
                        // 簡單的吸附邏輯
                        food.x += Math.sign(dx);
                        food.y += Math.sign(dy);
                    }
                });
            }
        }
        
        document.addEventListener('DOMContentLoaded', () => {
            window.game = new DigitalSnakeGame();
        });
    </script>
</body>
</html> 